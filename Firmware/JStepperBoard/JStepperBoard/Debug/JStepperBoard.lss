
JStepperBoard.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000e770  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000001f0  20000000  0040e770  00020000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  2 .bss          00011618  200001f0  0040e960  000201f0  2**3
                  ALLOC
  3 .stack        00003000  20011808  0041ff78  000201f0  2**0
                  ALLOC
  4 .ARM.attributes 0000002e  00000000  00000000  000201f0  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002021e  2**0
                  CONTENTS, READONLY
  6 .debug_info   0005f2c1  00000000  00000000  00020277  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00009b2e  00000000  00000000  0007f538  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0001d72a  00000000  00000000  00089066  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001de0  00000000  00000000  000a6790  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00002340  00000000  00000000  000a8570  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00026f99  00000000  00000000  000aa8b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00022a67  00000000  00000000  000d1849  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00079c11  00000000  00000000  000f42b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000060f4  00000000  00000000  0016dec4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	08 48 01 20 75 af 40 00 71 af 40 00 71 af 40 00     .H. u.@.q.@.q.@.
  400010:	71 af 40 00 71 af 40 00 71 af 40 00 00 00 00 00     q.@.q.@.q.@.....
	...
  40002c:	4d 8d 40 00 71 af 40 00 00 00 00 00 c9 8d 40 00     M.@.q.@.......@.
  40003c:	19 8e 40 00 71 af 40 00 71 af 40 00 71 af 40 00     ..@.q.@.q.@.q.@.
  40004c:	71 af 40 00 71 af 40 00 71 af 40 00 71 af 40 00     q.@.q.@.q.@.q.@.
  40005c:	71 af 40 00 71 af 40 00 21 ac 40 00 35 ac 40 00     q.@.q.@.!.@.5.@.
  40006c:	49 ac 40 00 5d ac 40 00 71 ac 40 00 91 38 40 00     I.@.].@.q.@..8@.
  40007c:	71 af 40 00 71 af 40 00 71 af 40 00 71 af 40 00     q.@.q.@.q.@.q.@.
  40008c:	71 af 40 00 71 af 40 00 71 af 40 00 71 af 40 00     q.@.q.@.q.@.q.@.
  40009c:	71 af 40 00 71 af 40 00 71 af 40 00 71 af 40 00     q.@.q.@.q.@.q.@.
  4000ac:	71 af 40 00 71 af 40 00 71 af 40 00 71 af 40 00     q.@.q.@.q.@.q.@.
  4000bc:	71 af 40 00 71 af 40 00 71 af 40 00 71 af 40 00     q.@.q.@.q.@.q.@.
  4000cc:	71 af 40 00 71 af 40 00 71 af 40 00 a5 39 40 00     q.@.q.@.q.@..9@.
  4000dc:	71 af 40 00 71 af 40 00 71 af 40 00 71 af 40 00     q.@.q.@.q.@.q.@.
  4000ec:	71 af 40 00 71 af 40 00 71 af 40 00                 q.@.q.@.q.@.

004000f8 <__do_global_dtors_aux>:
  4000f8:	b510      	push	{r4, lr}
  4000fa:	4c05      	ldr	r4, [pc, #20]	; (400110 <__do_global_dtors_aux+0x18>)
  4000fc:	7823      	ldrb	r3, [r4, #0]
  4000fe:	b933      	cbnz	r3, 40010e <__do_global_dtors_aux+0x16>
  400100:	4b04      	ldr	r3, [pc, #16]	; (400114 <__do_global_dtors_aux+0x1c>)
  400102:	b113      	cbz	r3, 40010a <__do_global_dtors_aux+0x12>
  400104:	4804      	ldr	r0, [pc, #16]	; (400118 <__do_global_dtors_aux+0x20>)
  400106:	f3af 8000 	nop.w
  40010a:	2301      	movs	r3, #1
  40010c:	7023      	strb	r3, [r4, #0]
  40010e:	bd10      	pop	{r4, pc}
  400110:	200001f0 	.word	0x200001f0
  400114:	00000000 	.word	0x00000000
  400118:	0040e770 	.word	0x0040e770

0040011c <frame_dummy>:
  40011c:	4b0c      	ldr	r3, [pc, #48]	; (400150 <frame_dummy+0x34>)
  40011e:	b143      	cbz	r3, 400132 <frame_dummy+0x16>
  400120:	480c      	ldr	r0, [pc, #48]	; (400154 <frame_dummy+0x38>)
  400122:	490d      	ldr	r1, [pc, #52]	; (400158 <frame_dummy+0x3c>)
  400124:	b510      	push	{r4, lr}
  400126:	f3af 8000 	nop.w
  40012a:	480c      	ldr	r0, [pc, #48]	; (40015c <frame_dummy+0x40>)
  40012c:	6803      	ldr	r3, [r0, #0]
  40012e:	b923      	cbnz	r3, 40013a <frame_dummy+0x1e>
  400130:	bd10      	pop	{r4, pc}
  400132:	480a      	ldr	r0, [pc, #40]	; (40015c <frame_dummy+0x40>)
  400134:	6803      	ldr	r3, [r0, #0]
  400136:	b933      	cbnz	r3, 400146 <frame_dummy+0x2a>
  400138:	4770      	bx	lr
  40013a:	4b09      	ldr	r3, [pc, #36]	; (400160 <frame_dummy+0x44>)
  40013c:	2b00      	cmp	r3, #0
  40013e:	d0f7      	beq.n	400130 <frame_dummy+0x14>
  400140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400144:	4718      	bx	r3
  400146:	4b06      	ldr	r3, [pc, #24]	; (400160 <frame_dummy+0x44>)
  400148:	2b00      	cmp	r3, #0
  40014a:	d0f5      	beq.n	400138 <frame_dummy+0x1c>
  40014c:	4718      	bx	r3
  40014e:	bf00      	nop
  400150:	00000000 	.word	0x00000000
  400154:	0040e770 	.word	0x0040e770
  400158:	200001f4 	.word	0x200001f4
  40015c:	0040e770 	.word	0x0040e770
  400160:	00000000 	.word	0x00000000

00400164 <_ZL16configure_sdcardv>:
    pio_enable_pin_interrupt(DRIVER_3_INTR);
    pio_enable_pin_interrupt(DRIVER_4_INTR);
}

/* ===================================== SD Card ==================================== */
static void configure_sdcard(void) {
  400164:	b508      	push	{r3, lr}
    /* Initialize SD MMC stack */
    sd_mmc_init();
  400166:	4b01      	ldr	r3, [pc, #4]	; (40016c <_ZL16configure_sdcardv+0x8>)
  400168:	4798      	blx	r3
  40016a:	bd08      	pop	{r3, pc}
  40016c:	004006d1 	.word	0x004006d1

00400170 <usart_serial_getchar>:
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  400170:	b530      	push	{r4, r5, lr}
  400172:	b083      	sub	sp, #12
  400174:	4604      	mov	r4, r0
  400176:	460d      	mov	r5, r1
	uint32_t val = 0;
  400178:	2300      	movs	r3, #0
  40017a:	9301      	str	r3, [sp, #4]
	if (UART == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  40017c:	4b17      	ldr	r3, [pc, #92]	; (4001dc <usart_serial_getchar+0x6c>)
  40017e:	4298      	cmp	r0, r3
  400180:	d00a      	beq.n	400198 <usart_serial_getchar+0x28>
		while (uart_read((Uart*)p_usart, data));
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  400182:	4b17      	ldr	r3, [pc, #92]	; (4001e0 <usart_serial_getchar+0x70>)
  400184:	429c      	cmp	r4, r3
  400186:	d00e      	beq.n	4001a6 <usart_serial_getchar+0x36>
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  400188:	4b16      	ldr	r3, [pc, #88]	; (4001e4 <usart_serial_getchar+0x74>)
  40018a:	429c      	cmp	r4, r3
  40018c:	d012      	beq.n	4001b4 <usart_serial_getchar+0x44>
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  40018e:	4b16      	ldr	r3, [pc, #88]	; (4001e8 <usart_serial_getchar+0x78>)
  400190:	429c      	cmp	r4, r3
  400192:	d019      	beq.n	4001c8 <usart_serial_getchar+0x58>
		*data = (uint8_t)(val & 0xFF);
	}
# endif
#endif /* ifdef USART */

}
  400194:	b003      	add	sp, #12
  400196:	bd30      	pop	{r4, r5, pc}
		while (uart_read((Uart*)p_usart, data));
  400198:	4629      	mov	r1, r5
  40019a:	4620      	mov	r0, r4
  40019c:	4b13      	ldr	r3, [pc, #76]	; (4001ec <usart_serial_getchar+0x7c>)
  40019e:	4798      	blx	r3
  4001a0:	2800      	cmp	r0, #0
  4001a2:	d1f9      	bne.n	400198 <usart_serial_getchar+0x28>
  4001a4:	e7ed      	b.n	400182 <usart_serial_getchar+0x12>
		while (uart_read((Uart*)p_usart, data));
  4001a6:	4629      	mov	r1, r5
  4001a8:	4620      	mov	r0, r4
  4001aa:	4b10      	ldr	r3, [pc, #64]	; (4001ec <usart_serial_getchar+0x7c>)
  4001ac:	4798      	blx	r3
  4001ae:	2800      	cmp	r0, #0
  4001b0:	d1f9      	bne.n	4001a6 <usart_serial_getchar+0x36>
  4001b2:	e7e9      	b.n	400188 <usart_serial_getchar+0x18>
		while (usart_read(p_usart, &val));
  4001b4:	a901      	add	r1, sp, #4
  4001b6:	4620      	mov	r0, r4
  4001b8:	4b0d      	ldr	r3, [pc, #52]	; (4001f0 <usart_serial_getchar+0x80>)
  4001ba:	4798      	blx	r3
  4001bc:	2800      	cmp	r0, #0
  4001be:	d1f9      	bne.n	4001b4 <usart_serial_getchar+0x44>
		*data = (uint8_t)(val & 0xFF);
  4001c0:	f89d 3004 	ldrb.w	r3, [sp, #4]
  4001c4:	702b      	strb	r3, [r5, #0]
  4001c6:	e7e2      	b.n	40018e <usart_serial_getchar+0x1e>
		while (usart_read(p_usart, &val));
  4001c8:	a901      	add	r1, sp, #4
  4001ca:	4620      	mov	r0, r4
  4001cc:	4b08      	ldr	r3, [pc, #32]	; (4001f0 <usart_serial_getchar+0x80>)
  4001ce:	4798      	blx	r3
  4001d0:	2800      	cmp	r0, #0
  4001d2:	d1f9      	bne.n	4001c8 <usart_serial_getchar+0x58>
		*data = (uint8_t)(val & 0xFF);
  4001d4:	f89d 3004 	ldrb.w	r3, [sp, #4]
  4001d8:	702b      	strb	r3, [r5, #0]
}
  4001da:	e7db      	b.n	400194 <usart_serial_getchar+0x24>
  4001dc:	400e0600 	.word	0x400e0600
  4001e0:	40060600 	.word	0x40060600
  4001e4:	400a0000 	.word	0x400a0000
  4001e8:	400a4000 	.word	0x400a4000
  4001ec:	0040af33 	.word	0x0040af33
  4001f0:	0040af59 	.word	0x0040af59

004001f4 <usart_serial_putchar>:
{
  4001f4:	b538      	push	{r3, r4, r5, lr}
  4001f6:	4604      	mov	r4, r0
  4001f8:	460d      	mov	r5, r1
	if (UART0 == (Uart*)p_usart) {
  4001fa:	4b17      	ldr	r3, [pc, #92]	; (400258 <usart_serial_putchar+0x64>)
  4001fc:	4298      	cmp	r0, r3
  4001fe:	d00a      	beq.n	400216 <usart_serial_putchar+0x22>
	if (UART1 == (Uart*)p_usart) {
  400200:	4b16      	ldr	r3, [pc, #88]	; (40025c <usart_serial_putchar+0x68>)
  400202:	4298      	cmp	r0, r3
  400204:	d00f      	beq.n	400226 <usart_serial_putchar+0x32>
	if (USART0 == p_usart) {
  400206:	4b16      	ldr	r3, [pc, #88]	; (400260 <usart_serial_putchar+0x6c>)
  400208:	4298      	cmp	r0, r3
  40020a:	d014      	beq.n	400236 <usart_serial_putchar+0x42>
	if (USART1 == p_usart) {
  40020c:	4b15      	ldr	r3, [pc, #84]	; (400264 <usart_serial_putchar+0x70>)
  40020e:	4298      	cmp	r0, r3
  400210:	d019      	beq.n	400246 <usart_serial_putchar+0x52>
	return 0;
  400212:	2000      	movs	r0, #0
}
  400214:	bd38      	pop	{r3, r4, r5, pc}
		while (uart_write((Uart*)p_usart, c)!=0);
  400216:	4629      	mov	r1, r5
  400218:	4620      	mov	r0, r4
  40021a:	4b13      	ldr	r3, [pc, #76]	; (400268 <usart_serial_putchar+0x74>)
  40021c:	4798      	blx	r3
  40021e:	2800      	cmp	r0, #0
  400220:	d1f9      	bne.n	400216 <usart_serial_putchar+0x22>
		return 1;
  400222:	2001      	movs	r0, #1
  400224:	bd38      	pop	{r3, r4, r5, pc}
		while (uart_write((Uart*)p_usart, c)!=0);
  400226:	4629      	mov	r1, r5
  400228:	4620      	mov	r0, r4
  40022a:	4b0f      	ldr	r3, [pc, #60]	; (400268 <usart_serial_putchar+0x74>)
  40022c:	4798      	blx	r3
  40022e:	2800      	cmp	r0, #0
  400230:	d1f9      	bne.n	400226 <usart_serial_putchar+0x32>
		return 1;
  400232:	2001      	movs	r0, #1
  400234:	bd38      	pop	{r3, r4, r5, pc}
		while (usart_write(p_usart, c)!=0);
  400236:	4629      	mov	r1, r5
  400238:	4620      	mov	r0, r4
  40023a:	4b0c      	ldr	r3, [pc, #48]	; (40026c <usart_serial_putchar+0x78>)
  40023c:	4798      	blx	r3
  40023e:	2800      	cmp	r0, #0
  400240:	d1f9      	bne.n	400236 <usart_serial_putchar+0x42>
		return 1;
  400242:	2001      	movs	r0, #1
  400244:	bd38      	pop	{r3, r4, r5, pc}
		while (usart_write(p_usart, c)!=0);
  400246:	4629      	mov	r1, r5
  400248:	4620      	mov	r0, r4
  40024a:	4b08      	ldr	r3, [pc, #32]	; (40026c <usart_serial_putchar+0x78>)
  40024c:	4798      	blx	r3
  40024e:	2800      	cmp	r0, #0
  400250:	d1f9      	bne.n	400246 <usart_serial_putchar+0x52>
		return 1;
  400252:	2001      	movs	r0, #1
  400254:	bd38      	pop	{r3, r4, r5, pc}
  400256:	bf00      	nop
  400258:	400e0600 	.word	0x400e0600
  40025c:	40060600 	.word	0x40060600
  400260:	400a0000 	.word	0x400a0000
  400264:	400a4000 	.word	0x400a4000
  400268:	0040af23 	.word	0x0040af23
  40026c:	0040af45 	.word	0x0040af45

00400270 <_ZL13configure_spiv>:
static void configure_spi(void) {
  400270:	b530      	push	{r4, r5, lr}
  400272:	b083      	sub	sp, #12
    spi_master_init(SPI_BUS);
  400274:	4c07      	ldr	r4, [pc, #28]	; (400294 <_ZL13configure_spiv+0x24>)
  400276:	4620      	mov	r0, r4
  400278:	4b07      	ldr	r3, [pc, #28]	; (400298 <_ZL13configure_spiv+0x28>)
  40027a:	4798      	blx	r3
    spi_master_setup_device(SPI_BUS, &DUMMY, SPI_MODE_3, 1000000, 0);
  40027c:	2300      	movs	r3, #0
  40027e:	9300      	str	r3, [sp, #0]
  400280:	4b06      	ldr	r3, [pc, #24]	; (40029c <_ZL13configure_spiv+0x2c>)
  400282:	2203      	movs	r2, #3
  400284:	4906      	ldr	r1, [pc, #24]	; (4002a0 <_ZL13configure_spiv+0x30>)
  400286:	4620      	mov	r0, r4
  400288:	4d06      	ldr	r5, [pc, #24]	; (4002a4 <_ZL13configure_spiv+0x34>)
  40028a:	47a8      	blx	r5
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_enable(Spi *p_spi)
{
	p_spi->SPI_CR = SPI_CR_SPIEN;
  40028c:	2301      	movs	r3, #1
  40028e:	6023      	str	r3, [r4, #0]
}
  400290:	b003      	add	sp, #12
  400292:	bd30      	pop	{r4, r5, pc}
  400294:	40088000 	.word	0x40088000
  400298:	0040a761 	.word	0x0040a761
  40029c:	000f4240 	.word	0x000f4240
  4002a0:	2000020c 	.word	0x2000020c
  4002a4:	0040a7b5 	.word	0x0040a7b5

004002a8 <_ZL18configure_steppersv>:
static void configure_steppers(void) {
  4002a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4002ac:	b086      	sub	sp, #24
                              DRIVER_0_INTR, DRIVER_0_5160_EN);
  4002ae:	20b8      	movs	r0, #184	; 0xb8
  4002b0:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 400384 <_ZL18configure_steppersv+0xdc>
  4002b4:	47c8      	blx	r9
  4002b6:	4682      	mov	sl, r0
  4002b8:	4c2f      	ldr	r4, [pc, #188]	; (400378 <_ZL18configure_steppersv+0xd0>)
  4002ba:	1d27      	adds	r7, r4, #4
  4002bc:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 400388 <_ZL18configure_steppersv+0xe0>
  4002c0:	2346      	movs	r3, #70	; 0x46
  4002c2:	9304      	str	r3, [sp, #16]
  4002c4:	2318      	movs	r3, #24
  4002c6:	9303      	str	r3, [sp, #12]
  4002c8:	2378      	movs	r3, #120	; 0x78
  4002ca:	9302      	str	r3, [sp, #8]
  4002cc:	2377      	movs	r3, #119	; 0x77
  4002ce:	9301      	str	r3, [sp, #4]
  4002d0:	4e2a      	ldr	r6, [pc, #168]	; (40037c <_ZL18configure_steppersv+0xd4>)
  4002d2:	9600      	str	r6, [sp, #0]
  4002d4:	2344      	movs	r3, #68	; 0x44
  4002d6:	463a      	mov	r2, r7
  4002d8:	4641      	mov	r1, r8
  4002da:	4d29      	ldr	r5, [pc, #164]	; (400380 <_ZL18configure_steppersv+0xd8>)
  4002dc:	47a8      	blx	r5
    steppers[0] = new Stepper(SPI_BUS, &SPI_MUTEX, DRIVER_0_CS_4361, FCLK, DRIVER_0_NFREEZE_4361, RST_TMC43610,
  4002de:	f8c4 a008 	str.w	sl, [r4, #8]
                              DRIVER_1_INTR, DRIVER_1_5160_EN);
  4002e2:	20b8      	movs	r0, #184	; 0xb8
  4002e4:	47c8      	blx	r9
  4002e6:	4682      	mov	sl, r0
  4002e8:	2376      	movs	r3, #118	; 0x76
  4002ea:	9304      	str	r3, [sp, #16]
  4002ec:	2374      	movs	r3, #116	; 0x74
  4002ee:	9303      	str	r3, [sp, #12]
  4002f0:	2375      	movs	r3, #117	; 0x75
  4002f2:	9302      	str	r3, [sp, #8]
  4002f4:	2373      	movs	r3, #115	; 0x73
  4002f6:	9301      	str	r3, [sp, #4]
  4002f8:	9600      	str	r6, [sp, #0]
  4002fa:	230b      	movs	r3, #11
  4002fc:	463a      	mov	r2, r7
  4002fe:	4641      	mov	r1, r8
  400300:	47a8      	blx	r5
    steppers[1] = new Stepper(SPI_BUS, &SPI_MUTEX, DRIVER_1_CS_4361, FCLK, DRIVER_1_NFREEZE_4361, RST_TMC43611,
  400302:	f8c4 a00c 	str.w	sl, [r4, #12]
                              DRIVER_2_INTR, DRIVER_2_5160_EN);
  400306:	20b8      	movs	r0, #184	; 0xb8
  400308:	47c8      	blx	r9
  40030a:	4682      	mov	sl, r0
  40030c:	2301      	movs	r3, #1
  40030e:	9304      	str	r3, [sp, #16]
  400310:	236a      	movs	r3, #106	; 0x6a
  400312:	9303      	str	r3, [sp, #12]
  400314:	2350      	movs	r3, #80	; 0x50
  400316:	9302      	str	r3, [sp, #8]
  400318:	2300      	movs	r3, #0
  40031a:	9301      	str	r3, [sp, #4]
  40031c:	9600      	str	r6, [sp, #0]
  40031e:	2322      	movs	r3, #34	; 0x22
  400320:	463a      	mov	r2, r7
  400322:	4641      	mov	r1, r8
  400324:	47a8      	blx	r5
    steppers[2] = new Stepper(SPI_BUS, &SPI_MUTEX, DRIVER_2_CS_4361, FCLK, DRIVER_2_NFREEZE_4361, RST_TMC43612,
  400326:	f8c4 a010 	str.w	sl, [r4, #16]
                              DRIVER_3_INTR, DRIVER_3_5160_EN);
  40032a:	20b8      	movs	r0, #184	; 0xb8
  40032c:	47c8      	blx	r9
  40032e:	4682      	mov	sl, r0
  400330:	236f      	movs	r3, #111	; 0x6f
  400332:	9304      	str	r3, [sp, #16]
  400334:	2352      	movs	r3, #82	; 0x52
  400336:	9303      	str	r3, [sp, #12]
  400338:	237d      	movs	r3, #125	; 0x7d
  40033a:	9302      	str	r3, [sp, #8]
  40033c:	2368      	movs	r3, #104	; 0x68
  40033e:	9301      	str	r3, [sp, #4]
  400340:	9600      	str	r6, [sp, #0]
  400342:	2316      	movs	r3, #22
  400344:	463a      	mov	r2, r7
  400346:	4641      	mov	r1, r8
  400348:	47a8      	blx	r5
    steppers[3] = new Stepper(SPI_BUS, &SPI_MUTEX, DRIVER_3_CS_4361, FCLK, DRIVER_3_NFREEZE_4361, RST_TMC43613,
  40034a:	f8c4 a014 	str.w	sl, [r4, #20]
                              DRIVER_4_INTR, DRIVER_4_5160_EN);
  40034e:	20b8      	movs	r0, #184	; 0xb8
  400350:	47c8      	blx	r9
  400352:	4681      	mov	r9, r0
  400354:	2362      	movs	r3, #98	; 0x62
  400356:	9304      	str	r3, [sp, #16]
  400358:	2363      	movs	r3, #99	; 0x63
  40035a:	9303      	str	r3, [sp, #12]
  40035c:	2358      	movs	r3, #88	; 0x58
  40035e:	9302      	str	r3, [sp, #8]
  400360:	2357      	movs	r3, #87	; 0x57
  400362:	9301      	str	r3, [sp, #4]
  400364:	9600      	str	r6, [sp, #0]
  400366:	2310      	movs	r3, #16
  400368:	463a      	mov	r2, r7
  40036a:	4641      	mov	r1, r8
  40036c:	47a8      	blx	r5
    steppers[4] = new Stepper(SPI_BUS, &SPI_MUTEX, DRIVER_4_CS_4361, FCLK, DRIVER_4_NFREEZE_4361, RST_TMC43614,
  40036e:	f8c4 9018 	str.w	r9, [r4, #24]
}
  400372:	b006      	add	sp, #24
  400374:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  400378:	2000020c 	.word	0x2000020c
  40037c:	00f42400 	.word	0x00f42400
  400380:	00404f11 	.word	0x00404f11
  400384:	0040b2b9 	.word	0x0040b2b9
  400388:	40088000 	.word	0x40088000

0040038c <_ZL21configure_motionQueuev>:
}

/* ================================== Motion Queue ================================== */
static void configure_motionQueue(void) { motion_queue.registerSteppers(steppers); }
  40038c:	b508      	push	{r3, lr}
  40038e:	4803      	ldr	r0, [pc, #12]	; (40039c <_ZL21configure_motionQueuev+0x10>)
  400390:	f100 0108 	add.w	r1, r0, #8
  400394:	301c      	adds	r0, #28
  400396:	4b02      	ldr	r3, [pc, #8]	; (4003a0 <_ZL21configure_motionQueuev+0x14>)
  400398:	4798      	blx	r3
  40039a:	bd08      	pop	{r3, pc}
  40039c:	2000020c 	.word	0x2000020c
  4003a0:	004072e5 	.word	0x004072e5

004003a4 <_ZL16initializeDriverv>:

/* ========================== Initial Loading from SD Card ========================== */
static void initializeDriver(void) {
  4003a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint8_t drivers_loaded = 0;

    sd_card.mount();
  4003a6:	4e12      	ldr	r6, [pc, #72]	; (4003f0 <_ZL16initializeDriverv+0x4c>)
  4003a8:	4630      	mov	r0, r6
  4003aa:	4b12      	ldr	r3, [pc, #72]	; (4003f4 <_ZL16initializeDriverv+0x50>)
  4003ac:	4798      	blx	r3
    drivers_loaded = parse_driverConfig(&sd_card, steppers);
  4003ae:	4f12      	ldr	r7, [pc, #72]	; (4003f8 <_ZL16initializeDriverv+0x54>)
  4003b0:	f107 0108 	add.w	r1, r7, #8
  4003b4:	4630      	mov	r0, r6
  4003b6:	4b11      	ldr	r3, [pc, #68]	; (4003fc <_ZL16initializeDriverv+0x58>)
  4003b8:	4798      	blx	r3
  4003ba:	4605      	mov	r5, r0
    parse_motionSequence(&sd_card, &motion_queue);
  4003bc:	f107 011c 	add.w	r1, r7, #28
  4003c0:	4630      	mov	r0, r6
  4003c2:	4b0f      	ldr	r3, [pc, #60]	; (400400 <_ZL16initializeDriverv+0x5c>)
  4003c4:	4798      	blx	r3
    sd_card.unmount();
  4003c6:	4630      	mov	r0, r6
  4003c8:	4b0e      	ldr	r3, [pc, #56]	; (400404 <_ZL16initializeDriverv+0x60>)
  4003ca:	4798      	blx	r3
  4003cc:	e000      	b.n	4003d0 <_ZL16initializeDriverv+0x2c>

    // First Initialize
    for (int i; i < MAX_STEPPERS; i++) {
  4003ce:	3401      	adds	r4, #1
  4003d0:	2c04      	cmp	r4, #4
  4003d2:	dc0b      	bgt.n	4003ec <_ZL16initializeDriverv+0x48>
        if ((drivers_loaded >> i) & 1 == 1) { steppers[i]->execInitController(); }
  4003d4:	fa45 f304 	asr.w	r3, r5, r4
  4003d8:	f013 0f01 	tst.w	r3, #1
  4003dc:	d0f7      	beq.n	4003ce <_ZL16initializeDriverv+0x2a>
  4003de:	4b06      	ldr	r3, [pc, #24]	; (4003f8 <_ZL16initializeDriverv+0x54>)
  4003e0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  4003e4:	6898      	ldr	r0, [r3, #8]
  4003e6:	4b08      	ldr	r3, [pc, #32]	; (400408 <_ZL16initializeDriverv+0x64>)
  4003e8:	4798      	blx	r3
  4003ea:	e7f0      	b.n	4003ce <_ZL16initializeDriverv+0x2a>
  4003ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4003ee:	bf00      	nop
  4003f0:	20007288 	.word	0x20007288
  4003f4:	00407fc5 	.word	0x00407fc5
  4003f8:	2000020c 	.word	0x2000020c
  4003fc:	00408899 	.word	0x00408899
  400400:	00408b09 	.word	0x00408b09
  400404:	00408031 	.word	0x00408031
  400408:	0040558d 	.word	0x0040558d

0040040c <_ZL13configure_canv>:
static void configure_can(void) {
  40040c:	b570      	push	{r4, r5, r6, lr}
    can_interface = new CANInterface(1);
  40040e:	f44f 703f 	mov.w	r0, #764	; 0x2fc
  400412:	4b10      	ldr	r3, [pc, #64]	; (400454 <_ZL13configure_canv+0x48>)
  400414:	4798      	blx	r3
  400416:	4606      	mov	r6, r0
  400418:	2101      	movs	r1, #1
  40041a:	4b0f      	ldr	r3, [pc, #60]	; (400458 <_ZL13configure_canv+0x4c>)
  40041c:	4798      	blx	r3
  40041e:	4c0f      	ldr	r4, [pc, #60]	; (40045c <_ZL13configure_canv+0x50>)
  400420:	f8c4 6d04 	str.w	r6, [r4, #3332]	; 0xd04
    can_interface->registerSteppers(steppers);
  400424:	4d0e      	ldr	r5, [pc, #56]	; (400460 <_ZL13configure_canv+0x54>)
  400426:	f105 0108 	add.w	r1, r5, #8
  40042a:	4630      	mov	r0, r6
  40042c:	4b0d      	ldr	r3, [pc, #52]	; (400464 <_ZL13configure_canv+0x58>)
  40042e:	4798      	blx	r3
    can_interface->registerMotionQueue(&motion_queue);
  400430:	f105 011c 	add.w	r1, r5, #28
  400434:	f8d4 0d04 	ldr.w	r0, [r4, #3332]	; 0xd04
  400438:	4b0b      	ldr	r3, [pc, #44]	; (400468 <_ZL13configure_canv+0x5c>)
  40043a:	4798      	blx	r3
    can_interface->registerSdCard(&sd_card);
  40043c:	f604 21ac 	addw	r1, r4, #2732	; 0xaac
  400440:	f8d4 0d04 	ldr.w	r0, [r4, #3332]	; 0xd04
  400444:	4b09      	ldr	r3, [pc, #36]	; (40046c <_ZL13configure_canv+0x60>)
  400446:	4798      	blx	r3
    can_interface->init();
  400448:	f8d4 0d04 	ldr.w	r0, [r4, #3332]	; 0xd04
  40044c:	4b08      	ldr	r3, [pc, #32]	; (400470 <_ZL13configure_canv+0x64>)
  40044e:	4798      	blx	r3
  400450:	bd70      	pop	{r4, r5, r6, pc}
  400452:	bf00      	nop
  400454:	0040b2b9 	.word	0x0040b2b9
  400458:	00403a9d 	.word	0x00403a9d
  40045c:	200067dc 	.word	0x200067dc
  400460:	2000020c 	.word	0x2000020c
  400464:	00403b6d 	.word	0x00403b6d
  400468:	00403b8b 	.word	0x00403b8b
  40046c:	00403b91 	.word	0x00403b91
  400470:	00403db1 	.word	0x00403db1

00400474 <_Z41__static_initialization_and_destruction_0ii>:

    /* ==================================== Can Test ==================================== */
    // xTaskCreate(test_canTransmit, (const signed char *)"CanTransmit", 496, &can_interface, 2, NULL); // create test

    vTaskStartScheduler(); // start all tasks
}
  400474:	2801      	cmp	r0, #1
  400476:	d000      	beq.n	40047a <_Z41__static_initialization_and_destruction_0ii+0x6>
  400478:	4770      	bx	lr
  40047a:	b508      	push	{r3, lr}
  40047c:	f64f 73ff 	movw	r3, #65535	; 0xffff
  400480:	4299      	cmp	r1, r3
  400482:	d000      	beq.n	400486 <_Z41__static_initialization_and_destruction_0ii+0x12>
  400484:	bd08      	pop	{r3, pc}
xQueueHandle SPI_MUTEX = xSemaphoreCreateMutex();
  400486:	4b06      	ldr	r3, [pc, #24]	; (4004a0 <_Z41__static_initialization_and_destruction_0ii+0x2c>)
  400488:	4798      	blx	r3
  40048a:	4b06      	ldr	r3, [pc, #24]	; (4004a4 <_Z41__static_initialization_and_destruction_0ii+0x30>)
  40048c:	6058      	str	r0, [r3, #4]
#    define sd_card_debug(...) printf(__VA_ARGS__)
#else
#    define sd_card_debug(...)
#endif

class SDCard {
  40048e:	2100      	movs	r1, #0
  400490:	4a05      	ldr	r2, [pc, #20]	; (4004a8 <_Z41__static_initialization_and_destruction_0ii+0x34>)
  400492:	f882 1d00 	strb.w	r1, [r2, #3328]	; 0xd00
MotionQueue   motion_queue;
  400496:	f103 001c 	add.w	r0, r3, #28
  40049a:	4b04      	ldr	r3, [pc, #16]	; (4004ac <_Z41__static_initialization_and_destruction_0ii+0x38>)
  40049c:	4798      	blx	r3
}
  40049e:	e7f1      	b.n	400484 <_Z41__static_initialization_and_destruction_0ii+0x10>
  4004a0:	00409331 	.word	0x00409331
  4004a4:	2000020c 	.word	0x2000020c
  4004a8:	200067dc 	.word	0x200067dc
  4004ac:	00407139 	.word	0x00407139

004004b0 <_ZL17configure_consolev>:
static void configure_console(void) {
  4004b0:	b530      	push	{r4, r5, lr}
  4004b2:	b089      	sub	sp, #36	; 0x24
    usart_serial_options_t uart_serial_options = {CONF_UART_BAUDRATE, 8, CONF_UART_PARITY, 1};
  4004b4:	4b14      	ldr	r3, [pc, #80]	; (400508 <_ZL17configure_consolev+0x58>)
  4004b6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  4004b8:	ac08      	add	r4, sp, #32
  4004ba:	e904 000f 	stmdb	r4, {r0, r1, r2, r3}
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  4004be:	2007      	movs	r0, #7
  4004c0:	4d12      	ldr	r5, [pc, #72]	; (40050c <_ZL17configure_consolev+0x5c>)
  4004c2:	47a8      	blx	r5
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
  4004c4:	4c12      	ldr	r4, [pc, #72]	; (400510 <_ZL17configure_consolev+0x60>)
  4004c6:	4b13      	ldr	r3, [pc, #76]	; (400514 <_ZL17configure_consolev+0x64>)
  4004c8:	601c      	str	r4, [r3, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
  4004ca:	4a13      	ldr	r2, [pc, #76]	; (400518 <_ZL17configure_consolev+0x68>)
  4004cc:	4b13      	ldr	r3, [pc, #76]	; (40051c <_ZL17configure_consolev+0x6c>)
  4004ce:	601a      	str	r2, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
  4004d0:	4a13      	ldr	r2, [pc, #76]	; (400520 <_ZL17configure_consolev+0x70>)
  4004d2:	4b14      	ldr	r3, [pc, #80]	; (400524 <_ZL17configure_consolev+0x74>)
  4004d4:	601a      	str	r2, [r3, #0]
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
  4004d6:	4b14      	ldr	r3, [pc, #80]	; (400528 <_ZL17configure_consolev+0x78>)
  4004d8:	9301      	str	r3, [sp, #4]
	uart_settings.ul_baudrate = opt->baudrate;
  4004da:	9b04      	ldr	r3, [sp, #16]
  4004dc:	9302      	str	r3, [sp, #8]
	uart_settings.ul_mode = opt->paritytype;
  4004de:	9b06      	ldr	r3, [sp, #24]
  4004e0:	9303      	str	r3, [sp, #12]
  4004e2:	2007      	movs	r0, #7
  4004e4:	47a8      	blx	r5
		uart_init((Uart*)p_usart, &uart_settings);
  4004e6:	a901      	add	r1, sp, #4
  4004e8:	4620      	mov	r0, r4
  4004ea:	4b10      	ldr	r3, [pc, #64]	; (40052c <_ZL17configure_consolev+0x7c>)
  4004ec:	4798      	blx	r3
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
  4004ee:	4d10      	ldr	r5, [pc, #64]	; (400530 <_ZL17configure_consolev+0x80>)
  4004f0:	682b      	ldr	r3, [r5, #0]
  4004f2:	2100      	movs	r1, #0
  4004f4:	6898      	ldr	r0, [r3, #8]
  4004f6:	4c0f      	ldr	r4, [pc, #60]	; (400534 <_ZL17configure_consolev+0x84>)
  4004f8:	47a0      	blx	r4
	setbuf(stdin, NULL);
  4004fa:	682b      	ldr	r3, [r5, #0]
  4004fc:	2100      	movs	r1, #0
  4004fe:	6858      	ldr	r0, [r3, #4]
  400500:	47a0      	blx	r4
}
  400502:	b009      	add	sp, #36	; 0x24
  400504:	bd30      	pop	{r4, r5, pc}
  400506:	bf00      	nop
  400508:	0040dc4c 	.word	0x0040dc4c
  40050c:	0040ad6d 	.word	0x0040ad6d
  400510:	400e0600 	.word	0x400e0600
  400514:	200117fc 	.word	0x200117fc
  400518:	004001f5 	.word	0x004001f5
  40051c:	200117f8 	.word	0x200117f8
  400520:	00400171 	.word	0x00400171
  400524:	200117f4 	.word	0x200117f4
  400528:	05b8d800 	.word	0x05b8d800
  40052c:	0040aeeb 	.word	0x0040aeeb
  400530:	20000020 	.word	0x20000020
  400534:	0040c411 	.word	0x0040c411

00400538 <vApplicationMallocFailedHook>:
void vApplicationMallocFailedHook(void) {}
  400538:	4770      	bx	lr
	...

0040053c <_Z16disable_watchdogv>:
    WDT->WDT_MR = WDT_MR_WDDIS;
  40053c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  400540:	4b01      	ldr	r3, [pc, #4]	; (400548 <_Z16disable_watchdogv+0xc>)
  400542:	605a      	str	r2, [r3, #4]
  400544:	4770      	bx	lr
  400546:	bf00      	nop
  400548:	400e1850 	.word	0x400e1850

0040054c <main>:
int main(void) {
  40054c:	b508      	push	{r3, lr}
    disable_watchdog();
  40054e:	4b0d      	ldr	r3, [pc, #52]	; (400584 <main+0x38>)
  400550:	4798      	blx	r3
    SystemInit();
  400552:	4b0d      	ldr	r3, [pc, #52]	; (400588 <main+0x3c>)
  400554:	4798      	blx	r3
    sysclk_init();
  400556:	4b0d      	ldr	r3, [pc, #52]	; (40058c <main+0x40>)
  400558:	4798      	blx	r3
    board_init();
  40055a:	4b0d      	ldr	r3, [pc, #52]	; (400590 <main+0x44>)
  40055c:	4798      	blx	r3
    configure_sdcard();
  40055e:	4b0d      	ldr	r3, [pc, #52]	; (400594 <main+0x48>)
  400560:	4798      	blx	r3
    configure_console();
  400562:	4b0d      	ldr	r3, [pc, #52]	; (400598 <main+0x4c>)
  400564:	4798      	blx	r3
    configure_spi();
  400566:	4b0d      	ldr	r3, [pc, #52]	; (40059c <main+0x50>)
  400568:	4798      	blx	r3
    configure_steppers();
  40056a:	4b0d      	ldr	r3, [pc, #52]	; (4005a0 <main+0x54>)
  40056c:	4798      	blx	r3
    configure_motionQueue();
  40056e:	4b0d      	ldr	r3, [pc, #52]	; (4005a4 <main+0x58>)
  400570:	4798      	blx	r3
    initializeDriver();
  400572:	4b0d      	ldr	r3, [pc, #52]	; (4005a8 <main+0x5c>)
  400574:	4798      	blx	r3
    configure_can();
  400576:	4b0d      	ldr	r3, [pc, #52]	; (4005ac <main+0x60>)
  400578:	4798      	blx	r3
    vTaskStartScheduler(); // start all tasks
  40057a:	4b0d      	ldr	r3, [pc, #52]	; (4005b0 <main+0x64>)
  40057c:	4798      	blx	r3
}
  40057e:	2000      	movs	r0, #0
  400580:	bd08      	pop	{r3, pc}
  400582:	bf00      	nop
  400584:	0040053d 	.word	0x0040053d
  400588:	0040b03d 	.word	0x0040b03d
  40058c:	0040a659 	.word	0x0040a659
  400590:	0040a455 	.word	0x0040a455
  400594:	00400165 	.word	0x00400165
  400598:	004004b1 	.word	0x004004b1
  40059c:	00400271 	.word	0x00400271
  4005a0:	004002a9 	.word	0x004002a9
  4005a4:	0040038d 	.word	0x0040038d
  4005a8:	004003a5 	.word	0x004003a5
  4005ac:	0040040d 	.word	0x0040040d
  4005b0:	00409915 	.word	0x00409915

004005b4 <_GLOBAL__sub_I_vApplicationMallocFailedHook>:
  4005b4:	b508      	push	{r3, lr}
  4005b6:	f64f 71ff 	movw	r1, #65535	; 0xffff
  4005ba:	2001      	movs	r0, #1
  4005bc:	4b01      	ldr	r3, [pc, #4]	; (4005c4 <_GLOBAL__sub_I_vApplicationMallocFailedHook+0x10>)
  4005be:	4798      	blx	r3
  4005c0:	bd08      	pop	{r3, pc}
  4005c2:	bf00      	nop
  4005c4:	00400475 	.word	0x00400475

004005c8 <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  4005c8:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  4005ca:	4b06      	ldr	r3, [pc, #24]	; (4005e4 <sd_mmc_configure_slot+0x1c>)
  4005cc:	6819      	ldr	r1, [r3, #0]
  4005ce:	7f8b      	ldrb	r3, [r1, #30]
  4005d0:	3300      	adds	r3, #0
  4005d2:	bf18      	it	ne
  4005d4:	2301      	movne	r3, #1
  4005d6:	7b4a      	ldrb	r2, [r1, #13]
  4005d8:	6809      	ldr	r1, [r1, #0]
  4005da:	4803      	ldr	r0, [pc, #12]	; (4005e8 <sd_mmc_configure_slot+0x20>)
  4005dc:	7800      	ldrb	r0, [r0, #0]
  4005de:	4c03      	ldr	r4, [pc, #12]	; (4005ec <sd_mmc_configure_slot+0x24>)
  4005e0:	47a0      	blx	r4
  4005e2:	bd10      	pop	{r4, pc}
  4005e4:	20007518 	.word	0x20007518
  4005e8:	20007540 	.word	0x20007540
  4005ec:	004014ed 	.word	0x004014ed

004005f0 <sd_mmc_select_slot>:
	if (slot >= SD_MMC_MEM_CNT) {
  4005f0:	b108      	cbz	r0, 4005f6 <sd_mmc_select_slot+0x6>
		return SD_MMC_ERR_SLOT;
  4005f2:	2004      	movs	r0, #4
  4005f4:	4770      	bx	lr
{
  4005f6:	b510      	push	{r4, lr}
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
  4005f8:	4b0e      	ldr	r3, [pc, #56]	; (400634 <sd_mmc_select_slot+0x44>)
			|| (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
  4005fa:	7a9b      	ldrb	r3, [r3, #10]
  4005fc:	3b03      	subs	r3, #3
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
  4005fe:	b2db      	uxtb	r3, r3
  400600:	2b01      	cmp	r3, #1
  400602:	d90d      	bls.n	400620 <sd_mmc_select_slot+0x30>
	sd_mmc_slot_sel = slot;
  400604:	2200      	movs	r2, #0
  400606:	4b0c      	ldr	r3, [pc, #48]	; (400638 <sd_mmc_select_slot+0x48>)
  400608:	701a      	strb	r2, [r3, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  40060a:	4c0a      	ldr	r4, [pc, #40]	; (400634 <sd_mmc_select_slot+0x44>)
  40060c:	4b0b      	ldr	r3, [pc, #44]	; (40063c <sd_mmc_select_slot+0x4c>)
  40060e:	601c      	str	r4, [r3, #0]
	sd_mmc_configure_slot();
  400610:	4b0b      	ldr	r3, [pc, #44]	; (400640 <sd_mmc_select_slot+0x50>)
  400612:	4798      	blx	r3
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  400614:	7aa0      	ldrb	r0, [r4, #10]
  400616:	2802      	cmp	r0, #2
  400618:	bf14      	ite	ne
  40061a:	2000      	movne	r0, #0
  40061c:	2001      	moveq	r0, #1
  40061e:	bd10      	pop	{r4, pc}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  400620:	4b04      	ldr	r3, [pc, #16]	; (400634 <sd_mmc_select_slot+0x44>)
  400622:	2202      	movs	r2, #2
  400624:	729a      	strb	r2, [r3, #10]
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  400626:	4a07      	ldr	r2, [pc, #28]	; (400644 <sd_mmc_select_slot+0x54>)
  400628:	601a      	str	r2, [r3, #0]
		sd_mmc_cards[slot].bus_width = 1;
  40062a:	2201      	movs	r2, #1
  40062c:	735a      	strb	r2, [r3, #13]
		sd_mmc_cards[slot].high_speed = 0;
  40062e:	2200      	movs	r2, #0
  400630:	779a      	strb	r2, [r3, #30]
  400632:	e7e7      	b.n	400604 <sd_mmc_select_slot+0x14>
  400634:	2000751c 	.word	0x2000751c
  400638:	20007540 	.word	0x20007540
  40063c:	20007518 	.word	0x20007518
  400640:	004005c9 	.word	0x004005c9
  400644:	00061a80 	.word	0x00061a80

00400648 <sdio_cmd52>:
{
  400648:	b538      	push	{r3, r4, r5, lr}
  40064a:	9c04      	ldr	r4, [sp, #16]
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
  40064c:	0252      	lsls	r2, r2, #9
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
  40064e:	ea42 62c3 	orr.w	r2, r2, r3, lsl #27
  400652:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
  400656:	ea42 72c0 	orr.w	r2, r2, r0, lsl #31
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
  40065a:	7821      	ldrb	r1, [r4, #0]
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
  40065c:	4311      	orrs	r1, r2
  40065e:	f241 3034 	movw	r0, #4916	; 0x1334
  400662:	4b05      	ldr	r3, [pc, #20]	; (400678 <sdio_cmd52+0x30>)
  400664:	4798      	blx	r3
  400666:	4605      	mov	r5, r0
  400668:	b908      	cbnz	r0, 40066e <sdio_cmd52+0x26>
}
  40066a:	4628      	mov	r0, r5
  40066c:	bd38      	pop	{r3, r4, r5, pc}
	*io_data = driver_get_response() & 0xFF;
  40066e:	4b03      	ldr	r3, [pc, #12]	; (40067c <sdio_cmd52+0x34>)
  400670:	4798      	blx	r3
  400672:	7020      	strb	r0, [r4, #0]
	return true;
  400674:	e7f9      	b.n	40066a <sdio_cmd52+0x22>
  400676:	bf00      	nop
  400678:	004015cd 	.word	0x004015cd
  40067c:	004015f9 	.word	0x004015f9

00400680 <sd_mmc_cmd9_mci>:
{
  400680:	b510      	push	{r4, lr}
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  400682:	4b09      	ldr	r3, [pc, #36]	; (4006a8 <sd_mmc_cmd9_mci+0x28>)
  400684:	681b      	ldr	r3, [r3, #0]
  400686:	8919      	ldrh	r1, [r3, #8]
  400688:	0409      	lsls	r1, r1, #16
  40068a:	f641 3009 	movw	r0, #6921	; 0x1b09
  40068e:	4b07      	ldr	r3, [pc, #28]	; (4006ac <sd_mmc_cmd9_mci+0x2c>)
  400690:	4798      	blx	r3
  400692:	4604      	mov	r4, r0
  400694:	b908      	cbnz	r0, 40069a <sd_mmc_cmd9_mci+0x1a>
}
  400696:	4620      	mov	r0, r4
  400698:	bd10      	pop	{r4, pc}
	driver_get_response_128(sd_mmc_card->csd);
  40069a:	4b03      	ldr	r3, [pc, #12]	; (4006a8 <sd_mmc_cmd9_mci+0x28>)
  40069c:	6818      	ldr	r0, [r3, #0]
  40069e:	300e      	adds	r0, #14
  4006a0:	4b03      	ldr	r3, [pc, #12]	; (4006b0 <sd_mmc_cmd9_mci+0x30>)
  4006a2:	4798      	blx	r3
	return true;
  4006a4:	e7f7      	b.n	400696 <sd_mmc_cmd9_mci+0x16>
  4006a6:	bf00      	nop
  4006a8:	20007518 	.word	0x20007518
  4006ac:	004015cd 	.word	0x004015cd
  4006b0:	00401605 	.word	0x00401605

004006b4 <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
  4006b4:	b508      	push	{r3, lr}
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4006b6:	4b04      	ldr	r3, [pc, #16]	; (4006c8 <sd_mmc_deselect_slot+0x14>)
  4006b8:	781b      	ldrb	r3, [r3, #0]
  4006ba:	b103      	cbz	r3, 4006be <sd_mmc_deselect_slot+0xa>
  4006bc:	bd08      	pop	{r3, pc}
		driver_deselect_device(sd_mmc_slot_sel);
  4006be:	2000      	movs	r0, #0
  4006c0:	4b02      	ldr	r3, [pc, #8]	; (4006cc <sd_mmc_deselect_slot+0x18>)
  4006c2:	4798      	blx	r3
	}
}
  4006c4:	e7fa      	b.n	4006bc <sd_mmc_deselect_slot+0x8>
  4006c6:	bf00      	nop
  4006c8:	20007540 	.word	0x20007540
  4006cc:	004015a5 	.word	0x004015a5

004006d0 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  4006d0:	b508      	push	{r3, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  4006d2:	2204      	movs	r2, #4
  4006d4:	4b03      	ldr	r3, [pc, #12]	; (4006e4 <sd_mmc_init+0x14>)
  4006d6:	729a      	strb	r2, [r3, #10]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  4006d8:	22ff      	movs	r2, #255	; 0xff
  4006da:	4b03      	ldr	r3, [pc, #12]	; (4006e8 <sd_mmc_init+0x18>)
  4006dc:	701a      	strb	r2, [r3, #0]
	driver_init();
  4006de:	4b03      	ldr	r3, [pc, #12]	; (4006ec <sd_mmc_init+0x1c>)
  4006e0:	4798      	blx	r3
  4006e2:	bd08      	pop	{r3, pc}
  4006e4:	2000751c 	.word	0x2000751c
  4006e8:	20007540 	.word	0x20007540
  4006ec:	004014b5 	.word	0x004014b5

004006f0 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  4006f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4006f4:	b095      	sub	sp, #84	; 0x54
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
  4006f6:	4ba7      	ldr	r3, [pc, #668]	; (400994 <sd_mmc_check+0x2a4>)
  4006f8:	4798      	blx	r3
  4006fa:	4604      	mov	r4, r0
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  4006fc:	2801      	cmp	r0, #1
  4006fe:	d005      	beq.n	40070c <sd_mmc_check+0x1c>
		sd_mmc_deselect_slot();
  400700:	4ba5      	ldr	r3, [pc, #660]	; (400998 <sd_mmc_check+0x2a8>)
  400702:	4798      	blx	r3
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  400704:	4620      	mov	r0, r4
  400706:	b015      	add	sp, #84	; 0x54
  400708:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint8_t data = 0x08;
  40070c:	ae14      	add	r6, sp, #80	; 0x50
  40070e:	2308      	movs	r3, #8
  400710:	f806 3d45 	strb.w	r3, [r6, #-69]!
	sd_mmc_card->type = CARD_TYPE_SD;
  400714:	4ba1      	ldr	r3, [pc, #644]	; (40099c <sd_mmc_check+0x2ac>)
  400716:	681b      	ldr	r3, [r3, #0]
  400718:	2701      	movs	r7, #1
  40071a:	72df      	strb	r7, [r3, #11]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  40071c:	2500      	movs	r5, #0
  40071e:	731d      	strb	r5, [r3, #12]
	sd_mmc_card->rca = 0;
  400720:	811d      	strh	r5, [r3, #8]
	driver_send_clock();
  400722:	4b9f      	ldr	r3, [pc, #636]	; (4009a0 <sd_mmc_check+0x2b0>)
  400724:	4798      	blx	r3
	sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA,SDIO_CCCR_IOA, 0, &data);
  400726:	9600      	str	r6, [sp, #0]
  400728:	462b      	mov	r3, r5
  40072a:	2206      	movs	r2, #6
  40072c:	4629      	mov	r1, r5
  40072e:	4638      	mov	r0, r7
  400730:	4e9c      	ldr	r6, [pc, #624]	; (4009a4 <sd_mmc_check+0x2b4>)
  400732:	47b0      	blx	r6
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  400734:	4629      	mov	r1, r5
  400736:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  40073a:	4b9b      	ldr	r3, [pc, #620]	; (4009a8 <sd_mmc_check+0x2b8>)
  40073c:	4798      	blx	r3
  40073e:	b930      	cbnz	r0, 40074e <sd_mmc_check+0x5e>
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  400740:	4b96      	ldr	r3, [pc, #600]	; (40099c <sd_mmc_check+0x2ac>)
  400742:	681b      	ldr	r3, [r3, #0]
  400744:	2403      	movs	r4, #3
  400746:	729c      	strb	r4, [r3, #10]
	sd_mmc_deselect_slot();
  400748:	4b93      	ldr	r3, [pc, #588]	; (400998 <sd_mmc_check+0x2a8>)
  40074a:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
  40074c:	e7da      	b.n	400704 <sd_mmc_check+0x14>
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  40074e:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  400752:	f245 5008 	movw	r0, #21768	; 0x5508
  400756:	4b94      	ldr	r3, [pc, #592]	; (4009a8 <sd_mmc_check+0x2b8>)
  400758:	4798      	blx	r3
  40075a:	2800      	cmp	r0, #0
  40075c:	f040 8093 	bne.w	400886 <sd_mmc_check+0x196>
	*v2 = 0;
  400760:	f04f 0900 	mov.w	r9, #0
	if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND, 0)) {
  400764:	2100      	movs	r1, #0
  400766:	f244 5005 	movw	r0, #17669	; 0x4505
  40076a:	4b8f      	ldr	r3, [pc, #572]	; (4009a8 <sd_mmc_check+0x2b8>)
  40076c:	4798      	blx	r3
  40076e:	2800      	cmp	r0, #0
  400770:	f040 8097 	bne.w	4008a2 <sd_mmc_check+0x1b2>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400774:	4b89      	ldr	r3, [pc, #548]	; (40099c <sd_mmc_check+0x2ac>)
  400776:	681b      	ldr	r3, [r3, #0]
  400778:	7adb      	ldrb	r3, [r3, #11]
  40077a:	f013 0f01 	tst.w	r3, #1
  40077e:	f040 80b5 	bne.w	4008ec <sd_mmc_check+0x1fc>
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  400782:	2100      	movs	r1, #0
  400784:	f245 1003 	movw	r0, #20739	; 0x5103
  400788:	4b87      	ldr	r3, [pc, #540]	; (4009a8 <sd_mmc_check+0x2b8>)
  40078a:	4798      	blx	r3
  40078c:	2800      	cmp	r0, #0
  40078e:	d0d7      	beq.n	400740 <sd_mmc_check+0x50>
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  400790:	4d82      	ldr	r5, [pc, #520]	; (40099c <sd_mmc_check+0x2ac>)
  400792:	682e      	ldr	r6, [r5, #0]
  400794:	4b85      	ldr	r3, [pc, #532]	; (4009ac <sd_mmc_check+0x2bc>)
  400796:	4798      	blx	r3
  400798:	0c00      	lsrs	r0, r0, #16
  40079a:	8130      	strh	r0, [r6, #8]
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40079c:	682b      	ldr	r3, [r5, #0]
  40079e:	7adb      	ldrb	r3, [r3, #11]
  4007a0:	f013 0f01 	tst.w	r3, #1
  4007a4:	d034      	beq.n	400810 <sd_mmc_check+0x120>
		if (!sd_mmc_cmd9_mci()) {
  4007a6:	4b82      	ldr	r3, [pc, #520]	; (4009b0 <sd_mmc_check+0x2c0>)
  4007a8:	4798      	blx	r3
  4007aa:	2800      	cmp	r0, #0
  4007ac:	d0c8      	beq.n	400740 <sd_mmc_check+0x50>
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  4007ae:	682b      	ldr	r3, [r5, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4007b0:	7c5a      	ldrb	r2, [r3, #17]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  4007b2:	f3c2 00c3 	ubfx	r0, r2, #3, #4
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  4007b6:	f002 0207 	and.w	r2, r2, #7
	sd_mmc_card->clock = unit * mul * 1000;
  4007ba:	497e      	ldr	r1, [pc, #504]	; (4009b4 <sd_mmc_check+0x2c4>)
  4007bc:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
  4007c0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4007c4:	fb02 f201 	mul.w	r2, r2, r1
  4007c8:	497b      	ldr	r1, [pc, #492]	; (4009b8 <sd_mmc_check+0x2c8>)
  4007ca:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  4007ce:	fb02 f201 	mul.w	r2, r2, r1
  4007d2:	601a      	str	r2, [r3, #0]
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  4007d4:	7b9a      	ldrb	r2, [r3, #14]
  4007d6:	0992      	lsrs	r2, r2, #6
  4007d8:	f040 820b 	bne.w	400bf2 <sd_mmc_check+0x502>
  4007dc:	7d99      	ldrb	r1, [r3, #22]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4007de:	7d58      	ldrb	r0, [r3, #21]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4007e0:	7d1a      	ldrb	r2, [r3, #20]
  4007e2:	0292      	lsls	r2, r2, #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4007e4:	ea42 0280 	orr.w	r2, r2, r0, lsl #2
  4007e8:	ea42 12a1 	orr.w	r2, r2, r1, asr #6
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4007ec:	7e18      	ldrb	r0, [r3, #24]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4007ee:	7dd9      	ldrb	r1, [r3, #23]
  4007f0:	0049      	lsls	r1, r1, #1
  4007f2:	ea41 11e0 	orr.w	r1, r1, r0, asr #7
	}
	value &=  ((uint32_t)1 << size) - 1;
  4007f6:	f3c2 020b 	ubfx	r2, r2, #0, #12
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4007fa:	3201      	adds	r2, #1
  4007fc:	f001 0107 	and.w	r1, r1, #7
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  400800:	3102      	adds	r1, #2
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400802:	408a      	lsls	r2, r1
  400804:	7cd9      	ldrb	r1, [r3, #19]
  400806:	f001 010f 	and.w	r1, r1, #15
		sd_mmc_card->capacity = blocknr *
  40080a:	408a      	lsls	r2, r1
				/ 1024;
  40080c:	0a92      	lsrs	r2, r2, #10
		sd_mmc_card->capacity = blocknr *
  40080e:	605a      	str	r2, [r3, #4]
			(uint32_t)sd_mmc_card->rca << 16)) {
  400810:	4b62      	ldr	r3, [pc, #392]	; (40099c <sd_mmc_check+0x2ac>)
  400812:	681b      	ldr	r3, [r3, #0]
  400814:	8919      	ldrh	r1, [r3, #8]
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  400816:	0409      	lsls	r1, r1, #16
  400818:	f243 1007 	movw	r0, #12551	; 0x3107
  40081c:	4b62      	ldr	r3, [pc, #392]	; (4009a8 <sd_mmc_check+0x2b8>)
  40081e:	4798      	blx	r3
  400820:	2800      	cmp	r0, #0
  400822:	d08d      	beq.n	400740 <sd_mmc_check+0x50>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400824:	4b5d      	ldr	r3, [pc, #372]	; (40099c <sd_mmc_check+0x2ac>)
  400826:	681b      	ldr	r3, [r3, #0]
  400828:	7ada      	ldrb	r2, [r3, #11]
  40082a:	f012 0f01 	tst.w	r2, #1
  40082e:	f040 81ed 	bne.w	400c0c <sd_mmc_check+0x51c>
	if (IS_SDIO()) {
  400832:	4b5a      	ldr	r3, [pc, #360]	; (40099c <sd_mmc_check+0x2ac>)
  400834:	681b      	ldr	r3, [r3, #0]
  400836:	7adb      	ldrb	r3, [r3, #11]
  400838:	f013 0f04 	tst.w	r3, #4
  40083c:	f000 829c 	beq.w	400d78 <sd_mmc_check+0x688>
  400840:	2509      	movs	r5, #9
		sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_old, 0, &addr_cis[i]);
  400842:	2700      	movs	r7, #0
  400844:	4e57      	ldr	r6, [pc, #348]	; (4009a4 <sd_mmc_check+0x2b4>)
  400846:	f1a5 0309 	sub.w	r3, r5, #9
  40084a:	aa03      	add	r2, sp, #12
  40084c:	4413      	add	r3, r2
  40084e:	9300      	str	r3, [sp, #0]
  400850:	463b      	mov	r3, r7
  400852:	462a      	mov	r2, r5
  400854:	4639      	mov	r1, r7
  400856:	4638      	mov	r0, r7
  400858:	47b0      	blx	r6
		addr_old++;
  40085a:	3501      	adds	r5, #1
	for(i = 0; i < 4; i++) {
  40085c:	2d0d      	cmp	r5, #13
  40085e:	d1f2      	bne.n	400846 <sd_mmc_check+0x156>
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + \
  400860:	f89d 300d 	ldrb.w	r3, [sp, #13]
  400864:	f89d 900c 	ldrb.w	r9, [sp, #12]
  400868:	eb09 2903 	add.w	r9, r9, r3, lsl #8
				(addr_cis[2] << 16) + (addr_cis[3] << 24);
  40086c:	f89d 300e 	ldrb.w	r3, [sp, #14]
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + \
  400870:	eb09 4903 	add.w	r9, r9, r3, lsl #16
				(addr_cis[2] << 16) + (addr_cis[3] << 24);
  400874:	f89d 300f 	ldrb.w	r3, [sp, #15]
  400878:	eb09 6903 	add.w	r9, r9, r3, lsl #24
	addr_new = addr_old;
  40087c:	464e      	mov	r6, r9
			sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
  40087e:	f04f 0800 	mov.w	r8, #0
  400882:	4f48      	ldr	r7, [pc, #288]	; (4009a4 <sd_mmc_check+0x2b4>)
  400884:	e239      	b.n	400cfa <sd_mmc_check+0x60a>
	resp = driver_get_response();
  400886:	4b49      	ldr	r3, [pc, #292]	; (4009ac <sd_mmc_check+0x2bc>)
  400888:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
  40088a:	f1b0 3fff 	cmp.w	r0, #4294967295
  40088e:	f000 8347 	beq.w	400f20 <sd_mmc_check+0x830>
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  400892:	f3c0 000b 	ubfx	r0, r0, #0, #12
  400896:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
  40089a:	f47f af51 	bne.w	400740 <sd_mmc_check+0x50>
	*v2 = 1;
  40089e:	46b9      	mov	r9, r7
  4008a0:	e760      	b.n	400764 <sd_mmc_check+0x74>
	resp = driver_get_response();
  4008a2:	4b42      	ldr	r3, [pc, #264]	; (4009ac <sd_mmc_check+0x2bc>)
  4008a4:	4798      	blx	r3
	if ((resp & OCR_SDIO_NF) == 0) {
  4008a6:	f010 4fe0 	tst.w	r0, #1879048192	; 0x70000000
  4008aa:	f43f af63 	beq.w	400774 <sd_mmc_check+0x84>
  4008ae:	f241 3589 	movw	r5, #5001	; 0x1389
		if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND,
  4008b2:	f244 5805 	movw	r8, #17669	; 0x4505
  4008b6:	4e3c      	ldr	r6, [pc, #240]	; (4009a8 <sd_mmc_check+0x2b8>)
		resp = driver_get_response();
  4008b8:	4f3c      	ldr	r7, [pc, #240]	; (4009ac <sd_mmc_check+0x2bc>)
		if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND,
  4008ba:	f400 11fc 	and.w	r1, r0, #2064384	; 0x1f8000
  4008be:	4640      	mov	r0, r8
  4008c0:	47b0      	blx	r6
  4008c2:	2800      	cmp	r0, #0
  4008c4:	f43f af3c 	beq.w	400740 <sd_mmc_check+0x50>
		resp = driver_get_response();
  4008c8:	47b8      	blx	r7
		if ((resp & OCR_POWER_UP_BUSY) == OCR_POWER_UP_BUSY) {
  4008ca:	2800      	cmp	r0, #0
  4008cc:	db02      	blt.n	4008d4 <sd_mmc_check+0x1e4>
		if (cmd5_retry-- == 0) {
  4008ce:	3d01      	subs	r5, #1
  4008d0:	d1f3      	bne.n	4008ba <sd_mmc_check+0x1ca>
  4008d2:	e735      	b.n	400740 <sd_mmc_check+0x50>
	if ((resp & OCR_SDIO_MP) > 0) {
  4008d4:	f010 6f00 	tst.w	r0, #134217728	; 0x8000000
  4008d8:	d104      	bne.n	4008e4 <sd_mmc_check+0x1f4>
		sd_mmc_card->type = CARD_TYPE_SDIO;
  4008da:	4b30      	ldr	r3, [pc, #192]	; (40099c <sd_mmc_check+0x2ac>)
  4008dc:	681b      	ldr	r3, [r3, #0]
  4008de:	2204      	movs	r2, #4
  4008e0:	72da      	strb	r2, [r3, #11]
  4008e2:	e74e      	b.n	400782 <sd_mmc_check+0x92>
		sd_mmc_card->type = CARD_TYPE_SD_COMBO;
  4008e4:	4b2d      	ldr	r3, [pc, #180]	; (40099c <sd_mmc_check+0x2ac>)
  4008e6:	681b      	ldr	r3, [r3, #0]
  4008e8:	2205      	movs	r2, #5
  4008ea:	72da      	strb	r2, [r3, #11]
  4008ec:	f1b9 0f00 	cmp.w	r9, #0
  4008f0:	4f32      	ldr	r7, [pc, #200]	; (4009bc <sd_mmc_check+0x2cc>)
  4008f2:	bf14      	ite	ne
  4008f4:	46b9      	movne	r9, r7
  4008f6:	f44f 19fc 	moveq.w	r9, #2064384	; 0x1f8000
	if ((resp & OCR_SDIO_NF) == 0) {
  4008fa:	f640 0535 	movw	r5, #2101	; 0x835
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  4008fe:	f04f 0800 	mov.w	r8, #0
  400902:	4e29      	ldr	r6, [pc, #164]	; (4009a8 <sd_mmc_check+0x2b8>)
		resp = driver_get_response();
  400904:	4f29      	ldr	r7, [pc, #164]	; (4009ac <sd_mmc_check+0x2bc>)
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  400906:	4641      	mov	r1, r8
  400908:	f241 1037 	movw	r0, #4407	; 0x1137
  40090c:	47b0      	blx	r6
  40090e:	b148      	cbz	r0, 400924 <sd_mmc_check+0x234>
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  400910:	4649      	mov	r1, r9
  400912:	f244 5029 	movw	r0, #17705	; 0x4529
  400916:	47b0      	blx	r6
  400918:	b120      	cbz	r0, 400924 <sd_mmc_check+0x234>
		resp = driver_get_response();
  40091a:	47b8      	blx	r7
		if (resp & OCR_POWER_UP_BUSY) {
  40091c:	2800      	cmp	r0, #0
  40091e:	db20      	blt.n	400962 <sd_mmc_check+0x272>
		if (retry-- == 0) {
  400920:	3d01      	subs	r5, #1
  400922:	d1f0      	bne.n	400906 <sd_mmc_check+0x216>
			sd_mmc_card->type = CARD_TYPE_MMC;
  400924:	4b1d      	ldr	r3, [pc, #116]	; (40099c <sd_mmc_check+0x2ac>)
  400926:	681b      	ldr	r3, [r3, #0]
  400928:	2202      	movs	r2, #2
  40092a:	72da      	strb	r2, [r3, #11]
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  40092c:	2100      	movs	r1, #0
  40092e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  400932:	4b1d      	ldr	r3, [pc, #116]	; (4009a8 <sd_mmc_check+0x2b8>)
  400934:	4798      	blx	r3
  400936:	2800      	cmp	r0, #0
  400938:	f43f af02 	beq.w	400740 <sd_mmc_check+0x50>
  40093c:	f241 0569 	movw	r5, #4201	; 0x1069
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  400940:	f8df 8078 	ldr.w	r8, [pc, #120]	; 4009bc <sd_mmc_check+0x2cc>
  400944:	4e18      	ldr	r6, [pc, #96]	; (4009a8 <sd_mmc_check+0x2b8>)
		resp = driver_get_response();
  400946:	4f19      	ldr	r7, [pc, #100]	; (4009ac <sd_mmc_check+0x2bc>)
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  400948:	4641      	mov	r1, r8
  40094a:	f244 5001 	movw	r0, #17665	; 0x4501
  40094e:	47b0      	blx	r6
  400950:	2800      	cmp	r0, #0
  400952:	f43f aef5 	beq.w	400740 <sd_mmc_check+0x50>
		resp = driver_get_response();
  400956:	47b8      	blx	r7
		if (resp & OCR_POWER_UP_BUSY) {
  400958:	2800      	cmp	r0, #0
  40095a:	db31      	blt.n	4009c0 <sd_mmc_check+0x2d0>
		if (retry-- == 0) {
  40095c:	3d01      	subs	r5, #1
  40095e:	d1f3      	bne.n	400948 <sd_mmc_check+0x258>
  400960:	e6ee      	b.n	400740 <sd_mmc_check+0x50>
			if ((resp & OCR_CCS) != 0) {
  400962:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
  400966:	d005      	beq.n	400974 <sd_mmc_check+0x284>
				sd_mmc_card->type |= CARD_TYPE_HC;
  400968:	4b0c      	ldr	r3, [pc, #48]	; (40099c <sd_mmc_check+0x2ac>)
  40096a:	681a      	ldr	r2, [r3, #0]
  40096c:	7ad3      	ldrb	r3, [r2, #11]
  40096e:	f043 0308 	orr.w	r3, r3, #8
  400972:	72d3      	strb	r3, [r2, #11]
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400974:	4b09      	ldr	r3, [pc, #36]	; (40099c <sd_mmc_check+0x2ac>)
  400976:	681b      	ldr	r3, [r3, #0]
  400978:	7adb      	ldrb	r3, [r3, #11]
  40097a:	f013 0f01 	tst.w	r3, #1
  40097e:	f43f af00 	beq.w	400782 <sd_mmc_check+0x92>
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  400982:	2100      	movs	r1, #0
  400984:	f645 3002 	movw	r0, #23298	; 0x5b02
  400988:	4b07      	ldr	r3, [pc, #28]	; (4009a8 <sd_mmc_check+0x2b8>)
  40098a:	4798      	blx	r3
  40098c:	2800      	cmp	r0, #0
  40098e:	f47f aef8 	bne.w	400782 <sd_mmc_check+0x92>
  400992:	e6d5      	b.n	400740 <sd_mmc_check+0x50>
  400994:	004005f1 	.word	0x004005f1
  400998:	004006b5 	.word	0x004006b5
  40099c:	20007518 	.word	0x20007518
  4009a0:	004015a9 	.word	0x004015a9
  4009a4:	00400649 	.word	0x00400649
  4009a8:	004015cd 	.word	0x004015cd
  4009ac:	004015f9 	.word	0x004015f9
  4009b0:	00400681 	.word	0x00400681
  4009b4:	0040dc9c 	.word	0x0040dc9c
  4009b8:	0040dcb8 	.word	0x0040dcb8
  4009bc:	401f8000 	.word	0x401f8000
			if ((resp & OCR_ACCESS_MODE_MASK)
  4009c0:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
  4009c4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  4009c8:	d027      	beq.n	400a1a <sd_mmc_check+0x32a>
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  4009ca:	2100      	movs	r1, #0
  4009cc:	f645 3002 	movw	r0, #23298	; 0x5b02
  4009d0:	4ba7      	ldr	r3, [pc, #668]	; (400c70 <sd_mmc_check+0x580>)
  4009d2:	4798      	blx	r3
  4009d4:	2800      	cmp	r0, #0
  4009d6:	f43f aeb3 	beq.w	400740 <sd_mmc_check+0x50>
	sd_mmc_card->rca = 1;
  4009da:	4ba6      	ldr	r3, [pc, #664]	; (400c74 <sd_mmc_check+0x584>)
  4009dc:	681b      	ldr	r3, [r3, #0]
  4009de:	2201      	movs	r2, #1
  4009e0:	811a      	strh	r2, [r3, #8]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  4009e2:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  4009e6:	f241 1003 	movw	r0, #4355	; 0x1103
  4009ea:	4ba1      	ldr	r3, [pc, #644]	; (400c70 <sd_mmc_check+0x580>)
  4009ec:	4798      	blx	r3
  4009ee:	2800      	cmp	r0, #0
  4009f0:	f43f aea6 	beq.w	400740 <sd_mmc_check+0x50>
	if (!sd_mmc_cmd9_mci()) {
  4009f4:	4ba0      	ldr	r3, [pc, #640]	; (400c78 <sd_mmc_check+0x588>)
  4009f6:	4798      	blx	r3
  4009f8:	2800      	cmp	r0, #0
  4009fa:	f43f aea1 	beq.w	400740 <sd_mmc_check+0x50>
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  4009fe:	4b9d      	ldr	r3, [pc, #628]	; (400c74 <sd_mmc_check+0x584>)
  400a00:	681a      	ldr	r2, [r3, #0]
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400a02:	7b93      	ldrb	r3, [r2, #14]
	value &=  ((uint32_t)1 << size) - 1;
  400a04:	f3c3 0383 	ubfx	r3, r3, #2, #4
  400a08:	3b01      	subs	r3, #1
  400a0a:	2b03      	cmp	r3, #3
  400a0c:	d80c      	bhi.n	400a28 <sd_mmc_check+0x338>
  400a0e:	e8df f013 	tbh	[pc, r3, lsl #1]
  400a12:	00cc      	.short	0x00cc
  400a14:	00d200cf 	.word	0x00d200cf
  400a18:	00d5      	.short	0x00d5
				sd_mmc_card->type |= CARD_TYPE_HC;
  400a1a:	4b96      	ldr	r3, [pc, #600]	; (400c74 <sd_mmc_check+0x584>)
  400a1c:	681a      	ldr	r2, [r3, #0]
  400a1e:	7ad3      	ldrb	r3, [r2, #11]
  400a20:	f043 0308 	orr.w	r3, r3, #8
  400a24:	72d3      	strb	r3, [r2, #11]
  400a26:	e7d0      	b.n	4009ca <sd_mmc_check+0x2da>
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  400a28:	2312      	movs	r3, #18
  400a2a:	7313      	strb	r3, [r2, #12]
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400a2c:	7c53      	ldrb	r3, [r2, #17]
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  400a2e:	f3c3 00c3 	ubfx	r0, r3, #3, #4
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400a32:	f003 0307 	and.w	r3, r3, #7
	sd_mmc_card->clock = unit * mul * 1000;
  400a36:	4991      	ldr	r1, [pc, #580]	; (400c7c <sd_mmc_check+0x58c>)
  400a38:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
  400a3c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  400a40:	fb03 f301 	mul.w	r3, r3, r1
  400a44:	498e      	ldr	r1, [pc, #568]	; (400c80 <sd_mmc_check+0x590>)
  400a46:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  400a4a:	fb03 f301 	mul.w	r3, r3, r1
  400a4e:	6013      	str	r3, [r2, #0]
  400a50:	7d91      	ldrb	r1, [r2, #22]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400a52:	7d50      	ldrb	r0, [r2, #21]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400a54:	7d13      	ldrb	r3, [r2, #20]
  400a56:	029b      	lsls	r3, r3, #10
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400a58:	ea43 0380 	orr.w	r3, r3, r0, lsl #2
  400a5c:	ea43 13a1 	orr.w	r3, r3, r1, asr #6
	value &=  ((uint32_t)1 << size) - 1;
  400a60:	f3c3 030b 	ubfx	r3, r3, #0, #12
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  400a64:	f640 71ff 	movw	r1, #4095	; 0xfff
  400a68:	428b      	cmp	r3, r1
  400a6a:	d00f      	beq.n	400a8c <sd_mmc_check+0x39c>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400a6c:	7e10      	ldrb	r0, [r2, #24]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400a6e:	7dd1      	ldrb	r1, [r2, #23]
  400a70:	0049      	lsls	r1, r1, #1
  400a72:	ea41 11e0 	orr.w	r1, r1, r0, asr #7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  400a76:	3301      	adds	r3, #1
	value &=  ((uint32_t)1 << size) - 1;
  400a78:	f001 0107 	and.w	r1, r1, #7
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  400a7c:	3102      	adds	r1, #2
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  400a7e:	408b      	lsls	r3, r1
  400a80:	7cd1      	ldrb	r1, [r2, #19]
  400a82:	f001 010f 	and.w	r1, r1, #15
		sd_mmc_card->capacity = blocknr *
  400a86:	408b      	lsls	r3, r1
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  400a88:	0a9b      	lsrs	r3, r3, #10
		sd_mmc_card->capacity = blocknr *
  400a8a:	6053      	str	r3, [r2, #4]
			(uint32_t)sd_mmc_card->rca << 16)) {
  400a8c:	8911      	ldrh	r1, [r2, #8]
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  400a8e:	0409      	lsls	r1, r1, #16
  400a90:	f243 1007 	movw	r0, #12551	; 0x3107
  400a94:	4b76      	ldr	r3, [pc, #472]	; (400c70 <sd_mmc_check+0x580>)
  400a96:	4798      	blx	r3
  400a98:	2800      	cmp	r0, #0
  400a9a:	f43f ae51 	beq.w	400740 <sd_mmc_check+0x50>
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  400a9e:	4b75      	ldr	r3, [pc, #468]	; (400c74 <sd_mmc_check+0x584>)
  400aa0:	681b      	ldr	r3, [r3, #0]
  400aa2:	7b1b      	ldrb	r3, [r3, #12]
  400aa4:	2b3f      	cmp	r3, #63	; 0x3f
  400aa6:	f240 8096 	bls.w	400bd6 <sd_mmc_check+0x4e6>
	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  400aaa:	2100      	movs	r1, #0
  400aac:	9100      	str	r1, [sp, #0]
  400aae:	2301      	movs	r3, #1
  400ab0:	f44f 7200 	mov.w	r2, #512	; 0x200
  400ab4:	4873      	ldr	r0, [pc, #460]	; (400c84 <sd_mmc_check+0x594>)
  400ab6:	4d74      	ldr	r5, [pc, #464]	; (400c88 <sd_mmc_check+0x598>)
  400ab8:	47a8      	blx	r5
  400aba:	2800      	cmp	r0, #0
  400abc:	f43f ae40 	beq.w	400740 <sd_mmc_check+0x50>
  400ac0:	2500      	movs	r5, #0
		if (!driver_read_word(&ext_csd)) {
  400ac2:	4e72      	ldr	r6, [pc, #456]	; (400c8c <sd_mmc_check+0x59c>)
  400ac4:	a803      	add	r0, sp, #12
  400ac6:	47b0      	blx	r6
  400ac8:	2800      	cmp	r0, #0
  400aca:	f43f ae39 	beq.w	400740 <sd_mmc_check+0x50>
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  400ace:	3501      	adds	r5, #1
  400ad0:	b2ad      	uxth	r5, r5
  400ad2:	2d32      	cmp	r5, #50	; 0x32
  400ad4:	d1f6      	bne.n	400ac4 <sd_mmc_check+0x3d4>
			& MMC_CTYPE_52MHZ;
  400ad6:	9e03      	ldr	r6, [sp, #12]
  400ad8:	f006 0602 	and.w	r6, r6, #2
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  400adc:	4b65      	ldr	r3, [pc, #404]	; (400c74 <sd_mmc_check+0x584>)
  400ade:	681b      	ldr	r3, [r3, #0]
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400ae0:	7d9a      	ldrb	r2, [r3, #22]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400ae2:	7d59      	ldrb	r1, [r3, #21]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400ae4:	7d1b      	ldrb	r3, [r3, #20]
  400ae6:	029b      	lsls	r3, r3, #10
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400ae8:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
  400aec:	ea43 13a2 	orr.w	r3, r3, r2, asr #6
	value &=  ((uint32_t)1 << size) - 1;
  400af0:	f3c3 030b 	ubfx	r3, r3, #0, #12
  400af4:	f640 72ff 	movw	r2, #4095	; 0xfff
  400af8:	4293      	cmp	r3, r2
  400afa:	d10e      	bne.n	400b1a <sd_mmc_check+0x42a>
			if (!driver_read_word(&sec_count)) {
  400afc:	4f63      	ldr	r7, [pc, #396]	; (400c8c <sd_mmc_check+0x59c>)
  400afe:	a804      	add	r0, sp, #16
  400b00:	47b8      	blx	r7
  400b02:	2800      	cmp	r0, #0
  400b04:	f43f ae1c 	beq.w	400740 <sd_mmc_check+0x50>
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  400b08:	3501      	adds	r5, #1
  400b0a:	b2ad      	uxth	r5, r5
  400b0c:	2d35      	cmp	r5, #53	; 0x35
  400b0e:	d9f6      	bls.n	400afe <sd_mmc_check+0x40e>
		sd_mmc_card->capacity = sec_count / 2;
  400b10:	4b58      	ldr	r3, [pc, #352]	; (400c74 <sd_mmc_check+0x584>)
  400b12:	681a      	ldr	r2, [r3, #0]
  400b14:	9b04      	ldr	r3, [sp, #16]
  400b16:	085b      	lsrs	r3, r3, #1
  400b18:	6053      	str	r3, [r2, #4]
		if (!driver_read_word(&sec_count)) {
  400b1a:	4f5c      	ldr	r7, [pc, #368]	; (400c8c <sd_mmc_check+0x59c>)
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  400b1c:	2d7f      	cmp	r5, #127	; 0x7f
  400b1e:	d950      	bls.n	400bc2 <sd_mmc_check+0x4d2>
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  400b20:	4b5b      	ldr	r3, [pc, #364]	; (400c90 <sd_mmc_check+0x5a0>)
  400b22:	7818      	ldrb	r0, [r3, #0]
  400b24:	4b5b      	ldr	r3, [pc, #364]	; (400c94 <sd_mmc_check+0x5a4>)
  400b26:	4798      	blx	r3
  400b28:	2803      	cmp	r0, #3
  400b2a:	d91d      	bls.n	400b68 <sd_mmc_check+0x478>
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  400b2c:	4b58      	ldr	r3, [pc, #352]	; (400c90 <sd_mmc_check+0x5a0>)
  400b2e:	7818      	ldrb	r0, [r3, #0]
  400b30:	4b58      	ldr	r3, [pc, #352]	; (400c94 <sd_mmc_check+0x5a4>)
  400b32:	4798      	blx	r3
  400b34:	4605      	mov	r5, r0
	switch (bus_width) {
  400b36:	2804      	cmp	r0, #4
  400b38:	d04b      	beq.n	400bd2 <sd_mmc_check+0x4e2>
		arg = MMC_CMD6_ACCESS_SET_BITS
  400b3a:	4b57      	ldr	r3, [pc, #348]	; (400c98 <sd_mmc_check+0x5a8>)
  400b3c:	4957      	ldr	r1, [pc, #348]	; (400c9c <sd_mmc_check+0x5ac>)
  400b3e:	2808      	cmp	r0, #8
  400b40:	bf18      	it	ne
  400b42:	4619      	movne	r1, r3
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  400b44:	f243 1006 	movw	r0, #12550	; 0x3106
  400b48:	4b49      	ldr	r3, [pc, #292]	; (400c70 <sd_mmc_check+0x580>)
  400b4a:	4798      	blx	r3
  400b4c:	2800      	cmp	r0, #0
  400b4e:	f43f adf7 	beq.w	400740 <sd_mmc_check+0x50>
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400b52:	4b53      	ldr	r3, [pc, #332]	; (400ca0 <sd_mmc_check+0x5b0>)
  400b54:	4798      	blx	r3
  400b56:	f010 0f80 	tst.w	r0, #128	; 0x80
  400b5a:	f47f adf1 	bne.w	400740 <sd_mmc_check+0x50>
	sd_mmc_card->bus_width = bus_width;
  400b5e:	4b45      	ldr	r3, [pc, #276]	; (400c74 <sd_mmc_check+0x584>)
  400b60:	681b      	ldr	r3, [r3, #0]
  400b62:	735d      	strb	r5, [r3, #13]
			sd_mmc_configure_slot();
  400b64:	4b4f      	ldr	r3, [pc, #316]	; (400ca4 <sd_mmc_check+0x5b4>)
  400b66:	4798      	blx	r3
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  400b68:	4b4f      	ldr	r3, [pc, #316]	; (400ca8 <sd_mmc_check+0x5b8>)
  400b6a:	4798      	blx	r3
  400b6c:	b1b0      	cbz	r0, 400b9c <sd_mmc_check+0x4ac>
  400b6e:	b1ae      	cbz	r6, 400b9c <sd_mmc_check+0x4ac>
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  400b70:	494e      	ldr	r1, [pc, #312]	; (400cac <sd_mmc_check+0x5bc>)
  400b72:	f243 1006 	movw	r0, #12550	; 0x3106
  400b76:	4b3e      	ldr	r3, [pc, #248]	; (400c70 <sd_mmc_check+0x580>)
  400b78:	4798      	blx	r3
  400b7a:	2800      	cmp	r0, #0
  400b7c:	f43f ade0 	beq.w	400740 <sd_mmc_check+0x50>
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400b80:	4b47      	ldr	r3, [pc, #284]	; (400ca0 <sd_mmc_check+0x5b0>)
  400b82:	4798      	blx	r3
  400b84:	f010 0f80 	tst.w	r0, #128	; 0x80
  400b88:	f47f adda 	bne.w	400740 <sd_mmc_check+0x50>
	sd_mmc_card->high_speed = 1;
  400b8c:	4b39      	ldr	r3, [pc, #228]	; (400c74 <sd_mmc_check+0x584>)
  400b8e:	681b      	ldr	r3, [r3, #0]
  400b90:	2201      	movs	r2, #1
  400b92:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock = 52000000lu;
  400b94:	4a46      	ldr	r2, [pc, #280]	; (400cb0 <sd_mmc_check+0x5c0>)
  400b96:	601a      	str	r2, [r3, #0]
			sd_mmc_configure_slot();
  400b98:	4b42      	ldr	r3, [pc, #264]	; (400ca4 <sd_mmc_check+0x5b4>)
  400b9a:	4798      	blx	r3
		arg = MMC_CMD6_ACCESS_SET_BITS
  400b9c:	250a      	movs	r5, #10
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400b9e:	f44f 7800 	mov.w	r8, #512	; 0x200
  400ba2:	f241 1710 	movw	r7, #4368	; 0x1110
  400ba6:	4e32      	ldr	r6, [pc, #200]	; (400c70 <sd_mmc_check+0x580>)
  400ba8:	e01d      	b.n	400be6 <sd_mmc_check+0x4f6>
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  400baa:	2314      	movs	r3, #20
  400bac:	7313      	strb	r3, [r2, #12]
  400bae:	e73d      	b.n	400a2c <sd_mmc_check+0x33c>
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  400bb0:	2322      	movs	r3, #34	; 0x22
  400bb2:	7313      	strb	r3, [r2, #12]
  400bb4:	e73a      	b.n	400a2c <sd_mmc_check+0x33c>
		sd_mmc_card->version = CARD_VER_MMC_3;
  400bb6:	2330      	movs	r3, #48	; 0x30
  400bb8:	7313      	strb	r3, [r2, #12]
  400bba:	e737      	b.n	400a2c <sd_mmc_check+0x33c>
		sd_mmc_card->version = CARD_VER_MMC_4;
  400bbc:	2340      	movs	r3, #64	; 0x40
  400bbe:	7313      	strb	r3, [r2, #12]
  400bc0:	e734      	b.n	400a2c <sd_mmc_check+0x33c>
		if (!driver_read_word(&sec_count)) {
  400bc2:	a804      	add	r0, sp, #16
  400bc4:	47b8      	blx	r7
  400bc6:	2800      	cmp	r0, #0
  400bc8:	f43f adba 	beq.w	400740 <sd_mmc_check+0x50>
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  400bcc:	3501      	adds	r5, #1
  400bce:	b2ad      	uxth	r5, r5
  400bd0:	e7a4      	b.n	400b1c <sd_mmc_check+0x42c>
		arg = MMC_CMD6_ACCESS_SET_BITS
  400bd2:	4938      	ldr	r1, [pc, #224]	; (400cb4 <sd_mmc_check+0x5c4>)
  400bd4:	e7b6      	b.n	400b44 <sd_mmc_check+0x454>
		sd_mmc_configure_slot();
  400bd6:	4b33      	ldr	r3, [pc, #204]	; (400ca4 <sd_mmc_check+0x5b4>)
  400bd8:	4798      	blx	r3
  400bda:	e7df      	b.n	400b9c <sd_mmc_check+0x4ac>
  400bdc:	3d01      	subs	r5, #1
	while (retry--) {
  400bde:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
  400be2:	f43f adad 	beq.w	400740 <sd_mmc_check+0x50>
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400be6:	4641      	mov	r1, r8
  400be8:	4638      	mov	r0, r7
  400bea:	47b0      	blx	r6
  400bec:	2800      	cmp	r0, #0
  400bee:	d0f5      	beq.n	400bdc <sd_mmc_check+0x4ec>
  400bf0:	e10e      	b.n	400e10 <sd_mmc_check+0x720>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400bf2:	7dd9      	ldrb	r1, [r3, #23]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400bf4:	7d98      	ldrb	r0, [r3, #22]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400bf6:	7d5a      	ldrb	r2, [r3, #21]
  400bf8:	0412      	lsls	r2, r2, #16
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400bfa:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  400bfe:	430a      	orrs	r2, r1
	value &=  ((uint32_t)1 << size) - 1;
  400c00:	f3c2 0215 	ubfx	r2, r2, #0, #22
				* 512;
  400c04:	3201      	adds	r2, #1
  400c06:	0252      	lsls	r2, r2, #9
		sd_mmc_card->capacity =
  400c08:	605a      	str	r2, [r3, #4]
  400c0a:	e601      	b.n	400810 <sd_mmc_check+0x120>
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400c0c:	8919      	ldrh	r1, [r3, #8]
  400c0e:	0409      	lsls	r1, r1, #16
  400c10:	f241 1037 	movw	r0, #4407	; 0x1137
  400c14:	4b16      	ldr	r3, [pc, #88]	; (400c70 <sd_mmc_check+0x580>)
  400c16:	4798      	blx	r3
  400c18:	2800      	cmp	r0, #0
  400c1a:	f43f ad91 	beq.w	400740 <sd_mmc_check+0x50>
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  400c1e:	2301      	movs	r3, #1
  400c20:	9300      	str	r3, [sp, #0]
  400c22:	2208      	movs	r2, #8
  400c24:	2100      	movs	r1, #0
  400c26:	4824      	ldr	r0, [pc, #144]	; (400cb8 <sd_mmc_check+0x5c8>)
  400c28:	4d17      	ldr	r5, [pc, #92]	; (400c88 <sd_mmc_check+0x598>)
  400c2a:	47a8      	blx	r5
  400c2c:	2800      	cmp	r0, #0
  400c2e:	f43f ad87 	beq.w	400740 <sd_mmc_check+0x50>
	if (!driver_start_read_blocks(scr, 1)) {
  400c32:	2101      	movs	r1, #1
  400c34:	a804      	add	r0, sp, #16
  400c36:	4b21      	ldr	r3, [pc, #132]	; (400cbc <sd_mmc_check+0x5cc>)
  400c38:	4798      	blx	r3
  400c3a:	2800      	cmp	r0, #0
  400c3c:	f43f ad80 	beq.w	400740 <sd_mmc_check+0x50>
	if (!driver_wait_end_of_read_blocks()) {
  400c40:	4b1f      	ldr	r3, [pc, #124]	; (400cc0 <sd_mmc_check+0x5d0>)
  400c42:	4798      	blx	r3
  400c44:	2800      	cmp	r0, #0
  400c46:	f43f ad7b 	beq.w	400740 <sd_mmc_check+0x50>
	switch (SD_SCR_SD_SPEC(scr)) {
  400c4a:	f89d 3010 	ldrb.w	r3, [sp, #16]
  400c4e:	f003 030f 	and.w	r3, r3, #15
  400c52:	2b01      	cmp	r3, #1
  400c54:	d036      	beq.n	400cc4 <sd_mmc_check+0x5d4>
  400c56:	b133      	cbz	r3, 400c66 <sd_mmc_check+0x576>
  400c58:	2b02      	cmp	r3, #2
  400c5a:	d038      	beq.n	400cce <sd_mmc_check+0x5de>
		sd_mmc_card->version = CARD_VER_SD_1_0;
  400c5c:	4b05      	ldr	r3, [pc, #20]	; (400c74 <sd_mmc_check+0x584>)
  400c5e:	681b      	ldr	r3, [r3, #0]
  400c60:	2210      	movs	r2, #16
  400c62:	731a      	strb	r2, [r3, #12]
  400c64:	e5e5      	b.n	400832 <sd_mmc_check+0x142>
		sd_mmc_card->version = CARD_VER_SD_1_0;
  400c66:	4b03      	ldr	r3, [pc, #12]	; (400c74 <sd_mmc_check+0x584>)
  400c68:	681b      	ldr	r3, [r3, #0]
  400c6a:	2210      	movs	r2, #16
  400c6c:	731a      	strb	r2, [r3, #12]
  400c6e:	e5e0      	b.n	400832 <sd_mmc_check+0x142>
  400c70:	004015cd 	.word	0x004015cd
  400c74:	20007518 	.word	0x20007518
  400c78:	00400681 	.word	0x00400681
  400c7c:	0040dc9c 	.word	0x0040dc9c
  400c80:	0040dc5c 	.word	0x0040dc5c
  400c84:	00081108 	.word	0x00081108
  400c88:	00401635 	.word	0x00401635
  400c8c:	004016f9 	.word	0x004016f9
  400c90:	20007540 	.word	0x20007540
  400c94:	004014dd 	.word	0x004014dd
  400c98:	01b70000 	.word	0x01b70000
  400c9c:	01b70200 	.word	0x01b70200
  400ca0:	004015f9 	.word	0x004015f9
  400ca4:	004005c9 	.word	0x004005c9
  400ca8:	004014e7 	.word	0x004014e7
  400cac:	03b90100 	.word	0x03b90100
  400cb0:	03197500 	.word	0x03197500
  400cb4:	01b70100 	.word	0x01b70100
  400cb8:	00081133 	.word	0x00081133
  400cbc:	00401769 	.word	0x00401769
  400cc0:	004017cd 	.word	0x004017cd
		sd_mmc_card->version = CARD_VER_SD_1_10;
  400cc4:	4b98      	ldr	r3, [pc, #608]	; (400f28 <sd_mmc_check+0x838>)
  400cc6:	681b      	ldr	r3, [r3, #0]
  400cc8:	221a      	movs	r2, #26
  400cca:	731a      	strb	r2, [r3, #12]
  400ccc:	e5b1      	b.n	400832 <sd_mmc_check+0x142>
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  400cce:	f89d 3012 	ldrb.w	r3, [sp, #18]
  400cd2:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
  400cd4:	4b94      	ldr	r3, [pc, #592]	; (400f28 <sd_mmc_check+0x838>)
  400cd6:	681b      	ldr	r3, [r3, #0]
  400cd8:	bf14      	ite	ne
  400cda:	2230      	movne	r2, #48	; 0x30
			sd_mmc_card->version = CARD_VER_SD_2_0;
  400cdc:	2220      	moveq	r2, #32
  400cde:	731a      	strb	r2, [r3, #12]
  400ce0:	e5a7      	b.n	400832 <sd_mmc_check+0x142>
		if (buf[1] == 0) {
  400ce2:	f89d 3011 	ldrb.w	r3, [sp, #17]
  400ce6:	2b00      	cmp	r3, #0
  400ce8:	f43f ad2a 	beq.w	400740 <sd_mmc_check+0x50>
		addr_new += buf[1]-1;
  400cec:	3302      	adds	r3, #2
  400cee:	441e      	add	r6, r3
		if (addr_new > (addr_old + 256)) {
  400cf0:	f509 7380 	add.w	r3, r9, #256	; 0x100
  400cf4:	429e      	cmp	r6, r3
  400cf6:	f63f ad23 	bhi.w	400740 <sd_mmc_check+0x50>
	addr_new = addr_old;
  400cfa:	2500      	movs	r5, #0
			sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
  400cfc:	ab04      	add	r3, sp, #16
  400cfe:	442b      	add	r3, r5
  400d00:	9300      	str	r3, [sp, #0]
  400d02:	4643      	mov	r3, r8
  400d04:	1972      	adds	r2, r6, r5
  400d06:	4641      	mov	r1, r8
  400d08:	4640      	mov	r0, r8
  400d0a:	47b8      	blx	r7
  400d0c:	3501      	adds	r5, #1
		for(i=0; i<3; i++) {
  400d0e:	2d03      	cmp	r5, #3
  400d10:	d1f4      	bne.n	400cfc <sd_mmc_check+0x60c>
		if (buf[0] == SDIO_CISTPL_END) {
  400d12:	f89d 3010 	ldrb.w	r3, [sp, #16]
  400d16:	2bff      	cmp	r3, #255	; 0xff
  400d18:	f43f ad12 	beq.w	400740 <sd_mmc_check+0x50>
		if (buf[0] == SDIO_CISTPL_FUNCE && buf[2] == 0x00) {
  400d1c:	2b22      	cmp	r3, #34	; 0x22
  400d1e:	d1e0      	bne.n	400ce2 <sd_mmc_check+0x5f2>
  400d20:	f89d 3012 	ldrb.w	r3, [sp, #18]
  400d24:	2b00      	cmp	r3, #0
  400d26:	d1dc      	bne.n	400ce2 <sd_mmc_check+0x5f2>
  400d28:	ad04      	add	r5, sp, #16
  400d2a:	f106 0906 	add.w	r9, r6, #6
		sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
  400d2e:	f04f 0800 	mov.w	r8, #0
  400d32:	4f7e      	ldr	r7, [pc, #504]	; (400f2c <sd_mmc_check+0x83c>)
  400d34:	9500      	str	r5, [sp, #0]
  400d36:	4643      	mov	r3, r8
  400d38:	4632      	mov	r2, r6
  400d3a:	4641      	mov	r1, r8
  400d3c:	4640      	mov	r0, r8
  400d3e:	47b8      	blx	r7
		addr_new++;
  400d40:	3601      	adds	r6, #1
  400d42:	3501      	adds	r5, #1
	for(i = 0; i < 6; i++) {
  400d44:	454e      	cmp	r6, r9
  400d46:	d1f5      	bne.n	400d34 <sd_mmc_check+0x644>
	tplfe_max_tran_speed = buf[5];
  400d48:	f89d 3015 	ldrb.w	r3, [sp, #21]
  400d4c:	2b32      	cmp	r3, #50	; 0x32
  400d4e:	bf28      	it	cs
  400d50:	2332      	movcs	r3, #50	; 0x32
	sd_mmc_card->clock = unit * mul * 1000;
  400d52:	4a75      	ldr	r2, [pc, #468]	; (400f28 <sd_mmc_check+0x838>)
  400d54:	6812      	ldr	r2, [r2, #0]
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
  400d56:	f3c3 00c3 	ubfx	r0, r3, #3, #4
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
  400d5a:	f003 0307 	and.w	r3, r3, #7
	sd_mmc_card->clock = unit * mul * 1000;
  400d5e:	4974      	ldr	r1, [pc, #464]	; (400f30 <sd_mmc_check+0x840>)
  400d60:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
  400d64:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  400d68:	fb03 f301 	mul.w	r3, r3, r1
  400d6c:	4971      	ldr	r1, [pc, #452]	; (400f34 <sd_mmc_check+0x844>)
  400d6e:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  400d72:	fb03 f301 	mul.w	r3, r3, r1
  400d76:	6013      	str	r3, [r2, #0]
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  400d78:	4b6f      	ldr	r3, [pc, #444]	; (400f38 <sd_mmc_check+0x848>)
  400d7a:	7818      	ldrb	r0, [r3, #0]
  400d7c:	4b6f      	ldr	r3, [pc, #444]	; (400f3c <sd_mmc_check+0x84c>)
  400d7e:	4798      	blx	r3
  400d80:	2803      	cmp	r0, #3
  400d82:	d922      	bls.n	400dca <sd_mmc_check+0x6da>
		if (IS_SDIO()) {
  400d84:	4b68      	ldr	r3, [pc, #416]	; (400f28 <sd_mmc_check+0x838>)
  400d86:	681b      	ldr	r3, [r3, #0]
  400d88:	7adb      	ldrb	r3, [r3, #11]
  400d8a:	f013 0f04 	tst.w	r3, #4
  400d8e:	d146      	bne.n	400e1e <sd_mmc_check+0x72e>
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  400d90:	4b65      	ldr	r3, [pc, #404]	; (400f28 <sd_mmc_check+0x838>)
  400d92:	681b      	ldr	r3, [r3, #0]
  400d94:	7ada      	ldrb	r2, [r3, #11]
  400d96:	f012 0f01 	tst.w	r2, #1
  400d9a:	d014      	beq.n	400dc6 <sd_mmc_check+0x6d6>
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400d9c:	8919      	ldrh	r1, [r3, #8]
  400d9e:	0409      	lsls	r1, r1, #16
  400da0:	f241 1037 	movw	r0, #4407	; 0x1137
  400da4:	4b66      	ldr	r3, [pc, #408]	; (400f40 <sd_mmc_check+0x850>)
  400da6:	4798      	blx	r3
  400da8:	2800      	cmp	r0, #0
  400daa:	f43f acc9 	beq.w	400740 <sd_mmc_check+0x50>
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  400dae:	2102      	movs	r1, #2
  400db0:	f241 1006 	movw	r0, #4358	; 0x1106
  400db4:	4b62      	ldr	r3, [pc, #392]	; (400f40 <sd_mmc_check+0x850>)
  400db6:	4798      	blx	r3
  400db8:	2800      	cmp	r0, #0
  400dba:	f43f acc1 	beq.w	400740 <sd_mmc_check+0x50>
	sd_mmc_card->bus_width = 4;
  400dbe:	4b5a      	ldr	r3, [pc, #360]	; (400f28 <sd_mmc_check+0x838>)
  400dc0:	681b      	ldr	r3, [r3, #0]
  400dc2:	2204      	movs	r2, #4
  400dc4:	735a      	strb	r2, [r3, #13]
		sd_mmc_configure_slot();
  400dc6:	4b5f      	ldr	r3, [pc, #380]	; (400f44 <sd_mmc_check+0x854>)
  400dc8:	4798      	blx	r3
	if (driver_is_high_speed_capable()) {
  400dca:	4b5f      	ldr	r3, [pc, #380]	; (400f48 <sd_mmc_check+0x858>)
  400dcc:	4798      	blx	r3
  400dce:	b180      	cbz	r0, 400df2 <sd_mmc_check+0x702>
		if (IS_SDIO()) {
  400dd0:	4b55      	ldr	r3, [pc, #340]	; (400f28 <sd_mmc_check+0x838>)
  400dd2:	681b      	ldr	r3, [r3, #0]
  400dd4:	7adb      	ldrb	r3, [r3, #11]
  400dd6:	f013 0f04 	tst.w	r3, #4
  400dda:	d141      	bne.n	400e60 <sd_mmc_check+0x770>
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  400ddc:	4b52      	ldr	r3, [pc, #328]	; (400f28 <sd_mmc_check+0x838>)
  400dde:	681b      	ldr	r3, [r3, #0]
  400de0:	7ada      	ldrb	r2, [r3, #11]
  400de2:	f012 0f01 	tst.w	r2, #1
  400de6:	d002      	beq.n	400dee <sd_mmc_check+0x6fe>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  400de8:	7b1b      	ldrb	r3, [r3, #12]
  400dea:	2b10      	cmp	r3, #16
  400dec:	d85d      	bhi.n	400eaa <sd_mmc_check+0x7ba>
		sd_mmc_configure_slot();
  400dee:	4b55      	ldr	r3, [pc, #340]	; (400f44 <sd_mmc_check+0x854>)
  400df0:	4798      	blx	r3
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400df2:	4b4d      	ldr	r3, [pc, #308]	; (400f28 <sd_mmc_check+0x838>)
  400df4:	681b      	ldr	r3, [r3, #0]
  400df6:	7adb      	ldrb	r3, [r3, #11]
  400df8:	f013 0f01 	tst.w	r3, #1
  400dfc:	d008      	beq.n	400e10 <sd_mmc_check+0x720>
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400dfe:	f44f 7100 	mov.w	r1, #512	; 0x200
  400e02:	f241 1010 	movw	r0, #4368	; 0x1110
  400e06:	4b4e      	ldr	r3, [pc, #312]	; (400f40 <sd_mmc_check+0x850>)
  400e08:	4798      	blx	r3
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
  400e0a:	2800      	cmp	r0, #0
  400e0c:	f43f ac98 	beq.w	400740 <sd_mmc_check+0x50>
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  400e10:	4b45      	ldr	r3, [pc, #276]	; (400f28 <sd_mmc_check+0x838>)
  400e12:	681b      	ldr	r3, [r3, #0]
  400e14:	2200      	movs	r2, #0
  400e16:	729a      	strb	r2, [r3, #10]
		sd_mmc_deselect_slot();
  400e18:	4b4c      	ldr	r3, [pc, #304]	; (400f4c <sd_mmc_check+0x85c>)
  400e1a:	4798      	blx	r3
		return SD_MMC_INIT_ONGOING;
  400e1c:	e472      	b.n	400704 <sd_mmc_check+0x14>
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_CAP,
  400e1e:	ab04      	add	r3, sp, #16
  400e20:	9300      	str	r3, [sp, #0]
  400e22:	2300      	movs	r3, #0
  400e24:	2208      	movs	r2, #8
  400e26:	4619      	mov	r1, r3
  400e28:	4618      	mov	r0, r3
  400e2a:	4d40      	ldr	r5, [pc, #256]	; (400f2c <sd_mmc_check+0x83c>)
  400e2c:	47a8      	blx	r5
  400e2e:	2800      	cmp	r0, #0
  400e30:	f43f ac86 	beq.w	400740 <sd_mmc_check+0x50>
	if ((u8_value & SDIO_CAP_4BLS) != SDIO_CAP_4BLS) {
  400e34:	f99d 3010 	ldrsb.w	r3, [sp, #16]
  400e38:	2b00      	cmp	r3, #0
  400e3a:	daa9      	bge.n	400d90 <sd_mmc_check+0x6a0>
	u8_value = SDIO_BUSWIDTH_4B;
  400e3c:	ab14      	add	r3, sp, #80	; 0x50
  400e3e:	2202      	movs	r2, #2
  400e40:	f803 2d40 	strb.w	r2, [r3, #-64]!
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_BUS_CTRL,
  400e44:	9300      	str	r3, [sp, #0]
  400e46:	2301      	movs	r3, #1
  400e48:	2207      	movs	r2, #7
  400e4a:	2100      	movs	r1, #0
  400e4c:	4618      	mov	r0, r3
  400e4e:	47a8      	blx	r5
  400e50:	2800      	cmp	r0, #0
  400e52:	f43f ac75 	beq.w	400740 <sd_mmc_check+0x50>
	sd_mmc_card->bus_width = 4;
  400e56:	4b34      	ldr	r3, [pc, #208]	; (400f28 <sd_mmc_check+0x838>)
  400e58:	681b      	ldr	r3, [r3, #0]
  400e5a:	2204      	movs	r2, #4
  400e5c:	735a      	strb	r2, [r3, #13]
  400e5e:	e797      	b.n	400d90 <sd_mmc_check+0x6a0>
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_HS, 0, &u8_value)) {
  400e60:	ab04      	add	r3, sp, #16
  400e62:	9300      	str	r3, [sp, #0]
  400e64:	2300      	movs	r3, #0
  400e66:	2213      	movs	r2, #19
  400e68:	4619      	mov	r1, r3
  400e6a:	4618      	mov	r0, r3
  400e6c:	4d2f      	ldr	r5, [pc, #188]	; (400f2c <sd_mmc_check+0x83c>)
  400e6e:	47a8      	blx	r5
  400e70:	2800      	cmp	r0, #0
  400e72:	f43f ac65 	beq.w	400740 <sd_mmc_check+0x50>
	if ((u8_value & SDIO_SHS) != SDIO_SHS) {
  400e76:	f89d 3010 	ldrb.w	r3, [sp, #16]
  400e7a:	f013 0f01 	tst.w	r3, #1
  400e7e:	d0ad      	beq.n	400ddc <sd_mmc_check+0x6ec>
	u8_value = SDIO_EHS;
  400e80:	ab14      	add	r3, sp, #80	; 0x50
  400e82:	2202      	movs	r2, #2
  400e84:	f803 2d40 	strb.w	r2, [r3, #-64]!
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_HS,
  400e88:	9300      	str	r3, [sp, #0]
  400e8a:	2301      	movs	r3, #1
  400e8c:	2213      	movs	r2, #19
  400e8e:	2100      	movs	r1, #0
  400e90:	4618      	mov	r0, r3
  400e92:	47a8      	blx	r5
  400e94:	2800      	cmp	r0, #0
  400e96:	f43f ac53 	beq.w	400740 <sd_mmc_check+0x50>
	sd_mmc_card->high_speed = 1;
  400e9a:	4b23      	ldr	r3, [pc, #140]	; (400f28 <sd_mmc_check+0x838>)
  400e9c:	681b      	ldr	r3, [r3, #0]
  400e9e:	2201      	movs	r2, #1
  400ea0:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400ea2:	681a      	ldr	r2, [r3, #0]
  400ea4:	0052      	lsls	r2, r2, #1
  400ea6:	601a      	str	r2, [r3, #0]
  400ea8:	e798      	b.n	400ddc <sd_mmc_check+0x6ec>
	uint8_t switch_status[SD_SW_STATUS_BSIZE] = {0};
  400eaa:	2540      	movs	r5, #64	; 0x40
  400eac:	462a      	mov	r2, r5
  400eae:	2100      	movs	r1, #0
  400eb0:	a804      	add	r0, sp, #16
  400eb2:	4b27      	ldr	r3, [pc, #156]	; (400f50 <sd_mmc_check+0x860>)
  400eb4:	4798      	blx	r3
	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  400eb6:	2301      	movs	r3, #1
  400eb8:	9300      	str	r3, [sp, #0]
  400eba:	462a      	mov	r2, r5
  400ebc:	4925      	ldr	r1, [pc, #148]	; (400f54 <sd_mmc_check+0x864>)
  400ebe:	4826      	ldr	r0, [pc, #152]	; (400f58 <sd_mmc_check+0x868>)
  400ec0:	4d26      	ldr	r5, [pc, #152]	; (400f5c <sd_mmc_check+0x86c>)
  400ec2:	47a8      	blx	r5
  400ec4:	2800      	cmp	r0, #0
  400ec6:	f43f ac3b 	beq.w	400740 <sd_mmc_check+0x50>
	if (!driver_start_read_blocks(switch_status, 1)) {
  400eca:	2101      	movs	r1, #1
  400ecc:	a804      	add	r0, sp, #16
  400ece:	4b24      	ldr	r3, [pc, #144]	; (400f60 <sd_mmc_check+0x870>)
  400ed0:	4798      	blx	r3
  400ed2:	2800      	cmp	r0, #0
  400ed4:	f43f ac34 	beq.w	400740 <sd_mmc_check+0x50>
	if (!driver_wait_end_of_read_blocks()) {
  400ed8:	4b22      	ldr	r3, [pc, #136]	; (400f64 <sd_mmc_check+0x874>)
  400eda:	4798      	blx	r3
  400edc:	2800      	cmp	r0, #0
  400ede:	f43f ac2f 	beq.w	400740 <sd_mmc_check+0x50>
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400ee2:	4b21      	ldr	r3, [pc, #132]	; (400f68 <sd_mmc_check+0x878>)
  400ee4:	4798      	blx	r3
  400ee6:	f010 0f80 	tst.w	r0, #128	; 0x80
  400eea:	f47f ac29 	bne.w	400740 <sd_mmc_check+0x50>
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  400eee:	f89d 3020 	ldrb.w	r3, [sp, #32]
  400ef2:	f003 030f 	and.w	r3, r3, #15
  400ef6:	2b0f      	cmp	r3, #15
  400ef8:	f43f af79 	beq.w	400dee <sd_mmc_check+0x6fe>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400efc:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400f00:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  400f04:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
  400f08:	f47f ac1a 	bne.w	400740 <sd_mmc_check+0x50>
	driver_send_clock();
  400f0c:	4b17      	ldr	r3, [pc, #92]	; (400f6c <sd_mmc_check+0x87c>)
  400f0e:	4798      	blx	r3
	sd_mmc_card->high_speed = 1;
  400f10:	4b05      	ldr	r3, [pc, #20]	; (400f28 <sd_mmc_check+0x838>)
  400f12:	681b      	ldr	r3, [r3, #0]
  400f14:	2201      	movs	r2, #1
  400f16:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400f18:	681a      	ldr	r2, [r3, #0]
  400f1a:	0052      	lsls	r2, r2, #1
  400f1c:	601a      	str	r2, [r3, #0]
  400f1e:	e766      	b.n	400dee <sd_mmc_check+0x6fe>
	*v2 = 0;
  400f20:	f04f 0900 	mov.w	r9, #0
  400f24:	e41e      	b.n	400764 <sd_mmc_check+0x74>
  400f26:	bf00      	nop
  400f28:	20007518 	.word	0x20007518
  400f2c:	00400649 	.word	0x00400649
  400f30:	0040dc9c 	.word	0x0040dc9c
  400f34:	0040dcb8 	.word	0x0040dcb8
  400f38:	20007540 	.word	0x20007540
  400f3c:	004014dd 	.word	0x004014dd
  400f40:	004015cd 	.word	0x004015cd
  400f44:	004005c9 	.word	0x004005c9
  400f48:	004014e7 	.word	0x004014e7
  400f4c:	004006b5 	.word	0x004006b5
  400f50:	0040c287 	.word	0x0040c287
  400f54:	80ffff01 	.word	0x80ffff01
  400f58:	00081106 	.word	0x00081106
  400f5c:	00401635 	.word	0x00401635
  400f60:	00401769 	.word	0x00401769
  400f64:	004017cd 	.word	0x004017cd
  400f68:	004015f9 	.word	0x004015f9
  400f6c:	004015a9 	.word	0x004015a9

00400f70 <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
  400f70:	b508      	push	{r3, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  400f72:	4b05      	ldr	r3, [pc, #20]	; (400f88 <sd_mmc_get_type+0x18>)
  400f74:	4798      	blx	r3
  400f76:	b108      	cbz	r0, 400f7c <sd_mmc_get_type+0xc>
		return CARD_TYPE_UNKNOWN;
  400f78:	2000      	movs	r0, #0
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
}
  400f7a:	bd08      	pop	{r3, pc}
	sd_mmc_deselect_slot();
  400f7c:	4b03      	ldr	r3, [pc, #12]	; (400f8c <sd_mmc_get_type+0x1c>)
  400f7e:	4798      	blx	r3
	return sd_mmc_card->type;
  400f80:	4b03      	ldr	r3, [pc, #12]	; (400f90 <sd_mmc_get_type+0x20>)
  400f82:	681b      	ldr	r3, [r3, #0]
  400f84:	7ad8      	ldrb	r0, [r3, #11]
  400f86:	bd08      	pop	{r3, pc}
  400f88:	004005f1 	.word	0x004005f1
  400f8c:	004006b5 	.word	0x004006b5
  400f90:	20007518 	.word	0x20007518

00400f94 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
  400f94:	b508      	push	{r3, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  400f96:	4b05      	ldr	r3, [pc, #20]	; (400fac <sd_mmc_get_capacity+0x18>)
  400f98:	4798      	blx	r3
  400f9a:	b108      	cbz	r0, 400fa0 <sd_mmc_get_capacity+0xc>
		return 0;
  400f9c:	2000      	movs	r0, #0
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
}
  400f9e:	bd08      	pop	{r3, pc}
	sd_mmc_deselect_slot();
  400fa0:	4b03      	ldr	r3, [pc, #12]	; (400fb0 <sd_mmc_get_capacity+0x1c>)
  400fa2:	4798      	blx	r3
	return sd_mmc_card->capacity;
  400fa4:	4b03      	ldr	r3, [pc, #12]	; (400fb4 <sd_mmc_get_capacity+0x20>)
  400fa6:	681b      	ldr	r3, [r3, #0]
  400fa8:	6858      	ldr	r0, [r3, #4]
  400faa:	bd08      	pop	{r3, pc}
  400fac:	004005f1 	.word	0x004005f1
  400fb0:	004006b5 	.word	0x004006b5
  400fb4:	20007518 	.word	0x20007518

00400fb8 <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
  400fb8:	2000      	movs	r0, #0
  400fba:	4770      	bx	lr

00400fbc <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  400fbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  400fc0:	b082      	sub	sp, #8
  400fc2:	468a      	mov	sl, r1
  400fc4:	4691      	mov	r9, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
  400fc6:	4b26      	ldr	r3, [pc, #152]	; (401060 <sd_mmc_init_read_blocks+0xa4>)
  400fc8:	4798      	blx	r3
	if (sd_mmc_err != SD_MMC_OK) {
  400fca:	4680      	mov	r8, r0
  400fcc:	b118      	cbz	r0, 400fd6 <sd_mmc_init_read_blocks+0x1a>
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  400fce:	4640      	mov	r0, r8
  400fd0:	b002      	add	sp, #8
  400fd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  400fd6:	4c23      	ldr	r4, [pc, #140]	; (401064 <sd_mmc_init_read_blocks+0xa8>)
					(uint32_t)sd_mmc_card->rca << 16)) {
  400fd8:	4e23      	ldr	r6, [pc, #140]	; (401068 <sd_mmc_init_read_blocks+0xac>)
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  400fda:	4d24      	ldr	r5, [pc, #144]	; (40106c <sd_mmc_init_read_blocks+0xb0>)
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  400fdc:	4f24      	ldr	r7, [pc, #144]	; (401070 <sd_mmc_init_read_blocks+0xb4>)
					(uint32_t)sd_mmc_card->rca << 16)) {
  400fde:	6833      	ldr	r3, [r6, #0]
  400fe0:	8919      	ldrh	r1, [r3, #8]
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  400fe2:	0409      	lsls	r1, r1, #16
  400fe4:	f241 100d 	movw	r0, #4365	; 0x110d
  400fe8:	47a8      	blx	r5
  400fea:	b128      	cbz	r0, 400ff8 <sd_mmc_init_read_blocks+0x3c>
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  400fec:	47b8      	blx	r7
  400fee:	f410 7f80 	tst.w	r0, #256	; 0x100
  400ff2:	d117      	bne.n	401024 <sd_mmc_init_read_blocks+0x68>
		if (nec_timeout-- == 0) {
  400ff4:	3c01      	subs	r4, #1
  400ff6:	d1f2      	bne.n	400fde <sd_mmc_init_read_blocks+0x22>
		sd_mmc_deselect_slot();
  400ff8:	4b1e      	ldr	r3, [pc, #120]	; (401074 <sd_mmc_init_read_blocks+0xb8>)
  400ffa:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  400ffc:	f04f 0805 	mov.w	r8, #5
  401000:	e7e5      	b.n	400fce <sd_mmc_init_read_blocks+0x12>
		resp = driver_get_response();
  401002:	4b1b      	ldr	r3, [pc, #108]	; (401070 <sd_mmc_init_read_blocks+0xb4>)
  401004:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  401006:	4b1c      	ldr	r3, [pc, #112]	; (401078 <sd_mmc_init_read_blocks+0xbc>)
  401008:	4003      	ands	r3, r0
  40100a:	b933      	cbnz	r3, 40101a <sd_mmc_init_read_blocks+0x5e>
	sd_mmc_nb_block_remaining = nb_block;
  40100c:	4b1b      	ldr	r3, [pc, #108]	; (40107c <sd_mmc_init_read_blocks+0xc0>)
  40100e:	f8a3 9000 	strh.w	r9, [r3]
	sd_mmc_nb_block_to_tranfer = nb_block;
  401012:	4b1b      	ldr	r3, [pc, #108]	; (401080 <sd_mmc_init_read_blocks+0xc4>)
  401014:	f8a3 9000 	strh.w	r9, [r3]
	return SD_MMC_OK;
  401018:	e7d9      	b.n	400fce <sd_mmc_init_read_blocks+0x12>
			sd_mmc_deselect_slot();
  40101a:	4b16      	ldr	r3, [pc, #88]	; (401074 <sd_mmc_init_read_blocks+0xb8>)
  40101c:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  40101e:	f04f 0805 	mov.w	r8, #5
  401022:	e7d4      	b.n	400fce <sd_mmc_init_read_blocks+0x12>
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  401024:	4b17      	ldr	r3, [pc, #92]	; (401084 <sd_mmc_init_read_blocks+0xc8>)
  401026:	4818      	ldr	r0, [pc, #96]	; (401088 <sd_mmc_init_read_blocks+0xcc>)
  401028:	f1b9 0f01 	cmp.w	r9, #1
  40102c:	bf98      	it	ls
  40102e:	4618      	movls	r0, r3
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401030:	4b0d      	ldr	r3, [pc, #52]	; (401068 <sd_mmc_init_read_blocks+0xac>)
  401032:	681b      	ldr	r3, [r3, #0]
  401034:	7adb      	ldrb	r3, [r3, #11]
  401036:	f013 0f08 	tst.w	r3, #8
  40103a:	d101      	bne.n	401040 <sd_mmc_init_read_blocks+0x84>
		arg = (start * SD_MMC_BLOCK_SIZE);
  40103c:	ea4f 2a4a 	mov.w	sl, sl, lsl #9
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  401040:	2301      	movs	r3, #1
  401042:	9300      	str	r3, [sp, #0]
  401044:	464b      	mov	r3, r9
  401046:	f44f 7200 	mov.w	r2, #512	; 0x200
  40104a:	4651      	mov	r1, sl
  40104c:	4c0f      	ldr	r4, [pc, #60]	; (40108c <sd_mmc_init_read_blocks+0xd0>)
  40104e:	47a0      	blx	r4
  401050:	2800      	cmp	r0, #0
  401052:	d1d6      	bne.n	401002 <sd_mmc_init_read_blocks+0x46>
		sd_mmc_deselect_slot();
  401054:	4b07      	ldr	r3, [pc, #28]	; (401074 <sd_mmc_init_read_blocks+0xb8>)
  401056:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  401058:	f04f 0805 	mov.w	r8, #5
  40105c:	e7b7      	b.n	400fce <sd_mmc_init_read_blocks+0x12>
  40105e:	bf00      	nop
  401060:	004005f1 	.word	0x004005f1
  401064:	00030d41 	.word	0x00030d41
  401068:	20007518 	.word	0x20007518
  40106c:	004015cd 	.word	0x004015cd
  401070:	004015f9 	.word	0x004015f9
  401074:	004006b5 	.word	0x004006b5
  401078:	e4580000 	.word	0xe4580000
  40107c:	2000753c 	.word	0x2000753c
  401080:	2000753e 	.word	0x2000753e
  401084:	00081111 	.word	0x00081111
  401088:	00101112 	.word	0x00101112
  40108c:	00401635 	.word	0x00401635

00401090 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  401090:	b510      	push	{r4, lr}
  401092:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  401094:	4b06      	ldr	r3, [pc, #24]	; (4010b0 <sd_mmc_start_read_blocks+0x20>)
  401096:	4798      	blx	r3
  401098:	b920      	cbnz	r0, 4010a4 <sd_mmc_start_read_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  40109a:	2200      	movs	r2, #0
  40109c:	4b05      	ldr	r3, [pc, #20]	; (4010b4 <sd_mmc_start_read_blocks+0x24>)
  40109e:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
  4010a0:	2005      	movs	r0, #5
  4010a2:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  4010a4:	4a03      	ldr	r2, [pc, #12]	; (4010b4 <sd_mmc_start_read_blocks+0x24>)
  4010a6:	8813      	ldrh	r3, [r2, #0]
  4010a8:	1b1c      	subs	r4, r3, r4
  4010aa:	8014      	strh	r4, [r2, #0]
	return SD_MMC_OK;
  4010ac:	2000      	movs	r0, #0
}
  4010ae:	bd10      	pop	{r4, pc}
  4010b0:	00401769 	.word	0x00401769
  4010b4:	2000753c 	.word	0x2000753c

004010b8 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  4010b8:	b510      	push	{r4, lr}
  4010ba:	4604      	mov	r4, r0
	if (!driver_wait_end_of_read_blocks()) {
  4010bc:	4b13      	ldr	r3, [pc, #76]	; (40110c <sd_mmc_wait_end_of_read_blocks+0x54>)
  4010be:	4798      	blx	r3
  4010c0:	b908      	cbnz	r0, 4010c6 <sd_mmc_wait_end_of_read_blocks+0xe>
		return SD_MMC_ERR_COMM;
  4010c2:	2005      	movs	r0, #5
  4010c4:	bd10      	pop	{r4, pc}
	}
	if (abort) {
  4010c6:	b184      	cbz	r4, 4010ea <sd_mmc_wait_end_of_read_blocks+0x32>
		sd_mmc_nb_block_remaining = 0;
  4010c8:	2200      	movs	r2, #0
  4010ca:	4b11      	ldr	r3, [pc, #68]	; (401110 <sd_mmc_wait_end_of_read_blocks+0x58>)
  4010cc:	801a      	strh	r2, [r3, #0]
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  4010ce:	4b11      	ldr	r3, [pc, #68]	; (401114 <sd_mmc_wait_end_of_read_blocks+0x5c>)
  4010d0:	881b      	ldrh	r3, [r3, #0]
  4010d2:	2b01      	cmp	r3, #1
  4010d4:	d00f      	beq.n	4010f6 <sd_mmc_wait_end_of_read_blocks+0x3e>
		return SD_MMC_OK;
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  4010d6:	2100      	movs	r1, #0
  4010d8:	f243 100c 	movw	r0, #12556	; 0x310c
  4010dc:	4b0e      	ldr	r3, [pc, #56]	; (401118 <sd_mmc_wait_end_of_read_blocks+0x60>)
  4010de:	4798      	blx	r3
  4010e0:	b168      	cbz	r0, 4010fe <sd_mmc_wait_end_of_read_blocks+0x46>
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
  4010e2:	4b0e      	ldr	r3, [pc, #56]	; (40111c <sd_mmc_wait_end_of_read_blocks+0x64>)
  4010e4:	4798      	blx	r3
	return SD_MMC_OK;
  4010e6:	2000      	movs	r0, #0
  4010e8:	bd10      	pop	{r4, pc}
	} else if (sd_mmc_nb_block_remaining) {
  4010ea:	4b09      	ldr	r3, [pc, #36]	; (401110 <sd_mmc_wait_end_of_read_blocks+0x58>)
  4010ec:	881b      	ldrh	r3, [r3, #0]
  4010ee:	2b00      	cmp	r3, #0
  4010f0:	d0ed      	beq.n	4010ce <sd_mmc_wait_end_of_read_blocks+0x16>
		return SD_MMC_OK;
  4010f2:	2000      	movs	r0, #0
}
  4010f4:	bd10      	pop	{r4, pc}
		sd_mmc_deselect_slot();
  4010f6:	4b09      	ldr	r3, [pc, #36]	; (40111c <sd_mmc_wait_end_of_read_blocks+0x64>)
  4010f8:	4798      	blx	r3
		return SD_MMC_OK;
  4010fa:	2000      	movs	r0, #0
  4010fc:	bd10      	pop	{r4, pc}
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
  4010fe:	2100      	movs	r1, #0
  401100:	f243 100c 	movw	r0, #12556	; 0x310c
  401104:	4b04      	ldr	r3, [pc, #16]	; (401118 <sd_mmc_wait_end_of_read_blocks+0x60>)
  401106:	4798      	blx	r3
  401108:	e7eb      	b.n	4010e2 <sd_mmc_wait_end_of_read_blocks+0x2a>
  40110a:	bf00      	nop
  40110c:	004017cd 	.word	0x004017cd
  401110:	2000753c 	.word	0x2000753c
  401114:	2000753e 	.word	0x2000753e
  401118:	004015cd 	.word	0x004015cd
  40111c:	004006b5 	.word	0x004006b5

00401120 <sd_mmc_init_write_blocks>:

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  401120:	b570      	push	{r4, r5, r6, lr}
  401122:	b082      	sub	sp, #8
  401124:	460e      	mov	r6, r1
  401126:	4615      	mov	r5, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
  401128:	4b16      	ldr	r3, [pc, #88]	; (401184 <sd_mmc_init_write_blocks+0x64>)
  40112a:	4798      	blx	r3
	if (sd_mmc_err != SD_MMC_OK) {
  40112c:	4604      	mov	r4, r0
  40112e:	b9b8      	cbnz	r0, 401160 <sd_mmc_init_write_blocks+0x40>
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD24_WRITE_BLOCK;
  401130:	4b15      	ldr	r3, [pc, #84]	; (401188 <sd_mmc_init_write_blocks+0x68>)
  401132:	4816      	ldr	r0, [pc, #88]	; (40118c <sd_mmc_init_write_blocks+0x6c>)
  401134:	2d01      	cmp	r5, #1
  401136:	bf98      	it	ls
  401138:	4618      	movls	r0, r3
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40113a:	4b15      	ldr	r3, [pc, #84]	; (401190 <sd_mmc_init_write_blocks+0x70>)
  40113c:	681b      	ldr	r3, [r3, #0]
  40113e:	7adb      	ldrb	r3, [r3, #11]
  401140:	f013 0f08 	tst.w	r3, #8
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  401144:	bf08      	it	eq
  401146:	0276      	lsleq	r6, r6, #9
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  401148:	2301      	movs	r3, #1
  40114a:	9300      	str	r3, [sp, #0]
  40114c:	462b      	mov	r3, r5
  40114e:	f44f 7200 	mov.w	r2, #512	; 0x200
  401152:	4631      	mov	r1, r6
  401154:	4e0f      	ldr	r6, [pc, #60]	; (401194 <sd_mmc_init_write_blocks+0x74>)
  401156:	47b0      	blx	r6
  401158:	b928      	cbnz	r0, 401166 <sd_mmc_init_write_blocks+0x46>
		sd_mmc_deselect_slot();
  40115a:	4b0f      	ldr	r3, [pc, #60]	; (401198 <sd_mmc_init_write_blocks+0x78>)
  40115c:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  40115e:	2405      	movs	r4, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401160:	4620      	mov	r0, r4
  401162:	b002      	add	sp, #8
  401164:	bd70      	pop	{r4, r5, r6, pc}
		resp = driver_get_response();
  401166:	4b0d      	ldr	r3, [pc, #52]	; (40119c <sd_mmc_init_write_blocks+0x7c>)
  401168:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  40116a:	4b0d      	ldr	r3, [pc, #52]	; (4011a0 <sd_mmc_init_write_blocks+0x80>)
  40116c:	4003      	ands	r3, r0
  40116e:	b923      	cbnz	r3, 40117a <sd_mmc_init_write_blocks+0x5a>
	sd_mmc_nb_block_remaining = nb_block;
  401170:	4b0c      	ldr	r3, [pc, #48]	; (4011a4 <sd_mmc_init_write_blocks+0x84>)
  401172:	801d      	strh	r5, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
  401174:	4b0c      	ldr	r3, [pc, #48]	; (4011a8 <sd_mmc_init_write_blocks+0x88>)
  401176:	801d      	strh	r5, [r3, #0]
	return SD_MMC_OK;
  401178:	e7f2      	b.n	401160 <sd_mmc_init_write_blocks+0x40>
			sd_mmc_deselect_slot();
  40117a:	4b07      	ldr	r3, [pc, #28]	; (401198 <sd_mmc_init_write_blocks+0x78>)
  40117c:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  40117e:	2405      	movs	r4, #5
  401180:	e7ee      	b.n	401160 <sd_mmc_init_write_blocks+0x40>
  401182:	bf00      	nop
  401184:	004005f1 	.word	0x004005f1
  401188:	00089118 	.word	0x00089118
  40118c:	00109119 	.word	0x00109119
  401190:	20007518 	.word	0x20007518
  401194:	00401635 	.word	0x00401635
  401198:	004006b5 	.word	0x004006b5
  40119c:	004015f9 	.word	0x004015f9
  4011a0:	e4580000 	.word	0xe4580000
  4011a4:	2000753c 	.word	0x2000753c
  4011a8:	2000753e 	.word	0x2000753e

004011ac <sd_mmc_start_write_blocks>:

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  4011ac:	b510      	push	{r4, lr}
  4011ae:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  4011b0:	4b06      	ldr	r3, [pc, #24]	; (4011cc <sd_mmc_start_write_blocks+0x20>)
  4011b2:	4798      	blx	r3
  4011b4:	b920      	cbnz	r0, 4011c0 <sd_mmc_start_write_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  4011b6:	2200      	movs	r2, #0
  4011b8:	4b05      	ldr	r3, [pc, #20]	; (4011d0 <sd_mmc_start_write_blocks+0x24>)
  4011ba:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
  4011bc:	2005      	movs	r0, #5
  4011be:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  4011c0:	4a03      	ldr	r2, [pc, #12]	; (4011d0 <sd_mmc_start_write_blocks+0x24>)
  4011c2:	8813      	ldrh	r3, [r2, #0]
  4011c4:	1b1c      	subs	r4, r3, r4
  4011c6:	8014      	strh	r4, [r2, #0]
	return SD_MMC_OK;
  4011c8:	2000      	movs	r0, #0
}
  4011ca:	bd10      	pop	{r4, pc}
  4011cc:	0040183d 	.word	0x0040183d
  4011d0:	2000753c 	.word	0x2000753c

004011d4 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  4011d4:	b510      	push	{r4, lr}
  4011d6:	4604      	mov	r4, r0
	if (!driver_wait_end_of_write_blocks()) {
  4011d8:	4b12      	ldr	r3, [pc, #72]	; (401224 <sd_mmc_wait_end_of_write_blocks+0x50>)
  4011da:	4798      	blx	r3
  4011dc:	b908      	cbnz	r0, 4011e2 <sd_mmc_wait_end_of_write_blocks+0xe>
		return SD_MMC_ERR_COMM;
  4011de:	2005      	movs	r0, #5
  4011e0:	bd10      	pop	{r4, pc}
	}
	if (abort) {
  4011e2:	b184      	cbz	r4, 401206 <sd_mmc_wait_end_of_write_blocks+0x32>
		sd_mmc_nb_block_remaining = 0;
  4011e4:	2200      	movs	r2, #0
  4011e6:	4b10      	ldr	r3, [pc, #64]	; (401228 <sd_mmc_wait_end_of_write_blocks+0x54>)
  4011e8:	801a      	strh	r2, [r3, #0]
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  4011ea:	4b10      	ldr	r3, [pc, #64]	; (40122c <sd_mmc_wait_end_of_write_blocks+0x58>)
  4011ec:	881b      	ldrh	r3, [r3, #0]
  4011ee:	2b01      	cmp	r3, #1
  4011f0:	d00f      	beq.n	401212 <sd_mmc_wait_end_of_write_blocks+0x3e>
	}

	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  4011f2:	2100      	movs	r1, #0
  4011f4:	f243 100c 	movw	r0, #12556	; 0x310c
  4011f8:	4b0d      	ldr	r3, [pc, #52]	; (401230 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  4011fa:	4798      	blx	r3
  4011fc:	b968      	cbnz	r0, 40121a <sd_mmc_wait_end_of_write_blocks+0x46>
			sd_mmc_deselect_slot();
  4011fe:	4b0d      	ldr	r3, [pc, #52]	; (401234 <sd_mmc_wait_end_of_write_blocks+0x60>)
  401200:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  401202:	2005      	movs	r0, #5
  401204:	bd10      	pop	{r4, pc}
	} else if (sd_mmc_nb_block_remaining) {
  401206:	4b08      	ldr	r3, [pc, #32]	; (401228 <sd_mmc_wait_end_of_write_blocks+0x54>)
  401208:	881b      	ldrh	r3, [r3, #0]
  40120a:	2b00      	cmp	r3, #0
  40120c:	d0ed      	beq.n	4011ea <sd_mmc_wait_end_of_write_blocks+0x16>
		return SD_MMC_OK;
  40120e:	2000      	movs	r0, #0
		}
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  401210:	bd10      	pop	{r4, pc}
		sd_mmc_deselect_slot();
  401212:	4b08      	ldr	r3, [pc, #32]	; (401234 <sd_mmc_wait_end_of_write_blocks+0x60>)
  401214:	4798      	blx	r3
		return SD_MMC_OK;
  401216:	2000      	movs	r0, #0
  401218:	bd10      	pop	{r4, pc}
	sd_mmc_deselect_slot();
  40121a:	4b06      	ldr	r3, [pc, #24]	; (401234 <sd_mmc_wait_end_of_write_blocks+0x60>)
  40121c:	4798      	blx	r3
	return SD_MMC_OK;
  40121e:	2000      	movs	r0, #0
  401220:	bd10      	pop	{r4, pc}
  401222:	bf00      	nop
  401224:	004018a5 	.word	0x004018a5
  401228:	2000753c 	.word	0x2000753c
  40122c:	2000753e 	.word	0x2000753e
  401230:	004015cd 	.word	0x004015cd
  401234:	004006b5 	.word	0x004006b5

00401238 <sd_mmc_test_unit_ready>:
 * @{
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot) {
  401238:	b510      	push	{r4, lr}
  40123a:	4604      	mov	r4, r0
  switch (sd_mmc_check(slot)) {
  40123c:	4b0f      	ldr	r3, [pc, #60]	; (40127c <sd_mmc_test_unit_ready+0x44>)
  40123e:	4798      	blx	r3
  401240:	2801      	cmp	r0, #1
  401242:	d018      	beq.n	401276 <sd_mmc_test_unit_ready+0x3e>
  401244:	b118      	cbz	r0, 40124e <sd_mmc_test_unit_ready+0x16>
  401246:	2802      	cmp	r0, #2
  401248:	d010      	beq.n	40126c <sd_mmc_test_unit_ready+0x34>

  case SD_MMC_INIT_ONGOING: return CTRL_BUSY;

  case SD_MMC_ERR_NO_CARD : sd_mmc_ejected[slot] = false; return CTRL_NO_PRESENT;

  default                 : return CTRL_FAIL;
  40124a:	2001      	movs	r0, #1
  40124c:	bd10      	pop	{r4, pc}
    if (sd_mmc_ejected[slot]) { return CTRL_NO_PRESENT; }
  40124e:	4b0c      	ldr	r3, [pc, #48]	; (401280 <sd_mmc_test_unit_ready+0x48>)
  401250:	5d1b      	ldrb	r3, [r3, r4]
  401252:	b10b      	cbz	r3, 401258 <sd_mmc_test_unit_ready+0x20>
  401254:	2002      	movs	r0, #2
  }
}
  401256:	bd10      	pop	{r4, pc}
    if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) { return CTRL_GOOD; }
  401258:	4620      	mov	r0, r4
  40125a:	4b0a      	ldr	r3, [pc, #40]	; (401284 <sd_mmc_test_unit_ready+0x4c>)
  40125c:	4798      	blx	r3
  40125e:	f000 0003 	and.w	r0, r0, #3
    return CTRL_NO_PRESENT;
  401262:	2800      	cmp	r0, #0
  401264:	bf14      	ite	ne
  401266:	2000      	movne	r0, #0
  401268:	2002      	moveq	r0, #2
  40126a:	bd10      	pop	{r4, pc}
  case SD_MMC_ERR_NO_CARD : sd_mmc_ejected[slot] = false; return CTRL_NO_PRESENT;
  40126c:	2200      	movs	r2, #0
  40126e:	4b04      	ldr	r3, [pc, #16]	; (401280 <sd_mmc_test_unit_ready+0x48>)
  401270:	551a      	strb	r2, [r3, r4]
  401272:	2002      	movs	r0, #2
  401274:	bd10      	pop	{r4, pc}
  case SD_MMC_INIT_ONGOING: return CTRL_BUSY;
  401276:	2003      	movs	r0, #3
  401278:	bd10      	pop	{r4, pc}
  40127a:	bf00      	nop
  40127c:	004006f1 	.word	0x004006f1
  401280:	20007544 	.word	0x20007544
  401284:	00400f71 	.word	0x00400f71

00401288 <sd_mmc_test_unit_ready_0>:

Ctrl_status sd_mmc_test_unit_ready_0(void) { return sd_mmc_test_unit_ready(0); }
  401288:	b508      	push	{r3, lr}
  40128a:	2000      	movs	r0, #0
  40128c:	4b01      	ldr	r3, [pc, #4]	; (401294 <sd_mmc_test_unit_ready_0+0xc>)
  40128e:	4798      	blx	r3
  401290:	bd08      	pop	{r3, pc}
  401292:	bf00      	nop
  401294:	00401239 	.word	0x00401239

00401298 <sd_mmc_read_capacity>:

Ctrl_status sd_mmc_test_unit_ready_1(void) { return sd_mmc_test_unit_ready(1); }

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector) {
  401298:	b538      	push	{r3, r4, r5, lr}
  40129a:	4604      	mov	r4, r0
  40129c:	460d      	mov	r5, r1
  // Return last sector address (-1)
  *nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  40129e:	4b04      	ldr	r3, [pc, #16]	; (4012b0 <sd_mmc_read_capacity+0x18>)
  4012a0:	4798      	blx	r3
  4012a2:	0040      	lsls	r0, r0, #1
  4012a4:	3801      	subs	r0, #1
  4012a6:	6028      	str	r0, [r5, #0]
  return sd_mmc_test_unit_ready(slot);
  4012a8:	4620      	mov	r0, r4
  4012aa:	4b02      	ldr	r3, [pc, #8]	; (4012b4 <sd_mmc_read_capacity+0x1c>)
  4012ac:	4798      	blx	r3
}
  4012ae:	bd38      	pop	{r3, r4, r5, pc}
  4012b0:	00400f95 	.word	0x00400f95
  4012b4:	00401239 	.word	0x00401239

004012b8 <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector) { return sd_mmc_read_capacity(0, nb_sector); }
  4012b8:	b508      	push	{r3, lr}
  4012ba:	4601      	mov	r1, r0
  4012bc:	2000      	movs	r0, #0
  4012be:	4b01      	ldr	r3, [pc, #4]	; (4012c4 <sd_mmc_read_capacity_0+0xc>)
  4012c0:	4798      	blx	r3
  4012c2:	bd08      	pop	{r3, pc}
  4012c4:	00401299 	.word	0x00401299

004012c8 <sd_mmc_wr_protect_0>:

bool sd_mmc_unload_1(bool unload) { return sd_mmc_unload(1, unload); }

bool sd_mmc_wr_protect(uint8_t slot) { return sd_mmc_is_write_protected(slot); }

bool sd_mmc_wr_protect_0(void) { return sd_mmc_wr_protect(0); }
  4012c8:	b508      	push	{r3, lr}
bool sd_mmc_wr_protect(uint8_t slot) { return sd_mmc_is_write_protected(slot); }
  4012ca:	2000      	movs	r0, #0
  4012cc:	4b01      	ldr	r3, [pc, #4]	; (4012d4 <sd_mmc_wr_protect_0+0xc>)
  4012ce:	4798      	blx	r3
bool sd_mmc_wr_protect_0(void) { return sd_mmc_wr_protect(0); }
  4012d0:	bd08      	pop	{r3, pc}
  4012d2:	bf00      	nop
  4012d4:	00400fb9 	.word	0x00400fb9

004012d8 <sd_mmc_mem_2_ram>:
#  if ACCESS_MEM_TO_RAM == true
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram) {
  4012d8:	b510      	push	{r4, lr}
  4012da:	4614      	mov	r4, r2
  switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  4012dc:	2201      	movs	r2, #1
  4012de:	4b0a      	ldr	r3, [pc, #40]	; (401308 <sd_mmc_mem_2_ram+0x30>)
  4012e0:	4798      	blx	r3
  4012e2:	b120      	cbz	r0, 4012ee <sd_mmc_mem_2_ram+0x16>
  case SD_MMC_OK         : break;
  case SD_MMC_ERR_NO_CARD: return CTRL_NO_PRESENT;
  default                : return CTRL_FAIL;
  4012e4:	2802      	cmp	r0, #2
  4012e6:	bf0c      	ite	eq
  4012e8:	2002      	moveq	r0, #2
  4012ea:	2001      	movne	r0, #1
  4012ec:	bd10      	pop	{r4, pc}
  }
  if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) { return CTRL_FAIL; }
  4012ee:	2101      	movs	r1, #1
  4012f0:	4620      	mov	r0, r4
  4012f2:	4b06      	ldr	r3, [pc, #24]	; (40130c <sd_mmc_mem_2_ram+0x34>)
  4012f4:	4798      	blx	r3
  4012f6:	b108      	cbz	r0, 4012fc <sd_mmc_mem_2_ram+0x24>
  4012f8:	2001      	movs	r0, #1
  if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) { return CTRL_FAIL; }
  return CTRL_GOOD;
}
  4012fa:	bd10      	pop	{r4, pc}
  if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) { return CTRL_FAIL; }
  4012fc:	4b04      	ldr	r3, [pc, #16]	; (401310 <sd_mmc_mem_2_ram+0x38>)
  4012fe:	4798      	blx	r3
  case SD_MMC_ERR_NO_CARD: return CTRL_NO_PRESENT;
  401300:	3000      	adds	r0, #0
  401302:	bf18      	it	ne
  401304:	2001      	movne	r0, #1
  401306:	bd10      	pop	{r4, pc}
  401308:	00400fbd 	.word	0x00400fbd
  40130c:	00401091 	.word	0x00401091
  401310:	004010b9 	.word	0x004010b9

00401314 <sd_mmc_mem_2_ram_0>:

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram) { return sd_mmc_mem_2_ram(0, addr, ram); }
  401314:	b508      	push	{r3, lr}
  401316:	460a      	mov	r2, r1
  401318:	4601      	mov	r1, r0
  40131a:	2000      	movs	r0, #0
  40131c:	4b01      	ldr	r3, [pc, #4]	; (401324 <sd_mmc_mem_2_ram_0+0x10>)
  40131e:	4798      	blx	r3
  401320:	bd08      	pop	{r3, pc}
  401322:	bf00      	nop
  401324:	004012d9 	.word	0x004012d9

00401328 <sd_mmc_ram_2_mem>:

Ctrl_status sd_mmc_mem_2_ram_1(uint32_t addr, void *ram) { return sd_mmc_mem_2_ram(1, addr, ram); }

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram) {
  401328:	b510      	push	{r4, lr}
  40132a:	4614      	mov	r4, r2
  switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  40132c:	2201      	movs	r2, #1
  40132e:	4b0a      	ldr	r3, [pc, #40]	; (401358 <sd_mmc_ram_2_mem+0x30>)
  401330:	4798      	blx	r3
  401332:	b120      	cbz	r0, 40133e <sd_mmc_ram_2_mem+0x16>
  case SD_MMC_OK         : break;
  case SD_MMC_ERR_NO_CARD: return CTRL_NO_PRESENT;
  default                : return CTRL_FAIL;
  401334:	2802      	cmp	r0, #2
  401336:	bf0c      	ite	eq
  401338:	2002      	moveq	r0, #2
  40133a:	2001      	movne	r0, #1
  40133c:	bd10      	pop	{r4, pc}
  }
  if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) { return CTRL_FAIL; }
  40133e:	2101      	movs	r1, #1
  401340:	4620      	mov	r0, r4
  401342:	4b06      	ldr	r3, [pc, #24]	; (40135c <sd_mmc_ram_2_mem+0x34>)
  401344:	4798      	blx	r3
  401346:	b108      	cbz	r0, 40134c <sd_mmc_ram_2_mem+0x24>
  401348:	2001      	movs	r0, #1
  if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) { return CTRL_FAIL; }
  return CTRL_GOOD;
}
  40134a:	bd10      	pop	{r4, pc}
  if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) { return CTRL_FAIL; }
  40134c:	4b04      	ldr	r3, [pc, #16]	; (401360 <sd_mmc_ram_2_mem+0x38>)
  40134e:	4798      	blx	r3
  case SD_MMC_ERR_NO_CARD: return CTRL_NO_PRESENT;
  401350:	3000      	adds	r0, #0
  401352:	bf18      	it	ne
  401354:	2001      	movne	r0, #1
  401356:	bd10      	pop	{r4, pc}
  401358:	00401121 	.word	0x00401121
  40135c:	004011ad 	.word	0x004011ad
  401360:	004011d5 	.word	0x004011d5

00401364 <sd_mmc_ram_2_mem_0>:

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram) { return sd_mmc_ram_2_mem(0, addr, ram); }
  401364:	b508      	push	{r3, lr}
  401366:	460a      	mov	r2, r1
  401368:	4601      	mov	r1, r0
  40136a:	2000      	movs	r0, #0
  40136c:	4b01      	ldr	r3, [pc, #4]	; (401374 <sd_mmc_ram_2_mem_0+0x10>)
  40136e:	4798      	blx	r3
  401370:	bd08      	pop	{r3, pc}
  401372:	bf00      	nop
  401374:	00401329 	.word	0x00401329

00401378 <mem_test_unit_ready>:

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  401378:	b108      	cbz	r0, 40137e <mem_test_unit_ready+0x6>
  40137a:	2001      	movs	r0, #1
  40137c:	4770      	bx	lr
{
  40137e:	b508      	push	{r3, lr}
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  401380:	4b01      	ldr	r3, [pc, #4]	; (401388 <mem_test_unit_ready+0x10>)
  401382:	4798      	blx	r3
  401384:	bd08      	pop	{r3, pc}
  401386:	bf00      	nop
  401388:	00401289 	.word	0x00401289

0040138c <mem_read_capacity>:

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  40138c:	b108      	cbz	r0, 401392 <mem_read_capacity+0x6>
  40138e:	2001      	movs	r0, #1
  401390:	4770      	bx	lr
{
  401392:	b508      	push	{r3, lr}
  401394:	4608      	mov	r0, r1
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  401396:	4b01      	ldr	r3, [pc, #4]	; (40139c <mem_read_capacity+0x10>)
  401398:	4798      	blx	r3
  40139a:	bd08      	pop	{r3, pc}
  40139c:	004012b9 	.word	0x004012b9

004013a0 <mem_sector_size>:
#endif

  Ctrl_access_unlock();

  return sector_size;
}
  4013a0:	fab0 f080 	clz	r0, r0
  4013a4:	0940      	lsrs	r0, r0, #5
  4013a6:	4770      	bx	lr

004013a8 <mem_wr_protect>:

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  4013a8:	b108      	cbz	r0, 4013ae <mem_wr_protect+0x6>
  4013aa:	2001      	movs	r0, #1
  4013ac:	4770      	bx	lr
{
  4013ae:	b508      	push	{r3, lr}
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  4013b0:	4b01      	ldr	r3, [pc, #4]	; (4013b8 <mem_wr_protect+0x10>)
  4013b2:	4798      	blx	r3
  4013b4:	bd08      	pop	{r3, pc}
  4013b6:	bf00      	nop
  4013b8:	004012c9 	.word	0x004012c9

004013bc <memory_2_ram>:
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  4013bc:	b108      	cbz	r0, 4013c2 <memory_2_ram+0x6>
  4013be:	2001      	movs	r0, #1
  4013c0:	4770      	bx	lr
{
  4013c2:	b508      	push	{r3, lr}
  4013c4:	4608      	mov	r0, r1
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  4013c6:	4611      	mov	r1, r2
  4013c8:	4b01      	ldr	r3, [pc, #4]	; (4013d0 <memory_2_ram+0x14>)
  4013ca:	4798      	blx	r3
  4013cc:	bd08      	pop	{r3, pc}
  4013ce:	bf00      	nop
  4013d0:	00401315 	.word	0x00401315

004013d4 <ram_2_memory>:
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
  4013d4:	b108      	cbz	r0, 4013da <ram_2_memory+0x6>
  4013d6:	2001      	movs	r0, #1
  4013d8:	4770      	bx	lr
{
  4013da:	b508      	push	{r3, lr}
  4013dc:	4608      	mov	r0, r1
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
  4013de:	4611      	mov	r1, r2
  4013e0:	4b01      	ldr	r3, [pc, #4]	; (4013e8 <ram_2_memory+0x14>)
  4013e2:	4798      	blx	r3
  4013e4:	bd08      	pop	{r3, pc}
  4013e6:	bf00      	nop
  4013e8:	00401365 	.word	0x00401365

004013ec <hsmci_reset>:

/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
  4013ec:	b470      	push	{r4, r5, r6}
	uint32_t mr = HSMCI->HSMCI_MR;
  4013ee:	4b08      	ldr	r3, [pc, #32]	; (401410 <hsmci_reset+0x24>)
  4013f0:	685d      	ldr	r5, [r3, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  4013f2:	689c      	ldr	r4, [r3, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  4013f4:	68d8      	ldr	r0, [r3, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  4013f6:	69d9      	ldr	r1, [r3, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  4013f8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4013fa:	2680      	movs	r6, #128	; 0x80
  4013fc:	601e      	str	r6, [r3, #0]
	HSMCI->HSMCI_MR = mr;
  4013fe:	605d      	str	r5, [r3, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401400:	609c      	str	r4, [r3, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401402:	60d8      	str	r0, [r3, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401404:	61d9      	str	r1, [r3, #28]
	HSMCI->HSMCI_CFG = cfg;
  401406:	655a      	str	r2, [r3, #84]	; 0x54
#ifdef HSMCI_DMA_DMAEN
	HSMCI->HSMCI_DMA = 0;
#endif
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401408:	2205      	movs	r2, #5
  40140a:	601a      	str	r2, [r3, #0]
}
  40140c:	bc70      	pop	{r4, r5, r6}
  40140e:	4770      	bx	lr
  401410:	40080000 	.word	0x40080000

00401414 <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  401414:	b508      	push	{r3, lr}
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  401416:	f001 033f 	and.w	r3, r1, #63	; 0x3f
  40141a:	4318      	orrs	r0, r3
	if (cmd & SDMMC_RESP_PRESENT) {
  40141c:	f411 7f80 	tst.w	r1, #256	; 0x100
  401420:	d004      	beq.n	40142c <hsmci_send_cmd_execute+0x18>
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  401422:	f411 6f00 	tst.w	r1, #2048	; 0x800
  401426:	d00d      	beq.n	401444 <hsmci_send_cmd_execute+0x30>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  401428:	f440 5084 	orr.w	r0, r0, #4224	; 0x1080
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  40142c:	f411 4f80 	tst.w	r1, #16384	; 0x4000
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  401430:	bf18      	it	ne
  401432:	f440 6000 	orrne.w	r0, r0, #2048	; 0x800
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401436:	4b1d      	ldr	r3, [pc, #116]	; (4014ac <hsmci_send_cmd_execute+0x98>)
  401438:	611a      	str	r2, [r3, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  40143a:	6158      	str	r0, [r3, #20]

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  40143c:	4618      	mov	r0, r3
		if (cmd & SDMMC_RESP_CRC) {
  40143e:	f401 5280 	and.w	r2, r1, #4096	; 0x1000
  401442:	e00d      	b.n	401460 <hsmci_send_cmd_execute+0x4c>
		} else if (cmd & SDMMC_RESP_BUSY) {
  401444:	f411 5f00 	tst.w	r1, #8192	; 0x2000
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  401448:	bf14      	ite	ne
  40144a:	f440 5086 	orrne.w	r0, r0, #4288	; 0x10c0
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  40144e:	f440 5082 	orreq.w	r0, r0, #4160	; 0x1040
  401452:	e7eb      	b.n	40142c <hsmci_send_cmd_execute+0x18>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401454:	f413 0f1b 	tst.w	r3, #10158080	; 0x9b0000
  401458:	d10c      	bne.n	401474 <hsmci_send_cmd_execute+0x60>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  40145a:	f013 0f01 	tst.w	r3, #1
  40145e:	d10d      	bne.n	40147c <hsmci_send_cmd_execute+0x68>
		sr = HSMCI->HSMCI_SR;
  401460:	6c03      	ldr	r3, [r0, #64]	; 0x40
		if (cmd & SDMMC_RESP_CRC) {
  401462:	2a00      	cmp	r2, #0
  401464:	d0f6      	beq.n	401454 <hsmci_send_cmd_execute+0x40>
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401466:	f413 0f1f 	tst.w	r3, #10420224	; 0x9f0000
  40146a:	d0f6      	beq.n	40145a <hsmci_send_cmd_execute+0x46>
				hsmci_reset();
  40146c:	4b10      	ldr	r3, [pc, #64]	; (4014b0 <hsmci_send_cmd_execute+0x9c>)
  40146e:	4798      	blx	r3
				return false;
  401470:	2000      	movs	r0, #0
  401472:	bd08      	pop	{r3, pc}
				hsmci_reset();
  401474:	4b0e      	ldr	r3, [pc, #56]	; (4014b0 <hsmci_send_cmd_execute+0x9c>)
  401476:	4798      	blx	r3
				return false;
  401478:	2000      	movs	r0, #0
  40147a:	bd08      	pop	{r3, pc}

	if (cmd & SDMMC_RESP_BUSY) {
  40147c:	f411 5f00 	tst.w	r1, #8192	; 0x2000
  401480:	d103      	bne.n	40148a <hsmci_send_cmd_execute+0x76>
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
  401482:	2001      	movs	r0, #1
  401484:	bd08      	pop	{r3, pc}
	return true;
  401486:	2001      	movs	r0, #1
  401488:	bd08      	pop	{r3, pc}
		sr = HSMCI->HSMCI_SR;
  40148a:	4b08      	ldr	r3, [pc, #32]	; (4014ac <hsmci_send_cmd_execute+0x98>)
  40148c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40148e:	f04f 32ff 	mov.w	r2, #4294967295
  401492:	4906      	ldr	r1, [pc, #24]	; (4014ac <hsmci_send_cmd_execute+0x98>)
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401494:	f003 0330 	and.w	r3, r3, #48	; 0x30
  401498:	2b20      	cmp	r3, #32
  40149a:	d0f4      	beq.n	401486 <hsmci_send_cmd_execute+0x72>
		sr = HSMCI->HSMCI_SR;
  40149c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (busy_wait-- == 0) {
  40149e:	3a01      	subs	r2, #1
  4014a0:	d1f8      	bne.n	401494 <hsmci_send_cmd_execute+0x80>
			hsmci_reset();
  4014a2:	4b03      	ldr	r3, [pc, #12]	; (4014b0 <hsmci_send_cmd_execute+0x9c>)
  4014a4:	4798      	blx	r3
			return false;
  4014a6:	2000      	movs	r0, #0
  4014a8:	bd08      	pop	{r3, pc}
  4014aa:	bf00      	nop
  4014ac:	40080000 	.word	0x40080000
  4014b0:	004013ed 	.word	0x004013ed

004014b4 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  4014b4:	b508      	push	{r3, lr}
	pmc_enable_periph_clk(ID_HSMCI);
  4014b6:	2010      	movs	r0, #16
  4014b8:	4b06      	ldr	r3, [pc, #24]	; (4014d4 <hsmci_init+0x20>)
  4014ba:	4798      	blx	r3
	pmc_enable_periph_clk(ID_XDMAC);
#endif
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  4014bc:	4b06      	ldr	r3, [pc, #24]	; (4014d8 <hsmci_init+0x24>)
  4014be:	2272      	movs	r2, #114	; 0x72
  4014c0:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  4014c2:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  4014c4:	2211      	movs	r2, #17
  4014c6:	655a      	str	r2, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  4014c8:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  4014cc:	605a      	str	r2, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  4014ce:	2205      	movs	r2, #5
  4014d0:	601a      	str	r2, [r3, #0]
  4014d2:	bd08      	pop	{r3, pc}
  4014d4:	0040ad6d 	.word	0x0040ad6d
  4014d8:	40080000 	.word	0x40080000

004014dc <hsmci_get_bus_width>:
}

uint8_t hsmci_get_bus_width(uint8_t slot)
{
	switch (slot) {
  4014dc:	2800      	cmp	r0, #0
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
	}
}
  4014de:	bf0c      	ite	eq
  4014e0:	2004      	moveq	r0, #4
  4014e2:	2000      	movne	r0, #0
  4014e4:	4770      	bx	lr

004014e6 <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
	return true;
}
  4014e6:	2001      	movs	r0, #1
  4014e8:	4770      	bx	lr
	...

004014ec <hsmci_select_device>:
void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
  4014ec:	b363      	cbz	r3, 401548 <hsmci_select_device+0x5c>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  4014ee:	482a      	ldr	r0, [pc, #168]	; (401598 <hsmci_select_device+0xac>)
  4014f0:	6d43      	ldr	r3, [r0, #84]	; 0x54
  4014f2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4014f6:	6543      	str	r3, [r0, #84]	; 0x54
	if ((speed * 2) < mck) {
  4014f8:	4b28      	ldr	r3, [pc, #160]	; (40159c <hsmci_select_device+0xb0>)
  4014fa:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
  4014fe:	d333      	bcc.n	401568 <hsmci_select_device+0x7c>
{
  401500:	b410      	push	{r4}
		div = (mck / speed) - 2;
  401502:	4827      	ldr	r0, [pc, #156]	; (4015a0 <hsmci_select_device+0xb4>)
  401504:	fbb0 f3f1 	udiv	r3, r0, r1
		if (mck % speed) {
  401508:	fb01 0113 	mls	r1, r1, r3, r0
  40150c:	bb11      	cbnz	r1, 401554 <hsmci_select_device+0x68>
		div = (mck / speed) - 2;
  40150e:	3b02      	subs	r3, #2
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401510:	4921      	ldr	r1, [pc, #132]	; (401598 <hsmci_select_device+0xac>)
  401512:	6848      	ldr	r0, [r1, #4]
  401514:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  401518:	6048      	str	r0, [r1, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  40151a:	684c      	ldr	r4, [r1, #4]
  40151c:	f3c3 0047 	ubfx	r0, r3, #1, #8
  401520:	4320      	orrs	r0, r4
  401522:	6048      	str	r0, [r1, #4]
	if (clkodd) {
  401524:	f013 0f01 	tst.w	r3, #1
  401528:	d016      	beq.n	401558 <hsmci_select_device+0x6c>
		HSMCI->HSMCI_MR |= HSMCI_MR_CLKODD;
  40152a:	684b      	ldr	r3, [r1, #4]
  40152c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  401530:	604b      	str	r3, [r1, #4]
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401532:	2a04      	cmp	r2, #4
  401534:	d016      	beq.n	401564 <hsmci_select_device+0x78>
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  401536:	2a08      	cmp	r2, #8
  401538:	bf0c      	ite	eq
  40153a:	22c0      	moveq	r2, #192	; 0xc0
  40153c:	2200      	movne	r2, #0
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  40153e:	4b16      	ldr	r3, [pc, #88]	; (401598 <hsmci_select_device+0xac>)
  401540:	60da      	str	r2, [r3, #12]
}
  401542:	f85d 4b04 	ldr.w	r4, [sp], #4
  401546:	4770      	bx	lr
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  401548:	4813      	ldr	r0, [pc, #76]	; (401598 <hsmci_select_device+0xac>)
  40154a:	6d43      	ldr	r3, [r0, #84]	; 0x54
  40154c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  401550:	6543      	str	r3, [r0, #84]	; 0x54
  401552:	e7d1      	b.n	4014f8 <hsmci_select_device+0xc>
			div++;
  401554:	3b01      	subs	r3, #1
  401556:	e7db      	b.n	401510 <hsmci_select_device+0x24>
		HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKODD;
  401558:	490f      	ldr	r1, [pc, #60]	; (401598 <hsmci_select_device+0xac>)
  40155a:	684b      	ldr	r3, [r1, #4]
  40155c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  401560:	604b      	str	r3, [r1, #4]
  401562:	e7e6      	b.n	401532 <hsmci_select_device+0x46>
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  401564:	2280      	movs	r2, #128	; 0x80
  401566:	e7ea      	b.n	40153e <hsmci_select_device+0x52>
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401568:	4b0b      	ldr	r3, [pc, #44]	; (401598 <hsmci_select_device+0xac>)
  40156a:	6859      	ldr	r1, [r3, #4]
  40156c:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  401570:	6059      	str	r1, [r3, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  401572:	6859      	ldr	r1, [r3, #4]
  401574:	6059      	str	r1, [r3, #4]
		HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKODD;
  401576:	4908      	ldr	r1, [pc, #32]	; (401598 <hsmci_select_device+0xac>)
  401578:	684b      	ldr	r3, [r1, #4]
  40157a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  40157e:	604b      	str	r3, [r1, #4]
	switch (bus_width) {
  401580:	2a04      	cmp	r2, #4
  401582:	d006      	beq.n	401592 <hsmci_select_device+0xa6>
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  401584:	2a08      	cmp	r2, #8
  401586:	bf0c      	ite	eq
  401588:	22c0      	moveq	r2, #192	; 0xc0
  40158a:	2200      	movne	r2, #0
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  40158c:	4b02      	ldr	r3, [pc, #8]	; (401598 <hsmci_select_device+0xac>)
  40158e:	60da      	str	r2, [r3, #12]
  401590:	4770      	bx	lr
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  401592:	2280      	movs	r2, #128	; 0x80
  401594:	e7fa      	b.n	40158c <hsmci_select_device+0xa0>
  401596:	bf00      	nop
  401598:	40080000 	.word	0x40080000
  40159c:	05b8d7ff 	.word	0x05b8d7ff
  4015a0:	05b8d800 	.word	0x05b8d800

004015a4 <hsmci_deselect_device>:

void hsmci_deselect_device(uint8_t slot)
{
  4015a4:	4770      	bx	lr
	...

004015a8 <hsmci_send_clock>:
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4015a8:	4b07      	ldr	r3, [pc, #28]	; (4015c8 <hsmci_send_clock+0x20>)
  4015aa:	685a      	ldr	r2, [r3, #4]
  4015ac:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  4015b0:	605a      	str	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  4015b2:	2200      	movs	r2, #0
  4015b4:	611a      	str	r2, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  4015b6:	f44f 6210 	mov.w	r2, #2304	; 0x900
  4015ba:	615a      	str	r2, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  4015bc:	461a      	mov	r2, r3
  4015be:	6c13      	ldr	r3, [r2, #64]	; 0x40
  4015c0:	f013 0f01 	tst.w	r3, #1
  4015c4:	d0fb      	beq.n	4015be <hsmci_send_clock+0x16>
}
  4015c6:	4770      	bx	lr
  4015c8:	40080000 	.word	0x40080000

004015cc <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  4015cc:	b510      	push	{r4, lr}
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4015ce:	4b08      	ldr	r3, [pc, #32]	; (4015f0 <hsmci_send_cmd+0x24>)
  4015d0:	685a      	ldr	r2, [r3, #4]
  4015d2:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  4015d6:	605a      	str	r2, [r3, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  4015d8:	685a      	ldr	r2, [r3, #4]
  4015da:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  4015de:	605a      	str	r2, [r3, #4]
#ifdef HSMCI_DMA_DMAEN
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#endif
	HSMCI->HSMCI_BLKR = 0;
  4015e0:	2400      	movs	r4, #0
  4015e2:	619c      	str	r4, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  4015e4:	460a      	mov	r2, r1
  4015e6:	4601      	mov	r1, r0
  4015e8:	4620      	mov	r0, r4
  4015ea:	4b02      	ldr	r3, [pc, #8]	; (4015f4 <hsmci_send_cmd+0x28>)
  4015ec:	4798      	blx	r3
}
  4015ee:	bd10      	pop	{r4, pc}
  4015f0:	40080000 	.word	0x40080000
  4015f4:	00401415 	.word	0x00401415

004015f8 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
  4015f8:	4b01      	ldr	r3, [pc, #4]	; (401600 <hsmci_get_response+0x8>)
  4015fa:	6a18      	ldr	r0, [r3, #32]
}
  4015fc:	4770      	bx	lr
  4015fe:	bf00      	nop
  401600:	40080000 	.word	0x40080000

00401604 <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  401604:	b410      	push	{r4}
  401606:	1d03      	adds	r3, r0, #4
  401608:	3014      	adds	r0, #20
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
  40160a:	4c09      	ldr	r4, [pc, #36]	; (401630 <hsmci_get_response_128+0x2c>)
  40160c:	6a22      	ldr	r2, [r4, #32]
		*response = (response_32 >> 24) & 0xFF;
  40160e:	0e11      	lsrs	r1, r2, #24
  401610:	f803 1c04 	strb.w	r1, [r3, #-4]
		response++;
		*response = (response_32 >> 16) & 0xFF;
  401614:	0c11      	lsrs	r1, r2, #16
  401616:	f803 1c03 	strb.w	r1, [r3, #-3]
		response++;
		*response = (response_32 >>  8) & 0xFF;
  40161a:	0a11      	lsrs	r1, r2, #8
  40161c:	f803 1c02 	strb.w	r1, [r3, #-2]
		response++;
		*response = (response_32 >>  0) & 0xFF;
  401620:	f803 2c01 	strb.w	r2, [r3, #-1]
  401624:	3304      	adds	r3, #4
	for (uint8_t i = 0; i < 4; i++) {
  401626:	4283      	cmp	r3, r0
  401628:	d1f0      	bne.n	40160c <hsmci_get_response_128+0x8>
		response++;
	}
}
  40162a:	f85d 4b04 	ldr.w	r4, [sp], #4
  40162e:	4770      	bx	lr
  401630:	40080000 	.word	0x40080000

00401634 <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  401634:	b570      	push	{r4, r5, r6, lr}
  401636:	f89d 4010 	ldrb.w	r4, [sp, #16]
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  40163a:	b374      	cbz	r4, 40169a <hsmci_adtc_start+0x66>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  40163c:	4d29      	ldr	r5, [pc, #164]	; (4016e4 <hsmci_adtc_start+0xb0>)
  40163e:	686c      	ldr	r4, [r5, #4]
  401640:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
  401644:	606c      	str	r4, [r5, #4]
#endif
#endif
	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  401646:	4d27      	ldr	r5, [pc, #156]	; (4016e4 <hsmci_adtc_start+0xb0>)
  401648:	686c      	ldr	r4, [r5, #4]
  40164a:	f444 54c0 	orr.w	r4, r4, #6144	; 0x1800
  40164e:	606c      	str	r4, [r5, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
  401650:	f012 0f03 	tst.w	r2, #3
  401654:	d027      	beq.n	4016a6 <hsmci_adtc_start+0x72>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  401656:	686c      	ldr	r4, [r5, #4]
  401658:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
  40165c:	606c      	str	r4, [r5, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	if (cmd & SDMMC_CMD_WRITE) {
  40165e:	f400 4400 	and.w	r4, r0, #32768	; 0x8000
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
  401662:	2c00      	cmp	r4, #0
  401664:	bf14      	ite	ne
  401666:	f44f 3480 	movne.w	r4, #65536	; 0x10000
  40166a:	f44f 24a0 	moveq.w	r4, #327680	; 0x50000
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  40166e:	f410 3f80 	tst.w	r0, #65536	; 0x10000
  401672:	d11e      	bne.n	4016b2 <hsmci_adtc_start+0x7e>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  401674:	ea43 4502 	orr.w	r5, r3, r2, lsl #16
  401678:	4e1a      	ldr	r6, [pc, #104]	; (4016e4 <hsmci_adtc_start+0xb0>)
  40167a:	61b5      	str	r5, [r6, #24]
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  40167c:	f410 3f00 	tst.w	r0, #131072	; 0x20000
  401680:	d12a      	bne.n	4016d8 <hsmci_adtc_start+0xa4>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  401682:	f410 2f80 	tst.w	r0, #262144	; 0x40000
  401686:	d12a      	bne.n	4016de <hsmci_adtc_start+0xaa>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  401688:	f410 2f00 	tst.w	r0, #524288	; 0x80000
  40168c:	d117      	bne.n	4016be <hsmci_adtc_start+0x8a>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  40168e:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  401692:	bf18      	it	ne
  401694:	f444 2400 	orrne.w	r4, r4, #524288	; 0x80000
  401698:	e011      	b.n	4016be <hsmci_adtc_start+0x8a>
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  40169a:	4d12      	ldr	r5, [pc, #72]	; (4016e4 <hsmci_adtc_start+0xb0>)
  40169c:	686c      	ldr	r4, [r5, #4]
  40169e:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
  4016a2:	606c      	str	r4, [r5, #4]
  4016a4:	e7cf      	b.n	401646 <hsmci_adtc_start+0x12>
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4016a6:	4d0f      	ldr	r5, [pc, #60]	; (4016e4 <hsmci_adtc_start+0xb0>)
  4016a8:	686c      	ldr	r4, [r5, #4]
  4016aa:	f424 5400 	bic.w	r4, r4, #8192	; 0x2000
  4016ae:	606c      	str	r4, [r5, #4]
  4016b0:	e7d5      	b.n	40165e <hsmci_adtc_start+0x2a>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  4016b2:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  4016b6:	f3c2 0508 	ubfx	r5, r2, #0, #9
  4016ba:	4e0a      	ldr	r6, [pc, #40]	; (4016e4 <hsmci_adtc_start+0xb0>)
  4016bc:	61b5      	str	r5, [r6, #24]
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  4016be:	2600      	movs	r6, #0
  4016c0:	4d09      	ldr	r5, [pc, #36]	; (4016e8 <hsmci_adtc_start+0xb4>)
  4016c2:	602e      	str	r6, [r5, #0]
	hsmci_block_size = block_size;
  4016c4:	4d09      	ldr	r5, [pc, #36]	; (4016ec <hsmci_adtc_start+0xb8>)
  4016c6:	802a      	strh	r2, [r5, #0]
	hsmci_nb_block = nb_block;
  4016c8:	4a09      	ldr	r2, [pc, #36]	; (4016f0 <hsmci_adtc_start+0xbc>)
  4016ca:	8013      	strh	r3, [r2, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  4016cc:	460a      	mov	r2, r1
  4016ce:	4601      	mov	r1, r0
  4016d0:	4620      	mov	r0, r4
  4016d2:	4b08      	ldr	r3, [pc, #32]	; (4016f4 <hsmci_adtc_start+0xc0>)
  4016d4:	4798      	blx	r3
}
  4016d6:	bd70      	pop	{r4, r5, r6, pc}
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  4016d8:	f444 1420 	orr.w	r4, r4, #2621440	; 0x280000
  4016dc:	e7ef      	b.n	4016be <hsmci_adtc_start+0x8a>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  4016de:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
  4016e2:	e7ec      	b.n	4016be <hsmci_adtc_start+0x8a>
  4016e4:	40080000 	.word	0x40080000
  4016e8:	2000754c 	.word	0x2000754c
  4016ec:	20007546 	.word	0x20007546
  4016f0:	20007548 	.word	0x20007548
  4016f4:	00401415 	.word	0x00401415

004016f8 <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  4016f8:	b508      	push	{r3, lr}

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  4016fa:	4915      	ldr	r1, [pc, #84]	; (401750 <hsmci_read_word+0x58>)
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4016fc:	4a15      	ldr	r2, [pc, #84]	; (401754 <hsmci_read_word+0x5c>)
		sr = HSMCI->HSMCI_SR;
  4016fe:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401700:	4213      	tst	r3, r2
  401702:	d11b      	bne.n	40173c <hsmci_read_word+0x44>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  401704:	f013 0f02 	tst.w	r3, #2
  401708:	d0f9      	beq.n	4016fe <hsmci_read_word+0x6>

	// Read data
	*value = HSMCI->HSMCI_RDR;
  40170a:	4b11      	ldr	r3, [pc, #68]	; (401750 <hsmci_read_word+0x58>)
  40170c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40170e:	6003      	str	r3, [r0, #0]
	hsmci_transfert_pos += 4;
  401710:	4a11      	ldr	r2, [pc, #68]	; (401758 <hsmci_read_word+0x60>)
  401712:	6813      	ldr	r3, [r2, #0]
  401714:	3304      	adds	r3, #4
  401716:	6013      	str	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401718:	4a10      	ldr	r2, [pc, #64]	; (40175c <hsmci_read_word+0x64>)
  40171a:	8811      	ldrh	r1, [r2, #0]
  40171c:	4a10      	ldr	r2, [pc, #64]	; (401760 <hsmci_read_word+0x68>)
  40171e:	8812      	ldrh	r2, [r2, #0]
  401720:	fb02 f201 	mul.w	r2, r2, r1
  401724:	4293      	cmp	r3, r2
  401726:	d311      	bcc.n	40174c <hsmci_read_word+0x54>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  401728:	4909      	ldr	r1, [pc, #36]	; (401750 <hsmci_read_word+0x58>)
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40172a:	4a0a      	ldr	r2, [pc, #40]	; (401754 <hsmci_read_word+0x5c>)
		sr = HSMCI->HSMCI_SR;
  40172c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40172e:	4213      	tst	r3, r2
  401730:	d108      	bne.n	401744 <hsmci_read_word+0x4c>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  401732:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
  401736:	d0f9      	beq.n	40172c <hsmci_read_word+0x34>
	return true;
  401738:	2001      	movs	r0, #1
  40173a:	bd08      	pop	{r3, pc}
			hsmci_reset();
  40173c:	4b09      	ldr	r3, [pc, #36]	; (401764 <hsmci_read_word+0x6c>)
  40173e:	4798      	blx	r3
			return false;
  401740:	2000      	movs	r0, #0
  401742:	bd08      	pop	{r3, pc}
			hsmci_reset();
  401744:	4b07      	ldr	r3, [pc, #28]	; (401764 <hsmci_read_word+0x6c>)
  401746:	4798      	blx	r3
			return false;
  401748:	2000      	movs	r0, #0
  40174a:	bd08      	pop	{r3, pc}
		return true;
  40174c:	2001      	movs	r0, #1
}
  40174e:	bd08      	pop	{r3, pc}
  401750:	40080000 	.word	0x40080000
  401754:	c0600000 	.word	0xc0600000
  401758:	2000754c 	.word	0x2000754c
  40175c:	20007546 	.word	0x20007546
  401760:	20007548 	.word	0x20007548
  401764:	004013ed 	.word	0x004013ed

00401768 <hsmci_start_read_blocks>:
#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401768:	4b15      	ldr	r3, [pc, #84]	; (4017c0 <hsmci_start_read_blocks+0x58>)
  40176a:	881b      	ldrh	r3, [r3, #0]
  40176c:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  401770:	f010 0f03 	tst.w	r0, #3
  401774:	d102      	bne.n	40177c <hsmci_start_read_blocks+0x14>
  401776:	f013 0f03 	tst.w	r3, #3
  40177a:	d01b      	beq.n	4017b4 <hsmci_start_read_blocks+0x4c>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  40177c:	4a11      	ldr	r2, [pc, #68]	; (4017c4 <hsmci_start_read_blocks+0x5c>)
  40177e:	6853      	ldr	r3, [r2, #4]
  401780:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  401784:	6053      	str	r3, [r2, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  401786:	4b0f      	ldr	r3, [pc, #60]	; (4017c4 <hsmci_start_read_blocks+0x5c>)
  401788:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  40178c:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
  40178e:	f413 5f00 	tst.w	r3, #8192	; 0x2000
  401792:	bf0c      	ite	eq
  401794:	088b      	lsreq	r3, r1, #2
  401796:	460b      	movne	r3, r1
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401798:	4a0a      	ldr	r2, [pc, #40]	; (4017c4 <hsmci_start_read_blocks+0x5c>)
  40179a:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
	HSMCI->HSMCI_RNCR = 0;
  40179e:	2300      	movs	r3, #0
  4017a0:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  4017a4:	2001      	movs	r0, #1
  4017a6:	f8c2 0120 	str.w	r0, [r2, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  4017aa:	4a07      	ldr	r2, [pc, #28]	; (4017c8 <hsmci_start_read_blocks+0x60>)
  4017ac:	6813      	ldr	r3, [r2, #0]
  4017ae:	440b      	add	r3, r1
  4017b0:	6013      	str	r3, [r2, #0]
	return true;
}
  4017b2:	4770      	bx	lr
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4017b4:	4a03      	ldr	r2, [pc, #12]	; (4017c4 <hsmci_start_read_blocks+0x5c>)
  4017b6:	6853      	ldr	r3, [r2, #4]
  4017b8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  4017bc:	6053      	str	r3, [r2, #4]
  4017be:	e7e2      	b.n	401786 <hsmci_start_read_blocks+0x1e>
  4017c0:	20007546 	.word	0x20007546
  4017c4:	40080000 	.word	0x40080000
  4017c8:	2000754c 	.word	0x2000754c

004017cc <hsmci_wait_end_of_read_blocks>:

bool hsmci_wait_end_of_read_blocks(void)
{
  4017cc:	b508      	push	{r3, lr}
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4017ce:	4915      	ldr	r1, [pc, #84]	; (401824 <hsmci_wait_end_of_read_blocks+0x58>)
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4017d0:	4a15      	ldr	r2, [pc, #84]	; (401828 <hsmci_wait_end_of_read_blocks+0x5c>)
		sr = HSMCI->HSMCI_SR;
  4017d2:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4017d4:	4213      	tst	r3, r2
  4017d6:	d116      	bne.n	401806 <hsmci_wait_end_of_read_blocks+0x3a>
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  4017d8:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  4017dc:	d0f9      	beq.n	4017d2 <hsmci_wait_end_of_read_blocks+0x6>

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  4017de:	4b13      	ldr	r3, [pc, #76]	; (40182c <hsmci_wait_end_of_read_blocks+0x60>)
  4017e0:	881a      	ldrh	r2, [r3, #0]
  4017e2:	4b13      	ldr	r3, [pc, #76]	; (401830 <hsmci_wait_end_of_read_blocks+0x64>)
  4017e4:	881b      	ldrh	r3, [r3, #0]
  4017e6:	fb03 f302 	mul.w	r3, r3, r2
  4017ea:	4a12      	ldr	r2, [pc, #72]	; (401834 <hsmci_wait_end_of_read_blocks+0x68>)
  4017ec:	6812      	ldr	r2, [r2, #0]
  4017ee:	4293      	cmp	r3, r2
  4017f0:	d816      	bhi.n	401820 <hsmci_wait_end_of_read_blocks+0x54>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4017f2:	490c      	ldr	r1, [pc, #48]	; (401824 <hsmci_wait_end_of_read_blocks+0x58>)
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4017f4:	4a0c      	ldr	r2, [pc, #48]	; (401828 <hsmci_wait_end_of_read_blocks+0x5c>)
		sr = HSMCI->HSMCI_SR;
  4017f6:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4017f8:	4213      	tst	r3, r2
  4017fa:	d10d      	bne.n	401818 <hsmci_wait_end_of_read_blocks+0x4c>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  4017fc:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
  401800:	d0f9      	beq.n	4017f6 <hsmci_wait_end_of_read_blocks+0x2a>
	return true;
  401802:	2001      	movs	r0, #1
  401804:	bd08      	pop	{r3, pc}
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401806:	f240 2202 	movw	r2, #514	; 0x202
  40180a:	4b06      	ldr	r3, [pc, #24]	; (401824 <hsmci_wait_end_of_read_blocks+0x58>)
  40180c:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
			hsmci_reset();
  401810:	4b09      	ldr	r3, [pc, #36]	; (401838 <hsmci_wait_end_of_read_blocks+0x6c>)
  401812:	4798      	blx	r3
			return false;
  401814:	2000      	movs	r0, #0
  401816:	bd08      	pop	{r3, pc}
			hsmci_reset();
  401818:	4b07      	ldr	r3, [pc, #28]	; (401838 <hsmci_wait_end_of_read_blocks+0x6c>)
  40181a:	4798      	blx	r3
			return false;
  40181c:	2000      	movs	r0, #0
  40181e:	bd08      	pop	{r3, pc}
		return true;
  401820:	2001      	movs	r0, #1
}
  401822:	bd08      	pop	{r3, pc}
  401824:	40080000 	.word	0x40080000
  401828:	c0600000 	.word	0xc0600000
  40182c:	20007546 	.word	0x20007546
  401830:	20007548 	.word	0x20007548
  401834:	2000754c 	.word	0x2000754c
  401838:	004013ed 	.word	0x004013ed

0040183c <hsmci_start_write_blocks>:

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  40183c:	4b16      	ldr	r3, [pc, #88]	; (401898 <hsmci_start_write_blocks+0x5c>)
  40183e:	881b      	ldrh	r3, [r3, #0]
  401840:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  401844:	f010 0f03 	tst.w	r0, #3
  401848:	d102      	bne.n	401850 <hsmci_start_write_blocks+0x14>
  40184a:	f013 0f03 	tst.w	r3, #3
  40184e:	d01d      	beq.n	40188c <hsmci_start_write_blocks+0x50>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  401850:	4a12      	ldr	r2, [pc, #72]	; (40189c <hsmci_start_write_blocks+0x60>)
  401852:	6853      	ldr	r3, [r2, #4]
  401854:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  401858:	6053      	str	r3, [r2, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  40185a:	4b10      	ldr	r3, [pc, #64]	; (40189c <hsmci_start_write_blocks+0x60>)
  40185c:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401860:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
  401862:	f413 5f00 	tst.w	r3, #8192	; 0x2000
  401866:	bf0c      	ite	eq
  401868:	088b      	lsreq	r3, r1, #2
  40186a:	460b      	movne	r3, r1
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  40186c:	4a0b      	ldr	r2, [pc, #44]	; (40189c <hsmci_start_write_blocks+0x60>)
  40186e:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
	HSMCI->HSMCI_TNCR = 0;
  401872:	2300      	movs	r3, #0
  401874:	f8c2 311c 	str.w	r3, [r2, #284]	; 0x11c
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  401878:	f44f 7380 	mov.w	r3, #256	; 0x100
  40187c:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  401880:	4a07      	ldr	r2, [pc, #28]	; (4018a0 <hsmci_start_write_blocks+0x64>)
  401882:	6813      	ldr	r3, [r2, #0]
  401884:	440b      	add	r3, r1
  401886:	6013      	str	r3, [r2, #0]
	return true;
}
  401888:	2001      	movs	r0, #1
  40188a:	4770      	bx	lr
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  40188c:	4a03      	ldr	r2, [pc, #12]	; (40189c <hsmci_start_write_blocks+0x60>)
  40188e:	6853      	ldr	r3, [r2, #4]
  401890:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  401894:	6053      	str	r3, [r2, #4]
  401896:	e7e0      	b.n	40185a <hsmci_start_write_blocks+0x1e>
  401898:	20007546 	.word	0x20007546
  40189c:	40080000 	.word	0x40080000
  4018a0:	2000754c 	.word	0x2000754c

004018a4 <hsmci_wait_end_of_write_blocks>:

bool hsmci_wait_end_of_write_blocks(void)
{
  4018a4:	b508      	push	{r3, lr}
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4018a6:	4915      	ldr	r1, [pc, #84]	; (4018fc <hsmci_wait_end_of_write_blocks+0x58>)
		if (sr &
  4018a8:	4a15      	ldr	r2, [pc, #84]	; (401900 <hsmci_wait_end_of_write_blocks+0x5c>)
		sr = HSMCI->HSMCI_SR;
  4018aa:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr &
  4018ac:	4213      	tst	r3, r2
  4018ae:	d116      	bne.n	4018de <hsmci_wait_end_of_write_blocks+0x3a>
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));
  4018b0:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  4018b4:	d0f9      	beq.n	4018aa <hsmci_wait_end_of_write_blocks+0x6>


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  4018b6:	4b13      	ldr	r3, [pc, #76]	; (401904 <hsmci_wait_end_of_write_blocks+0x60>)
  4018b8:	881a      	ldrh	r2, [r3, #0]
  4018ba:	4b13      	ldr	r3, [pc, #76]	; (401908 <hsmci_wait_end_of_write_blocks+0x64>)
  4018bc:	881b      	ldrh	r3, [r3, #0]
  4018be:	fb03 f302 	mul.w	r3, r3, r2
  4018c2:	4a12      	ldr	r2, [pc, #72]	; (40190c <hsmci_wait_end_of_write_blocks+0x68>)
  4018c4:	6812      	ldr	r2, [r2, #0]
  4018c6:	4293      	cmp	r3, r2
  4018c8:	d816      	bhi.n	4018f8 <hsmci_wait_end_of_write_blocks+0x54>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4018ca:	490c      	ldr	r1, [pc, #48]	; (4018fc <hsmci_wait_end_of_write_blocks+0x58>)
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4018cc:	4a0c      	ldr	r2, [pc, #48]	; (401900 <hsmci_wait_end_of_write_blocks+0x5c>)
		sr = HSMCI->HSMCI_SR;
  4018ce:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4018d0:	4213      	tst	r3, r2
  4018d2:	d10d      	bne.n	4018f0 <hsmci_wait_end_of_write_blocks+0x4c>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
  4018d4:	f013 0f20 	tst.w	r3, #32
  4018d8:	d0f9      	beq.n	4018ce <hsmci_wait_end_of_write_blocks+0x2a>
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
  4018da:	2001      	movs	r0, #1
  4018dc:	bd08      	pop	{r3, pc}
			hsmci_reset();
  4018de:	4b0c      	ldr	r3, [pc, #48]	; (401910 <hsmci_wait_end_of_write_blocks+0x6c>)
  4018e0:	4798      	blx	r3
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  4018e2:	f240 2202 	movw	r2, #514	; 0x202
  4018e6:	4b05      	ldr	r3, [pc, #20]	; (4018fc <hsmci_wait_end_of_write_blocks+0x58>)
  4018e8:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
			return false;
  4018ec:	2000      	movs	r0, #0
  4018ee:	bd08      	pop	{r3, pc}
			hsmci_reset();
  4018f0:	4b07      	ldr	r3, [pc, #28]	; (401910 <hsmci_wait_end_of_write_blocks+0x6c>)
  4018f2:	4798      	blx	r3
			return false;
  4018f4:	2000      	movs	r0, #0
  4018f6:	bd08      	pop	{r3, pc}
		return true;
  4018f8:	2001      	movs	r0, #1
}
  4018fa:	bd08      	pop	{r3, pc}
  4018fc:	40080000 	.word	0x40080000
  401900:	c0600000 	.word	0xc0600000
  401904:	20007546 	.word	0x20007546
  401908:	20007548 	.word	0x20007548
  40190c:	2000754c 	.word	0x2000754c
  401910:	004013ed 	.word	0x004013ed

00401914 <rtc_get_time>:
 * \param pul_minute Current minute.
 * \param pul_second Current second.
 */
void rtc_get_time(Rtc *p_rtc, uint32_t *pul_hour, uint32_t *pul_minute,
		uint32_t *pul_second)
{
  401914:	b430      	push	{r4, r5}
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
  401916:	6885      	ldr	r5, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  401918:	6884      	ldr	r4, [r0, #8]
  40191a:	42a5      	cmp	r5, r4
  40191c:	d003      	beq.n	401926 <rtc_get_time+0x12>
		ul_time = p_rtc->RTC_TIMR;
  40191e:	6885      	ldr	r5, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  401920:	6884      	ldr	r4, [r0, #8]
  401922:	42ac      	cmp	r4, r5
  401924:	d1fb      	bne.n	40191e <rtc_get_time+0xa>
	}

	/* Hour */
	if (pul_hour) {
  401926:	b161      	cbz	r1, 401942 <rtc_get_time+0x2e>
		ul_temp = (ul_time & RTC_TIMR_HOUR_Msk) >> RTC_TIMR_HOUR_Pos;
		*pul_hour = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401928:	f3c4 5001 	ubfx	r0, r4, #20, #2
  40192c:	eb00 0580 	add.w	r5, r0, r0, lsl #2
  401930:	f3c4 4003 	ubfx	r0, r4, #16, #4
  401934:	eb00 0045 	add.w	r0, r0, r5, lsl #1

		if ((ul_time & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
  401938:	f414 0f80 	tst.w	r4, #4194304	; 0x400000
			*pul_hour += 12;
  40193c:	bf18      	it	ne
  40193e:	300c      	addne	r0, #12
  401940:	6008      	str	r0, [r1, #0]
		}
	}

	/* Minute */
	if (pul_minute) {
  401942:	b142      	cbz	r2, 401956 <rtc_get_time+0x42>
		ul_temp = (ul_time & RTC_TIMR_MIN_Msk) >> RTC_TIMR_MIN_Pos;
		*pul_minute = (ul_temp >> BCD_SHIFT) * BCD_FACTOR +  (ul_temp & BCD_MASK);
  401944:	f3c4 3102 	ubfx	r1, r4, #12, #3
  401948:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40194c:	f3c4 2003 	ubfx	r0, r4, #8, #4
  401950:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  401954:	6011      	str	r1, [r2, #0]
	}

	/* Second */
	if (pul_second) {
  401956:	b143      	cbz	r3, 40196a <rtc_get_time+0x56>
		ul_temp = (ul_time & RTC_TIMR_SEC_Msk) >> RTC_TIMR_SEC_Pos;
		*pul_second = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401958:	f3c4 1202 	ubfx	r2, r4, #4, #3
  40195c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  401960:	f004 040f 	and.w	r4, r4, #15
  401964:	eb04 0442 	add.w	r4, r4, r2, lsl #1
  401968:	601c      	str	r4, [r3, #0]
	}
}
  40196a:	bc30      	pop	{r4, r5}
  40196c:	4770      	bx	lr

0040196e <rtc_get_date>:
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  40196e:	b4f0      	push	{r4, r5, r6, r7}
  401970:	9e04      	ldr	r6, [sp, #16]
	uint32_t ul_date;
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
  401972:	68c5      	ldr	r5, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  401974:	68c4      	ldr	r4, [r0, #12]
  401976:	42a5      	cmp	r5, r4
  401978:	d003      	beq.n	401982 <rtc_get_date+0x14>
		ul_date = p_rtc->RTC_CALR;
  40197a:	68c5      	ldr	r5, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  40197c:	68c4      	ldr	r4, [r0, #12]
  40197e:	42ac      	cmp	r4, r5
  401980:	d1fb      	bne.n	40197a <rtc_get_date+0xc>
	}

	/* Retrieve year */
	if (pul_year) {
  401982:	b199      	cbz	r1, 4019ac <rtc_get_date+0x3e>
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401984:	f3c4 3003 	ubfx	r0, r4, #12, #4
  401988:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40198c:	f3c4 2703 	ubfx	r7, r4, #8, #4
  401990:	eb07 0740 	add.w	r7, r7, r0, lsl #1
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401994:	f3c4 1002 	ubfx	r0, r4, #4, #3
  401998:	eb00 0580 	add.w	r5, r0, r0, lsl #2
  40199c:	f004 000f 	and.w	r0, r4, #15
  4019a0:	eb00 0045 	add.w	r0, r0, r5, lsl #1
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4019a4:	2564      	movs	r5, #100	; 0x64
  4019a6:	fb05 7000 	mla	r0, r5, r0, r7
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  4019aa:	6008      	str	r0, [r1, #0]
	}

	/* Retrieve month */
	if (pul_month) {
  4019ac:	b142      	cbz	r2, 4019c0 <rtc_get_date+0x52>
		ul_temp = (ul_date & RTC_CALR_MONTH_Msk) >> RTC_CALR_MONTH_Pos;
		*pul_month = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4019ae:	f3c4 5000 	ubfx	r0, r4, #20, #1
  4019b2:	0081      	lsls	r1, r0, #2
  4019b4:	4408      	add	r0, r1
  4019b6:	f3c4 4103 	ubfx	r1, r4, #16, #4
  4019ba:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  4019be:	6011      	str	r1, [r2, #0]
	}

	/* Retrieve day */
	if (pul_day) {
  4019c0:	b143      	cbz	r3, 4019d4 <rtc_get_date+0x66>
		ul_temp = (ul_date & RTC_CALR_DATE_Msk) >> RTC_CALR_DATE_Pos;
		*pul_day = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4019c2:	f3c4 7201 	ubfx	r2, r4, #28, #2
  4019c6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4019ca:	f3c4 6103 	ubfx	r1, r4, #24, #4
  4019ce:	eb01 0242 	add.w	r2, r1, r2, lsl #1
  4019d2:	601a      	str	r2, [r3, #0]
	}

	/* Retrieve week */
	if (pul_week) {
  4019d4:	b116      	cbz	r6, 4019dc <rtc_get_date+0x6e>
		*pul_week = ((ul_date & RTC_CALR_DAY_Msk) >> RTC_CALR_DAY_Pos);
  4019d6:	f3c4 5442 	ubfx	r4, r4, #21, #3
  4019da:	6034      	str	r4, [r6, #0]
	}
}
  4019dc:	bcf0      	pop	{r4, r5, r6, r7}
  4019de:	4770      	bx	lr

004019e0 <disk_initialize>:
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
  4019e0:	2801      	cmp	r0, #1
  4019e2:	d901      	bls.n	4019e8 <disk_initialize+0x8>
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
  4019e4:	2001      	movs	r0, #1
  4019e6:	4770      	bx	lr
{
  4019e8:	b510      	push	{r4, lr}
  4019ea:	4604      	mov	r4, r0
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  4019ec:	4b0a      	ldr	r3, [pc, #40]	; (401a18 <disk_initialize+0x38>)
  4019ee:	4798      	blx	r3
		if (CTRL_BUSY != mem_status) {
  4019f0:	2803      	cmp	r0, #3
  4019f2:	d106      	bne.n	401a02 <disk_initialize+0x22>
		mem_status = mem_test_unit_ready(drv);
  4019f4:	4620      	mov	r0, r4
  4019f6:	4b08      	ldr	r3, [pc, #32]	; (401a18 <disk_initialize+0x38>)
  4019f8:	4798      	blx	r3
		if (CTRL_BUSY != mem_status) {
  4019fa:	2803      	cmp	r0, #3
  4019fc:	d101      	bne.n	401a02 <disk_initialize+0x22>
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
  4019fe:	2001      	movs	r0, #1
  401a00:	bd10      	pop	{r4, pc}
	if (mem_status != CTRL_GOOD) {
  401a02:	b938      	cbnz	r0, 401a14 <disk_initialize+0x34>
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
  401a04:	4620      	mov	r0, r4
  401a06:	4b05      	ldr	r3, [pc, #20]	; (401a1c <disk_initialize+0x3c>)
  401a08:	4798      	blx	r3
  401a0a:	2800      	cmp	r0, #0
		return STA_PROTECT;
	}

	/* The memory should already be initialized */
	return 0;
  401a0c:	bf14      	ite	ne
  401a0e:	2004      	movne	r0, #4
  401a10:	2000      	moveq	r0, #0
  401a12:	bd10      	pop	{r4, pc}
		return STA_NOINIT;
  401a14:	2001      	movs	r0, #1
}
  401a16:	bd10      	pop	{r4, pc}
  401a18:	00401379 	.word	0x00401379
  401a1c:	004013a9 	.word	0x004013a9

00401a20 <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
  401a20:	b508      	push	{r3, lr}
	switch (mem_test_unit_ready(drv)) {
  401a22:	4b05      	ldr	r3, [pc, #20]	; (401a38 <disk_status+0x18>)
  401a24:	4798      	blx	r3
  401a26:	b120      	cbz	r0, 401a32 <disk_status+0x12>
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
  401a28:	2802      	cmp	r0, #2
  401a2a:	bf0c      	ite	eq
  401a2c:	2003      	moveq	r0, #3
  401a2e:	2001      	movne	r0, #1
  401a30:	bd08      	pop	{r3, pc}
		return 0;
  401a32:	2000      	movs	r0, #0
	}
}
  401a34:	bd08      	pop	{r3, pc}
  401a36:	bf00      	nop
  401a38:	00401379 	.word	0x00401379

00401a3c <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  401a3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401a40:	b083      	sub	sp, #12
  401a42:	4680      	mov	r8, r0
  401a44:	460d      	mov	r5, r1
  401a46:	4614      	mov	r4, r2
  401a48:	461f      	mov	r7, r3
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  401a4a:	4b15      	ldr	r3, [pc, #84]	; (401aa0 <disk_read+0x64>)
  401a4c:	4798      	blx	r3
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  401a4e:	b918      	cbnz	r0, 401a58 <disk_read+0x1c>
		return RES_ERROR;
  401a50:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  401a52:	b003      	add	sp, #12
  401a54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401a58:	4606      	mov	r6, r0
	mem_read_capacity(drv, &ul_last_sector_num);
  401a5a:	a901      	add	r1, sp, #4
  401a5c:	4640      	mov	r0, r8
  401a5e:	4b11      	ldr	r3, [pc, #68]	; (401aa4 <disk_read+0x68>)
  401a60:	4798      	blx	r3
			(ul_last_sector_num + 1) * uc_sector_size) {
  401a62:	46b1      	mov	r9, r6
	if ((sector + count * uc_sector_size) >
  401a64:	fb06 4207 	mla	r2, r6, r7, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  401a68:	9b01      	ldr	r3, [sp, #4]
  401a6a:	fb03 6306 	mla	r3, r3, r6, r6
	if ((sector + count * uc_sector_size) >
  401a6e:	429a      	cmp	r2, r3
  401a70:	d901      	bls.n	401a76 <disk_read+0x3a>
		return RES_PARERR;
  401a72:	2004      	movs	r0, #4
  401a74:	e7ed      	b.n	401a52 <disk_read+0x16>
	for (i = 0; i < count; i++) {
  401a76:	46ba      	mov	sl, r7
  401a78:	b177      	cbz	r7, 401a98 <disk_read+0x5c>
  401a7a:	0276      	lsls	r6, r6, #9
  401a7c:	2700      	movs	r7, #0
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  401a7e:	f8df b028 	ldr.w	fp, [pc, #40]	; 401aa8 <disk_read+0x6c>
  401a82:	462a      	mov	r2, r5
  401a84:	4621      	mov	r1, r4
  401a86:	4640      	mov	r0, r8
  401a88:	47d8      	blx	fp
  401a8a:	b938      	cbnz	r0, 401a9c <disk_read+0x60>
	for (i = 0; i < count; i++) {
  401a8c:	3701      	adds	r7, #1
  401a8e:	444c      	add	r4, r9
  401a90:	4435      	add	r5, r6
  401a92:	4557      	cmp	r7, sl
  401a94:	d1f5      	bne.n	401a82 <disk_read+0x46>
  401a96:	e7dc      	b.n	401a52 <disk_read+0x16>
	return RES_OK;
  401a98:	2000      	movs	r0, #0
  401a9a:	e7da      	b.n	401a52 <disk_read+0x16>
			return RES_ERROR;
  401a9c:	2001      	movs	r0, #1
  401a9e:	e7d8      	b.n	401a52 <disk_read+0x16>
  401aa0:	004013a1 	.word	0x004013a1
  401aa4:	0040138d 	.word	0x0040138d
  401aa8:	004013bd 	.word	0x004013bd

00401aac <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  401aac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401ab0:	b083      	sub	sp, #12
  401ab2:	4680      	mov	r8, r0
  401ab4:	460d      	mov	r5, r1
  401ab6:	4614      	mov	r4, r2
  401ab8:	461f      	mov	r7, r3
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  401aba:	4b15      	ldr	r3, [pc, #84]	; (401b10 <disk_write+0x64>)
  401abc:	4798      	blx	r3
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  401abe:	b918      	cbnz	r0, 401ac8 <disk_write+0x1c>
		return RES_ERROR;
  401ac0:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  401ac2:	b003      	add	sp, #12
  401ac4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401ac8:	4606      	mov	r6, r0
	mem_read_capacity(drv, &ul_last_sector_num);
  401aca:	a901      	add	r1, sp, #4
  401acc:	4640      	mov	r0, r8
  401ace:	4b11      	ldr	r3, [pc, #68]	; (401b14 <disk_write+0x68>)
  401ad0:	4798      	blx	r3
			(ul_last_sector_num + 1) * uc_sector_size) {
  401ad2:	46b1      	mov	r9, r6
	if ((sector + count * uc_sector_size) >
  401ad4:	fb06 4207 	mla	r2, r6, r7, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  401ad8:	9b01      	ldr	r3, [sp, #4]
  401ada:	fb03 6306 	mla	r3, r3, r6, r6
	if ((sector + count * uc_sector_size) >
  401ade:	429a      	cmp	r2, r3
  401ae0:	d901      	bls.n	401ae6 <disk_write+0x3a>
		return RES_PARERR;
  401ae2:	2004      	movs	r0, #4
  401ae4:	e7ed      	b.n	401ac2 <disk_write+0x16>
	for (i = 0; i < count; i++) {
  401ae6:	46ba      	mov	sl, r7
  401ae8:	b177      	cbz	r7, 401b08 <disk_write+0x5c>
  401aea:	0276      	lsls	r6, r6, #9
  401aec:	2700      	movs	r7, #0
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  401aee:	f8df b028 	ldr.w	fp, [pc, #40]	; 401b18 <disk_write+0x6c>
  401af2:	462a      	mov	r2, r5
  401af4:	4621      	mov	r1, r4
  401af6:	4640      	mov	r0, r8
  401af8:	47d8      	blx	fp
  401afa:	b938      	cbnz	r0, 401b0c <disk_write+0x60>
	for (i = 0; i < count; i++) {
  401afc:	3701      	adds	r7, #1
  401afe:	444c      	add	r4, r9
  401b00:	4435      	add	r5, r6
  401b02:	4557      	cmp	r7, sl
  401b04:	d1f5      	bne.n	401af2 <disk_write+0x46>
  401b06:	e7dc      	b.n	401ac2 <disk_write+0x16>
	return RES_OK;
  401b08:	2000      	movs	r0, #0
  401b0a:	e7da      	b.n	401ac2 <disk_write+0x16>
			return RES_ERROR;
  401b0c:	2001      	movs	r0, #1
  401b0e:	e7d8      	b.n	401ac2 <disk_write+0x16>
  401b10:	004013a1 	.word	0x004013a1
  401b14:	0040138d 	.word	0x0040138d
  401b18:	004013d5 	.word	0x004013d5

00401b1c <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
  401b1c:	b510      	push	{r4, lr}
  401b1e:	b082      	sub	sp, #8
  401b20:	4614      	mov	r4, r2
	DRESULT res = RES_PARERR;

	switch (ctrl) {
  401b22:	2903      	cmp	r1, #3
  401b24:	d827      	bhi.n	401b76 <disk_ioctl+0x5a>
  401b26:	e8df f001 	tbb	[pc, r1]
  401b2a:	071f      	.short	0x071f
  401b2c:	020f      	.short	0x020f
	case GET_BLOCK_SIZE:
		*(DWORD *)buff = 1;
  401b2e:	2301      	movs	r3, #1
  401b30:	6013      	str	r3, [r2, #0]
		res = RES_OK;
  401b32:	2000      	movs	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  401b34:	b002      	add	sp, #8
  401b36:	bd10      	pop	{r4, pc}
		mem_read_capacity(drv, &ul_last_sector_num);
  401b38:	a901      	add	r1, sp, #4
  401b3a:	4b11      	ldr	r3, [pc, #68]	; (401b80 <disk_ioctl+0x64>)
  401b3c:	4798      	blx	r3
		*(DWORD *)buff = ul_last_sector_num + 1;
  401b3e:	9b01      	ldr	r3, [sp, #4]
  401b40:	3301      	adds	r3, #1
  401b42:	6023      	str	r3, [r4, #0]
		res = RES_OK;
  401b44:	2000      	movs	r0, #0
	break;
  401b46:	e7f5      	b.n	401b34 <disk_ioctl+0x18>
		uint8_t uc_sector_size = mem_sector_size(drv);
  401b48:	4b0e      	ldr	r3, [pc, #56]	; (401b84 <disk_ioctl+0x68>)
  401b4a:	4798      	blx	r3
		if ((uc_sector_size != SECTOR_SIZE_512) &&
  401b4c:	2808      	cmp	r0, #8
  401b4e:	d814      	bhi.n	401b7a <disk_ioctl+0x5e>
  401b50:	f44f 738b 	mov.w	r3, #278	; 0x116
  401b54:	fa23 f000 	lsr.w	r0, r3, r0
  401b58:	f010 0f01 	tst.w	r0, #1
  401b5c:	d101      	bne.n	401b62 <disk_ioctl+0x46>
			return RES_ERROR;
  401b5e:	2001      	movs	r0, #1
  401b60:	e7e8      	b.n	401b34 <disk_ioctl+0x18>
		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
  401b62:	2000      	movs	r0, #0
  401b64:	7020      	strb	r0, [r4, #0]
	break;
  401b66:	e7e5      	b.n	401b34 <disk_ioctl+0x18>
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
  401b68:	4b07      	ldr	r3, [pc, #28]	; (401b88 <disk_ioctl+0x6c>)
  401b6a:	4798      	blx	r3
  401b6c:	2800      	cmp	r0, #0
			res = RES_NOTRDY;
  401b6e:	bf0c      	ite	eq
  401b70:	2000      	moveq	r0, #0
  401b72:	2003      	movne	r0, #3
  401b74:	e7de      	b.n	401b34 <disk_ioctl+0x18>
		res = RES_PARERR;
  401b76:	2004      	movs	r0, #4
  401b78:	e7dc      	b.n	401b34 <disk_ioctl+0x18>
			return RES_ERROR;
  401b7a:	2001      	movs	r0, #1
  401b7c:	e7da      	b.n	401b34 <disk_ioctl+0x18>
  401b7e:	bf00      	nop
  401b80:	0040138d 	.word	0x0040138d
  401b84:	004013a1 	.word	0x004013a1
  401b88:	00401379 	.word	0x00401379

00401b8c <get_fattime>:
 * bit4:0    Second (0..29)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  401b8c:	b530      	push	{r4, r5, lr}
  401b8e:	b08b      	sub	sp, #44	; 0x2c
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  401b90:	4c11      	ldr	r4, [pc, #68]	; (401bd8 <get_fattime+0x4c>)
  401b92:	ab07      	add	r3, sp, #28
  401b94:	aa08      	add	r2, sp, #32
  401b96:	a909      	add	r1, sp, #36	; 0x24
  401b98:	4620      	mov	r0, r4
  401b9a:	4d10      	ldr	r5, [pc, #64]	; (401bdc <get_fattime+0x50>)
  401b9c:	47a8      	blx	r5
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);
  401b9e:	ab03      	add	r3, sp, #12
  401ba0:	9300      	str	r3, [sp, #0]
  401ba2:	ab04      	add	r3, sp, #16
  401ba4:	aa05      	add	r2, sp, #20
  401ba6:	a906      	add	r1, sp, #24
  401ba8:	4620      	mov	r0, r4
  401baa:	4c0d      	ldr	r4, [pc, #52]	; (401be0 <get_fattime+0x54>)
  401bac:	47a0      	blx	r4

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
			| (ul_day << 16)
  401bae:	9b04      	ldr	r3, [sp, #16]
  401bb0:	041b      	lsls	r3, r3, #16
	ul_time = ((ul_year - 1980) << 25)
  401bb2:	9805      	ldr	r0, [sp, #20]
  401bb4:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
  401bb8:	9809      	ldr	r0, [sp, #36]	; 0x24
  401bba:	ea43 23c0 	orr.w	r3, r3, r0, lsl #11
  401bbe:	9808      	ldr	r0, [sp, #32]
  401bc0:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
  401bc4:	9807      	ldr	r0, [sp, #28]
  401bc6:	ea43 0350 	orr.w	r3, r3, r0, lsr #1
  401bca:	9806      	ldr	r0, [sp, #24]
  401bcc:	f2a0 70bc 	subw	r0, r0, #1980	; 0x7bc
			| (ul_hour << 11)
			| (ul_minute << 5)
			| ((ul_second >> 1) << 0);

	return ul_time;
}
  401bd0:	ea43 6040 	orr.w	r0, r3, r0, lsl #25
  401bd4:	b00b      	add	sp, #44	; 0x2c
  401bd6:	bd30      	pop	{r4, r5, pc}
  401bd8:	400e1860 	.word	0x400e1860
  401bdc:	00401915 	.word	0x00401915
  401be0:	0040196f 	.word	0x0040196f

00401be4 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  401be4:	b13a      	cbz	r2, 401bf6 <mem_cpy+0x12>
  401be6:	3801      	subs	r0, #1
  401be8:	188a      	adds	r2, r1, r2
		*d++ = *s++;
  401bea:	f811 3b01 	ldrb.w	r3, [r1], #1
  401bee:	f800 3f01 	strb.w	r3, [r0, #1]!
	while (cnt--)
  401bf2:	4291      	cmp	r1, r2
  401bf4:	d1f9      	bne.n	401bea <mem_cpy+0x6>
  401bf6:	4770      	bx	lr

00401bf8 <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  401bf8:	b122      	cbz	r2, 401c04 <mem_set+0xc>
  401bfa:	1882      	adds	r2, r0, r2
		*d++ = (BYTE)val;
  401bfc:	f800 1b01 	strb.w	r1, [r0], #1
	while (cnt--)
  401c00:	4282      	cmp	r2, r0
  401c02:	d1fb      	bne.n	401bfc <mem_set+0x4>
  401c04:	4770      	bx	lr

00401c06 <clust2sect>:
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  401c06:	3902      	subs	r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  401c08:	6983      	ldr	r3, [r0, #24]
  401c0a:	3b02      	subs	r3, #2
  401c0c:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
  401c0e:	bf3d      	ittte	cc
  401c10:	7883      	ldrbcc	r3, [r0, #2]
  401c12:	6a80      	ldrcc	r0, [r0, #40]	; 0x28
  401c14:	fb01 0003 	mlacc	r0, r1, r3, r0
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  401c18:	2000      	movcs	r0, #0
}
  401c1a:	4770      	bx	lr

00401c1c <sum_sfn>:
#if _USE_LFN
static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
  401c1c:	4602      	mov	r2, r0
  401c1e:	f100 010b 	add.w	r1, r0, #11
	BYTE sum = 0;
  401c22:	2000      	movs	r0, #0
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  401c24:	01c3      	lsls	r3, r0, #7
  401c26:	ea43 0350 	orr.w	r3, r3, r0, lsr #1
  401c2a:	f812 0b01 	ldrb.w	r0, [r2], #1
  401c2e:	fa50 f383 	uxtab	r3, r0, r3
  401c32:	b2d8      	uxtb	r0, r3
  401c34:	428a      	cmp	r2, r1
  401c36:	d1f5      	bne.n	401c24 <sum_sfn+0x8>
	return sum;
}
  401c38:	4770      	bx	lr
	...

00401c3c <validate>:
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
  401c3c:	b198      	cbz	r0, 401c66 <validate+0x2a>
{
  401c3e:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
  401c40:	7802      	ldrb	r2, [r0, #0]
  401c42:	b90a      	cbnz	r2, 401c48 <validate+0xc>
		return FR_INVALID_OBJECT;
  401c44:	2009      	movs	r0, #9
  401c46:	bd08      	pop	{r3, pc}
	if (!fs || !fs->fs_type || fs->id != id)
  401c48:	88c2      	ldrh	r2, [r0, #6]
  401c4a:	428a      	cmp	r2, r1
  401c4c:	d001      	beq.n	401c52 <validate+0x16>
		return FR_INVALID_OBJECT;
  401c4e:	2009      	movs	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
  401c50:	bd08      	pop	{r3, pc}
	if (disk_status(fs->drv) & STA_NOINIT)
  401c52:	7840      	ldrb	r0, [r0, #1]
  401c54:	4b05      	ldr	r3, [pc, #20]	; (401c6c <validate+0x30>)
  401c56:	4798      	blx	r3
  401c58:	f000 0001 	and.w	r0, r0, #1
	return FR_OK;
  401c5c:	2800      	cmp	r0, #0
  401c5e:	bf14      	ite	ne
  401c60:	2003      	movne	r0, #3
  401c62:	2000      	moveq	r0, #0
  401c64:	bd08      	pop	{r3, pc}
		return FR_INVALID_OBJECT;
  401c66:	2009      	movs	r0, #9
  401c68:	4770      	bx	lr
  401c6a:	bf00      	nop
  401c6c:	00401a21 	.word	0x00401a21

00401c70 <check_fs>:
{
  401c70:	b538      	push	{r3, r4, r5, lr}
  401c72:	4604      	mov	r4, r0
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  401c74:	2301      	movs	r3, #1
  401c76:	460a      	mov	r2, r1
  401c78:	f100 0130 	add.w	r1, r0, #48	; 0x30
  401c7c:	7840      	ldrb	r0, [r0, #1]
  401c7e:	4d1d      	ldr	r5, [pc, #116]	; (401cf4 <check_fs+0x84>)
  401c80:	47a8      	blx	r5
  401c82:	b108      	cbz	r0, 401c88 <check_fs+0x18>
		return 3;
  401c84:	2003      	movs	r0, #3
  401c86:	bd38      	pop	{r3, r4, r5, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  401c88:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
  401c8c:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
  401c90:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  401c94:	b21b      	sxth	r3, r3
  401c96:	4a18      	ldr	r2, [pc, #96]	; (401cf8 <check_fs+0x88>)
  401c98:	4293      	cmp	r3, r2
  401c9a:	d001      	beq.n	401ca0 <check_fs+0x30>
		return 2;
  401c9c:	2002      	movs	r0, #2
  401c9e:	bd38      	pop	{r3, r4, r5, pc}
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  401ca0:	f894 2069 	ldrb.w	r2, [r4, #105]	; 0x69
  401ca4:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
  401ca8:	041b      	lsls	r3, r3, #16
  401caa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  401cae:	f894 2066 	ldrb.w	r2, [r4, #102]	; 0x66
  401cb2:	4313      	orrs	r3, r2
  401cb4:	f894 2067 	ldrb.w	r2, [r4, #103]	; 0x67
  401cb8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  401cbc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  401cc0:	4a0e      	ldr	r2, [pc, #56]	; (401cfc <check_fs+0x8c>)
  401cc2:	4293      	cmp	r3, r2
  401cc4:	d013      	beq.n	401cee <check_fs+0x7e>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  401cc6:	f894 3085 	ldrb.w	r3, [r4, #133]	; 0x85
  401cca:	f894 0084 	ldrb.w	r0, [r4, #132]	; 0x84
  401cce:	0400      	lsls	r0, r0, #16
  401cd0:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
  401cd4:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
  401cd8:	4318      	orrs	r0, r3
  401cda:	f894 3083 	ldrb.w	r3, [r4, #131]	; 0x83
  401cde:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  401ce2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 3;
  401ce6:	1a80      	subs	r0, r0, r2
  401ce8:	bf18      	it	ne
  401cea:	2001      	movne	r0, #1
  401cec:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
  401cee:	2000      	movs	r0, #0
}
  401cf0:	bd38      	pop	{r3, r4, r5, pc}
  401cf2:	bf00      	nop
  401cf4:	00401a3d 	.word	0x00401a3d
  401cf8:	ffffaa55 	.word	0xffffaa55
  401cfc:	00544146 	.word	0x00544146

00401d00 <chk_mounted>:
{
  401d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const TCHAR *p = *path;
  401d02:	6803      	ldr	r3, [r0, #0]
	vol = p[0] - '0';					/* Is there a drive number? */
  401d04:	781c      	ldrb	r4, [r3, #0]
  401d06:	3c30      	subs	r4, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  401d08:	2c09      	cmp	r4, #9
  401d0a:	d80a      	bhi.n	401d22 <chk_mounted+0x22>
  401d0c:	785d      	ldrb	r5, [r3, #1]
  401d0e:	2d3a      	cmp	r5, #58	; 0x3a
  401d10:	d001      	beq.n	401d16 <chk_mounted+0x16>
  401d12:	2400      	movs	r4, #0
  401d14:	e006      	b.n	401d24 <chk_mounted+0x24>
		p += 2; *path = p;				/* Return pointer to the path name */
  401d16:	3302      	adds	r3, #2
  401d18:	6003      	str	r3, [r0, #0]
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  401d1a:	2c07      	cmp	r4, #7
  401d1c:	d902      	bls.n	401d24 <chk_mounted+0x24>
		return FR_INVALID_DRIVE;
  401d1e:	200b      	movs	r0, #11
  401d20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401d22:	2400      	movs	r4, #0
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  401d24:	4bad      	ldr	r3, [pc, #692]	; (401fdc <chk_mounted+0x2dc>)
  401d26:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
  401d2a:	600d      	str	r5, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  401d2c:	2d00      	cmp	r5, #0
  401d2e:	f000 813d 	beq.w	401fac <chk_mounted+0x2ac>
  401d32:	4616      	mov	r6, r2
	if (fs->fs_type) {					/* If the logical drive has been mounted */
  401d34:	782b      	ldrb	r3, [r5, #0]
  401d36:	b17b      	cbz	r3, 401d58 <chk_mounted+0x58>
		stat = disk_status(fs->drv);
  401d38:	7868      	ldrb	r0, [r5, #1]
  401d3a:	4ba9      	ldr	r3, [pc, #676]	; (401fe0 <chk_mounted+0x2e0>)
  401d3c:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  401d3e:	f010 0f01 	tst.w	r0, #1
  401d42:	d109      	bne.n	401d58 <chk_mounted+0x58>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
  401d44:	2e00      	cmp	r6, #0
  401d46:	f000 8133 	beq.w	401fb0 <chk_mounted+0x2b0>
  401d4a:	f000 0004 	and.w	r0, r0, #4
				return FR_WRITE_PROTECTED;
  401d4e:	2800      	cmp	r0, #0
  401d50:	bf0c      	ite	eq
  401d52:	2000      	moveq	r0, #0
  401d54:	200a      	movne	r0, #10
  401d56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fs->fs_type = 0;					/* Clear the file system object */
  401d58:	2300      	movs	r3, #0
  401d5a:	702b      	strb	r3, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  401d5c:	b2e0      	uxtb	r0, r4
  401d5e:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  401d60:	4ba0      	ldr	r3, [pc, #640]	; (401fe4 <chk_mounted+0x2e4>)
  401d62:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  401d64:	f010 0f01 	tst.w	r0, #1
  401d68:	d001      	beq.n	401d6e <chk_mounted+0x6e>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  401d6a:	2003      	movs	r0, #3
  401d6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
  401d6e:	b126      	cbz	r6, 401d7a <chk_mounted+0x7a>
  401d70:	f010 0f04 	tst.w	r0, #4
  401d74:	d001      	beq.n	401d7a <chk_mounted+0x7a>
		return FR_WRITE_PROTECTED;
  401d76:	200a      	movs	r0, #10
  401d78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  401d7a:	2100      	movs	r1, #0
  401d7c:	4628      	mov	r0, r5
  401d7e:	4b9a      	ldr	r3, [pc, #616]	; (401fe8 <chk_mounted+0x2e8>)
  401d80:	4798      	blx	r3
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  401d82:	2801      	cmp	r0, #1
  401d84:	d006      	beq.n	401d94 <chk_mounted+0x94>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  401d86:	2400      	movs	r4, #0
	if (fmt == 3) return FR_DISK_ERR;
  401d88:	2803      	cmp	r0, #3
  401d8a:	f000 8113 	beq.w	401fb4 <chk_mounted+0x2b4>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  401d8e:	b1c8      	cbz	r0, 401dc4 <chk_mounted+0xc4>
  401d90:	200d      	movs	r0, #13
  401d92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (tbl[4]) {						/* Is the partition existing? */
  401d94:	f895 31f2 	ldrb.w	r3, [r5, #498]	; 0x1f2
  401d98:	b90b      	cbnz	r3, 401d9e <chk_mounted+0x9e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  401d9a:	200d      	movs	r0, #13
  401d9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  401d9e:	f895 31f9 	ldrb.w	r3, [r5, #505]	; 0x1f9
  401da2:	f895 41f8 	ldrb.w	r4, [r5, #504]	; 0x1f8
  401da6:	0424      	lsls	r4, r4, #16
  401da8:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
  401dac:	f895 31f6 	ldrb.w	r3, [r5, #502]	; 0x1f6
  401db0:	431c      	orrs	r4, r3
  401db2:	f895 31f7 	ldrb.w	r3, [r5, #503]	; 0x1f7
  401db6:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
  401dba:	4621      	mov	r1, r4
  401dbc:	4628      	mov	r0, r5
  401dbe:	4b8a      	ldr	r3, [pc, #552]	; (401fe8 <chk_mounted+0x2e8>)
  401dc0:	4798      	blx	r3
  401dc2:	e7e1      	b.n	401d88 <chk_mounted+0x88>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  401dc4:	f895 203c 	ldrb.w	r2, [r5, #60]	; 0x3c
  401dc8:	f895 303b 	ldrb.w	r3, [r5, #59]	; 0x3b
  401dcc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  401dd0:	b21b      	sxth	r3, r3
  401dd2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  401dd6:	d001      	beq.n	401ddc <chk_mounted+0xdc>
		return FR_NO_FILESYSTEM;
  401dd8:	200d      	movs	r0, #13
  401dda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  401ddc:	f895 3047 	ldrb.w	r3, [r5, #71]	; 0x47
  401de0:	f895 2046 	ldrb.w	r2, [r5, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  401de4:	ea52 2203 	orrs.w	r2, r2, r3, lsl #8
  401de8:	d10d      	bne.n	401e06 <chk_mounted+0x106>
  401dea:	f895 3057 	ldrb.w	r3, [r5, #87]	; 0x57
  401dee:	f895 2056 	ldrb.w	r2, [r5, #86]	; 0x56
  401df2:	0412      	lsls	r2, r2, #16
  401df4:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
  401df8:	f895 3054 	ldrb.w	r3, [r5, #84]	; 0x54
  401dfc:	431a      	orrs	r2, r3
  401dfe:	f895 3055 	ldrb.w	r3, [r5, #85]	; 0x55
  401e02:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	fs->fsize = fasize;
  401e06:	61ea      	str	r2, [r5, #28]
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  401e08:	f895 e040 	ldrb.w	lr, [r5, #64]	; 0x40
  401e0c:	f885 e003 	strb.w	lr, [r5, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  401e10:	f10e 33ff 	add.w	r3, lr, #4294967295
  401e14:	b2db      	uxtb	r3, r3
  401e16:	2b01      	cmp	r3, #1
  401e18:	d901      	bls.n	401e1e <chk_mounted+0x11e>
  401e1a:	200d      	movs	r0, #13
  401e1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  401e1e:	f895 603d 	ldrb.w	r6, [r5, #61]	; 0x3d
  401e22:	70ae      	strb	r6, [r5, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  401e24:	2e00      	cmp	r6, #0
  401e26:	f000 80c7 	beq.w	401fb8 <chk_mounted+0x2b8>
  401e2a:	1e73      	subs	r3, r6, #1
  401e2c:	4233      	tst	r3, r6
  401e2e:	d001      	beq.n	401e34 <chk_mounted+0x134>
  401e30:	200d      	movs	r0, #13
  401e32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  401e34:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
  401e38:	f895 1041 	ldrb.w	r1, [r5, #65]	; 0x41
  401e3c:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
  401e40:	8129      	strh	r1, [r5, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  401e42:	f011 0f0f 	tst.w	r1, #15
  401e46:	f040 80b9 	bne.w	401fbc <chk_mounted+0x2bc>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  401e4a:	f895 0044 	ldrb.w	r0, [r5, #68]	; 0x44
  401e4e:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  401e52:	ea53 2300 	orrs.w	r3, r3, r0, lsl #8
  401e56:	d10d      	bne.n	401e74 <chk_mounted+0x174>
  401e58:	f895 0053 	ldrb.w	r0, [r5, #83]	; 0x53
  401e5c:	f895 3052 	ldrb.w	r3, [r5, #82]	; 0x52
  401e60:	041b      	lsls	r3, r3, #16
  401e62:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  401e66:	f895 0050 	ldrb.w	r0, [r5, #80]	; 0x50
  401e6a:	4303      	orrs	r3, r0
  401e6c:	f895 0051 	ldrb.w	r0, [r5, #81]	; 0x51
  401e70:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  401e74:	f895 003f 	ldrb.w	r0, [r5, #63]	; 0x3f
  401e78:	f895 703e 	ldrb.w	r7, [r5, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  401e7c:	ea57 2700 	orrs.w	r7, r7, r0, lsl #8
  401e80:	f000 809e 	beq.w	401fc0 <chk_mounted+0x2c0>
	fasize *= b;										/* Number of sectors for FAT area */
  401e84:	fb02 fe0e 	mul.w	lr, r2, lr
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  401e88:	eb07 1011 	add.w	r0, r7, r1, lsr #4
  401e8c:	4470      	add	r0, lr
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  401e8e:	4283      	cmp	r3, r0
  401e90:	f0c0 8098 	bcc.w	401fc4 <chk_mounted+0x2c4>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  401e94:	1a1b      	subs	r3, r3, r0
  401e96:	fbb3 f3f6 	udiv	r3, r3, r6
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  401e9a:	2b00      	cmp	r3, #0
  401e9c:	f000 8094 	beq.w	401fc8 <chk_mounted+0x2c8>
	fmt = FS_FAT12;
  401ea0:	f640 76f5 	movw	r6, #4085	; 0xff5
  401ea4:	42b3      	cmp	r3, r6
  401ea6:	bf8c      	ite	hi
  401ea8:	2602      	movhi	r6, #2
  401eaa:	2601      	movls	r6, #1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  401eac:	f64f 7cf5 	movw	ip, #65525	; 0xfff5
  401eb0:	4563      	cmp	r3, ip
  401eb2:	f200 80a3 	bhi.w	401ffc <chk_mounted+0x2fc>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  401eb6:	3302      	adds	r3, #2
  401eb8:	61ab      	str	r3, [r5, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  401eba:	4420      	add	r0, r4
  401ebc:	62a8      	str	r0, [r5, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  401ebe:	443c      	add	r4, r7
  401ec0:	622c      	str	r4, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  401ec2:	2900      	cmp	r1, #0
  401ec4:	f000 8088 	beq.w	401fd8 <chk_mounted+0x2d8>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  401ec8:	4474      	add	r4, lr
  401eca:	626c      	str	r4, [r5, #36]	; 0x24
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  401ecc:	2e02      	cmp	r6, #2
  401ece:	bf0f      	iteee	eq
  401ed0:	005b      	lsleq	r3, r3, #1
  401ed2:	eb03 0143 	addne.w	r1, r3, r3, lsl #1
  401ed6:	f003 0301 	andne.w	r3, r3, #1
  401eda:	eb03 0351 	addne.w	r3, r3, r1, lsr #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  401ede:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  401ee2:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
  401ee6:	d375      	bcc.n	401fd4 <chk_mounted+0x2d4>
	fs->free_clust = 0xFFFFFFFF;
  401ee8:	f04f 33ff 	mov.w	r3, #4294967295
  401eec:	612b      	str	r3, [r5, #16]
	fs->last_clust = 0;
  401eee:	2300      	movs	r3, #0
  401ef0:	60eb      	str	r3, [r5, #12]
  401ef2:	e04a      	b.n	401f8a <chk_mounted+0x28a>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  401ef4:	f895 222f 	ldrb.w	r2, [r5, #559]	; 0x22f
  401ef8:	f895 322e 	ldrb.w	r3, [r5, #558]	; 0x22e
  401efc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  401f00:	b21b      	sxth	r3, r3
  401f02:	4a3a      	ldr	r2, [pc, #232]	; (401fec <chk_mounted+0x2ec>)
  401f04:	4293      	cmp	r3, r2
  401f06:	d14b      	bne.n	401fa0 <chk_mounted+0x2a0>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  401f08:	f895 2033 	ldrb.w	r2, [r5, #51]	; 0x33
  401f0c:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
  401f10:	041b      	lsls	r3, r3, #16
  401f12:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  401f16:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
  401f1a:	4313      	orrs	r3, r2
  401f1c:	f895 2031 	ldrb.w	r2, [r5, #49]	; 0x31
  401f20:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  401f24:	4a32      	ldr	r2, [pc, #200]	; (401ff0 <chk_mounted+0x2f0>)
  401f26:	4293      	cmp	r3, r2
  401f28:	d13c      	bne.n	401fa4 <chk_mounted+0x2a4>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  401f2a:	f895 2217 	ldrb.w	r2, [r5, #535]	; 0x217
  401f2e:	f895 3216 	ldrb.w	r3, [r5, #534]	; 0x216
  401f32:	041b      	lsls	r3, r3, #16
  401f34:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  401f38:	f895 2214 	ldrb.w	r2, [r5, #532]	; 0x214
  401f3c:	4313      	orrs	r3, r2
  401f3e:	f895 2215 	ldrb.w	r2, [r5, #533]	; 0x215
  401f42:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  401f46:	4a2b      	ldr	r2, [pc, #172]	; (401ff4 <chk_mounted+0x2f4>)
  401f48:	4293      	cmp	r3, r2
  401f4a:	d12d      	bne.n	401fa8 <chk_mounted+0x2a8>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  401f4c:	f895 221f 	ldrb.w	r2, [r5, #543]	; 0x21f
  401f50:	f895 321e 	ldrb.w	r3, [r5, #542]	; 0x21e
  401f54:	041b      	lsls	r3, r3, #16
  401f56:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  401f5a:	f895 221c 	ldrb.w	r2, [r5, #540]	; 0x21c
  401f5e:	4313      	orrs	r3, r2
  401f60:	f895 221d 	ldrb.w	r2, [r5, #541]	; 0x21d
  401f64:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  401f68:	60eb      	str	r3, [r5, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  401f6a:	f895 221b 	ldrb.w	r2, [r5, #539]	; 0x21b
  401f6e:	f895 321a 	ldrb.w	r3, [r5, #538]	; 0x21a
  401f72:	041b      	lsls	r3, r3, #16
  401f74:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  401f78:	f895 2218 	ldrb.w	r2, [r5, #536]	; 0x218
  401f7c:	4313      	orrs	r3, r2
  401f7e:	f895 2219 	ldrb.w	r2, [r5, #537]	; 0x219
  401f82:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  401f86:	612b      	str	r3, [r5, #16]
  401f88:	2603      	movs	r6, #3
	fs->fs_type = fmt;		/* FAT sub-type */
  401f8a:	702e      	strb	r6, [r5, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  401f8c:	4a1a      	ldr	r2, [pc, #104]	; (401ff8 <chk_mounted+0x2f8>)
  401f8e:	8813      	ldrh	r3, [r2, #0]
  401f90:	3301      	adds	r3, #1
  401f92:	b29b      	uxth	r3, r3
  401f94:	8013      	strh	r3, [r2, #0]
  401f96:	80eb      	strh	r3, [r5, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
  401f98:	2000      	movs	r0, #0
  401f9a:	62e8      	str	r0, [r5, #44]	; 0x2c
	fs->wflag = 0;
  401f9c:	7128      	strb	r0, [r5, #4]
	return FR_OK;
  401f9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401fa0:	2603      	movs	r6, #3
  401fa2:	e7f2      	b.n	401f8a <chk_mounted+0x28a>
  401fa4:	2603      	movs	r6, #3
  401fa6:	e7f0      	b.n	401f8a <chk_mounted+0x28a>
  401fa8:	2603      	movs	r6, #3
  401faa:	e7ee      	b.n	401f8a <chk_mounted+0x28a>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  401fac:	200c      	movs	r0, #12
  401fae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return FR_OK;				/* The file system object is valid */
  401fb0:	2000      	movs	r0, #0
  401fb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (fmt == 3) return FR_DISK_ERR;
  401fb4:	2001      	movs	r0, #1
  401fb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  401fb8:	200d      	movs	r0, #13
  401fba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  401fbc:	200d      	movs	r0, #13
  401fbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  401fc0:	200d      	movs	r0, #13
  401fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  401fc4:	200d      	movs	r0, #13
  401fc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  401fc8:	200d      	movs	r0, #13
  401fca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return FR_NO_FILESYSTEM;
  401fcc:	200d      	movs	r0, #13
  401fce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  401fd0:	200d      	movs	r0, #13
  401fd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return FR_NO_FILESYSTEM;
  401fd4:	200d      	movs	r0, #13
  401fd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  401fd8:	200d      	movs	r0, #13
  401fda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401fdc:	20007550 	.word	0x20007550
  401fe0:	00401a21 	.word	0x00401a21
  401fe4:	004019e1 	.word	0x004019e1
  401fe8:	00401c71 	.word	0x00401c71
  401fec:	ffffaa55 	.word	0xffffaa55
  401ff0:	41615252 	.word	0x41615252
  401ff4:	61417272 	.word	0x61417272
  401ff8:	20007570 	.word	0x20007570
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  401ffc:	3302      	adds	r3, #2
  401ffe:	61ab      	str	r3, [r5, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  402000:	4420      	add	r0, r4
  402002:	62a8      	str	r0, [r5, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402004:	4427      	add	r7, r4
  402006:	622f      	str	r7, [r5, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  402008:	2900      	cmp	r1, #0
  40200a:	d1e1      	bne.n	401fd0 <chk_mounted+0x2d0>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  40200c:	f895 005f 	ldrb.w	r0, [r5, #95]	; 0x5f
  402010:	f895 105e 	ldrb.w	r1, [r5, #94]	; 0x5e
  402014:	0409      	lsls	r1, r1, #16
  402016:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
  40201a:	f895 005c 	ldrb.w	r0, [r5, #92]	; 0x5c
  40201e:	4301      	orrs	r1, r0
  402020:	f895 005d 	ldrb.w	r0, [r5, #93]	; 0x5d
  402024:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
  402028:	6269      	str	r1, [r5, #36]	; 0x24
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  40202a:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  40202c:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  402030:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
  402034:	d3ca      	bcc.n	401fcc <chk_mounted+0x2cc>
	fs->free_clust = 0xFFFFFFFF;
  402036:	f04f 33ff 	mov.w	r3, #4294967295
  40203a:	612b      	str	r3, [r5, #16]
	fs->last_clust = 0;
  40203c:	2300      	movs	r3, #0
  40203e:	60eb      	str	r3, [r5, #12]
	 	fs->fsi_flag = 0;
  402040:	716b      	strb	r3, [r5, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  402042:	f895 3061 	ldrb.w	r3, [r5, #97]	; 0x61
  402046:	f895 2060 	ldrb.w	r2, [r5, #96]	; 0x60
  40204a:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
  40204e:	4422      	add	r2, r4
  402050:	616a      	str	r2, [r5, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  402052:	2301      	movs	r3, #1
  402054:	f105 0130 	add.w	r1, r5, #48	; 0x30
  402058:	7868      	ldrb	r0, [r5, #1]
  40205a:	4c03      	ldr	r4, [pc, #12]	; (402068 <chk_mounted+0x368>)
  40205c:	47a0      	blx	r4
  40205e:	2800      	cmp	r0, #0
  402060:	f43f af48 	beq.w	401ef4 <chk_mounted+0x1f4>
  402064:	2603      	movs	r6, #3
  402066:	e790      	b.n	401f8a <chk_mounted+0x28a>
  402068:	00401a3d 	.word	0x00401a3d

0040206c <move_window>:
{
  40206c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wsect = fs->winsect;
  402070:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
	if (wsect != sector) {	/* Changed current window */
  402072:	428f      	cmp	r7, r1
  402074:	d035      	beq.n	4020e2 <move_window+0x76>
  402076:	460e      	mov	r6, r1
  402078:	4604      	mov	r4, r0
		if (fs->wflag) {	/* Write back dirty window if needed */
  40207a:	7903      	ldrb	r3, [r0, #4]
  40207c:	b91b      	cbnz	r3, 402086 <move_window+0x1a>
		if (sector) {
  40207e:	bb2e      	cbnz	r6, 4020cc <move_window+0x60>
	return FR_OK;
  402080:	2000      	movs	r0, #0
  402082:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
  402086:	f100 0830 	add.w	r8, r0, #48	; 0x30
  40208a:	2301      	movs	r3, #1
  40208c:	463a      	mov	r2, r7
  40208e:	4641      	mov	r1, r8
  402090:	7840      	ldrb	r0, [r0, #1]
  402092:	4d18      	ldr	r5, [pc, #96]	; (4020f4 <move_window+0x88>)
  402094:	47a8      	blx	r5
  402096:	bb38      	cbnz	r0, 4020e8 <move_window+0x7c>
			fs->wflag = 0;
  402098:	2300      	movs	r3, #0
  40209a:	7123      	strb	r3, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  40209c:	6a23      	ldr	r3, [r4, #32]
  40209e:	69e2      	ldr	r2, [r4, #28]
  4020a0:	4413      	add	r3, r2
  4020a2:	429f      	cmp	r7, r3
  4020a4:	d2eb      	bcs.n	40207e <move_window+0x12>
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4020a6:	78e5      	ldrb	r5, [r4, #3]
  4020a8:	2d01      	cmp	r5, #1
  4020aa:	d9e8      	bls.n	40207e <move_window+0x12>
					disk_write(fs->drv, fs->win, wsect, 1);
  4020ac:	f04f 0a01 	mov.w	sl, #1
  4020b0:	f8df 9040 	ldr.w	r9, [pc, #64]	; 4020f4 <move_window+0x88>
					wsect += fs->fsize;
  4020b4:	69e3      	ldr	r3, [r4, #28]
  4020b6:	441f      	add	r7, r3
					disk_write(fs->drv, fs->win, wsect, 1);
  4020b8:	4653      	mov	r3, sl
  4020ba:	463a      	mov	r2, r7
  4020bc:	4641      	mov	r1, r8
  4020be:	7860      	ldrb	r0, [r4, #1]
  4020c0:	47c8      	blx	r9
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4020c2:	3d01      	subs	r5, #1
  4020c4:	b2ed      	uxtb	r5, r5
  4020c6:	2d01      	cmp	r5, #1
  4020c8:	d1f4      	bne.n	4020b4 <move_window+0x48>
  4020ca:	e7d8      	b.n	40207e <move_window+0x12>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  4020cc:	2301      	movs	r3, #1
  4020ce:	4632      	mov	r2, r6
  4020d0:	f104 0130 	add.w	r1, r4, #48	; 0x30
  4020d4:	7860      	ldrb	r0, [r4, #1]
  4020d6:	4d08      	ldr	r5, [pc, #32]	; (4020f8 <move_window+0x8c>)
  4020d8:	47a8      	blx	r5
  4020da:	b940      	cbnz	r0, 4020ee <move_window+0x82>
			fs->winsect = sector;
  4020dc:	62e6      	str	r6, [r4, #44]	; 0x2c
  4020de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return FR_OK;
  4020e2:	2000      	movs	r0, #0
  4020e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				return FR_DISK_ERR;
  4020e8:	2001      	movs	r0, #1
  4020ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				return FR_DISK_ERR;
  4020ee:	2001      	movs	r0, #1
}
  4020f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4020f4:	00401aad 	.word	0x00401aad
  4020f8:	00401a3d 	.word	0x00401a3d

004020fc <get_fat>:
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  4020fc:	2901      	cmp	r1, #1
  4020fe:	d96a      	bls.n	4021d6 <get_fat+0xda>
{
  402100:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402102:	6983      	ldr	r3, [r0, #24]
  402104:	4299      	cmp	r1, r3
  402106:	d268      	bcs.n	4021da <get_fat+0xde>
  402108:	460c      	mov	r4, r1
  40210a:	4606      	mov	r6, r0
	switch (fs->fs_type) {
  40210c:	7803      	ldrb	r3, [r0, #0]
  40210e:	2b02      	cmp	r3, #2
  402110:	d02f      	beq.n	402172 <get_fat+0x76>
  402112:	2b03      	cmp	r3, #3
  402114:	d041      	beq.n	40219a <get_fat+0x9e>
  402116:	2b01      	cmp	r3, #1
  402118:	d002      	beq.n	402120 <get_fat+0x24>
	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  40211a:	f04f 30ff 	mov.w	r0, #4294967295
  40211e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		bc = (UINT)clst; bc += bc / 2;
  402120:	eb01 0751 	add.w	r7, r1, r1, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402124:	6a01      	ldr	r1, [r0, #32]
  402126:	eb01 2157 	add.w	r1, r1, r7, lsr #9
  40212a:	4b2d      	ldr	r3, [pc, #180]	; (4021e0 <get_fat+0xe4>)
  40212c:	4798      	blx	r3
  40212e:	b110      	cbz	r0, 402136 <get_fat+0x3a>
	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  402130:	f04f 30ff 	mov.w	r0, #4294967295
  402134:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		wc = fs->win[bc % SS(fs)]; bc++;
  402136:	f3c7 0308 	ubfx	r3, r7, #0, #9
  40213a:	4433      	add	r3, r6
  40213c:	f893 5030 	ldrb.w	r5, [r3, #48]	; 0x30
  402140:	3701      	adds	r7, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402142:	6a31      	ldr	r1, [r6, #32]
  402144:	eb01 2157 	add.w	r1, r1, r7, lsr #9
  402148:	4630      	mov	r0, r6
  40214a:	4b25      	ldr	r3, [pc, #148]	; (4021e0 <get_fat+0xe4>)
  40214c:	4798      	blx	r3
  40214e:	b110      	cbz	r0, 402156 <get_fat+0x5a>
	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  402150:	f04f 30ff 	mov.w	r0, #4294967295
  402154:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		wc |= fs->win[bc % SS(fs)] << 8;
  402156:	f3c7 0708 	ubfx	r7, r7, #0, #9
  40215a:	19f0      	adds	r0, r6, r7
  40215c:	f890 0030 	ldrb.w	r0, [r0, #48]	; 0x30
  402160:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  402164:	f014 0f01 	tst.w	r4, #1
  402168:	bf14      	ite	ne
  40216a:	0900      	lsrne	r0, r0, #4
  40216c:	f3c0 000b 	ubfxeq	r0, r0, #0, #12
  402170:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  402172:	6a01      	ldr	r1, [r0, #32]
  402174:	eb01 2114 	add.w	r1, r1, r4, lsr #8
  402178:	4b19      	ldr	r3, [pc, #100]	; (4021e0 <get_fat+0xe4>)
  40217a:	4798      	blx	r3
  40217c:	b110      	cbz	r0, 402184 <get_fat+0x88>
	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  40217e:	f04f 30ff 	mov.w	r0, #4294967295
  402182:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		p = &fs->win[clst * 2 % SS(fs)];
  402184:	0060      	lsls	r0, r4, #1
  402186:	f400 70ff 	and.w	r0, r0, #510	; 0x1fe
		return LD_WORD(p);
  40218a:	4430      	add	r0, r6
  40218c:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
  402190:	f890 0030 	ldrb.w	r0, [r0, #48]	; 0x30
  402194:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  402198:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  40219a:	6a01      	ldr	r1, [r0, #32]
  40219c:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
  4021a0:	4b0f      	ldr	r3, [pc, #60]	; (4021e0 <get_fat+0xe4>)
  4021a2:	4798      	blx	r3
  4021a4:	b110      	cbz	r0, 4021ac <get_fat+0xb0>
	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  4021a6:	f04f 30ff 	mov.w	r0, #4294967295
}
  4021aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		p = &fs->win[clst * 4 % SS(fs)];
  4021ac:	00a0      	lsls	r0, r4, #2
  4021ae:	f400 70fe 	and.w	r0, r0, #508	; 0x1fc
  4021b2:	f100 0230 	add.w	r2, r0, #48	; 0x30
  4021b6:	4432      	add	r2, r6
		return LD_DWORD(p) & 0x0FFFFFFF;
  4021b8:	78d1      	ldrb	r1, [r2, #3]
  4021ba:	7893      	ldrb	r3, [r2, #2]
  4021bc:	041b      	lsls	r3, r3, #16
  4021be:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
  4021c2:	4430      	add	r0, r6
  4021c4:	f890 0030 	ldrb.w	r0, [r0, #48]	; 0x30
  4021c8:	4318      	orrs	r0, r3
  4021ca:	7853      	ldrb	r3, [r2, #1]
  4021cc:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  4021d0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
  4021d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 1;
  4021d6:	2001      	movs	r0, #1
  4021d8:	4770      	bx	lr
  4021da:	2001      	movs	r0, #1
  4021dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4021de:	bf00      	nop
  4021e0:	0040206d 	.word	0x0040206d

004021e4 <dir_sdi>:
{
  4021e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4021e6:	4605      	mov	r5, r0
  4021e8:	460c      	mov	r4, r1
	dj->index = idx;
  4021ea:	80c1      	strh	r1, [r0, #6]
	clst = dj->sclust;
  4021ec:	6881      	ldr	r1, [r0, #8]
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  4021ee:	2901      	cmp	r1, #1
  4021f0:	d03d      	beq.n	40226e <dir_sdi+0x8a>
  4021f2:	6803      	ldr	r3, [r0, #0]
  4021f4:	699a      	ldr	r2, [r3, #24]
  4021f6:	4291      	cmp	r1, r2
  4021f8:	d301      	bcc.n	4021fe <dir_sdi+0x1a>
		return FR_INT_ERR;
  4021fa:	2002      	movs	r0, #2
  4021fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  4021fe:	b961      	cbnz	r1, 40221a <dir_sdi+0x36>
  402200:	781a      	ldrb	r2, [r3, #0]
  402202:	2a03      	cmp	r2, #3
  402204:	d006      	beq.n	402214 <dir_sdi+0x30>
		dj->clust = clst;
  402206:	2200      	movs	r2, #0
  402208:	60ea      	str	r2, [r5, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  40220a:	891a      	ldrh	r2, [r3, #8]
  40220c:	42a2      	cmp	r2, r4
  40220e:	d821      	bhi.n	402254 <dir_sdi+0x70>
			return FR_INT_ERR;
  402210:	2002      	movs	r0, #2
  402212:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		clst = dj->fs->dirbase;
  402214:	6a59      	ldr	r1, [r3, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  402216:	2900      	cmp	r1, #0
  402218:	d0f5      	beq.n	402206 <dir_sdi+0x22>
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  40221a:	789e      	ldrb	r6, [r3, #2]
  40221c:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
  40221e:	42b4      	cmp	r4, r6
  402220:	d310      	bcc.n	402244 <dir_sdi+0x60>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
  402222:	4f17      	ldr	r7, [pc, #92]	; (402280 <dir_sdi+0x9c>)
  402224:	6828      	ldr	r0, [r5, #0]
  402226:	47b8      	blx	r7
  402228:	4601      	mov	r1, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  40222a:	f1b0 3fff 	cmp.w	r0, #4294967295
  40222e:	d020      	beq.n	402272 <dir_sdi+0x8e>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  402230:	2801      	cmp	r0, #1
  402232:	d920      	bls.n	402276 <dir_sdi+0x92>
  402234:	682b      	ldr	r3, [r5, #0]
  402236:	699b      	ldr	r3, [r3, #24]
  402238:	4298      	cmp	r0, r3
  40223a:	d21e      	bcs.n	40227a <dir_sdi+0x96>
			idx -= ic;
  40223c:	1ba4      	subs	r4, r4, r6
  40223e:	b2a4      	uxth	r4, r4
		while (idx >= ic) {	/* Follow cluster chain */
  402240:	42a6      	cmp	r6, r4
  402242:	d9ef      	bls.n	402224 <dir_sdi+0x40>
		dj->clust = clst;
  402244:	60e9      	str	r1, [r5, #12]
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402246:	6828      	ldr	r0, [r5, #0]
  402248:	4b0e      	ldr	r3, [pc, #56]	; (402284 <dir_sdi+0xa0>)
  40224a:	4798      	blx	r3
  40224c:	eb00 1014 	add.w	r0, r0, r4, lsr #4
  402250:	6128      	str	r0, [r5, #16]
  402252:	e003      	b.n	40225c <dir_sdi+0x78>
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402254:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  402256:	eb03 1314 	add.w	r3, r3, r4, lsr #4
  40225a:	612b      	str	r3, [r5, #16]
	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  40225c:	682b      	ldr	r3, [r5, #0]
  40225e:	3330      	adds	r3, #48	; 0x30
  402260:	f004 040f 	and.w	r4, r4, #15
  402264:	eb03 1444 	add.w	r4, r3, r4, lsl #5
  402268:	616c      	str	r4, [r5, #20]
	return FR_OK;	/* Seek succeeded */
  40226a:	2000      	movs	r0, #0
  40226c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return FR_INT_ERR;
  40226e:	2002      	movs	r0, #2
  402270:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  402272:	2001      	movs	r0, #1
  402274:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return FR_INT_ERR;
  402276:	2002      	movs	r0, #2
  402278:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40227a:	2002      	movs	r0, #2
}
  40227c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40227e:	bf00      	nop
  402280:	004020fd 	.word	0x004020fd
  402284:	00401c07 	.word	0x00401c07

00402288 <put_fat>:
{
  402288:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  40228c:	2901      	cmp	r1, #1
  40228e:	f240 808f 	bls.w	4023b0 <put_fat+0x128>
  402292:	6983      	ldr	r3, [r0, #24]
  402294:	4299      	cmp	r1, r3
  402296:	d301      	bcc.n	40229c <put_fat+0x14>
		res = FR_INT_ERR;
  402298:	2702      	movs	r7, #2
	return res;
  40229a:	e08a      	b.n	4023b2 <put_fat+0x12a>
  40229c:	4615      	mov	r5, r2
  40229e:	460c      	mov	r4, r1
  4022a0:	4606      	mov	r6, r0
		switch (fs->fs_type) {
  4022a2:	7803      	ldrb	r3, [r0, #0]
  4022a4:	2b02      	cmp	r3, #2
  4022a6:	d04e      	beq.n	402346 <put_fat+0xbe>
  4022a8:	2b03      	cmp	r3, #3
  4022aa:	d05f      	beq.n	40236c <put_fat+0xe4>
  4022ac:	2b01      	cmp	r3, #1
  4022ae:	d003      	beq.n	4022b8 <put_fat+0x30>
			res = FR_INT_ERR;
  4022b0:	2702      	movs	r7, #2
		fs->wflag = 1;
  4022b2:	2301      	movs	r3, #1
  4022b4:	7133      	strb	r3, [r6, #4]
  4022b6:	e07c      	b.n	4023b2 <put_fat+0x12a>
			bc = clst; bc += bc / 2;
  4022b8:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  4022bc:	6a01      	ldr	r1, [r0, #32]
  4022be:	eb01 2158 	add.w	r1, r1, r8, lsr #9
  4022c2:	4b3d      	ldr	r3, [pc, #244]	; (4023b8 <put_fat+0x130>)
  4022c4:	4798      	blx	r3
			if (res != FR_OK) break;
  4022c6:	4607      	mov	r7, r0
  4022c8:	2800      	cmp	r0, #0
  4022ca:	d1f2      	bne.n	4022b2 <put_fat+0x2a>
			p = &fs->win[bc % SS(fs)];
  4022cc:	f3c8 0308 	ubfx	r3, r8, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  4022d0:	f014 0f01 	tst.w	r4, #1
  4022d4:	d01c      	beq.n	402310 <put_fat+0x88>
  4022d6:	4433      	add	r3, r6
  4022d8:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
  4022dc:	f002 020f 	and.w	r2, r2, #15
  4022e0:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  4022e4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
  4022e8:	f108 0801 	add.w	r8, r8, #1
			fs->wflag = 1;
  4022ec:	2301      	movs	r3, #1
  4022ee:	7133      	strb	r3, [r6, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  4022f0:	6a31      	ldr	r1, [r6, #32]
  4022f2:	eb01 2158 	add.w	r1, r1, r8, lsr #9
  4022f6:	4630      	mov	r0, r6
  4022f8:	4b2f      	ldr	r3, [pc, #188]	; (4023b8 <put_fat+0x130>)
  4022fa:	4798      	blx	r3
			if (res != FR_OK) break;
  4022fc:	2800      	cmp	r0, #0
  4022fe:	d153      	bne.n	4023a8 <put_fat+0x120>
			p = &fs->win[bc % SS(fs)];
  402300:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402304:	f3c5 1207 	ubfx	r2, r5, #4, #8
  402308:	44b0      	add	r8, r6
  40230a:	f888 2030 	strb.w	r2, [r8, #48]	; 0x30
			break;
  40230e:	e7d0      	b.n	4022b2 <put_fat+0x2a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  402310:	4433      	add	r3, r6
  402312:	f883 5030 	strb.w	r5, [r3, #48]	; 0x30
			bc++;
  402316:	f108 0801 	add.w	r8, r8, #1
			fs->wflag = 1;
  40231a:	2301      	movs	r3, #1
  40231c:	7133      	strb	r3, [r6, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  40231e:	6a31      	ldr	r1, [r6, #32]
  402320:	eb01 2158 	add.w	r1, r1, r8, lsr #9
  402324:	4630      	mov	r0, r6
  402326:	4b24      	ldr	r3, [pc, #144]	; (4023b8 <put_fat+0x130>)
  402328:	4798      	blx	r3
			if (res != FR_OK) break;
  40232a:	2800      	cmp	r0, #0
  40232c:	d13e      	bne.n	4023ac <put_fat+0x124>
			p = &fs->win[bc % SS(fs)];
  40232e:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402332:	eb06 0308 	add.w	r3, r6, r8
  402336:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
  40233a:	f023 030f 	bic.w	r3, r3, #15
  40233e:	f3c5 2203 	ubfx	r2, r5, #8, #4
  402342:	431a      	orrs	r2, r3
  402344:	e7e0      	b.n	402308 <put_fat+0x80>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  402346:	6a01      	ldr	r1, [r0, #32]
  402348:	eb01 2114 	add.w	r1, r1, r4, lsr #8
  40234c:	4b1a      	ldr	r3, [pc, #104]	; (4023b8 <put_fat+0x130>)
  40234e:	4798      	blx	r3
			if (res != FR_OK) break;
  402350:	4607      	mov	r7, r0
  402352:	2800      	cmp	r0, #0
  402354:	d1ad      	bne.n	4022b2 <put_fat+0x2a>
			p = &fs->win[clst * 2 % SS(fs)];
  402356:	0063      	lsls	r3, r4, #1
  402358:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
  40235c:	4433      	add	r3, r6
  40235e:	f883 5030 	strb.w	r5, [r3, #48]	; 0x30
  402362:	f3c5 2207 	ubfx	r2, r5, #8, #8
  402366:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
			break;
  40236a:	e7a2      	b.n	4022b2 <put_fat+0x2a>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  40236c:	6a01      	ldr	r1, [r0, #32]
  40236e:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
  402372:	4b11      	ldr	r3, [pc, #68]	; (4023b8 <put_fat+0x130>)
  402374:	4798      	blx	r3
			if (res != FR_OK) break;
  402376:	4607      	mov	r7, r0
  402378:	2800      	cmp	r0, #0
  40237a:	d19a      	bne.n	4022b2 <put_fat+0x2a>
			p = &fs->win[clst * 4 % SS(fs)];
  40237c:	00a1      	lsls	r1, r4, #2
  40237e:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
  402382:	f101 0330 	add.w	r3, r1, #48	; 0x30
  402386:	4433      	add	r3, r6
			val |= LD_DWORD(p) & 0xF0000000;
  402388:	78da      	ldrb	r2, [r3, #3]
  40238a:	0612      	lsls	r2, r2, #24
  40238c:	4431      	add	r1, r6
  40238e:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
  402392:	432a      	orrs	r2, r5
			ST_DWORD(p, val);
  402394:	f881 2030 	strb.w	r2, [r1, #48]	; 0x30
  402398:	f3c2 2107 	ubfx	r1, r2, #8, #8
  40239c:	7059      	strb	r1, [r3, #1]
  40239e:	0c11      	lsrs	r1, r2, #16
  4023a0:	7099      	strb	r1, [r3, #2]
  4023a2:	0e12      	lsrs	r2, r2, #24
  4023a4:	70da      	strb	r2, [r3, #3]
			break;
  4023a6:	e784      	b.n	4022b2 <put_fat+0x2a>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  4023a8:	4607      	mov	r7, r0
  4023aa:	e782      	b.n	4022b2 <put_fat+0x2a>
  4023ac:	4607      	mov	r7, r0
  4023ae:	e780      	b.n	4022b2 <put_fat+0x2a>
		res = FR_INT_ERR;
  4023b0:	2702      	movs	r7, #2
}
  4023b2:	4638      	mov	r0, r7
  4023b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4023b8:	0040206d 	.word	0x0040206d

004023bc <create_chain>:
{
  4023bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4023c0:	4605      	mov	r5, r0
	if (clst == 0) {		/* Create a new chain */
  4023c2:	4688      	mov	r8, r1
  4023c4:	b941      	cbnz	r1, 4023d8 <create_chain+0x1c>
		scl = fs->last_clust;			/* Get suggested start point */
  4023c6:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
  4023c8:	b186      	cbz	r6, 4023ec <create_chain+0x30>
  4023ca:	6983      	ldr	r3, [r0, #24]
  4023cc:	429e      	cmp	r6, r3
  4023ce:	bf28      	it	cs
  4023d0:	2601      	movcs	r6, #1
	ncl = scl;				/* Start cluster */
  4023d2:	4634      	mov	r4, r6
		cs = get_fat(fs, ncl);			/* Get the cluster status */
  4023d4:	4f27      	ldr	r7, [pc, #156]	; (402474 <create_chain+0xb8>)
  4023d6:	e017      	b.n	402408 <create_chain+0x4c>
		cs = get_fat(fs, clst);			/* Check the cluster status */
  4023d8:	4b26      	ldr	r3, [pc, #152]	; (402474 <create_chain+0xb8>)
  4023da:	4798      	blx	r3
  4023dc:	4603      	mov	r3, r0
		if (cs < 2) return 1;			/* It is an invalid cluster */
  4023de:	2801      	cmp	r0, #1
  4023e0:	d93e      	bls.n	402460 <create_chain+0xa4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  4023e2:	69aa      	ldr	r2, [r5, #24]
  4023e4:	4290      	cmp	r0, r2
  4023e6:	d340      	bcc.n	40246a <create_chain+0xae>
		scl = clst;
  4023e8:	4646      	mov	r6, r8
  4023ea:	e7f2      	b.n	4023d2 <create_chain+0x16>
		if (!scl || scl >= fs->n_fatent) scl = 1;
  4023ec:	2601      	movs	r6, #1
  4023ee:	e7f0      	b.n	4023d2 <create_chain+0x16>
		cs = get_fat(fs, ncl);			/* Get the cluster status */
  4023f0:	4621      	mov	r1, r4
  4023f2:	4628      	mov	r0, r5
  4023f4:	47b8      	blx	r7
		if (cs == 0) break;				/* Found a free cluster */
  4023f6:	4603      	mov	r3, r0
  4023f8:	b170      	cbz	r0, 402418 <create_chain+0x5c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
  4023fa:	f1b0 3fff 	cmp.w	r0, #4294967295
  4023fe:	d034      	beq.n	40246a <create_chain+0xae>
  402400:	2801      	cmp	r0, #1
  402402:	d032      	beq.n	40246a <create_chain+0xae>
		if (ncl == scl) return 0;		/* No free cluster */
  402404:	42b4      	cmp	r4, r6
  402406:	d02f      	beq.n	402468 <create_chain+0xac>
		ncl++;							/* Next cluster */
  402408:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
  40240a:	69ab      	ldr	r3, [r5, #24]
  40240c:	429c      	cmp	r4, r3
  40240e:	d3ef      	bcc.n	4023f0 <create_chain+0x34>
			if (ncl > scl) return 0;	/* No free cluster */
  402410:	2e01      	cmp	r6, #1
  402412:	d927      	bls.n	402464 <create_chain+0xa8>
			ncl = 2;
  402414:	2402      	movs	r4, #2
  402416:	e7eb      	b.n	4023f0 <create_chain+0x34>
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
  402418:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
  40241c:	4621      	mov	r1, r4
  40241e:	4628      	mov	r0, r5
  402420:	4b15      	ldr	r3, [pc, #84]	; (402478 <create_chain+0xbc>)
  402422:	4798      	blx	r3
	if (res == FR_OK && clst != 0) {
  402424:	4603      	mov	r3, r0
  402426:	b9a8      	cbnz	r0, 402454 <create_chain+0x98>
  402428:	f1b8 0f00 	cmp.w	r8, #0
  40242c:	d10a      	bne.n	402444 <create_chain+0x88>
		fs->last_clust = ncl;			/* Update FSINFO */
  40242e:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
  402430:	692b      	ldr	r3, [r5, #16]
  402432:	f1b3 3fff 	cmp.w	r3, #4294967295
  402436:	d01b      	beq.n	402470 <create_chain+0xb4>
			fs->free_clust--;
  402438:	3b01      	subs	r3, #1
  40243a:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
  40243c:	2301      	movs	r3, #1
  40243e:	716b      	strb	r3, [r5, #5]
  402440:	4623      	mov	r3, r4
  402442:	e012      	b.n	40246a <create_chain+0xae>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
  402444:	4622      	mov	r2, r4
  402446:	4641      	mov	r1, r8
  402448:	4628      	mov	r0, r5
  40244a:	4b0b      	ldr	r3, [pc, #44]	; (402478 <create_chain+0xbc>)
  40244c:	4798      	blx	r3
	if (res == FR_OK) {
  40244e:	4603      	mov	r3, r0
  402450:	2800      	cmp	r0, #0
  402452:	d0ec      	beq.n	40242e <create_chain+0x72>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  402454:	2b01      	cmp	r3, #1
  402456:	bf0c      	ite	eq
  402458:	f04f 33ff 	moveq.w	r3, #4294967295
  40245c:	2301      	movne	r3, #1
  40245e:	e004      	b.n	40246a <create_chain+0xae>
		if (cs < 2) return 1;			/* It is an invalid cluster */
  402460:	2301      	movs	r3, #1
  402462:	e002      	b.n	40246a <create_chain+0xae>
			if (ncl > scl) return 0;	/* No free cluster */
  402464:	2300      	movs	r3, #0
  402466:	e000      	b.n	40246a <create_chain+0xae>
		if (ncl == scl) return 0;		/* No free cluster */
  402468:	2300      	movs	r3, #0
}
  40246a:	4618      	mov	r0, r3
  40246c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402470:	4623      	mov	r3, r4
  402472:	e7fa      	b.n	40246a <create_chain+0xae>
  402474:	004020fd 	.word	0x004020fd
  402478:	00402289 	.word	0x00402289

0040247c <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  40247c:	2901      	cmp	r1, #1
  40247e:	d92e      	bls.n	4024de <remove_chain+0x62>
{
  402480:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  402484:	4604      	mov	r4, r0
  402486:	460e      	mov	r6, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  402488:	6983      	ldr	r3, [r0, #24]
  40248a:	4299      	cmp	r1, r3
  40248c:	d303      	bcc.n	402496 <remove_chain+0x1a>
		res = FR_INT_ERR;
  40248e:	2202      	movs	r2, #2
}
  402490:	4610      	mov	r0, r2
  402492:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			nxt = get_fat(fs, clst);			/* Get cluster status */
  402496:	4f16      	ldr	r7, [pc, #88]	; (4024f0 <remove_chain+0x74>)
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
  402498:	f04f 0900 	mov.w	r9, #0
  40249c:	f8df 8054 	ldr.w	r8, [pc, #84]	; 4024f4 <remove_chain+0x78>
  4024a0:	e003      	b.n	4024aa <remove_chain+0x2e>
  4024a2:	462e      	mov	r6, r5
		while (clst < fs->n_fatent) {			/* Not a last link? */
  4024a4:	69a3      	ldr	r3, [r4, #24]
  4024a6:	42ab      	cmp	r3, r5
  4024a8:	d9f2      	bls.n	402490 <remove_chain+0x14>
			nxt = get_fat(fs, clst);			/* Get cluster status */
  4024aa:	4631      	mov	r1, r6
  4024ac:	4620      	mov	r0, r4
  4024ae:	47b8      	blx	r7
			if (nxt == 0) break;				/* Empty cluster? */
  4024b0:	4605      	mov	r5, r0
  4024b2:	b1b8      	cbz	r0, 4024e4 <remove_chain+0x68>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  4024b4:	2801      	cmp	r0, #1
  4024b6:	d017      	beq.n	4024e8 <remove_chain+0x6c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  4024b8:	f1b0 3fff 	cmp.w	r0, #4294967295
  4024bc:	d016      	beq.n	4024ec <remove_chain+0x70>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
  4024be:	464a      	mov	r2, r9
  4024c0:	4631      	mov	r1, r6
  4024c2:	4620      	mov	r0, r4
  4024c4:	47c0      	blx	r8
			if (res != FR_OK) break;
  4024c6:	4602      	mov	r2, r0
  4024c8:	2800      	cmp	r0, #0
  4024ca:	d1e1      	bne.n	402490 <remove_chain+0x14>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  4024cc:	6923      	ldr	r3, [r4, #16]
  4024ce:	f1b3 3fff 	cmp.w	r3, #4294967295
  4024d2:	d0e6      	beq.n	4024a2 <remove_chain+0x26>
				fs->free_clust++;
  4024d4:	3301      	adds	r3, #1
  4024d6:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
  4024d8:	2301      	movs	r3, #1
  4024da:	7163      	strb	r3, [r4, #5]
  4024dc:	e7e1      	b.n	4024a2 <remove_chain+0x26>
		res = FR_INT_ERR;
  4024de:	2202      	movs	r2, #2
}
  4024e0:	4610      	mov	r0, r2
  4024e2:	4770      	bx	lr
  4024e4:	2200      	movs	r2, #0
  4024e6:	e7d3      	b.n	402490 <remove_chain+0x14>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  4024e8:	2202      	movs	r2, #2
  4024ea:	e7d1      	b.n	402490 <remove_chain+0x14>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  4024ec:	2201      	movs	r2, #1
  4024ee:	e7cf      	b.n	402490 <remove_chain+0x14>
  4024f0:	004020fd 	.word	0x004020fd
  4024f4:	00402289 	.word	0x00402289

004024f8 <dir_next>:
{
  4024f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	i = dj->index + 1;
  4024fc:	88c4      	ldrh	r4, [r0, #6]
  4024fe:	3401      	adds	r4, #1
  402500:	b2a4      	uxth	r4, r4
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402502:	b914      	cbnz	r4, 40250a <dir_next+0x12>
		return FR_NO_FILE;
  402504:	2004      	movs	r0, #4
  402506:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  40250a:	6903      	ldr	r3, [r0, #16]
  40250c:	b913      	cbnz	r3, 402514 <dir_next+0x1c>
		return FR_NO_FILE;
  40250e:	2004      	movs	r0, #4
  402510:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402514:	460e      	mov	r6, r1
  402516:	4605      	mov	r5, r0
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  402518:	f014 070f 	ands.w	r7, r4, #15
  40251c:	d110      	bne.n	402540 <dir_next+0x48>
		dj->sect++;					/* Next sector */
  40251e:	3301      	adds	r3, #1
  402520:	6103      	str	r3, [r0, #16]
		if (dj->clust == 0) {	/* Static table */
  402522:	68c1      	ldr	r1, [r0, #12]
  402524:	b931      	cbnz	r1, 402534 <dir_next+0x3c>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402526:	6803      	ldr	r3, [r0, #0]
  402528:	891b      	ldrh	r3, [r3, #8]
  40252a:	42a3      	cmp	r3, r4
  40252c:	d808      	bhi.n	402540 <dir_next+0x48>
				return FR_NO_FILE;
  40252e:	2004      	movs	r0, #4
  402530:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  402534:	6800      	ldr	r0, [r0, #0]
  402536:	7883      	ldrb	r3, [r0, #2]
  402538:	3b01      	subs	r3, #1
  40253a:	ea13 1314 	ands.w	r3, r3, r4, lsr #4
  40253e:	d008      	beq.n	402552 <dir_next+0x5a>
	dj->index = i;
  402540:	80ec      	strh	r4, [r5, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  402542:	682b      	ldr	r3, [r5, #0]
  402544:	3330      	adds	r3, #48	; 0x30
  402546:	eb03 1347 	add.w	r3, r3, r7, lsl #5
  40254a:	616b      	str	r3, [r5, #20]
	return FR_OK;
  40254c:	2000      	movs	r0, #0
  40254e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
  402552:	4b32      	ldr	r3, [pc, #200]	; (40261c <dir_next+0x124>)
  402554:	4798      	blx	r3
  402556:	4680      	mov	r8, r0
				if (clst <= 1) return FR_INT_ERR;
  402558:	2801      	cmp	r0, #1
  40255a:	d94d      	bls.n	4025f8 <dir_next+0x100>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  40255c:	f1b0 3fff 	cmp.w	r0, #4294967295
  402560:	d04d      	beq.n	4025fe <dir_next+0x106>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  402562:	6828      	ldr	r0, [r5, #0]
  402564:	6983      	ldr	r3, [r0, #24]
  402566:	4598      	cmp	r8, r3
  402568:	d33e      	bcc.n	4025e8 <dir_next+0xf0>
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
  40256a:	b916      	cbnz	r6, 402572 <dir_next+0x7a>
  40256c:	2004      	movs	r0, #4
  40256e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
  402572:	68e9      	ldr	r1, [r5, #12]
  402574:	4b2a      	ldr	r3, [pc, #168]	; (402620 <dir_next+0x128>)
  402576:	4798      	blx	r3
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  402578:	4680      	mov	r8, r0
  40257a:	b910      	cbnz	r0, 402582 <dir_next+0x8a>
  40257c:	2007      	movs	r0, #7
  40257e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (clst == 1) return FR_INT_ERR;
  402582:	2801      	cmp	r0, #1
  402584:	d03e      	beq.n	402604 <dir_next+0x10c>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402586:	f1b0 3fff 	cmp.w	r0, #4294967295
  40258a:	d03e      	beq.n	40260a <dir_next+0x112>
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  40258c:	2100      	movs	r1, #0
  40258e:	6828      	ldr	r0, [r5, #0]
  402590:	4b24      	ldr	r3, [pc, #144]	; (402624 <dir_next+0x12c>)
  402592:	4798      	blx	r3
  402594:	2800      	cmp	r0, #0
  402596:	d13b      	bne.n	402610 <dir_next+0x118>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  402598:	6828      	ldr	r0, [r5, #0]
  40259a:	f44f 7200 	mov.w	r2, #512	; 0x200
  40259e:	2100      	movs	r1, #0
  4025a0:	3030      	adds	r0, #48	; 0x30
  4025a2:	4b21      	ldr	r3, [pc, #132]	; (402628 <dir_next+0x130>)
  4025a4:	4798      	blx	r3
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  4025a6:	682e      	ldr	r6, [r5, #0]
  4025a8:	4641      	mov	r1, r8
  4025aa:	4630      	mov	r0, r6
  4025ac:	4b1f      	ldr	r3, [pc, #124]	; (40262c <dir_next+0x134>)
  4025ae:	4798      	blx	r3
  4025b0:	62f0      	str	r0, [r6, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  4025b2:	2600      	movs	r6, #0
						dj->fs->wflag = 1;
  4025b4:	f04f 0b01 	mov.w	fp, #1
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  4025b8:	46b2      	mov	sl, r6
  4025ba:	f8df 9068 	ldr.w	r9, [pc, #104]	; 402624 <dir_next+0x12c>
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  4025be:	682b      	ldr	r3, [r5, #0]
  4025c0:	7899      	ldrb	r1, [r3, #2]
  4025c2:	b2f2      	uxtb	r2, r6
  4025c4:	4291      	cmp	r1, r2
  4025c6:	d90b      	bls.n	4025e0 <dir_next+0xe8>
						dj->fs->wflag = 1;
  4025c8:	f883 b004 	strb.w	fp, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  4025cc:	4651      	mov	r1, sl
  4025ce:	6828      	ldr	r0, [r5, #0]
  4025d0:	47c8      	blx	r9
  4025d2:	3601      	adds	r6, #1
  4025d4:	b9f8      	cbnz	r0, 402616 <dir_next+0x11e>
						dj->fs->winsect++;
  4025d6:	682a      	ldr	r2, [r5, #0]
  4025d8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
  4025da:	3301      	adds	r3, #1
  4025dc:	62d3      	str	r3, [r2, #44]	; 0x2c
  4025de:	e7ee      	b.n	4025be <dir_next+0xc6>
					dj->fs->winsect -= c;						/* Rewind window address */
  4025e0:	4616      	mov	r6, r2
  4025e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4025e4:	1b96      	subs	r6, r2, r6
  4025e6:	62de      	str	r6, [r3, #44]	; 0x2c
				dj->clust = clst;				/* Initialize data for new cluster */
  4025e8:	f8c5 800c 	str.w	r8, [r5, #12]
				dj->sect = clust2sect(dj->fs, clst);
  4025ec:	4641      	mov	r1, r8
  4025ee:	6828      	ldr	r0, [r5, #0]
  4025f0:	4b0e      	ldr	r3, [pc, #56]	; (40262c <dir_next+0x134>)
  4025f2:	4798      	blx	r3
  4025f4:	6128      	str	r0, [r5, #16]
  4025f6:	e7a3      	b.n	402540 <dir_next+0x48>
				if (clst <= 1) return FR_INT_ERR;
  4025f8:	2002      	movs	r0, #2
  4025fa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  4025fe:	2001      	movs	r0, #1
  402600:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (clst == 1) return FR_INT_ERR;
  402604:	2002      	movs	r0, #2
  402606:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  40260a:	2001      	movs	r0, #1
  40260c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  402610:	2001      	movs	r0, #1
  402612:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  402616:	2001      	movs	r0, #1
}
  402618:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40261c:	004020fd 	.word	0x004020fd
  402620:	004023bd 	.word	0x004023bd
  402624:	0040206d 	.word	0x0040206d
  402628:	00401bf9 	.word	0x00401bf9
  40262c:	00401c07 	.word	0x00401c07

00402630 <dir_find>:
{
  402630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402634:	b085      	sub	sp, #20
  402636:	4605      	mov	r5, r0
	res = dir_sdi(dj, 0);			/* Rewind directory object */
  402638:	2100      	movs	r1, #0
  40263a:	4b62      	ldr	r3, [pc, #392]	; (4027c4 <dir_find+0x194>)
  40263c:	4798      	blx	r3
	if (res != FR_OK) return res;
  40263e:	4680      	mov	r8, r0
  402640:	bb08      	cbnz	r0, 402686 <dir_find+0x56>
  402642:	f04f 0bff 	mov.w	fp, #255	; 0xff
  402646:	46d9      	mov	r9, fp
		res = move_window(dj->fs, dj->sect);
  402648:	4f5f      	ldr	r7, [pc, #380]	; (4027c8 <dir_find+0x198>)
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  40264a:	46da      	mov	sl, fp
  40264c:	e095      	b.n	40277a <dir_find+0x14a>
			if (a == AM_LFN) {			/* An LFN entry is found */
  40264e:	2a0f      	cmp	r2, #15
  402650:	d01d      	beq.n	40268e <dir_find+0x5e>
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  402652:	f1b9 0f00 	cmp.w	r9, #0
  402656:	d104      	bne.n	402662 <dir_find+0x32>
  402658:	4620      	mov	r0, r4
  40265a:	4b5c      	ldr	r3, [pc, #368]	; (4027cc <dir_find+0x19c>)
  40265c:	4798      	blx	r3
  40265e:	4582      	cmp	sl, r0
  402660:	d011      	beq.n	402686 <dir_find+0x56>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  402662:	f64f 73ff 	movw	r3, #65535	; 0xffff
  402666:	842b      	strh	r3, [r5, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  402668:	69ab      	ldr	r3, [r5, #24]
  40266a:	7ada      	ldrb	r2, [r3, #11]
  40266c:	f012 0f01 	tst.w	r2, #1
  402670:	d17a      	bne.n	402768 <dir_find+0x138>
  402672:	f104 000b 	add.w	r0, r4, #11
	while (cnt-- && (r = *d++ - *s++) == 0) ;
  402676:	f814 1b01 	ldrb.w	r1, [r4], #1
  40267a:	f813 2b01 	ldrb.w	r2, [r3], #1
  40267e:	4291      	cmp	r1, r2
  402680:	d16c      	bne.n	40275c <dir_find+0x12c>
  402682:	42a0      	cmp	r0, r4
  402684:	d1f7      	bne.n	402676 <dir_find+0x46>
}
  402686:	4640      	mov	r0, r8
  402688:	b005      	add	sp, #20
  40268a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (dj->lfn) {
  40268e:	f8d5 801c 	ldr.w	r8, [r5, #28]
  402692:	f1b8 0f00 	cmp.w	r8, #0
  402696:	d069      	beq.n	40276c <dir_find+0x13c>
					if (c & LLE) {		/* Is it start of LFN sequence? */
  402698:	f016 0f40 	tst.w	r6, #64	; 0x40
  40269c:	d00c      	beq.n	4026b8 <dir_find+0x88>
						sum = dir[LDIR_Chksum];
  40269e:	f894 a00d 	ldrb.w	sl, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
  4026a2:	f006 06bf 	and.w	r6, r6, #191	; 0xbf
						dj->lfn_idx = dj->index;
  4026a6:	88eb      	ldrh	r3, [r5, #6]
  4026a8:	842b      	strh	r3, [r5, #32]
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  4026aa:	f894 b00d 	ldrb.w	fp, [r4, #13]
  4026ae:	45d3      	cmp	fp, sl
  4026b0:	d008      	beq.n	4026c4 <dir_find+0x94>
  4026b2:	f04f 09ff 	mov.w	r9, #255	; 0xff
  4026b6:	e059      	b.n	40276c <dir_find+0x13c>
  4026b8:	45b1      	cmp	r9, r6
  4026ba:	bf18      	it	ne
  4026bc:	f04f 09ff 	movne.w	r9, #255	; 0xff
  4026c0:	d154      	bne.n	40276c <dir_find+0x13c>
  4026c2:	e7f2      	b.n	4026aa <dir_find+0x7a>
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
  4026c4:	f894 a000 	ldrb.w	sl, [r4]
  4026c8:	f02a 0a40 	bic.w	sl, sl, #64	; 0x40
  4026cc:	f10a 3aff 	add.w	sl, sl, #4294967295
  4026d0:	eb0a 034a 	add.w	r3, sl, sl, lsl #1
  4026d4:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
  4026d8:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 4027d8 <dir_find+0x1a8>
  4026dc:	f109 0a0d 	add.w	sl, r9, #13
	s = 0; wc = 1;
  4026e0:	2001      	movs	r0, #1
			if (uc != 0xFFFF) return 0;	/* Check filler */
  4026e2:	9603      	str	r6, [sp, #12]
  4026e4:	f8cd b004 	str.w	fp, [sp, #4]
  4026e8:	461e      	mov	r6, r3
  4026ea:	9502      	str	r5, [sp, #8]
  4026ec:	e00f      	b.n	40270e <dir_find+0xde>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  4026ee:	4618      	mov	r0, r3
  4026f0:	4b37      	ldr	r3, [pc, #220]	; (4027d0 <dir_find+0x1a0>)
  4026f2:	4798      	blx	r3
  4026f4:	4683      	mov	fp, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  4026f6:	2efe      	cmp	r6, #254	; 0xfe
  4026f8:	d85b      	bhi.n	4027b2 <dir_find+0x182>
  4026fa:	1c75      	adds	r5, r6, #1
  4026fc:	f838 0016 	ldrh.w	r0, [r8, r6, lsl #1]
  402700:	4b33      	ldr	r3, [pc, #204]	; (4027d0 <dir_find+0x1a0>)
  402702:	4798      	blx	r3
  402704:	4583      	cmp	fp, r0
  402706:	d158      	bne.n	4027ba <dir_find+0x18a>
  402708:	462e      	mov	r6, r5
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
  40270a:	45d1      	cmp	r9, sl
  40270c:	d013      	beq.n	402736 <dir_find+0x106>
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
  40270e:	f819 2b01 	ldrb.w	r2, [r9], #1
  402712:	18a3      	adds	r3, r4, r2
  402714:	7859      	ldrb	r1, [r3, #1]
  402716:	5ca3      	ldrb	r3, [r4, r2]
  402718:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		if (wc) {	/* Last char has not been processed */
  40271c:	2800      	cmp	r0, #0
  40271e:	d1e6      	bne.n	4026ee <dir_find+0xbe>
			if (uc != 0xFFFF) return 0;	/* Check filler */
  402720:	f64f 72ff 	movw	r2, #65535	; 0xffff
  402724:	4293      	cmp	r3, r2
  402726:	d0f0      	beq.n	40270a <dir_find+0xda>
  402728:	f8dd b004 	ldr.w	fp, [sp, #4]
  40272c:	9d02      	ldr	r5, [sp, #8]
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  40272e:	46da      	mov	sl, fp
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  402730:	f04f 09ff 	mov.w	r9, #255	; 0xff
  402734:	e01a      	b.n	40276c <dir_find+0x13c>
  402736:	f8dd b004 	ldr.w	fp, [sp, #4]
  40273a:	4632      	mov	r2, r6
  40273c:	9e03      	ldr	r6, [sp, #12]
  40273e:	9d02      	ldr	r5, [sp, #8]
	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
  402740:	7823      	ldrb	r3, [r4, #0]
  402742:	f013 0f40 	tst.w	r3, #64	; 0x40
  402746:	d004      	beq.n	402752 <dir_find+0x122>
  402748:	b118      	cbz	r0, 402752 <dir_find+0x122>
  40274a:	f838 3012 	ldrh.w	r3, [r8, r2, lsl #1]
  40274e:	2b00      	cmp	r3, #0
  402750:	d1ed      	bne.n	40272e <dir_find+0xfe>
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  402752:	3e01      	subs	r6, #1
  402754:	fa5f f986 	uxtb.w	r9, r6
  402758:	46da      	mov	sl, fp
  40275a:	e007      	b.n	40276c <dir_find+0x13c>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  40275c:	f04f 09ff 	mov.w	r9, #255	; 0xff
  402760:	e004      	b.n	40276c <dir_find+0x13c>
			ord = 0xFF;
  402762:	f04f 09ff 	mov.w	r9, #255	; 0xff
  402766:	e001      	b.n	40276c <dir_find+0x13c>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  402768:	f04f 09ff 	mov.w	r9, #255	; 0xff
		res = dir_next(dj, 0);		/* Next entry */
  40276c:	2100      	movs	r1, #0
  40276e:	4628      	mov	r0, r5
  402770:	4b18      	ldr	r3, [pc, #96]	; (4027d4 <dir_find+0x1a4>)
  402772:	4798      	blx	r3
	} while (res == FR_OK);
  402774:	4680      	mov	r8, r0
  402776:	2800      	cmp	r0, #0
  402778:	d185      	bne.n	402686 <dir_find+0x56>
		res = move_window(dj->fs, dj->sect);
  40277a:	6929      	ldr	r1, [r5, #16]
  40277c:	6828      	ldr	r0, [r5, #0]
  40277e:	47b8      	blx	r7
		if (res != FR_OK) break;
  402780:	4680      	mov	r8, r0
  402782:	2800      	cmp	r0, #0
  402784:	f47f af7f 	bne.w	402686 <dir_find+0x56>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  402788:	696c      	ldr	r4, [r5, #20]
		c = dir[DIR_Name];
  40278a:	7826      	ldrb	r6, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  40278c:	b176      	cbz	r6, 4027ac <dir_find+0x17c>
		a = dir[DIR_Attr] & AM_MASK;
  40278e:	7ae3      	ldrb	r3, [r4, #11]
  402790:	f003 023f 	and.w	r2, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402794:	2ee5      	cmp	r6, #229	; 0xe5
  402796:	d0e4      	beq.n	402762 <dir_find+0x132>
  402798:	f013 0f08 	tst.w	r3, #8
  40279c:	f43f af57 	beq.w	40264e <dir_find+0x1e>
  4027a0:	2a0f      	cmp	r2, #15
  4027a2:	f43f af74 	beq.w	40268e <dir_find+0x5e>
			ord = 0xFF;
  4027a6:	f04f 09ff 	mov.w	r9, #255	; 0xff
  4027aa:	e7df      	b.n	40276c <dir_find+0x13c>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  4027ac:	f04f 0804 	mov.w	r8, #4
  4027b0:	e769      	b.n	402686 <dir_find+0x56>
  4027b2:	f8dd b004 	ldr.w	fp, [sp, #4]
  4027b6:	9d02      	ldr	r5, [sp, #8]
  4027b8:	e7b9      	b.n	40272e <dir_find+0xfe>
  4027ba:	f8dd b004 	ldr.w	fp, [sp, #4]
  4027be:	9d02      	ldr	r5, [sp, #8]
  4027c0:	e7b5      	b.n	40272e <dir_find+0xfe>
  4027c2:	bf00      	nop
  4027c4:	004021e5 	.word	0x004021e5
  4027c8:	0040206d 	.word	0x0040206d
  4027cc:	00401c1d 	.word	0x00401c1d
  4027d0:	0040385d 	.word	0x0040385d
  4027d4:	004024f9 	.word	0x004024f9
  4027d8:	0040dcf8 	.word	0x0040dcf8

004027dc <dir_register>:
{
  4027dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4027e0:	b089      	sub	sp, #36	; 0x24
  4027e2:	4604      	mov	r4, r0
	fn = dj->fn; lfn = dj->lfn;
  4027e4:	6985      	ldr	r5, [r0, #24]
  4027e6:	f8d0 b01c 	ldr.w	fp, [r0, #28]
	mem_cpy(sn, fn, 12);
  4027ea:	220c      	movs	r2, #12
  4027ec:	4629      	mov	r1, r5
  4027ee:	a805      	add	r0, sp, #20
  4027f0:	4ba8      	ldr	r3, [pc, #672]	; (402a94 <dir_register+0x2b8>)
  4027f2:	4798      	blx	r3
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
  4027f4:	f89d 301f 	ldrb.w	r3, [sp, #31]
  4027f8:	f013 0f01 	tst.w	r3, #1
  4027fc:	d079      	beq.n	4028f2 <dir_register+0x116>
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  4027fe:	2300      	movs	r3, #0
  402800:	72eb      	strb	r3, [r5, #11]
  402802:	61e3      	str	r3, [r4, #28]
	mem_cpy(dst, src, 11);
  402804:	220b      	movs	r2, #11
  402806:	a905      	add	r1, sp, #20
  402808:	4628      	mov	r0, r5
  40280a:	4ba2      	ldr	r3, [pc, #648]	; (402a94 <dir_register+0x2b8>)
  40280c:	4798      	blx	r3
		for (n = 1; n < 100; n++) {
  40280e:	2701      	movs	r7, #1
  402810:	463b      	mov	r3, r7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  402812:	f04f 0820 	mov.w	r8, #32
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
  402816:	f8df 929c 	ldr.w	r9, [pc, #668]	; 402ab4 <dir_register+0x2d8>
	mem_cpy(dst, src, 11);
  40281a:	f8df a278 	ldr.w	sl, [pc, #632]	; 402a94 <dir_register+0x2b8>
  40281e:	e032      	b.n	402886 <dir_register+0xaa>
		for (n = 1; n < 100; n++) {
  402820:	463b      	mov	r3, r7
  402822:	e030      	b.n	402886 <dir_register+0xaa>
	for (j = 0; j < i && dst[j] != ' '; j++) {
  402824:	4613      	mov	r3, r2
  402826:	e002      	b.n	40282e <dir_register+0x52>
  402828:	2300      	movs	r3, #0
  40282a:	e000      	b.n	40282e <dir_register+0x52>
  40282c:	4613      	mov	r3, r2
  40282e:	442b      	add	r3, r5
  402830:	e005      	b.n	40283e <dir_register+0x62>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  402832:	4641      	mov	r1, r8
  402834:	f803 1b01 	strb.w	r1, [r3], #1
	} while (j < 8);
  402838:	1b59      	subs	r1, r3, r5
  40283a:	2907      	cmp	r1, #7
  40283c:	d807      	bhi.n	40284e <dir_register+0x72>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  40283e:	2a07      	cmp	r2, #7
  402840:	d8f7      	bhi.n	402832 <dir_register+0x56>
  402842:	a908      	add	r1, sp, #32
  402844:	4411      	add	r1, r2
  402846:	f811 1c14 	ldrb.w	r1, [r1, #-20]
  40284a:	3201      	adds	r2, #1
  40284c:	e7f2      	b.n	402834 <dir_register+0x58>
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
  40284e:	4620      	mov	r0, r4
  402850:	47c8      	blx	r9
			if (res != FR_OK) break;
  402852:	4606      	mov	r6, r0
  402854:	2800      	cmp	r0, #0
  402856:	d13e      	bne.n	4028d6 <dir_register+0xfa>
		for (n = 1; n < 100; n++) {
  402858:	3701      	adds	r7, #1
  40285a:	b2bf      	uxth	r7, r7
  40285c:	2f64      	cmp	r7, #100	; 0x64
  40285e:	d038      	beq.n	4028d2 <dir_register+0xf6>
	mem_cpy(dst, src, 11);
  402860:	220b      	movs	r2, #11
  402862:	a905      	add	r1, sp, #20
  402864:	4628      	mov	r0, r5
  402866:	47d0      	blx	sl
	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  402868:	2f05      	cmp	r7, #5
  40286a:	d9d9      	bls.n	402820 <dir_register+0x44>
  40286c:	463b      	mov	r3, r7
  40286e:	4659      	mov	r1, fp
		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
  402870:	03da      	lsls	r2, r3, #15
  402872:	ea42 0353 	orr.w	r3, r2, r3, lsr #1
  402876:	f831 2b02 	ldrh.w	r2, [r1], #2
  40287a:	fa12 f383 	uxtah	r3, r2, r3
  40287e:	b29b      	uxth	r3, r3
  402880:	880a      	ldrh	r2, [r1, #0]
  402882:	2a00      	cmp	r2, #0
  402884:	d1f4      	bne.n	402870 <dir_register+0x94>
  402886:	f10d 0613 	add.w	r6, sp, #19
		for (n = 1; n < 100; n++) {
  40288a:	2207      	movs	r2, #7
		c = (seq % 16) + '0';
  40288c:	f003 000f 	and.w	r0, r3, #15
  402890:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
  402894:	2939      	cmp	r1, #57	; 0x39
  402896:	bf88      	it	hi
  402898:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
  40289c:	3a01      	subs	r2, #1
  40289e:	f806 1901 	strb.w	r1, [r6], #-1
		seq /= 16;
  4028a2:	f3c3 130f 	ubfx	r3, r3, #4, #16
	} while (seq);
  4028a6:	2b00      	cmp	r3, #0
  4028a8:	d1f0      	bne.n	40288c <dir_register+0xb0>
	ns[i] = '~';
  4028aa:	217e      	movs	r1, #126	; 0x7e
  4028ac:	ab08      	add	r3, sp, #32
  4028ae:	4413      	add	r3, r2
  4028b0:	f803 1c14 	strb.w	r1, [r3, #-20]
	for (j = 0; j < i && dst[j] != ' '; j++) {
  4028b4:	2a00      	cmp	r2, #0
  4028b6:	d0b5      	beq.n	402824 <dir_register+0x48>
  4028b8:	782b      	ldrb	r3, [r5, #0]
  4028ba:	2b20      	cmp	r3, #32
  4028bc:	d0b4      	beq.n	402828 <dir_register+0x4c>
  4028be:	4629      	mov	r1, r5
  4028c0:	2300      	movs	r3, #0
  4028c2:	3301      	adds	r3, #1
  4028c4:	429a      	cmp	r2, r3
  4028c6:	d0b1      	beq.n	40282c <dir_register+0x50>
  4028c8:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  4028cc:	2820      	cmp	r0, #32
  4028ce:	d1f8      	bne.n	4028c2 <dir_register+0xe6>
  4028d0:	e7ad      	b.n	40282e <dir_register+0x52>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
  4028d2:	2607      	movs	r6, #7
  4028d4:	e004      	b.n	4028e0 <dir_register+0x104>
  4028d6:	2f64      	cmp	r7, #100	; 0x64
  4028d8:	f000 809f 	beq.w	402a1a <dir_register+0x23e>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
  4028dc:	2804      	cmp	r0, #4
  4028de:	d003      	beq.n	4028e8 <dir_register+0x10c>
}
  4028e0:	4630      	mov	r0, r6
  4028e2:	b009      	add	sp, #36	; 0x24
  4028e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		fn[NS] = sn[NS]; dj->lfn = lfn;
  4028e8:	f89d 301f 	ldrb.w	r3, [sp, #31]
  4028ec:	72eb      	strb	r3, [r5, #11]
  4028ee:	f8c4 b01c 	str.w	fp, [r4, #28]
	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
  4028f2:	f89d 301f 	ldrb.w	r3, [sp, #31]
  4028f6:	f013 0f02 	tst.w	r3, #2
  4028fa:	d014      	beq.n	402926 <dir_register+0x14a>
		for (ne = 0; lfn[ne]; ne++) ;
  4028fc:	f8bb 3000 	ldrh.w	r3, [fp]
  402900:	b17b      	cbz	r3, 402922 <dir_register+0x146>
  402902:	2300      	movs	r3, #0
  402904:	3301      	adds	r3, #1
  402906:	b29b      	uxth	r3, r3
  402908:	f83b 2013 	ldrh.w	r2, [fp, r3, lsl #1]
  40290c:	2a00      	cmp	r2, #0
  40290e:	d1f9      	bne.n	402904 <dir_register+0x128>
		ne = (ne + 25) / 13;
  402910:	3319      	adds	r3, #25
  402912:	4f61      	ldr	r7, [pc, #388]	; (402a98 <dir_register+0x2bc>)
  402914:	fb87 2703 	smull	r2, r7, r7, r3
  402918:	17db      	asrs	r3, r3, #31
  40291a:	ebc3 07a7 	rsb	r7, r3, r7, asr #2
  40291e:	b2bf      	uxth	r7, r7
  402920:	e002      	b.n	402928 <dir_register+0x14c>
		for (ne = 0; lfn[ne]; ne++) ;
  402922:	2300      	movs	r3, #0
  402924:	e7f4      	b.n	402910 <dir_register+0x134>
		ne = 1;
  402926:	2701      	movs	r7, #1
	res = dir_sdi(dj, 0);
  402928:	2100      	movs	r1, #0
  40292a:	4620      	mov	r0, r4
  40292c:	4b5b      	ldr	r3, [pc, #364]	; (402a9c <dir_register+0x2c0>)
  40292e:	4798      	blx	r3
	if (res != FR_OK) return res;
  402930:	4606      	mov	r6, r0
  402932:	2800      	cmp	r0, #0
  402934:	d1d4      	bne.n	4028e0 <dir_register+0x104>
  402936:	f04f 0a00 	mov.w	sl, #0
  40293a:	4655      	mov	r5, sl
		res = move_window(dj->fs, dj->sect);
  40293c:	f8df 8168 	ldr.w	r8, [pc, #360]	; 402aa8 <dir_register+0x2cc>
			n = 0;					/* Not a blank entry. Restart to search */
  402940:	46d3      	mov	fp, sl
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  402942:	f8df 9160 	ldr.w	r9, [pc, #352]	; 402aa4 <dir_register+0x2c8>
  402946:	e00a      	b.n	40295e <dir_register+0x182>
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  402948:	1c6b      	adds	r3, r5, #1
  40294a:	b29b      	uxth	r3, r3
  40294c:	429f      	cmp	r7, r3
  40294e:	d066      	beq.n	402a1e <dir_register+0x242>
  402950:	461d      	mov	r5, r3
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  402952:	2101      	movs	r1, #1
  402954:	4620      	mov	r0, r4
  402956:	47c8      	blx	r9
	} while (res == FR_OK);
  402958:	4606      	mov	r6, r0
  40295a:	2800      	cmp	r0, #0
  40295c:	d1c0      	bne.n	4028e0 <dir_register+0x104>
		res = move_window(dj->fs, dj->sect);
  40295e:	6921      	ldr	r1, [r4, #16]
  402960:	6820      	ldr	r0, [r4, #0]
  402962:	47c0      	blx	r8
		if (res != FR_OK) break;
  402964:	4606      	mov	r6, r0
  402966:	2800      	cmp	r0, #0
  402968:	d1ba      	bne.n	4028e0 <dir_register+0x104>
		c = *dj->dir;				/* Check the entry status */
  40296a:	6963      	ldr	r3, [r4, #20]
  40296c:	781b      	ldrb	r3, [r3, #0]
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
  40296e:	2be5      	cmp	r3, #229	; 0xe5
  402970:	d000      	beq.n	402974 <dir_register+0x198>
  402972:	b923      	cbnz	r3, 40297e <dir_register+0x1a2>
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
  402974:	2d00      	cmp	r5, #0
  402976:	d1e7      	bne.n	402948 <dir_register+0x16c>
  402978:	f8b4 a006 	ldrh.w	sl, [r4, #6]
  40297c:	e7e4      	b.n	402948 <dir_register+0x16c>
			n = 0;					/* Not a blank entry. Restart to search */
  40297e:	465d      	mov	r5, fp
  402980:	e7e7      	b.n	402952 <dir_register+0x176>
		res = dir_sdi(dj, is);
  402982:	4651      	mov	r1, sl
  402984:	4620      	mov	r0, r4
  402986:	4b45      	ldr	r3, [pc, #276]	; (402a9c <dir_register+0x2c0>)
  402988:	4798      	blx	r3
		if (res == FR_OK) {
  40298a:	4606      	mov	r6, r0
  40298c:	2800      	cmp	r0, #0
  40298e:	d1a7      	bne.n	4028e0 <dir_register+0x104>
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
  402990:	69a0      	ldr	r0, [r4, #24]
  402992:	4b43      	ldr	r3, [pc, #268]	; (402aa0 <dir_register+0x2c4>)
  402994:	4798      	blx	r3
  402996:	9000      	str	r0, [sp, #0]
	dir[LDIR_Type] = 0;
  402998:	2700      	movs	r7, #0
	s = wc = 0;
  40299a:	9701      	str	r7, [sp, #4]
  40299c:	e019      	b.n	4029d2 <dir_register+0x1f6>
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  40299e:	4671      	mov	r1, lr
  4029a0:	e062      	b.n	402a68 <dir_register+0x28c>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
  4029a2:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4029a6:	4293      	cmp	r3, r2
  4029a8:	d002      	beq.n	4029b0 <dir_register+0x1d4>
  4029aa:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
  4029ae:	b90b      	cbnz	r3, 4029b4 <dir_register+0x1d8>
  4029b0:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
  4029b4:	f880 b000 	strb.w	fp, [r0]
				dj->fs->wflag = 1;
  4029b8:	6823      	ldr	r3, [r4, #0]
  4029ba:	2201      	movs	r2, #1
  4029bc:	711a      	strb	r2, [r3, #4]
				res = dir_next(dj, 0);	/* Next entry */
  4029be:	4639      	mov	r1, r7
  4029c0:	4620      	mov	r0, r4
  4029c2:	4b38      	ldr	r3, [pc, #224]	; (402aa4 <dir_register+0x2c8>)
  4029c4:	4798      	blx	r3
			} while (res == FR_OK && --ne);
  4029c6:	4606      	mov	r6, r0
  4029c8:	2800      	cmp	r0, #0
  4029ca:	d189      	bne.n	4028e0 <dir_register+0x104>
  4029cc:	3d01      	subs	r5, #1
  4029ce:	b2ad      	uxth	r5, r5
  4029d0:	b33d      	cbz	r5, 402a22 <dir_register+0x246>
				res = move_window(dj->fs, dj->sect);
  4029d2:	6921      	ldr	r1, [r4, #16]
  4029d4:	6820      	ldr	r0, [r4, #0]
  4029d6:	4b34      	ldr	r3, [pc, #208]	; (402aa8 <dir_register+0x2cc>)
  4029d8:	4798      	blx	r3
				if (res != FR_OK) break;
  4029da:	4606      	mov	r6, r0
  4029dc:	2800      	cmp	r0, #0
  4029de:	f47f af7f 	bne.w	4028e0 <dir_register+0x104>
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  4029e2:	f8d4 901c 	ldr.w	r9, [r4, #28]
  4029e6:	6960      	ldr	r0, [r4, #20]
  4029e8:	fa5f fb85 	uxtb.w	fp, r5
	dir[LDIR_Chksum] = sum;			/* Set check sum */
  4029ec:	f89d 3000 	ldrb.w	r3, [sp]
  4029f0:	7343      	strb	r3, [r0, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  4029f2:	230f      	movs	r3, #15
  4029f4:	72c3      	strb	r3, [r0, #11]
	dir[LDIR_Type] = 0;
  4029f6:	7307      	strb	r7, [r0, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
  4029f8:	7687      	strb	r7, [r0, #26]
  4029fa:	76c7      	strb	r7, [r0, #27]
	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  4029fc:	f10b 31ff 	add.w	r1, fp, #4294967295
  402a00:	eb01 0341 	add.w	r3, r1, r1, lsl #1
  402a04:	eb01 0183 	add.w	r1, r1, r3, lsl #2
  402a08:	4a28      	ldr	r2, [pc, #160]	; (402aac <dir_register+0x2d0>)
  402a0a:	f102 080d 	add.w	r8, r2, #13
	s = wc = 0;
  402a0e:	9b01      	ldr	r3, [sp, #4]
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  402a10:	f64f 76ff 	movw	r6, #65535	; 0xffff
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402a14:	f04f 0aff 	mov.w	sl, #255	; 0xff
  402a18:	e029      	b.n	402a6e <dir_register+0x292>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
  402a1a:	2607      	movs	r6, #7
  402a1c:	e760      	b.n	4028e0 <dir_register+0x104>
	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
  402a1e:	2b01      	cmp	r3, #1
  402a20:	d8af      	bhi.n	402982 <dir_register+0x1a6>
		res = move_window(dj->fs, dj->sect);
  402a22:	6921      	ldr	r1, [r4, #16]
  402a24:	6820      	ldr	r0, [r4, #0]
  402a26:	4b20      	ldr	r3, [pc, #128]	; (402aa8 <dir_register+0x2cc>)
  402a28:	4798      	blx	r3
		if (res == FR_OK) {
  402a2a:	4606      	mov	r6, r0
  402a2c:	2800      	cmp	r0, #0
  402a2e:	f47f af57 	bne.w	4028e0 <dir_register+0x104>
			dir = dj->dir;
  402a32:	6965      	ldr	r5, [r4, #20]
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
  402a34:	2220      	movs	r2, #32
  402a36:	2100      	movs	r1, #0
  402a38:	4628      	mov	r0, r5
  402a3a:	4b1d      	ldr	r3, [pc, #116]	; (402ab0 <dir_register+0x2d4>)
  402a3c:	4798      	blx	r3
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
  402a3e:	220b      	movs	r2, #11
  402a40:	69a1      	ldr	r1, [r4, #24]
  402a42:	4628      	mov	r0, r5
  402a44:	4b13      	ldr	r3, [pc, #76]	; (402a94 <dir_register+0x2b8>)
  402a46:	4798      	blx	r3
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
  402a48:	69a3      	ldr	r3, [r4, #24]
  402a4a:	7adb      	ldrb	r3, [r3, #11]
  402a4c:	f003 0318 	and.w	r3, r3, #24
  402a50:	732b      	strb	r3, [r5, #12]
			dj->fs->wflag = 1;
  402a52:	6823      	ldr	r3, [r4, #0]
  402a54:	2201      	movs	r2, #1
  402a56:	711a      	strb	r2, [r3, #4]
  402a58:	e742      	b.n	4028e0 <dir_register+0x104>
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402a5a:	f892 e000 	ldrb.w	lr, [r2]
  402a5e:	f800 a00e 	strb.w	sl, [r0, lr]
  402a62:	4486      	add	lr, r0
  402a64:	f88e a001 	strb.w	sl, [lr, #1]
  402a68:	3201      	adds	r2, #1
	} while (++s < 13);
  402a6a:	4542      	cmp	r2, r8
  402a6c:	d099      	beq.n	4029a2 <dir_register+0x1c6>
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  402a6e:	42b3      	cmp	r3, r6
  402a70:	d0f3      	beq.n	402a5a <dir_register+0x27e>
  402a72:	f101 0e01 	add.w	lr, r1, #1
  402a76:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402a7a:	7811      	ldrb	r1, [r2, #0]
  402a7c:	5443      	strb	r3, [r0, r1]
  402a7e:	4401      	add	r1, r0
  402a80:	ea4f 2c13 	mov.w	ip, r3, lsr #8
  402a84:	f881 c001 	strb.w	ip, [r1, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
  402a88:	2b00      	cmp	r3, #0
  402a8a:	d188      	bne.n	40299e <dir_register+0x1c2>
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  402a8c:	4671      	mov	r1, lr
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
  402a8e:	4633      	mov	r3, r6
  402a90:	e7ea      	b.n	402a68 <dir_register+0x28c>
  402a92:	bf00      	nop
  402a94:	00401be5 	.word	0x00401be5
  402a98:	4ec4ec4f 	.word	0x4ec4ec4f
  402a9c:	004021e5 	.word	0x004021e5
  402aa0:	00401c1d 	.word	0x00401c1d
  402aa4:	004024f9 	.word	0x004024f9
  402aa8:	0040206d 	.word	0x0040206d
  402aac:	0040dcf8 	.word	0x0040dcf8
  402ab0:	00401bf9 	.word	0x00401bf9
  402ab4:	00402631 	.word	0x00402631

00402ab8 <dir_read>:
{
  402ab8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402abc:	4604      	mov	r4, r0
	BYTE a, ord = 0xFF, sum = 0xFF;
  402abe:	f04f 09ff 	mov.w	r9, #255	; 0xff
  402ac2:	464e      	mov	r6, r9
	res = FR_NO_FILE;
  402ac4:	2504      	movs	r5, #4
		res = move_window(dj->fs, dj->sect);
  402ac6:	4f40      	ldr	r7, [pc, #256]	; (402bc8 <dir_read+0x110>)
			if (uc != 0xFFFF) return 0;		/* Check filler */
  402ac8:	f64f 78ff 	movw	r8, #65535	; 0xffff
	while (dj->sect) {
  402acc:	e05a      	b.n	402b84 <dir_read+0xcc>
			if (a == AM_LFN) {			/* An LFN entry is found */
  402ace:	290f      	cmp	r1, #15
  402ad0:	d146      	bne.n	402b60 <dir_read+0xa8>
				if (c & LLE) {			/* Is it start of LFN sequence? */
  402ad2:	f013 0f40 	tst.w	r3, #64	; 0x40
  402ad6:	d00b      	beq.n	402af0 <dir_read+0x38>
					sum = dir[LDIR_Chksum];
  402ad8:	f890 900d 	ldrb.w	r9, [r0, #13]
					c &= ~LLE; ord = c;
  402adc:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
					dj->lfn_idx = dj->index;
  402ae0:	88e2      	ldrh	r2, [r4, #6]
  402ae2:	8422      	strh	r2, [r4, #32]
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  402ae4:	f890 e00d 	ldrb.w	lr, [r0, #13]
  402ae8:	45ce      	cmp	lr, r9
  402aea:	d006      	beq.n	402afa <dir_read+0x42>
  402aec:	26ff      	movs	r6, #255	; 0xff
  402aee:	e043      	b.n	402b78 <dir_read+0xc0>
  402af0:	429e      	cmp	r6, r3
  402af2:	bf18      	it	ne
  402af4:	26ff      	movne	r6, #255	; 0xff
  402af6:	d13f      	bne.n	402b78 <dir_read+0xc0>
  402af8:	e7f4      	b.n	402ae4 <dir_read+0x2c>
  402afa:	f8d4 a01c 	ldr.w	sl, [r4, #28]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
  402afe:	7806      	ldrb	r6, [r0, #0]
  402b00:	f006 063f 	and.w	r6, r6, #63	; 0x3f
  402b04:	3e01      	subs	r6, #1
  402b06:	eb06 0246 	add.w	r2, r6, r6, lsl #1
  402b0a:	eb06 0682 	add.w	r6, r6, r2, lsl #2
  402b0e:	492f      	ldr	r1, [pc, #188]	; (402bcc <dir_read+0x114>)
  402b10:	f101 090d 	add.w	r9, r1, #13
	s = 0; wc = 1;
  402b14:	f04f 0c01 	mov.w	ip, #1
  402b18:	e003      	b.n	402b22 <dir_read+0x6a>
			if (uc != 0xFFFF) return 0;		/* Check filler */
  402b1a:	4542      	cmp	r2, r8
  402b1c:	d14b      	bne.n	402bb6 <dir_read+0xfe>
	} while (++s < 13);						/* Read all character in the entry */
  402b1e:	4589      	cmp	r9, r1
  402b20:	d011      	beq.n	402b46 <dir_read+0x8e>
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
  402b22:	f811 5b01 	ldrb.w	r5, [r1], #1
  402b26:	1942      	adds	r2, r0, r5
  402b28:	f892 b001 	ldrb.w	fp, [r2, #1]
  402b2c:	5d42      	ldrb	r2, [r0, r5]
  402b2e:	ea42 220b 	orr.w	r2, r2, fp, lsl #8
		if (wc) {	/* Last char has not been processed */
  402b32:	f1bc 0f00 	cmp.w	ip, #0
  402b36:	d0f0      	beq.n	402b1a <dir_read+0x62>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
  402b38:	2efe      	cmp	r6, #254	; 0xfe
  402b3a:	d83c      	bhi.n	402bb6 <dir_read+0xfe>
			lfnbuf[i++] = wc = uc;			/* Store it */
  402b3c:	f82a 2016 	strh.w	r2, [sl, r6, lsl #1]
  402b40:	4694      	mov	ip, r2
  402b42:	3601      	adds	r6, #1
  402b44:	e7eb      	b.n	402b1e <dir_read+0x66>
	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
  402b46:	7802      	ldrb	r2, [r0, #0]
  402b48:	f012 0f40 	tst.w	r2, #64	; 0x40
  402b4c:	d004      	beq.n	402b58 <dir_read+0xa0>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
  402b4e:	2efe      	cmp	r6, #254	; 0xfe
  402b50:	d831      	bhi.n	402bb6 <dir_read+0xfe>
		lfnbuf[i] = 0;
  402b52:	2200      	movs	r2, #0
  402b54:	f82a 2016 	strh.w	r2, [sl, r6, lsl #1]
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  402b58:	3b01      	subs	r3, #1
  402b5a:	b2de      	uxtb	r6, r3
  402b5c:	46f1      	mov	r9, lr
  402b5e:	e00b      	b.n	402b78 <dir_read+0xc0>
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
  402b60:	b91e      	cbnz	r6, 402b6a <dir_read+0xb2>
  402b62:	4b1b      	ldr	r3, [pc, #108]	; (402bd0 <dir_read+0x118>)
  402b64:	4798      	blx	r3
  402b66:	4581      	cmp	r9, r0
  402b68:	d02b      	beq.n	402bc2 <dir_read+0x10a>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
  402b6a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  402b6e:	8423      	strh	r3, [r4, #32]
  402b70:	e027      	b.n	402bc2 <dir_read+0x10a>
			ord = 0xFF;
  402b72:	26ff      	movs	r6, #255	; 0xff
  402b74:	e000      	b.n	402b78 <dir_read+0xc0>
  402b76:	26ff      	movs	r6, #255	; 0xff
		res = dir_next(dj, 0);				/* Next entry */
  402b78:	2100      	movs	r1, #0
  402b7a:	4620      	mov	r0, r4
  402b7c:	4b15      	ldr	r3, [pc, #84]	; (402bd4 <dir_read+0x11c>)
  402b7e:	4798      	blx	r3
		if (res != FR_OK) break;
  402b80:	4605      	mov	r5, r0
  402b82:	b9e0      	cbnz	r0, 402bbe <dir_read+0x106>
	while (dj->sect) {
  402b84:	6921      	ldr	r1, [r4, #16]
  402b86:	b1a1      	cbz	r1, 402bb2 <dir_read+0xfa>
		res = move_window(dj->fs, dj->sect);
  402b88:	6820      	ldr	r0, [r4, #0]
  402b8a:	47b8      	blx	r7
		if (res != FR_OK) break;
  402b8c:	4605      	mov	r5, r0
  402b8e:	b9b0      	cbnz	r0, 402bbe <dir_read+0x106>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  402b90:	6960      	ldr	r0, [r4, #20]
		c = dir[DIR_Name];
  402b92:	7803      	ldrb	r3, [r0, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  402b94:	b193      	cbz	r3, 402bbc <dir_read+0x104>
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402b96:	2be5      	cmp	r3, #229	; 0xe5
  402b98:	d0eb      	beq.n	402b72 <dir_read+0xba>
  402b9a:	2b2e      	cmp	r3, #46	; 0x2e
  402b9c:	d0eb      	beq.n	402b76 <dir_read+0xbe>
		a = dir[DIR_Attr] & AM_MASK;
  402b9e:	7ac2      	ldrb	r2, [r0, #11]
  402ba0:	f002 013f 	and.w	r1, r2, #63	; 0x3f
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402ba4:	f012 0f08 	tst.w	r2, #8
  402ba8:	d091      	beq.n	402ace <dir_read+0x16>
  402baa:	290f      	cmp	r1, #15
  402bac:	d091      	beq.n	402ad2 <dir_read+0x1a>
			ord = 0xFF;
  402bae:	26ff      	movs	r6, #255	; 0xff
  402bb0:	e7e2      	b.n	402b78 <dir_read+0xc0>
	if (res != FR_OK) dj->sect = 0;
  402bb2:	b135      	cbz	r5, 402bc2 <dir_read+0x10a>
  402bb4:	e003      	b.n	402bbe <dir_read+0x106>
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  402bb6:	46f1      	mov	r9, lr
  402bb8:	26ff      	movs	r6, #255	; 0xff
  402bba:	e7dd      	b.n	402b78 <dir_read+0xc0>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  402bbc:	2504      	movs	r5, #4
	if (res != FR_OK) dj->sect = 0;
  402bbe:	2300      	movs	r3, #0
  402bc0:	6123      	str	r3, [r4, #16]
}
  402bc2:	4628      	mov	r0, r5
  402bc4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402bc8:	0040206d 	.word	0x0040206d
  402bcc:	0040dcf8 	.word	0x0040dcf8
  402bd0:	00401c1d 	.word	0x00401c1d
  402bd4:	004024f9 	.word	0x004024f9

00402bd8 <dir_remove>:
{
  402bd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402bdc:	4604      	mov	r4, r0
	i = dj->index;	/* SFN index */
  402bde:	88c5      	ldrh	r5, [r0, #6]
	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
  402be0:	8c01      	ldrh	r1, [r0, #32]
  402be2:	f64f 73ff 	movw	r3, #65535	; 0xffff
  402be6:	4299      	cmp	r1, r3
  402be8:	bf08      	it	eq
  402bea:	4629      	moveq	r1, r5
  402bec:	4b10      	ldr	r3, [pc, #64]	; (402c30 <dir_remove+0x58>)
  402bee:	4798      	blx	r3
	if (res == FR_OK) {
  402bf0:	4603      	mov	r3, r0
  402bf2:	b9c8      	cbnz	r0, 402c28 <dir_remove+0x50>
			res = move_window(dj->fs, dj->sect);
  402bf4:	4e0f      	ldr	r6, [pc, #60]	; (402c34 <dir_remove+0x5c>)
			*dj->dir = DDE;			/* Mark the entry "deleted" */
  402bf6:	27e5      	movs	r7, #229	; 0xe5
			res = dir_next(dj, 0);		/* Next entry */
  402bf8:	f8df 803c 	ldr.w	r8, [pc, #60]	; 402c38 <dir_remove+0x60>
			res = move_window(dj->fs, dj->sect);
  402bfc:	6921      	ldr	r1, [r4, #16]
  402bfe:	6820      	ldr	r0, [r4, #0]
  402c00:	47b0      	blx	r6
			if (res != FR_OK) break;
  402c02:	4603      	mov	r3, r0
  402c04:	b968      	cbnz	r0, 402c22 <dir_remove+0x4a>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
  402c06:	6962      	ldr	r2, [r4, #20]
  402c08:	7017      	strb	r7, [r2, #0]
			dj->fs->wflag = 1;
  402c0a:	6822      	ldr	r2, [r4, #0]
  402c0c:	2101      	movs	r1, #1
  402c0e:	7111      	strb	r1, [r2, #4]
			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
  402c10:	88e2      	ldrh	r2, [r4, #6]
  402c12:	42aa      	cmp	r2, r5
  402c14:	d208      	bcs.n	402c28 <dir_remove+0x50>
			res = dir_next(dj, 0);		/* Next entry */
  402c16:	2100      	movs	r1, #0
  402c18:	4620      	mov	r0, r4
  402c1a:	47c0      	blx	r8
		} while (res == FR_OK);
  402c1c:	4603      	mov	r3, r0
  402c1e:	2800      	cmp	r0, #0
  402c20:	d0ec      	beq.n	402bfc <dir_remove+0x24>
		if (res == FR_NO_FILE) res = FR_INT_ERR;
  402c22:	2b04      	cmp	r3, #4
  402c24:	bf08      	it	eq
  402c26:	2302      	moveq	r3, #2
}
  402c28:	4618      	mov	r0, r3
  402c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402c2e:	bf00      	nop
  402c30:	004021e5 	.word	0x004021e5
  402c34:	0040206d 	.word	0x0040206d
  402c38:	004024f9 	.word	0x004024f9

00402c3c <sync>:
{
  402c3c:	b570      	push	{r4, r5, r6, lr}
  402c3e:	4604      	mov	r4, r0
	res = move_window(fs, 0);
  402c40:	2100      	movs	r1, #0
  402c42:	4b2d      	ldr	r3, [pc, #180]	; (402cf8 <sync+0xbc>)
  402c44:	4798      	blx	r3
	if (res == FR_OK) {
  402c46:	4603      	mov	r3, r0
  402c48:	b950      	cbnz	r0, 402c60 <sync+0x24>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  402c4a:	7823      	ldrb	r3, [r4, #0]
  402c4c:	2b03      	cmp	r3, #3
  402c4e:	d009      	beq.n	402c64 <sync+0x28>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
  402c50:	2200      	movs	r2, #0
  402c52:	4611      	mov	r1, r2
  402c54:	7860      	ldrb	r0, [r4, #1]
  402c56:	4b29      	ldr	r3, [pc, #164]	; (402cfc <sync+0xc0>)
  402c58:	4798      	blx	r3
	res = move_window(fs, 0);
  402c5a:	1c03      	adds	r3, r0, #0
  402c5c:	bf18      	it	ne
  402c5e:	2301      	movne	r3, #1
}
  402c60:	4618      	mov	r0, r3
  402c62:	bd70      	pop	{r4, r5, r6, pc}
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  402c64:	7963      	ldrb	r3, [r4, #5]
  402c66:	2b00      	cmp	r3, #0
  402c68:	d0f2      	beq.n	402c50 <sync+0x14>
			fs->winsect = 0;
  402c6a:	2600      	movs	r6, #0
  402c6c:	62e6      	str	r6, [r4, #44]	; 0x2c
			mem_set(fs->win, 0, 512);
  402c6e:	f104 0530 	add.w	r5, r4, #48	; 0x30
  402c72:	f44f 7200 	mov.w	r2, #512	; 0x200
  402c76:	4631      	mov	r1, r6
  402c78:	4628      	mov	r0, r5
  402c7a:	4b21      	ldr	r3, [pc, #132]	; (402d00 <sync+0xc4>)
  402c7c:	4798      	blx	r3
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  402c7e:	2355      	movs	r3, #85	; 0x55
  402c80:	f884 322e 	strb.w	r3, [r4, #558]	; 0x22e
  402c84:	23aa      	movs	r3, #170	; 0xaa
  402c86:	f884 322f 	strb.w	r3, [r4, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402c8a:	2352      	movs	r3, #82	; 0x52
  402c8c:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  402c90:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
  402c94:	2361      	movs	r3, #97	; 0x61
  402c96:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
  402c9a:	2241      	movs	r2, #65	; 0x41
  402c9c:	f884 2033 	strb.w	r2, [r4, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  402ca0:	2172      	movs	r1, #114	; 0x72
  402ca2:	f884 1214 	strb.w	r1, [r4, #532]	; 0x214
  402ca6:	f884 1215 	strb.w	r1, [r4, #533]	; 0x215
  402caa:	f884 2216 	strb.w	r2, [r4, #534]	; 0x216
  402cae:	f884 3217 	strb.w	r3, [r4, #535]	; 0x217
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402cb2:	6923      	ldr	r3, [r4, #16]
  402cb4:	f884 3218 	strb.w	r3, [r4, #536]	; 0x218
  402cb8:	f3c3 2207 	ubfx	r2, r3, #8, #8
  402cbc:	f884 2219 	strb.w	r2, [r4, #537]	; 0x219
  402cc0:	0c1a      	lsrs	r2, r3, #16
  402cc2:	f884 221a 	strb.w	r2, [r4, #538]	; 0x21a
  402cc6:	0e1b      	lsrs	r3, r3, #24
  402cc8:	f884 321b 	strb.w	r3, [r4, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402ccc:	68e3      	ldr	r3, [r4, #12]
  402cce:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
  402cd2:	f3c3 2207 	ubfx	r2, r3, #8, #8
  402cd6:	f884 221d 	strb.w	r2, [r4, #541]	; 0x21d
  402cda:	0c1a      	lsrs	r2, r3, #16
  402cdc:	f884 221e 	strb.w	r2, [r4, #542]	; 0x21e
  402ce0:	0e1b      	lsrs	r3, r3, #24
  402ce2:	f884 321f 	strb.w	r3, [r4, #543]	; 0x21f
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  402ce6:	2301      	movs	r3, #1
  402ce8:	6962      	ldr	r2, [r4, #20]
  402cea:	4629      	mov	r1, r5
  402cec:	7860      	ldrb	r0, [r4, #1]
  402cee:	4d05      	ldr	r5, [pc, #20]	; (402d04 <sync+0xc8>)
  402cf0:	47a8      	blx	r5
			fs->fsi_flag = 0;
  402cf2:	7166      	strb	r6, [r4, #5]
  402cf4:	e7ac      	b.n	402c50 <sync+0x14>
  402cf6:	bf00      	nop
  402cf8:	0040206d 	.word	0x0040206d
  402cfc:	00401b1d 	.word	0x00401b1d
  402d00:	00401bf9 	.word	0x00401bf9
  402d04:	00401aad 	.word	0x00401aad

00402d08 <follow_path>:
{
  402d08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402d0c:	b083      	sub	sp, #12
  402d0e:	4682      	mov	sl, r0
  402d10:	4688      	mov	r8, r1
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  402d12:	780b      	ldrb	r3, [r1, #0]
  402d14:	2b2f      	cmp	r3, #47	; 0x2f
  402d16:	d00c      	beq.n	402d32 <follow_path+0x2a>
  402d18:	2b5c      	cmp	r3, #92	; 0x5c
  402d1a:	d00a      	beq.n	402d32 <follow_path+0x2a>
	dj->sclust = 0;						/* Start from the root dir */
  402d1c:	2300      	movs	r3, #0
  402d1e:	f8ca 3008 	str.w	r3, [sl, #8]
	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  402d22:	f898 3000 	ldrb.w	r3, [r8]
  402d26:	2b1f      	cmp	r3, #31
  402d28:	d906      	bls.n	402d38 <follow_path+0x30>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402d2a:	f8df 92f4 	ldr.w	r9, [pc, #756]	; 403020 <follow_path+0x318>
			res = dir_find(dj);				/* Find it */
  402d2e:	4644      	mov	r4, r8
  402d30:	e00c      	b.n	402d4c <follow_path+0x44>
		path++;
  402d32:	f108 0801 	add.w	r8, r8, #1
  402d36:	e7f1      	b.n	402d1c <follow_path+0x14>
		res = dir_sdi(dj, 0);
  402d38:	2100      	movs	r1, #0
  402d3a:	4650      	mov	r0, sl
  402d3c:	4bb2      	ldr	r3, [pc, #712]	; (403008 <follow_path+0x300>)
  402d3e:	4798      	blx	r3
  402d40:	4603      	mov	r3, r0
		dj->dir = 0;
  402d42:	2200      	movs	r2, #0
  402d44:	f8ca 2014 	str.w	r2, [sl, #20]
  402d48:	e12e      	b.n	402fa8 <follow_path+0x2a0>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  402d4a:	461c      	mov	r4, r3
  402d4c:	4627      	mov	r7, r4
  402d4e:	4623      	mov	r3, r4
  402d50:	f813 0b01 	ldrb.w	r0, [r3], #1
  402d54:	282f      	cmp	r0, #47	; 0x2f
  402d56:	d0f8      	beq.n	402d4a <follow_path+0x42>
  402d58:	285c      	cmp	r0, #92	; 0x5c
  402d5a:	bf08      	it	eq
  402d5c:	461c      	moveq	r4, r3
  402d5e:	d0f5      	beq.n	402d4c <follow_path+0x44>
	lfn = dj->lfn;
  402d60:	f8da b01c 	ldr.w	fp, [sl, #28]
		w = p[si++];					/* Get a character */
  402d64:	b280      	uxth	r0, r0
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402d66:	281f      	cmp	r0, #31
  402d68:	f240 812d 	bls.w	402fc6 <follow_path+0x2be>
  402d6c:	282f      	cmp	r0, #47	; 0x2f
  402d6e:	f000 812f 	beq.w	402fd0 <follow_path+0x2c8>
  402d72:	285c      	cmp	r0, #92	; 0x5c
  402d74:	f000 8135 	beq.w	402fe2 <follow_path+0x2da>
  402d78:	f1ab 0602 	sub.w	r6, fp, #2
  402d7c:	2501      	movs	r5, #1
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402d7e:	46a8      	mov	r8, r5
  402d80:	e012      	b.n	402da8 <follow_path+0xa0>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  402d82:	bb73      	cbnz	r3, 402de2 <follow_path+0xda>
		lfn[di++] = w;					/* Store the Unicode char */
  402d84:	f826 2f02 	strh.w	r2, [r6, #2]!
		w = p[si++];					/* Get a character */
  402d88:	1c6b      	adds	r3, r5, #1
  402d8a:	f814 0f01 	ldrb.w	r0, [r4, #1]!
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402d8e:	281f      	cmp	r0, #31
  402d90:	f240 811b 	bls.w	402fca <follow_path+0x2c2>
  402d94:	282f      	cmp	r0, #47	; 0x2f
  402d96:	f000 811d 	beq.w	402fd4 <follow_path+0x2cc>
  402d9a:	285c      	cmp	r0, #92	; 0x5c
  402d9c:	f000 811a 	beq.w	402fd4 <follow_path+0x2cc>
		if (di >= _MAX_LFN)				/* Reject too long name */
  402da0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  402da4:	d01d      	beq.n	402de2 <follow_path+0xda>
		w = p[si++];					/* Get a character */
  402da6:	461d      	mov	r5, r3
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402da8:	4641      	mov	r1, r8
  402daa:	47c8      	blx	r9
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  402dac:	4602      	mov	r2, r0
  402dae:	b1c0      	cbz	r0, 402de2 <follow_path+0xda>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  402db0:	287f      	cmp	r0, #127	; 0x7f
  402db2:	d8e7      	bhi.n	402d84 <follow_path+0x7c>
	while (*str && *str != chr) str++;
  402db4:	2822      	cmp	r0, #34	; 0x22
  402db6:	f000 80f6 	beq.w	402fa6 <follow_path+0x29e>
  402dba:	232a      	movs	r3, #42	; 0x2a
  402dbc:	4993      	ldr	r1, [pc, #588]	; (40300c <follow_path+0x304>)
  402dbe:	b298      	uxth	r0, r3
  402dc0:	4290      	cmp	r0, r2
  402dc2:	d0de      	beq.n	402d82 <follow_path+0x7a>
  402dc4:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  402dc8:	2b00      	cmp	r3, #0
  402dca:	d1f8      	bne.n	402dbe <follow_path+0xb6>
  402dcc:	e7da      	b.n	402d84 <follow_path+0x7c>
	while (di) {						/* Strip trailing spaces and dots */
  402dce:	3d01      	subs	r5, #1
  402dd0:	f000 80e9 	beq.w	402fa6 <follow_path+0x29e>
		w = lfn[di-1];
  402dd4:	f832 3d02 	ldrh.w	r3, [r2, #-2]!
		if (w != ' ' && w != '.') break;
  402dd8:	2b20      	cmp	r3, #32
  402dda:	d0f8      	beq.n	402dce <follow_path+0xc6>
  402ddc:	2b2e      	cmp	r3, #46	; 0x2e
  402dde:	d0f6      	beq.n	402dce <follow_path+0xc6>
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
  402de0:	b90d      	cbnz	r5, 402de6 <follow_path+0xde>
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  402de2:	2306      	movs	r3, #6
	return res;
  402de4:	e0e0      	b.n	402fa8 <follow_path+0x2a0>
	lfn[di] = 0;						/* LFN is created */
  402de6:	006f      	lsls	r7, r5, #1
  402de8:	f04f 0800 	mov.w	r8, #0
  402dec:	f82b 8015 	strh.w	r8, [fp, r5, lsl #1]
	mem_set(dj->fn, ' ', 11);
  402df0:	220b      	movs	r2, #11
  402df2:	2120      	movs	r1, #32
  402df4:	f8da 0018 	ldr.w	r0, [sl, #24]
  402df8:	4b85      	ldr	r3, [pc, #532]	; (403010 <follow_path+0x308>)
  402dfa:	4798      	blx	r3
  402dfc:	f1ab 0102 	sub.w	r1, fp, #2
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  402e00:	4643      	mov	r3, r8
  402e02:	e000      	b.n	402e06 <follow_path+0xfe>
  402e04:	3301      	adds	r3, #1
  402e06:	f831 2f02 	ldrh.w	r2, [r1, #2]!
  402e0a:	2a20      	cmp	r2, #32
  402e0c:	d0fa      	beq.n	402e04 <follow_path+0xfc>
  402e0e:	2a2e      	cmp	r2, #46	; 0x2e
  402e10:	d0f8      	beq.n	402e04 <follow_path+0xfc>
	if (si) cf |= NS_LOSS | NS_LFN;
  402e12:	b10b      	cbz	r3, 402e18 <follow_path+0x110>
  402e14:	f046 0603 	orr.w	r6, r6, #3
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  402e18:	3f02      	subs	r7, #2
  402e1a:	eb0b 0207 	add.w	r2, fp, r7
  402e1e:	f83b 1007 	ldrh.w	r1, [fp, r7]
  402e22:	292e      	cmp	r1, #46	; 0x2e
  402e24:	d005      	beq.n	402e32 <follow_path+0x12a>
  402e26:	3d01      	subs	r5, #1
  402e28:	d003      	beq.n	402e32 <follow_path+0x12a>
  402e2a:	f832 1d02 	ldrh.w	r1, [r2, #-2]!
  402e2e:	292e      	cmp	r1, #46	; 0x2e
  402e30:	d1f9      	bne.n	402e26 <follow_path+0x11e>
		dj->fn[i++] = (BYTE)w;
  402e32:	2208      	movs	r2, #8
  402e34:	9200      	str	r2, [sp, #0]
  402e36:	f04f 0800 	mov.w	r8, #0
  402e3a:	f8cd 8004 	str.w	r8, [sp, #4]
  402e3e:	e005      	b.n	402e4c <follow_path+0x144>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  402e40:	42af      	cmp	r7, r5
  402e42:	f000 80d1 	beq.w	402fe8 <follow_path+0x2e0>
			cf |= NS_LOSS | NS_LFN; continue;
  402e46:	f046 0603 	orr.w	r6, r6, #3
		w = lfn[si++];					/* Get an LFN char */
  402e4a:	463b      	mov	r3, r7
  402e4c:	1c5f      	adds	r7, r3, #1
  402e4e:	f83b 0013 	ldrh.w	r0, [fp, r3, lsl #1]
		if (!w) break;					/* Break on end of the LFN */
  402e52:	b350      	cbz	r0, 402eaa <follow_path+0x1a2>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  402e54:	2820      	cmp	r0, #32
  402e56:	d0f6      	beq.n	402e46 <follow_path+0x13e>
  402e58:	282e      	cmp	r0, #46	; 0x2e
  402e5a:	d0f1      	beq.n	402e40 <follow_path+0x138>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
  402e5c:	9b00      	ldr	r3, [sp, #0]
  402e5e:	4598      	cmp	r8, r3
  402e60:	d219      	bcs.n	402e96 <follow_path+0x18e>
  402e62:	42af      	cmp	r7, r5
  402e64:	f000 80c0 	beq.w	402fe8 <follow_path+0x2e0>
		if (w >= 0x80) {				/* Non ASCII char */
  402e68:	287f      	cmp	r0, #127	; 0x7f
  402e6a:	d86c      	bhi.n	402f46 <follow_path+0x23e>
	while (*str && *str != chr) str++;
  402e6c:	282b      	cmp	r0, #43	; 0x2b
  402e6e:	d079      	beq.n	402f64 <follow_path+0x25c>
  402e70:	232c      	movs	r3, #44	; 0x2c
  402e72:	4a68      	ldr	r2, [pc, #416]	; (403014 <follow_path+0x30c>)
  402e74:	b299      	uxth	r1, r3
  402e76:	4281      	cmp	r1, r0
  402e78:	d072      	beq.n	402f60 <follow_path+0x258>
  402e7a:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  402e7e:	2b00      	cmp	r3, #0
  402e80:	d1f8      	bne.n	402e74 <follow_path+0x16c>
				if (IsUpper(w)) {		/* ASCII large capital */
  402e82:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
  402e86:	b29b      	uxth	r3, r3
  402e88:	2b19      	cmp	r3, #25
  402e8a:	d876      	bhi.n	402f7a <follow_path+0x272>
					b |= 2;
  402e8c:	9b01      	ldr	r3, [sp, #4]
  402e8e:	f043 0302 	orr.w	r3, r3, #2
  402e92:	9301      	str	r3, [sp, #4]
  402e94:	e069      	b.n	402f6a <follow_path+0x262>
			if (ni == 11) {				/* Long extension */
  402e96:	9b00      	ldr	r3, [sp, #0]
  402e98:	2b0b      	cmp	r3, #11
  402e9a:	d048      	beq.n	402f2e <follow_path+0x226>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  402e9c:	42af      	cmp	r7, r5
  402e9e:	f000 80a6 	beq.w	402fee <follow_path+0x2e6>
  402ea2:	f046 0603 	orr.w	r6, r6, #3
			if (si > di) break;			/* No extension */
  402ea6:	f240 80a2 	bls.w	402fee <follow_path+0x2e6>
	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  402eaa:	f8da 3018 	ldr.w	r3, [sl, #24]
  402eae:	781a      	ldrb	r2, [r3, #0]
  402eb0:	2ae5      	cmp	r2, #229	; 0xe5
  402eb2:	d045      	beq.n	402f40 <follow_path+0x238>
	if (ni == 8) b <<= 2;
  402eb4:	9b00      	ldr	r3, [sp, #0]
  402eb6:	2b08      	cmp	r3, #8
  402eb8:	d06b      	beq.n	402f92 <follow_path+0x28a>
  402eba:	9a01      	ldr	r2, [sp, #4]
  402ebc:	f002 030c 	and.w	r3, r2, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
  402ec0:	2b0c      	cmp	r3, #12
  402ec2:	d06d      	beq.n	402fa0 <follow_path+0x298>
  402ec4:	f002 0203 	and.w	r2, r2, #3
  402ec8:	2a03      	cmp	r2, #3
  402eca:	d069      	beq.n	402fa0 <follow_path+0x298>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
  402ecc:	f016 0f02 	tst.w	r6, #2
  402ed0:	d10b      	bne.n	402eea <follow_path+0x1e2>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  402ed2:	9a01      	ldr	r2, [sp, #4]
  402ed4:	f002 0b03 	and.w	fp, r2, #3
  402ed8:	f1bb 0f01 	cmp.w	fp, #1
  402edc:	bf08      	it	eq
  402ede:	f046 0610 	orreq.w	r6, r6, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  402ee2:	2b04      	cmp	r3, #4
  402ee4:	bf08      	it	eq
  402ee6:	f046 0608 	orreq.w	r6, r6, #8
	dj->fn[NS] = cf;	/* SFN is created */
  402eea:	f8da 3018 	ldr.w	r3, [sl, #24]
  402eee:	72de      	strb	r6, [r3, #11]
			res = dir_find(dj);				/* Find it */
  402ef0:	4650      	mov	r0, sl
  402ef2:	4b49      	ldr	r3, [pc, #292]	; (403018 <follow_path+0x310>)
  402ef4:	4798      	blx	r3
			ns = *(dj->fn+NS);
  402ef6:	f8da 3018 	ldr.w	r3, [sl, #24]
  402efa:	7ada      	ldrb	r2, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
  402efc:	4603      	mov	r3, r0
  402efe:	2800      	cmp	r0, #0
  402f00:	d156      	bne.n	402fb0 <follow_path+0x2a8>
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  402f02:	f012 0f04 	tst.w	r2, #4
  402f06:	d14f      	bne.n	402fa8 <follow_path+0x2a0>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
  402f08:	f8da 2014 	ldr.w	r2, [sl, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  402f0c:	7ad3      	ldrb	r3, [r2, #11]
  402f0e:	f013 0f10 	tst.w	r3, #16
  402f12:	d056      	beq.n	402fc2 <follow_path+0x2ba>
			dj->sclust = LD_CLUST(dir);
  402f14:	7d51      	ldrb	r1, [r2, #21]
  402f16:	7d13      	ldrb	r3, [r2, #20]
  402f18:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  402f1c:	7ed0      	ldrb	r0, [r2, #27]
  402f1e:	7e93      	ldrb	r3, [r2, #26]
  402f20:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  402f24:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  402f28:	f8ca 3008 	str.w	r3, [sl, #8]
			res = create_name(dj, &path);	/* Get a segment */
  402f2c:	e70e      	b.n	402d4c <follow_path+0x44>
				cf |= NS_LOSS | NS_LFN; break;
  402f2e:	f046 0603 	orr.w	r6, r6, #3
	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  402f32:	f8da 3018 	ldr.w	r3, [sl, #24]
  402f36:	781a      	ldrb	r2, [r3, #0]
  402f38:	2ae5      	cmp	r2, #229	; 0xe5
  402f3a:	d1be      	bne.n	402eba <follow_path+0x1b2>
  402f3c:	220b      	movs	r2, #11
  402f3e:	9200      	str	r2, [sp, #0]
  402f40:	2205      	movs	r2, #5
  402f42:	701a      	strb	r2, [r3, #0]
  402f44:	e7b6      	b.n	402eb4 <follow_path+0x1ac>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  402f46:	2100      	movs	r1, #0
  402f48:	47c8      	blx	r9
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  402f4a:	4603      	mov	r3, r0
  402f4c:	2800      	cmp	r0, #0
  402f4e:	d058      	beq.n	403002 <follow_path+0x2fa>
  402f50:	4a32      	ldr	r2, [pc, #200]	; (40301c <follow_path+0x314>)
  402f52:	4413      	add	r3, r2
  402f54:	f813 0c80 	ldrb.w	r0, [r3, #-128]
			cf |= NS_LFN;				/* Force create LFN entry */
  402f58:	f046 0602 	orr.w	r6, r6, #2
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  402f5c:	b110      	cbz	r0, 402f64 <follow_path+0x25c>
  402f5e:	e785      	b.n	402e6c <follow_path+0x164>
  402f60:	2b00      	cmp	r3, #0
  402f62:	d08e      	beq.n	402e82 <follow_path+0x17a>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  402f64:	f046 0603 	orr.w	r6, r6, #3
  402f68:	205f      	movs	r0, #95	; 0x5f
		dj->fn[i++] = (BYTE)w;
  402f6a:	f8da 3018 	ldr.w	r3, [sl, #24]
  402f6e:	f803 0008 	strb.w	r0, [r3, r8]
		w = lfn[si++];					/* Get an LFN char */
  402f72:	463b      	mov	r3, r7
		dj->fn[i++] = (BYTE)w;
  402f74:	f108 0801 	add.w	r8, r8, #1
  402f78:	e768      	b.n	402e4c <follow_path+0x144>
					if (IsLower(w)) {	/* ASCII small capital */
  402f7a:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
  402f7e:	b29b      	uxth	r3, r3
  402f80:	2b19      	cmp	r3, #25
  402f82:	d8f2      	bhi.n	402f6a <follow_path+0x262>
						b |= 1; w -= 0x20;
  402f84:	9b01      	ldr	r3, [sp, #4]
  402f86:	f043 0301 	orr.w	r3, r3, #1
  402f8a:	9301      	str	r3, [sp, #4]
  402f8c:	3820      	subs	r0, #32
  402f8e:	b280      	uxth	r0, r0
  402f90:	e7eb      	b.n	402f6a <follow_path+0x262>
	if (ni == 8) b <<= 2;
  402f92:	9b01      	ldr	r3, [sp, #4]
  402f94:	ea4f 0b83 	mov.w	fp, r3, lsl #2
  402f98:	fa5f f38b 	uxtb.w	r3, fp
  402f9c:	9301      	str	r3, [sp, #4]
  402f9e:	e78c      	b.n	402eba <follow_path+0x1b2>
		cf |= NS_LFN;
  402fa0:	f046 0602 	orr.w	r6, r6, #2
  402fa4:	e792      	b.n	402ecc <follow_path+0x1c4>
  402fa6:	2306      	movs	r3, #6
}
  402fa8:	4618      	mov	r0, r3
  402faa:	b003      	add	sp, #12
  402fac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  402fb0:	2804      	cmp	r0, #4
  402fb2:	d1f9      	bne.n	402fa8 <follow_path+0x2a0>
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  402fb4:	f002 0204 	and.w	r2, r2, #4
  402fb8:	2a00      	cmp	r2, #0
  402fba:	bf14      	ite	ne
  402fbc:	4603      	movne	r3, r0
  402fbe:	2305      	moveq	r3, #5
  402fc0:	e7f2      	b.n	402fa8 <follow_path+0x2a0>
				res = FR_NO_PATH; break;
  402fc2:	2305      	movs	r3, #5
  402fc4:	e7f0      	b.n	402fa8 <follow_path+0x2a0>
		w = p[si++];					/* Get a character */
  402fc6:	2301      	movs	r3, #1
	si = di = 0;
  402fc8:	2500      	movs	r5, #0
	*path = &p[si];						/* Return pointer to the next segment */
  402fca:	18fc      	adds	r4, r7, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  402fcc:	2604      	movs	r6, #4
  402fce:	e003      	b.n	402fd8 <follow_path+0x2d0>
		w = p[si++];					/* Get a character */
  402fd0:	2301      	movs	r3, #1
	si = di = 0;
  402fd2:	2500      	movs	r5, #0
	*path = &p[si];						/* Return pointer to the next segment */
  402fd4:	18fc      	adds	r4, r7, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  402fd6:	2600      	movs	r6, #0
	while (di) {						/* Strip trailing spaces and dots */
  402fd8:	2d00      	cmp	r5, #0
  402fda:	d0e4      	beq.n	402fa6 <follow_path+0x29e>
  402fdc:	eb0b 0245 	add.w	r2, fp, r5, lsl #1
  402fe0:	e6f8      	b.n	402dd4 <follow_path+0xcc>
		w = p[si++];					/* Get a character */
  402fe2:	2301      	movs	r3, #1
	si = di = 0;
  402fe4:	2500      	movs	r5, #0
  402fe6:	e7f5      	b.n	402fd4 <follow_path+0x2cc>
			if (ni == 11) {				/* Long extension */
  402fe8:	9b00      	ldr	r3, [sp, #0]
  402fea:	2b0b      	cmp	r3, #11
  402fec:	d09f      	beq.n	402f2e <follow_path+0x226>
			b <<= 2; continue;
  402fee:	9b01      	ldr	r3, [sp, #4]
  402ff0:	009b      	lsls	r3, r3, #2
  402ff2:	b2db      	uxtb	r3, r3
  402ff4:	9301      	str	r3, [sp, #4]
  402ff6:	462b      	mov	r3, r5
			si = di; i = 8; ni = 11;	/* Enter extension section */
  402ff8:	220b      	movs	r2, #11
  402ffa:	9200      	str	r2, [sp, #0]
  402ffc:	f04f 0808 	mov.w	r8, #8
  403000:	e724      	b.n	402e4c <follow_path+0x144>
			cf |= NS_LFN;				/* Force create LFN entry */
  403002:	f046 0602 	orr.w	r6, r6, #2
  403006:	e7ad      	b.n	402f64 <follow_path+0x25c>
  403008:	004021e5 	.word	0x004021e5
  40300c:	0040dd89 	.word	0x0040dd89
  403010:	00401bf9 	.word	0x00401bf9
  403014:	0040dd95 	.word	0x0040dd95
  403018:	00402631 	.word	0x00402631
  40301c:	0040dd08 	.word	0x0040dd08
  403020:	0040381d 	.word	0x0040381d

00403024 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  403024:	2807      	cmp	r0, #7
  403026:	d901      	bls.n	40302c <f_mount+0x8>
		return FR_INVALID_DRIVE;
  403028:	200b      	movs	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
  40302a:	4770      	bx	lr
	rfs = FatFs[vol];			/* Get current fs object */
  40302c:	4b06      	ldr	r3, [pc, #24]	; (403048 <f_mount+0x24>)
  40302e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
	if (rfs) {
  403032:	b10b      	cbz	r3, 403038 <f_mount+0x14>
		rfs->fs_type = 0;		/* Clear old fs object */
  403034:	2200      	movs	r2, #0
  403036:	701a      	strb	r2, [r3, #0]
	if (fs) {
  403038:	b109      	cbz	r1, 40303e <f_mount+0x1a>
		fs->fs_type = 0;		/* Clear new fs object */
  40303a:	2300      	movs	r3, #0
  40303c:	700b      	strb	r3, [r1, #0]
	FatFs[vol] = fs;			/* Register new fs object */
  40303e:	4b02      	ldr	r3, [pc, #8]	; (403048 <f_mount+0x24>)
  403040:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
	return FR_OK;
  403044:	2000      	movs	r0, #0
  403046:	4770      	bx	lr
  403048:	20007550 	.word	0x20007550

0040304c <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  40304c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  403050:	f5ad 7d0e 	sub.w	sp, sp, #568	; 0x238
  403054:	4605      	mov	r5, r0
  403056:	9101      	str	r1, [sp, #4]
  403058:	4616      	mov	r6, r2
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  40305a:	2300      	movs	r3, #0
  40305c:	6003      	str	r3, [r0, #0]

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  40305e:	f002 071f 	and.w	r7, r2, #31
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  403062:	f002 021e 	and.w	r2, r2, #30
  403066:	a985      	add	r1, sp, #532	; 0x214
  403068:	a801      	add	r0, sp, #4
  40306a:	4b58      	ldr	r3, [pc, #352]	; (4031cc <f_open+0x180>)
  40306c:	4798      	blx	r3
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
  40306e:	ab82      	add	r3, sp, #520	; 0x208
  403070:	938b      	str	r3, [sp, #556]	; 0x22c
  403072:	ab02      	add	r3, sp, #8
  403074:	938c      	str	r3, [sp, #560]	; 0x230
	if (res == FR_OK)
  403076:	b140      	cbz	r0, 40308a <f_open+0x3e>
  403078:	4603      	mov	r3, r0
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
  40307a:	9c8a      	ldr	r4, [sp, #552]	; 0x228
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  40307c:	f016 0f1c 	tst.w	r6, #28
  403080:	d117      	bne.n	4030b2 <f_open+0x66>
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
  403082:	2b00      	cmp	r3, #0
  403084:	f040 8092 	bne.w	4031ac <f_open+0x160>
  403088:	e00d      	b.n	4030a6 <f_open+0x5a>
		res = follow_path(&dj, path);	/* Follow the file path */
  40308a:	9901      	ldr	r1, [sp, #4]
  40308c:	a885      	add	r0, sp, #532	; 0x214
  40308e:	4b50      	ldr	r3, [pc, #320]	; (4031d0 <f_open+0x184>)
  403090:	4798      	blx	r3
	dir = dj.dir;
  403092:	9c8a      	ldr	r4, [sp, #552]	; 0x228
	if (res == FR_OK) {
  403094:	4603      	mov	r3, r0
  403096:	2800      	cmp	r0, #0
  403098:	d1f0      	bne.n	40307c <f_open+0x30>
		if (!dir)	/* Current dir itself */
  40309a:	2c00      	cmp	r4, #0
  40309c:	f000 808b 	beq.w	4031b6 <f_open+0x16a>
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  4030a0:	f016 0f1c 	tst.w	r6, #28
  4030a4:	d116      	bne.n	4030d4 <f_open+0x88>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
  4030a6:	7ae3      	ldrb	r3, [r4, #11]
  4030a8:	f013 0f10 	tst.w	r3, #16
  4030ac:	d04f      	beq.n	40314e <f_open+0x102>
				res = FR_NO_FILE;
  4030ae:	2304      	movs	r3, #4
  4030b0:	e07c      	b.n	4031ac <f_open+0x160>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
  4030b2:	2b04      	cmp	r3, #4
  4030b4:	d005      	beq.n	4030c2 <f_open+0x76>
			mode |= FA_CREATE_ALWAYS;		/* File is created */
  4030b6:	f047 0708 	orr.w	r7, r7, #8
			dir = dj.dir;					/* New entry */
  4030ba:	9c8a      	ldr	r4, [sp, #552]	; 0x228
		}
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
  4030bc:	2b00      	cmp	r3, #0
  4030be:	d057      	beq.n	403170 <f_open+0x124>
  4030c0:	e074      	b.n	4031ac <f_open+0x160>
				res = dir_register(&dj);
  4030c2:	a885      	add	r0, sp, #532	; 0x214
  4030c4:	4b43      	ldr	r3, [pc, #268]	; (4031d4 <f_open+0x188>)
  4030c6:	4798      	blx	r3
			mode |= FA_CREATE_ALWAYS;		/* File is created */
  4030c8:	f047 0708 	orr.w	r7, r7, #8
			dir = dj.dir;					/* New entry */
  4030cc:	9c8a      	ldr	r4, [sp, #552]	; 0x228
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  4030ce:	4603      	mov	r3, r0
  4030d0:	b138      	cbz	r0, 4030e2 <f_open+0x96>
  4030d2:	e06b      	b.n	4031ac <f_open+0x160>
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  4030d4:	7ae3      	ldrb	r3, [r4, #11]
  4030d6:	f013 0f11 	tst.w	r3, #17
  4030da:	d173      	bne.n	4031c4 <f_open+0x178>
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
  4030dc:	f016 0f04 	tst.w	r6, #4
  4030e0:	d172      	bne.n	4031c8 <f_open+0x17c>
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  4030e2:	f017 0f08 	tst.w	r7, #8
  4030e6:	d03f      	beq.n	403168 <f_open+0x11c>
			dw = get_fattime();					/* Created time */
  4030e8:	4b3b      	ldr	r3, [pc, #236]	; (4031d8 <f_open+0x18c>)
  4030ea:	4798      	blx	r3
			ST_DWORD(dir+DIR_CrtTime, dw);
  4030ec:	73a0      	strb	r0, [r4, #14]
  4030ee:	f3c0 2307 	ubfx	r3, r0, #8, #8
  4030f2:	73e3      	strb	r3, [r4, #15]
  4030f4:	0c03      	lsrs	r3, r0, #16
  4030f6:	7423      	strb	r3, [r4, #16]
  4030f8:	0e00      	lsrs	r0, r0, #24
  4030fa:	7460      	strb	r0, [r4, #17]
			dir[DIR_Attr] = 0;					/* Reset attribute */
  4030fc:	2300      	movs	r3, #0
  4030fe:	72e3      	strb	r3, [r4, #11]
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
  403100:	7723      	strb	r3, [r4, #28]
  403102:	7763      	strb	r3, [r4, #29]
  403104:	77a3      	strb	r3, [r4, #30]
  403106:	77e3      	strb	r3, [r4, #31]
			cl = LD_CLUST(dir);					/* Get start cluster */
  403108:	7d62      	ldrb	r2, [r4, #21]
  40310a:	7d26      	ldrb	r6, [r4, #20]
  40310c:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
  403110:	7ee1      	ldrb	r1, [r4, #27]
  403112:	7ea2      	ldrb	r2, [r4, #26]
  403114:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
			ST_CLUST(dir, 0);					/* cluster = 0 */
  403118:	76a3      	strb	r3, [r4, #26]
  40311a:	76e3      	strb	r3, [r4, #27]
  40311c:	7523      	strb	r3, [r4, #20]
  40311e:	7563      	strb	r3, [r4, #21]
			dj.fs->wflag = 1;
  403120:	9885      	ldr	r0, [sp, #532]	; 0x214
  403122:	2301      	movs	r3, #1
  403124:	7103      	strb	r3, [r0, #4]
			if (cl) {							/* Remove the cluster chain if exist */
  403126:	ea52 4606 	orrs.w	r6, r2, r6, lsl #16
  40312a:	d01b      	beq.n	403164 <f_open+0x118>
				dw = dj.fs->winsect;
  40312c:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
				res = remove_chain(dj.fs, cl);
  403130:	4631      	mov	r1, r6
  403132:	4b2a      	ldr	r3, [pc, #168]	; (4031dc <f_open+0x190>)
  403134:	4798      	blx	r3
				if (res == FR_OK) {
  403136:	4603      	mov	r3, r0
  403138:	2800      	cmp	r0, #0
  40313a:	d137      	bne.n	4031ac <f_open+0x160>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  40313c:	9885      	ldr	r0, [sp, #532]	; 0x214
  40313e:	3e01      	subs	r6, #1
  403140:	60c6      	str	r6, [r0, #12]
					res = move_window(dj.fs, dw);
  403142:	4641      	mov	r1, r8
  403144:	4b26      	ldr	r3, [pc, #152]	; (4031e0 <f_open+0x194>)
  403146:	4798      	blx	r3
	if (res == FR_OK) {
  403148:	4603      	mov	r3, r0
  40314a:	b158      	cbz	r0, 403164 <f_open+0x118>
  40314c:	e02e      	b.n	4031ac <f_open+0x160>
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
  40314e:	f016 0f02 	tst.w	r6, #2
  403152:	d004      	beq.n	40315e <f_open+0x112>
  403154:	f013 0f01 	tst.w	r3, #1
  403158:	d001      	beq.n	40315e <f_open+0x112>
					res = FR_DENIED;
  40315a:	2307      	movs	r3, #7
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
  40315c:	e026      	b.n	4031ac <f_open+0x160>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
  40315e:	f016 0f08 	tst.w	r6, #8
  403162:	d001      	beq.n	403168 <f_open+0x11c>
			mode |= FA__WRITTEN;
  403164:	f047 0720 	orr.w	r7, r7, #32
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  403168:	9b85      	ldr	r3, [sp, #532]	; 0x214
  40316a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40316c:	61eb      	str	r3, [r5, #28]
		fp->dir_ptr = dir;
  40316e:	622c      	str	r4, [r5, #32]
		fp->flag = mode;					/* File access mode */
  403170:	71af      	strb	r7, [r5, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  403172:	7d62      	ldrb	r2, [r4, #21]
  403174:	7d23      	ldrb	r3, [r4, #20]
  403176:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
  40317a:	7ee1      	ldrb	r1, [r4, #27]
  40317c:	7ea3      	ldrb	r3, [r4, #26]
  40317e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  403182:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  403186:	612b      	str	r3, [r5, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  403188:	7fe2      	ldrb	r2, [r4, #31]
  40318a:	7fa3      	ldrb	r3, [r4, #30]
  40318c:	041b      	lsls	r3, r3, #16
  40318e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  403192:	7f22      	ldrb	r2, [r4, #28]
  403194:	4313      	orrs	r3, r2
  403196:	7f62      	ldrb	r2, [r4, #29]
  403198:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  40319c:	60eb      	str	r3, [r5, #12]
		fp->fptr = 0;						/* File pointer */
  40319e:	2300      	movs	r3, #0
  4031a0:	60ab      	str	r3, [r5, #8]
		fp->dsect = 0;
  4031a2:	61ab      	str	r3, [r5, #24]
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  4031a4:	9a85      	ldr	r2, [sp, #532]	; 0x214
  4031a6:	602a      	str	r2, [r5, #0]
  4031a8:	88d2      	ldrh	r2, [r2, #6]
  4031aa:	80aa      	strh	r2, [r5, #4]
}
  4031ac:	4618      	mov	r0, r3
  4031ae:	f50d 7d0e 	add.w	sp, sp, #568	; 0x238
  4031b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  4031b6:	f016 0f1c 	tst.w	r6, #28
  4031ba:	d101      	bne.n	4031c0 <f_open+0x174>
			res = FR_INVALID_NAME;
  4031bc:	2306      	movs	r3, #6
  4031be:	e77d      	b.n	4030bc <f_open+0x70>
  4031c0:	2306      	movs	r3, #6
  4031c2:	e778      	b.n	4030b6 <f_open+0x6a>
				res = FR_DENIED;
  4031c4:	2307      	movs	r3, #7
  4031c6:	e7f1      	b.n	4031ac <f_open+0x160>
					res = FR_EXIST;
  4031c8:	2308      	movs	r3, #8
  4031ca:	e7ef      	b.n	4031ac <f_open+0x160>
  4031cc:	00401d01 	.word	0x00401d01
  4031d0:	00402d09 	.word	0x00402d09
  4031d4:	004027dd 	.word	0x004027dd
  4031d8:	00401b8d 	.word	0x00401b8d
  4031dc:	0040247d 	.word	0x0040247d
  4031e0:	0040206d 	.word	0x0040206d

004031e4 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  4031e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4031e8:	b083      	sub	sp, #12
  4031ea:	4604      	mov	r4, r0
  4031ec:	4689      	mov	r9, r1
  4031ee:	4615      	mov	r5, r2
  4031f0:	4698      	mov	r8, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  4031f2:	2300      	movs	r3, #0
  4031f4:	f8c8 3000 	str.w	r3, [r8]

	res = validate(fp->fs, fp->id);				/* Check validity */
  4031f8:	8881      	ldrh	r1, [r0, #4]
  4031fa:	6800      	ldr	r0, [r0, #0]
  4031fc:	4b58      	ldr	r3, [pc, #352]	; (403360 <f_read+0x17c>)
  4031fe:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  403200:	9001      	str	r0, [sp, #4]
  403202:	2800      	cmp	r0, #0
  403204:	f040 80a8 	bne.w	403358 <f_read+0x174>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  403208:	79a3      	ldrb	r3, [r4, #6]
  40320a:	f013 0f80 	tst.w	r3, #128	; 0x80
  40320e:	f040 80a1 	bne.w	403354 <f_read+0x170>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  403212:	f013 0f01 	tst.w	r3, #1
  403216:	d102      	bne.n	40321e <f_read+0x3a>
		LEAVE_FF(fp->fs, FR_DENIED);
  403218:	2307      	movs	r3, #7
  40321a:	9301      	str	r3, [sp, #4]
  40321c:	e09c      	b.n	403358 <f_read+0x174>
	remain = fp->fsize - fp->fptr;
  40321e:	68e6      	ldr	r6, [r4, #12]
  403220:	68a3      	ldr	r3, [r4, #8]
  403222:	1af6      	subs	r6, r6, r3
  403224:	42ae      	cmp	r6, r5
  403226:	bf28      	it	cs
  403228:	462e      	movcs	r6, r5
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  40322a:	2e00      	cmp	r6, #0
  40322c:	d14c      	bne.n	4032c8 <f_read+0xe4>
  40322e:	e093      	b.n	403358 <f_read+0x174>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  403230:	6961      	ldr	r1, [r4, #20]
  403232:	4b4c      	ldr	r3, [pc, #304]	; (403364 <f_read+0x180>)
  403234:	4798      	blx	r3
  403236:	e057      	b.n	4032e8 <f_read+0x104>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  403238:	79a3      	ldrb	r3, [r4, #6]
  40323a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40323e:	71a3      	strb	r3, [r4, #6]
  403240:	2302      	movs	r3, #2
  403242:	9301      	str	r3, [sp, #4]
  403244:	e088      	b.n	403358 <f_read+0x174>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  403246:	79a3      	ldrb	r3, [r4, #6]
  403248:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40324c:	71a3      	strb	r3, [r4, #6]
  40324e:	2301      	movs	r3, #1
  403250:	9301      	str	r3, [sp, #4]
  403252:	e081      	b.n	403358 <f_read+0x174>
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403254:	79a3      	ldrb	r3, [r4, #6]
  403256:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40325a:	71a3      	strb	r3, [r4, #6]
  40325c:	2302      	movs	r3, #2
  40325e:	9301      	str	r3, [sp, #4]
  403260:	e07a      	b.n	403358 <f_read+0x174>
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
					cc = fp->fs->csize - csect;
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
  403262:	79a3      	ldrb	r3, [r4, #6]
  403264:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403268:	71a3      	strb	r3, [r4, #6]
  40326a:	2301      	movs	r3, #1
  40326c:	9301      	str	r3, [sp, #4]
  40326e:	e073      	b.n	403358 <f_read+0x174>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
  403270:	f44f 7200 	mov.w	r2, #512	; 0x200
  403274:	3130      	adds	r1, #48	; 0x30
  403276:	eb09 2040 	add.w	r0, r9, r0, lsl #9
  40327a:	4b3b      	ldr	r3, [pc, #236]	; (403368 <f_read+0x184>)
  40327c:	4798      	blx	r3
  40327e:	e05f      	b.n	403340 <f_read+0x15c>
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  403280:	61a5      	str	r5, [r4, #24]
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  403282:	68a5      	ldr	r5, [r4, #8]
  403284:	f3c5 0508 	ubfx	r5, r5, #0, #9
  403288:	f5c5 7500 	rsb	r5, r5, #512	; 0x200
  40328c:	42b5      	cmp	r5, r6
  40328e:	bf28      	it	cs
  403290:	4635      	movcs	r5, r6
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
  403292:	69a1      	ldr	r1, [r4, #24]
  403294:	6820      	ldr	r0, [r4, #0]
  403296:	4b35      	ldr	r3, [pc, #212]	; (40336c <f_read+0x188>)
  403298:	4798      	blx	r3
  40329a:	2800      	cmp	r0, #0
  40329c:	d153      	bne.n	403346 <f_read+0x162>
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  40329e:	68a1      	ldr	r1, [r4, #8]
  4032a0:	f3c1 0108 	ubfx	r1, r1, #0, #9
  4032a4:	3130      	adds	r1, #48	; 0x30
  4032a6:	6823      	ldr	r3, [r4, #0]
  4032a8:	462a      	mov	r2, r5
  4032aa:	4419      	add	r1, r3
  4032ac:	4648      	mov	r0, r9
  4032ae:	4b2e      	ldr	r3, [pc, #184]	; (403368 <f_read+0x184>)
  4032b0:	4798      	blx	r3
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  4032b2:	44a9      	add	r9, r5
  4032b4:	68a3      	ldr	r3, [r4, #8]
  4032b6:	442b      	add	r3, r5
  4032b8:	60a3      	str	r3, [r4, #8]
  4032ba:	f8d8 3000 	ldr.w	r3, [r8]
  4032be:	442b      	add	r3, r5
  4032c0:	f8c8 3000 	str.w	r3, [r8]
	for ( ;  btr;								/* Repeat until all data read */
  4032c4:	1b76      	subs	r6, r6, r5
  4032c6:	d047      	beq.n	403358 <f_read+0x174>
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  4032c8:	68a2      	ldr	r2, [r4, #8]
  4032ca:	f3c2 0308 	ubfx	r3, r2, #0, #9
  4032ce:	2b00      	cmp	r3, #0
  4032d0:	d1d7      	bne.n	403282 <f_read+0x9e>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  4032d2:	6820      	ldr	r0, [r4, #0]
  4032d4:	7883      	ldrb	r3, [r0, #2]
  4032d6:	3b01      	subs	r3, #1
  4032d8:	ea03 2352 	and.w	r3, r3, r2, lsr #9
			if (!csect) {						/* On the cluster boundary? */
  4032dc:	f013 07ff 	ands.w	r7, r3, #255	; 0xff
  4032e0:	d108      	bne.n	4032f4 <f_read+0x110>
				if (fp->fptr == 0) {			/* On the top of the file? */
  4032e2:	2a00      	cmp	r2, #0
  4032e4:	d1a4      	bne.n	403230 <f_read+0x4c>
					clst = fp->sclust;			/* Follow from the origin */
  4032e6:	6920      	ldr	r0, [r4, #16]
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  4032e8:	2801      	cmp	r0, #1
  4032ea:	d9a5      	bls.n	403238 <f_read+0x54>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  4032ec:	f1b0 3fff 	cmp.w	r0, #4294967295
  4032f0:	d0a9      	beq.n	403246 <f_read+0x62>
				fp->clust = clst;				/* Update current cluster */
  4032f2:	6160      	str	r0, [r4, #20]
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  4032f4:	f8d4 a000 	ldr.w	sl, [r4]
  4032f8:	6961      	ldr	r1, [r4, #20]
  4032fa:	4650      	mov	r0, sl
  4032fc:	4b1c      	ldr	r3, [pc, #112]	; (403370 <f_read+0x18c>)
  4032fe:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403300:	4605      	mov	r5, r0
  403302:	2800      	cmp	r0, #0
  403304:	d0a6      	beq.n	403254 <f_read+0x70>
			sect += csect;
  403306:	443d      	add	r5, r7
			if (cc) {							/* Read maximum contiguous sectors directly */
  403308:	ea5f 2b56 	movs.w	fp, r6, lsr #9
  40330c:	d0b8      	beq.n	403280 <f_read+0x9c>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  40330e:	f89a 3002 	ldrb.w	r3, [sl, #2]
  403312:	eb07 020b 	add.w	r2, r7, fp
  403316:	429a      	cmp	r2, r3
					cc = fp->fs->csize - csect;
  403318:	bf88      	it	hi
  40331a:	eba3 0b07 	subhi.w	fp, r3, r7
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  40331e:	fa5f f38b 	uxtb.w	r3, fp
  403322:	462a      	mov	r2, r5
  403324:	4649      	mov	r1, r9
  403326:	f89a 0001 	ldrb.w	r0, [sl, #1]
  40332a:	4f12      	ldr	r7, [pc, #72]	; (403374 <f_read+0x190>)
  40332c:	47b8      	blx	r7
  40332e:	2800      	cmp	r0, #0
  403330:	d197      	bne.n	403262 <f_read+0x7e>
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
  403332:	6821      	ldr	r1, [r4, #0]
  403334:	790b      	ldrb	r3, [r1, #4]
  403336:	b11b      	cbz	r3, 403340 <f_read+0x15c>
  403338:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
  40333a:	1b40      	subs	r0, r0, r5
  40333c:	4583      	cmp	fp, r0
  40333e:	d897      	bhi.n	403270 <f_read+0x8c>
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  403340:	ea4f 254b 	mov.w	r5, fp, lsl #9
				continue;
  403344:	e7b5      	b.n	4032b2 <f_read+0xce>
			ABORT(fp->fs, FR_DISK_ERR);
  403346:	79a3      	ldrb	r3, [r4, #6]
  403348:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40334c:	71a3      	strb	r3, [r4, #6]
  40334e:	2301      	movs	r3, #1
  403350:	9301      	str	r3, [sp, #4]
  403352:	e001      	b.n	403358 <f_read+0x174>
		LEAVE_FF(fp->fs, FR_INT_ERR);
  403354:	2302      	movs	r3, #2
  403356:	9301      	str	r3, [sp, #4]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  403358:	9801      	ldr	r0, [sp, #4]
  40335a:	b003      	add	sp, #12
  40335c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  403360:	00401c3d 	.word	0x00401c3d
  403364:	004020fd 	.word	0x004020fd
  403368:	00401be5 	.word	0x00401be5
  40336c:	0040206d 	.word	0x0040206d
  403370:	00401c07 	.word	0x00401c07
  403374:	00401a3d 	.word	0x00401a3d

00403378 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
  403378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40337c:	b083      	sub	sp, #12
  40337e:	4604      	mov	r4, r0
  403380:	4689      	mov	r9, r1
  403382:	4616      	mov	r6, r2
  403384:	4698      	mov	r8, r3
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */
  403386:	2300      	movs	r3, #0
  403388:	f8c8 3000 	str.w	r3, [r8]

	res = validate(fp->fs, fp->id);			/* Check validity */
  40338c:	8881      	ldrh	r1, [r0, #4]
  40338e:	6800      	ldr	r0, [r0, #0]
  403390:	4b75      	ldr	r3, [pc, #468]	; (403568 <f_write+0x1f0>)
  403392:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  403394:	9001      	str	r0, [sp, #4]
  403396:	2800      	cmp	r0, #0
  403398:	f040 80e2 	bne.w	403560 <f_write+0x1e8>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
  40339c:	79a3      	ldrb	r3, [r4, #6]
  40339e:	f013 0f80 	tst.w	r3, #128	; 0x80
  4033a2:	f040 80db 	bne.w	40355c <f_write+0x1e4>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
  4033a6:	f013 0f02 	tst.w	r3, #2
  4033aa:	d102      	bne.n	4033b2 <f_write+0x3a>
		LEAVE_FF(fp->fs, FR_DENIED);
  4033ac:	2307      	movs	r3, #7
  4033ae:	9301      	str	r3, [sp, #4]
  4033b0:	e0d6      	b.n	403560 <f_write+0x1e8>
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
  4033b2:	68e3      	ldr	r3, [r4, #12]
  4033b4:	42f3      	cmn	r3, r6
  4033b6:	d20e      	bcs.n	4033d6 <f_write+0x5e>

	for ( ;  btw;							/* Repeat until all data written */
  4033b8:	2e00      	cmp	r6, #0
  4033ba:	d174      	bne.n	4034a6 <f_write+0x12e>
  4033bc:	e00b      	b.n	4033d6 <f_write+0x5e>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
  4033be:	2100      	movs	r1, #0
  4033c0:	4b6a      	ldr	r3, [pc, #424]	; (40356c <f_write+0x1f4>)
  4033c2:	4798      	blx	r3
  4033c4:	4603      	mov	r3, r0
  4033c6:	6120      	str	r0, [r4, #16]
  4033c8:	e003      	b.n	4033d2 <f_write+0x5a>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
  4033ca:	6961      	ldr	r1, [r4, #20]
  4033cc:	4b67      	ldr	r3, [pc, #412]	; (40356c <f_write+0x1f4>)
  4033ce:	4798      	blx	r3
  4033d0:	4603      	mov	r3, r0
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
  4033d2:	2b00      	cmp	r3, #0
  4033d4:	d17a      	bne.n	4034cc <f_write+0x154>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
  4033d6:	68a3      	ldr	r3, [r4, #8]
  4033d8:	68e2      	ldr	r2, [r4, #12]
  4033da:	4293      	cmp	r3, r2
  4033dc:	bf88      	it	hi
  4033de:	60e3      	strhi	r3, [r4, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
  4033e0:	79a3      	ldrb	r3, [r4, #6]
  4033e2:	f043 0320 	orr.w	r3, r3, #32
  4033e6:	71a3      	strb	r3, [r4, #6]

	LEAVE_FF(fp->fs, FR_OK);
  4033e8:	e0ba      	b.n	403560 <f_write+0x1e8>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  4033ea:	79a3      	ldrb	r3, [r4, #6]
  4033ec:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4033f0:	71a3      	strb	r3, [r4, #6]
  4033f2:	2302      	movs	r3, #2
  4033f4:	9301      	str	r3, [sp, #4]
  4033f6:	e0b3      	b.n	403560 <f_write+0x1e8>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  4033f8:	79a3      	ldrb	r3, [r4, #6]
  4033fa:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4033fe:	71a3      	strb	r3, [r4, #6]
  403400:	2301      	movs	r3, #1
  403402:	9301      	str	r3, [sp, #4]
  403404:	e0ac      	b.n	403560 <f_write+0x1e8>
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
  403406:	2100      	movs	r1, #0
  403408:	4b59      	ldr	r3, [pc, #356]	; (403570 <f_write+0x1f8>)
  40340a:	4798      	blx	r3
  40340c:	2800      	cmp	r0, #0
  40340e:	d068      	beq.n	4034e2 <f_write+0x16a>
				ABORT(fp->fs, FR_DISK_ERR);
  403410:	79a3      	ldrb	r3, [r4, #6]
  403412:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403416:	71a3      	strb	r3, [r4, #6]
  403418:	2301      	movs	r3, #1
  40341a:	9301      	str	r3, [sp, #4]
  40341c:	e0a0      	b.n	403560 <f_write+0x1e8>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  40341e:	79a3      	ldrb	r3, [r4, #6]
  403420:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403424:	71a3      	strb	r3, [r4, #6]
  403426:	2302      	movs	r3, #2
  403428:	9301      	str	r3, [sp, #4]
  40342a:	e099      	b.n	403560 <f_write+0x1e8>
					ABORT(fp->fs, FR_DISK_ERR);
  40342c:	79a3      	ldrb	r3, [r4, #6]
  40342e:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403432:	71a3      	strb	r3, [r4, #6]
  403434:	2301      	movs	r3, #1
  403436:	9301      	str	r3, [sp, #4]
  403438:	e092      	b.n	403560 <f_write+0x1e8>
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
  40343a:	f44f 7200 	mov.w	r2, #512	; 0x200
  40343e:	eb09 2141 	add.w	r1, r9, r1, lsl #9
  403442:	3030      	adds	r0, #48	; 0x30
  403444:	4b4b      	ldr	r3, [pc, #300]	; (403574 <f_write+0x1fc>)
  403446:	4798      	blx	r3
					fp->fs->wflag = 0;
  403448:	6823      	ldr	r3, [r4, #0]
  40344a:	2200      	movs	r2, #0
  40344c:	711a      	strb	r2, [r3, #4]
  40344e:	e06c      	b.n	40352a <f_write+0x1b2>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
  403450:	68a2      	ldr	r2, [r4, #8]
  403452:	68e3      	ldr	r3, [r4, #12]
  403454:	429a      	cmp	r2, r3
  403456:	d26b      	bcs.n	403530 <f_write+0x1b8>
			fp->dsect = sect;
  403458:	61a5      	str	r5, [r4, #24]
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
  40345a:	68a5      	ldr	r5, [r4, #8]
  40345c:	f3c5 0508 	ubfx	r5, r5, #0, #9
  403460:	f5c5 7500 	rsb	r5, r5, #512	; 0x200
  403464:	42b5      	cmp	r5, r6
  403466:	bf28      	it	cs
  403468:	4635      	movcs	r5, r6
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
  40346a:	69a1      	ldr	r1, [r4, #24]
  40346c:	6820      	ldr	r0, [r4, #0]
  40346e:	4b40      	ldr	r3, [pc, #256]	; (403570 <f_write+0x1f8>)
  403470:	4798      	blx	r3
  403472:	2800      	cmp	r0, #0
  403474:	d16b      	bne.n	40354e <f_write+0x1d6>
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
  403476:	68a0      	ldr	r0, [r4, #8]
  403478:	f3c0 0008 	ubfx	r0, r0, #0, #9
  40347c:	3030      	adds	r0, #48	; 0x30
  40347e:	6823      	ldr	r3, [r4, #0]
  403480:	462a      	mov	r2, r5
  403482:	4649      	mov	r1, r9
  403484:	4418      	add	r0, r3
  403486:	4b3b      	ldr	r3, [pc, #236]	; (403574 <f_write+0x1fc>)
  403488:	4798      	blx	r3
		fp->fs->wflag = 1;
  40348a:	6823      	ldr	r3, [r4, #0]
  40348c:	2201      	movs	r2, #1
  40348e:	711a      	strb	r2, [r3, #4]
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
  403490:	44a9      	add	r9, r5
  403492:	68a3      	ldr	r3, [r4, #8]
  403494:	442b      	add	r3, r5
  403496:	60a3      	str	r3, [r4, #8]
  403498:	f8d8 3000 	ldr.w	r3, [r8]
  40349c:	442b      	add	r3, r5
  40349e:	f8c8 3000 	str.w	r3, [r8]
	for ( ;  btw;							/* Repeat until all data written */
  4034a2:	1b76      	subs	r6, r6, r5
  4034a4:	d097      	beq.n	4033d6 <f_write+0x5e>
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
  4034a6:	68a2      	ldr	r2, [r4, #8]
  4034a8:	f3c2 0308 	ubfx	r3, r2, #0, #9
  4034ac:	2b00      	cmp	r3, #0
  4034ae:	d1d4      	bne.n	40345a <f_write+0xe2>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  4034b0:	6820      	ldr	r0, [r4, #0]
  4034b2:	7883      	ldrb	r3, [r0, #2]
  4034b4:	3b01      	subs	r3, #1
  4034b6:	ea03 2352 	and.w	r3, r3, r2, lsr #9
			if (!csect) {					/* On the cluster boundary? */
  4034ba:	f013 07ff 	ands.w	r7, r3, #255	; 0xff
  4034be:	d10b      	bne.n	4034d8 <f_write+0x160>
				if (fp->fptr == 0) {		/* On the top of the file? */
  4034c0:	2a00      	cmp	r2, #0
  4034c2:	d182      	bne.n	4033ca <f_write+0x52>
					clst = fp->sclust;		/* Follow from the origin */
  4034c4:	6923      	ldr	r3, [r4, #16]
					if (clst == 0)			/* When no cluster is allocated, */
  4034c6:	2b00      	cmp	r3, #0
  4034c8:	f43f af79 	beq.w	4033be <f_write+0x46>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  4034cc:	2b01      	cmp	r3, #1
  4034ce:	d08c      	beq.n	4033ea <f_write+0x72>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  4034d0:	f1b3 3fff 	cmp.w	r3, #4294967295
  4034d4:	d090      	beq.n	4033f8 <f_write+0x80>
				fp->clust = clst;			/* Update current cluster */
  4034d6:	6163      	str	r3, [r4, #20]
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
  4034d8:	6820      	ldr	r0, [r4, #0]
  4034da:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  4034dc:	69a3      	ldr	r3, [r4, #24]
  4034de:	429a      	cmp	r2, r3
  4034e0:	d091      	beq.n	403406 <f_write+0x8e>
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  4034e2:	f8d4 a000 	ldr.w	sl, [r4]
  4034e6:	6961      	ldr	r1, [r4, #20]
  4034e8:	4650      	mov	r0, sl
  4034ea:	4b23      	ldr	r3, [pc, #140]	; (403578 <f_write+0x200>)
  4034ec:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  4034ee:	4605      	mov	r5, r0
  4034f0:	2800      	cmp	r0, #0
  4034f2:	d094      	beq.n	40341e <f_write+0xa6>
			sect += csect;
  4034f4:	443d      	add	r5, r7
			if (cc) {						/* Write maximum contiguous sectors directly */
  4034f6:	ea5f 2b56 	movs.w	fp, r6, lsr #9
  4034fa:	d0a9      	beq.n	403450 <f_write+0xd8>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  4034fc:	f89a 3002 	ldrb.w	r3, [sl, #2]
  403500:	eb07 020b 	add.w	r2, r7, fp
  403504:	429a      	cmp	r2, r3
					cc = fp->fs->csize - csect;
  403506:	bf88      	it	hi
  403508:	eba3 0b07 	subhi.w	fp, r3, r7
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
  40350c:	fa5f f38b 	uxtb.w	r3, fp
  403510:	462a      	mov	r2, r5
  403512:	4649      	mov	r1, r9
  403514:	f89a 0001 	ldrb.w	r0, [sl, #1]
  403518:	4f18      	ldr	r7, [pc, #96]	; (40357c <f_write+0x204>)
  40351a:	47b8      	blx	r7
  40351c:	2800      	cmp	r0, #0
  40351e:	d185      	bne.n	40342c <f_write+0xb4>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
  403520:	6820      	ldr	r0, [r4, #0]
  403522:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  403524:	1b49      	subs	r1, r1, r5
  403526:	458b      	cmp	fp, r1
  403528:	d887      	bhi.n	40343a <f_write+0xc2>
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
  40352a:	ea4f 254b 	mov.w	r5, fp, lsl #9
				continue;
  40352e:	e7af      	b.n	403490 <f_write+0x118>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
  403530:	2100      	movs	r1, #0
  403532:	4650      	mov	r0, sl
  403534:	4b0e      	ldr	r3, [pc, #56]	; (403570 <f_write+0x1f8>)
  403536:	4798      	blx	r3
  403538:	b910      	cbnz	r0, 403540 <f_write+0x1c8>
				fp->fs->winsect = sect;
  40353a:	6823      	ldr	r3, [r4, #0]
  40353c:	62dd      	str	r5, [r3, #44]	; 0x2c
  40353e:	e78b      	b.n	403458 <f_write+0xe0>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
  403540:	79a3      	ldrb	r3, [r4, #6]
  403542:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403546:	71a3      	strb	r3, [r4, #6]
  403548:	2301      	movs	r3, #1
  40354a:	9301      	str	r3, [sp, #4]
  40354c:	e008      	b.n	403560 <f_write+0x1e8>
			ABORT(fp->fs, FR_DISK_ERR);
  40354e:	79a3      	ldrb	r3, [r4, #6]
  403550:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403554:	71a3      	strb	r3, [r4, #6]
  403556:	2301      	movs	r3, #1
  403558:	9301      	str	r3, [sp, #4]
  40355a:	e001      	b.n	403560 <f_write+0x1e8>
		LEAVE_FF(fp->fs, FR_INT_ERR);
  40355c:	2302      	movs	r3, #2
  40355e:	9301      	str	r3, [sp, #4]
}
  403560:	9801      	ldr	r0, [sp, #4]
  403562:	b003      	add	sp, #12
  403564:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  403568:	00401c3d 	.word	0x00401c3d
  40356c:	004023bd 	.word	0x004023bd
  403570:	0040206d 	.word	0x0040206d
  403574:	00401be5 	.word	0x00401be5
  403578:	00401c07 	.word	0x00401c07
  40357c:	00401aad 	.word	0x00401aad

00403580 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
  403580:	b538      	push	{r3, r4, r5, lr}
  403582:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  403584:	8881      	ldrh	r1, [r0, #4]
  403586:	6800      	ldr	r0, [r0, #0]
  403588:	4b1f      	ldr	r3, [pc, #124]	; (403608 <f_sync+0x88>)
  40358a:	4798      	blx	r3
	if (res == FR_OK) {
  40358c:	4603      	mov	r3, r0
  40358e:	b918      	cbnz	r0, 403598 <f_sync+0x18>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
  403590:	79a2      	ldrb	r2, [r4, #6]
  403592:	f012 0f20 	tst.w	r2, #32
  403596:	d101      	bne.n	40359c <f_sync+0x1c>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
  403598:	4618      	mov	r0, r3
  40359a:	bd38      	pop	{r3, r4, r5, pc}
			res = move_window(fp->fs, fp->dir_sect);
  40359c:	69e1      	ldr	r1, [r4, #28]
  40359e:	6820      	ldr	r0, [r4, #0]
  4035a0:	4b1a      	ldr	r3, [pc, #104]	; (40360c <f_sync+0x8c>)
  4035a2:	4798      	blx	r3
			if (res == FR_OK) {
  4035a4:	4603      	mov	r3, r0
  4035a6:	2800      	cmp	r0, #0
  4035a8:	d1f6      	bne.n	403598 <f_sync+0x18>
				dir = fp->dir_ptr;
  4035aa:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
  4035ac:	7aeb      	ldrb	r3, [r5, #11]
  4035ae:	f043 0320 	orr.w	r3, r3, #32
  4035b2:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
  4035b4:	68e3      	ldr	r3, [r4, #12]
  4035b6:	772b      	strb	r3, [r5, #28]
  4035b8:	89a3      	ldrh	r3, [r4, #12]
  4035ba:	0a1b      	lsrs	r3, r3, #8
  4035bc:	776b      	strb	r3, [r5, #29]
  4035be:	89e3      	ldrh	r3, [r4, #14]
  4035c0:	77ab      	strb	r3, [r5, #30]
  4035c2:	7be3      	ldrb	r3, [r4, #15]
  4035c4:	77eb      	strb	r3, [r5, #31]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  4035c6:	6923      	ldr	r3, [r4, #16]
  4035c8:	76ab      	strb	r3, [r5, #26]
  4035ca:	8a23      	ldrh	r3, [r4, #16]
  4035cc:	0a1b      	lsrs	r3, r3, #8
  4035ce:	76eb      	strb	r3, [r5, #27]
  4035d0:	8a63      	ldrh	r3, [r4, #18]
  4035d2:	752b      	strb	r3, [r5, #20]
  4035d4:	8a63      	ldrh	r3, [r4, #18]
  4035d6:	0a1b      	lsrs	r3, r3, #8
  4035d8:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();						/* Update updated time */
  4035da:	4b0d      	ldr	r3, [pc, #52]	; (403610 <f_sync+0x90>)
  4035dc:	4798      	blx	r3
				ST_DWORD(dir+DIR_WrtTime, tim);
  4035de:	75a8      	strb	r0, [r5, #22]
  4035e0:	f3c0 2307 	ubfx	r3, r0, #8, #8
  4035e4:	75eb      	strb	r3, [r5, #23]
  4035e6:	0c03      	lsrs	r3, r0, #16
  4035e8:	762b      	strb	r3, [r5, #24]
  4035ea:	0e00      	lsrs	r0, r0, #24
  4035ec:	7668      	strb	r0, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
  4035ee:	79a3      	ldrb	r3, [r4, #6]
  4035f0:	f023 0320 	bic.w	r3, r3, #32
  4035f4:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
  4035f6:	6823      	ldr	r3, [r4, #0]
  4035f8:	2201      	movs	r2, #1
  4035fa:	711a      	strb	r2, [r3, #4]
				res = sync(fp->fs);
  4035fc:	6820      	ldr	r0, [r4, #0]
  4035fe:	4b05      	ldr	r3, [pc, #20]	; (403614 <f_sync+0x94>)
  403600:	4798      	blx	r3
  403602:	4603      	mov	r3, r0
  403604:	e7c8      	b.n	403598 <f_sync+0x18>
  403606:	bf00      	nop
  403608:	00401c3d 	.word	0x00401c3d
  40360c:	0040206d 	.word	0x0040206d
  403610:	00401b8d 	.word	0x00401b8d
  403614:	00402c3d 	.word	0x00402c3d

00403618 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403618:	b510      	push	{r4, lr}
  40361a:	4604      	mov	r4, r0
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  40361c:	4b03      	ldr	r3, [pc, #12]	; (40362c <f_close+0x14>)
  40361e:	4798      	blx	r3
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  403620:	4603      	mov	r3, r0
  403622:	b908      	cbnz	r0, 403628 <f_close+0x10>
  403624:	2200      	movs	r2, #0
  403626:	6022      	str	r2, [r4, #0]
	return res;
#endif
}
  403628:	4618      	mov	r0, r3
  40362a:	bd10      	pop	{r4, pc}
  40362c:	00403581 	.word	0x00403581

00403630 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
  403630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403634:	b083      	sub	sp, #12
  403636:	ab02      	add	r3, sp, #8
  403638:	f843 0d04 	str.w	r0, [r3, #-4]!
  40363c:	468a      	mov	sl, r1
  40363e:	4615      	mov	r5, r2
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
  403640:	2200      	movs	r2, #0
  403642:	4629      	mov	r1, r5
  403644:	4618      	mov	r0, r3
  403646:	4b39      	ldr	r3, [pc, #228]	; (40372c <f_getfree+0xfc>)
  403648:	4798      	blx	r3
	if (res == FR_OK) {
  40364a:	4680      	mov	r8, r0
  40364c:	2800      	cmp	r0, #0
  40364e:	d15d      	bne.n	40370c <f_getfree+0xdc>
		/* If free_clust is valid, return it without full cluster scan */
		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
  403650:	682b      	ldr	r3, [r5, #0]
  403652:	691a      	ldr	r2, [r3, #16]
  403654:	699c      	ldr	r4, [r3, #24]
  403656:	1ea1      	subs	r1, r4, #2
  403658:	428a      	cmp	r2, r1
  40365a:	d909      	bls.n	403670 <f_getfree+0x40>
			*nclst = (*fatfs)->free_clust;
		} else {
			/* Get number of free clusters */
			fat = (*fatfs)->fs_type;
  40365c:	781f      	ldrb	r7, [r3, #0]
			n = 0;
			if (fat == FS_FAT12) {
  40365e:	2f01      	cmp	r7, #1
  403660:	d009      	beq.n	403676 <f_getfree+0x46>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < (*fatfs)->n_fatent);
			} else {
				clst = (*fatfs)->n_fatent;
				sect = (*fatfs)->fatbase;
  403662:	6a19      	ldr	r1, [r3, #32]
				i = 0; p = 0;
  403664:	2200      	movs	r2, #0
  403666:	4610      	mov	r0, r2
			n = 0;
  403668:	4616      	mov	r6, r2
				do {
					if (!i) {
						res = move_window(*fatfs, sect++);
  40366a:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 403734 <f_getfree+0x104>
  40366e:	e02f      	b.n	4036d0 <f_getfree+0xa0>
			*nclst = (*fatfs)->free_clust;
  403670:	f8ca 2000 	str.w	r2, [sl]
  403674:	e04a      	b.n	40370c <f_getfree+0xdc>
  403676:	2402      	movs	r4, #2
  403678:	2600      	movs	r6, #0
					stat = get_fat(*fatfs, clst);
  40367a:	4f2d      	ldr	r7, [pc, #180]	; (403730 <f_getfree+0x100>)
  40367c:	e004      	b.n	403688 <f_getfree+0x58>
				} while (++clst < (*fatfs)->n_fatent);
  40367e:	3401      	adds	r4, #1
  403680:	682b      	ldr	r3, [r5, #0]
  403682:	699b      	ldr	r3, [r3, #24]
  403684:	429c      	cmp	r4, r3
  403686:	d24b      	bcs.n	403720 <f_getfree+0xf0>
					stat = get_fat(*fatfs, clst);
  403688:	4621      	mov	r1, r4
  40368a:	6828      	ldr	r0, [r5, #0]
  40368c:	47b8      	blx	r7
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
  40368e:	f1b0 3fff 	cmp.w	r0, #4294967295
  403692:	d043      	beq.n	40371c <f_getfree+0xec>
					if (stat == 1) { res = FR_INT_ERR; break; }
  403694:	2801      	cmp	r0, #1
  403696:	d046      	beq.n	403726 <f_getfree+0xf6>
					if (stat == 0) n++;
  403698:	2800      	cmp	r0, #0
  40369a:	d1f0      	bne.n	40367e <f_getfree+0x4e>
  40369c:	3601      	adds	r6, #1
  40369e:	e7ee      	b.n	40367e <f_getfree+0x4e>
						if (res != FR_OK) break;
						p = (*fatfs)->win;
						i = SS(*fatfs);
					}
					if (fat == FS_FAT16) {
  4036a0:	2f02      	cmp	r7, #2
  4036a2:	d022      	beq.n	4036ea <f_getfree+0xba>
						if (LD_WORD(p) == 0) n++;
						p += 2; i -= 2;
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
  4036a4:	f892 e003 	ldrb.w	lr, [r2, #3]
  4036a8:	7893      	ldrb	r3, [r2, #2]
  4036aa:	041b      	lsls	r3, r3, #16
  4036ac:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
  4036b0:	f892 e000 	ldrb.w	lr, [r2]
  4036b4:	ea43 030e 	orr.w	r3, r3, lr
  4036b8:	f892 e001 	ldrb.w	lr, [r2, #1]
  4036bc:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
  4036c0:	f033 4370 	bics.w	r3, r3, #4026531840	; 0xf0000000
  4036c4:	bf08      	it	eq
  4036c6:	3601      	addeq	r6, #1
						p += 4; i -= 4;
  4036c8:	3204      	adds	r2, #4
  4036ca:	3804      	subs	r0, #4
					}
				} while (--clst);
  4036cc:	3c01      	subs	r4, #1
  4036ce:	d017      	beq.n	403700 <f_getfree+0xd0>
					if (!i) {
  4036d0:	2800      	cmp	r0, #0
  4036d2:	d1e5      	bne.n	4036a0 <f_getfree+0x70>
						res = move_window(*fatfs, sect++);
  4036d4:	f101 0b01 	add.w	fp, r1, #1
  4036d8:	6828      	ldr	r0, [r5, #0]
  4036da:	47c8      	blx	r9
						if (res != FR_OK) break;
  4036dc:	b978      	cbnz	r0, 4036fe <f_getfree+0xce>
						p = (*fatfs)->win;
  4036de:	682a      	ldr	r2, [r5, #0]
  4036e0:	3230      	adds	r2, #48	; 0x30
						res = move_window(*fatfs, sect++);
  4036e2:	4659      	mov	r1, fp
						i = SS(*fatfs);
  4036e4:	f44f 7000 	mov.w	r0, #512	; 0x200
  4036e8:	e7da      	b.n	4036a0 <f_getfree+0x70>
						if (LD_WORD(p) == 0) n++;
  4036ea:	f892 e001 	ldrb.w	lr, [r2, #1]
  4036ee:	7813      	ldrb	r3, [r2, #0]
  4036f0:	ea53 230e 	orrs.w	r3, r3, lr, lsl #8
  4036f4:	bf08      	it	eq
  4036f6:	3601      	addeq	r6, #1
						p += 2; i -= 2;
  4036f8:	3202      	adds	r2, #2
  4036fa:	3802      	subs	r0, #2
  4036fc:	e7e6      	b.n	4036cc <f_getfree+0x9c>
						res = move_window(*fatfs, sect++);
  4036fe:	4680      	mov	r8, r0
			}
			(*fatfs)->free_clust = n;
  403700:	682b      	ldr	r3, [r5, #0]
  403702:	611e      	str	r6, [r3, #16]
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
  403704:	2f03      	cmp	r7, #3
  403706:	d005      	beq.n	403714 <f_getfree+0xe4>
			*nclst = n;
  403708:	f8ca 6000 	str.w	r6, [sl]
		}
	}
	LEAVE_FF(*fatfs, res);
}
  40370c:	4640      	mov	r0, r8
  40370e:	b003      	add	sp, #12
  403710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
  403714:	682b      	ldr	r3, [r5, #0]
  403716:	2201      	movs	r2, #1
  403718:	715a      	strb	r2, [r3, #5]
  40371a:	e7f5      	b.n	403708 <f_getfree+0xd8>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
  40371c:	f04f 0801 	mov.w	r8, #1
			(*fatfs)->free_clust = n;
  403720:	682b      	ldr	r3, [r5, #0]
  403722:	611e      	str	r6, [r3, #16]
  403724:	e7f0      	b.n	403708 <f_getfree+0xd8>
					if (stat == 1) { res = FR_INT_ERR; break; }
  403726:	f04f 0802 	mov.w	r8, #2
  40372a:	e7f9      	b.n	403720 <f_getfree+0xf0>
  40372c:	00401d01 	.word	0x00401d01
  403730:	004020fd 	.word	0x004020fd
  403734:	0040206d 	.word	0x0040206d

00403738 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
  403738:	b510      	push	{r4, lr}
  40373a:	f5ad 7d18 	sub.w	sp, sp, #608	; 0x260
  40373e:	9001      	str	r0, [sp, #4]
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  403740:	2201      	movs	r2, #1
  403742:	a98f      	add	r1, sp, #572	; 0x23c
  403744:	a801      	add	r0, sp, #4
  403746:	4b2d      	ldr	r3, [pc, #180]	; (4037fc <f_unlink+0xc4>)
  403748:	4798      	blx	r3
	if (res == FR_OK) {
  40374a:	4603      	mov	r3, r0
  40374c:	b118      	cbz	r0, 403756 <f_unlink+0x1e>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
  40374e:	4618      	mov	r0, r3
  403750:	f50d 7d18 	add.w	sp, sp, #608	; 0x260
  403754:	bd10      	pop	{r4, pc}
		INIT_BUF(dj);
  403756:	ab83      	add	r3, sp, #524	; 0x20c
  403758:	9395      	str	r3, [sp, #596]	; 0x254
  40375a:	ab03      	add	r3, sp, #12
  40375c:	9396      	str	r3, [sp, #600]	; 0x258
		res = follow_path(&dj, path);		/* Follow the file path */
  40375e:	9901      	ldr	r1, [sp, #4]
  403760:	a88f      	add	r0, sp, #572	; 0x23c
  403762:	4b27      	ldr	r3, [pc, #156]	; (403800 <f_unlink+0xc8>)
  403764:	4798      	blx	r3
		if (res == FR_OK) {					/* The object is accessible */
  403766:	4603      	mov	r3, r0
  403768:	2800      	cmp	r0, #0
  40376a:	d1f0      	bne.n	40374e <f_unlink+0x16>
			dir = dj.dir;
  40376c:	9b94      	ldr	r3, [sp, #592]	; 0x250
			if (!dir) {
  40376e:	2b00      	cmp	r3, #0
  403770:	d03e      	beq.n	4037f0 <f_unlink+0xb8>
				if (dir[DIR_Attr] & AM_RDO)
  403772:	7ada      	ldrb	r2, [r3, #11]
  403774:	f012 0f01 	tst.w	r2, #1
  403778:	d13c      	bne.n	4037f4 <f_unlink+0xbc>
			dclst = LD_CLUST(dir);
  40377a:	7d5a      	ldrb	r2, [r3, #21]
  40377c:	7d1c      	ldrb	r4, [r3, #20]
  40377e:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  403782:	7ed9      	ldrb	r1, [r3, #27]
  403784:	7e9c      	ldrb	r4, [r3, #26]
  403786:	ea44 2401 	orr.w	r4, r4, r1, lsl #8
  40378a:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
  40378e:	7adb      	ldrb	r3, [r3, #11]
  403790:	f013 0f10 	tst.w	r3, #16
  403794:	d10b      	bne.n	4037ae <f_unlink+0x76>
				res = dir_remove(&dj);		/* Remove the directory entry */
  403796:	a88f      	add	r0, sp, #572	; 0x23c
  403798:	4b1a      	ldr	r3, [pc, #104]	; (403804 <f_unlink+0xcc>)
  40379a:	4798      	blx	r3
				if (res == FR_OK) {
  40379c:	4603      	mov	r3, r0
  40379e:	2800      	cmp	r0, #0
  4037a0:	d1d5      	bne.n	40374e <f_unlink+0x16>
					if (dclst)				/* Remove the cluster chain if exist */
  4037a2:	b9dc      	cbnz	r4, 4037dc <f_unlink+0xa4>
					if (res == FR_OK) res = sync(dj.fs);
  4037a4:	988f      	ldr	r0, [sp, #572]	; 0x23c
  4037a6:	4b18      	ldr	r3, [pc, #96]	; (403808 <f_unlink+0xd0>)
  4037a8:	4798      	blx	r3
  4037aa:	4603      	mov	r3, r0
  4037ac:	e7cf      	b.n	40374e <f_unlink+0x16>
				if (dclst < 2) {
  4037ae:	2c01      	cmp	r4, #1
  4037b0:	d91c      	bls.n	4037ec <f_unlink+0xb4>
					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
  4037b2:	2224      	movs	r2, #36	; 0x24
  4037b4:	a98f      	add	r1, sp, #572	; 0x23c
  4037b6:	a886      	add	r0, sp, #536	; 0x218
  4037b8:	4b14      	ldr	r3, [pc, #80]	; (40380c <f_unlink+0xd4>)
  4037ba:	4798      	blx	r3
					sdj.sclust = dclst;
  4037bc:	9488      	str	r4, [sp, #544]	; 0x220
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
  4037be:	2102      	movs	r1, #2
  4037c0:	a886      	add	r0, sp, #536	; 0x218
  4037c2:	4b13      	ldr	r3, [pc, #76]	; (403810 <f_unlink+0xd8>)
  4037c4:	4798      	blx	r3
					if (res == FR_OK) {
  4037c6:	4603      	mov	r3, r0
  4037c8:	2800      	cmp	r0, #0
  4037ca:	d1c0      	bne.n	40374e <f_unlink+0x16>
						res = dir_read(&sdj);
  4037cc:	a886      	add	r0, sp, #536	; 0x218
  4037ce:	4b11      	ldr	r3, [pc, #68]	; (403814 <f_unlink+0xdc>)
  4037d0:	4798      	blx	r3
						if (res == FR_OK			/* Not empty dir */
  4037d2:	4603      	mov	r3, r0
  4037d4:	b180      	cbz	r0, 4037f8 <f_unlink+0xc0>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
  4037d6:	2804      	cmp	r0, #4
  4037d8:	d0dd      	beq.n	403796 <f_unlink+0x5e>
  4037da:	e7b8      	b.n	40374e <f_unlink+0x16>
						res = remove_chain(dj.fs, dclst);
  4037dc:	4621      	mov	r1, r4
  4037de:	988f      	ldr	r0, [sp, #572]	; 0x23c
  4037e0:	4b0d      	ldr	r3, [pc, #52]	; (403818 <f_unlink+0xe0>)
  4037e2:	4798      	blx	r3
					if (res == FR_OK) res = sync(dj.fs);
  4037e4:	4603      	mov	r3, r0
  4037e6:	2800      	cmp	r0, #0
  4037e8:	d1b1      	bne.n	40374e <f_unlink+0x16>
  4037ea:	e7db      	b.n	4037a4 <f_unlink+0x6c>
					res = FR_INT_ERR;
  4037ec:	2302      	movs	r3, #2
  4037ee:	e7ae      	b.n	40374e <f_unlink+0x16>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
  4037f0:	2306      	movs	r3, #6
  4037f2:	e7ac      	b.n	40374e <f_unlink+0x16>
					res = FR_DENIED;		/* Cannot remove R/O object */
  4037f4:	2307      	movs	r3, #7
  4037f6:	e7aa      	b.n	40374e <f_unlink+0x16>
						) res = FR_DENIED;
  4037f8:	2307      	movs	r3, #7
	LEAVE_FF(dj.fs, res);
  4037fa:	e7a8      	b.n	40374e <f_unlink+0x16>
  4037fc:	00401d01 	.word	0x00401d01
  403800:	00402d09 	.word	0x00402d09
  403804:	00402bd9 	.word	0x00402bd9
  403808:	00402c3d 	.word	0x00402c3d
  40380c:	00401be5 	.word	0x00401be5
  403810:	004021e5 	.word	0x004021e5
  403814:	00402ab9 	.word	0x00402ab9
  403818:	0040247d 	.word	0x0040247d

0040381c <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  40381c:	287f      	cmp	r0, #127	; 0x7f
  40381e:	d919      	bls.n	403854 <ff_convert+0x38>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
  403820:	b971      	cbnz	r1, 403840 <ff_convert+0x24>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
				if (src == Tbl[c]) break;
  403822:	28c7      	cmp	r0, #199	; 0xc7
  403824:	d013      	beq.n	40384e <ff_convert+0x32>
  403826:	4a0c      	ldr	r2, [pc, #48]	; (403858 <ff_convert+0x3c>)
			for (c = 0; c < 0x80; c++) {
  403828:	2301      	movs	r3, #1
				if (src == Tbl[c]) break;
  40382a:	f832 1f02 	ldrh.w	r1, [r2, #2]!
  40382e:	4281      	cmp	r1, r0
  403830:	d003      	beq.n	40383a <ff_convert+0x1e>
			for (c = 0; c < 0x80; c++) {
  403832:	3301      	adds	r3, #1
  403834:	b29b      	uxth	r3, r3
  403836:	2b80      	cmp	r3, #128	; 0x80
  403838:	d1f7      	bne.n	40382a <ff_convert+0xe>
			}
			c = (c + 0x80) & 0xFF;
  40383a:	3380      	adds	r3, #128	; 0x80
  40383c:	b2d8      	uxtb	r0, r3
  40383e:	4770      	bx	lr
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403840:	28ff      	cmp	r0, #255	; 0xff
  403842:	d806      	bhi.n	403852 <ff_convert+0x36>
  403844:	3880      	subs	r0, #128	; 0x80
  403846:	4b04      	ldr	r3, [pc, #16]	; (403858 <ff_convert+0x3c>)
  403848:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
  40384c:	4770      	bx	lr
				if (src == Tbl[c]) break;
  40384e:	2300      	movs	r3, #0
  403850:	e7f3      	b.n	40383a <ff_convert+0x1e>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403852:	2000      	movs	r0, #0
		}
	}

	return c;
}
  403854:	4770      	bx	lr
  403856:	bf00      	nop
  403858:	0040dd9c 	.word	0x0040dd9c

0040385c <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  40385c:	2861      	cmp	r0, #97	; 0x61
  40385e:	d010      	beq.n	403882 <ff_wtoupper+0x26>
  403860:	4909      	ldr	r1, [pc, #36]	; (403888 <ff_wtoupper+0x2c>)
  403862:	2201      	movs	r2, #1
  403864:	2362      	movs	r3, #98	; 0x62
  403866:	4298      	cmp	r0, r3
  403868:	d005      	beq.n	403876 <ff_wtoupper+0x1a>
  40386a:	3201      	adds	r2, #1
  40386c:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  403870:	2b00      	cmp	r3, #0
  403872:	d1f8      	bne.n	403866 <ff_wtoupper+0xa>
  403874:	e003      	b.n	40387e <ff_wtoupper+0x22>

	return tbl_lower[i] ? tbl_upper[i] : chr;
  403876:	b118      	cbz	r0, 403880 <ff_wtoupper+0x24>
  403878:	4b04      	ldr	r3, [pc, #16]	; (40388c <ff_wtoupper+0x30>)
  40387a:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
  40387e:	4770      	bx	lr
  403880:	4770      	bx	lr
	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403882:	2200      	movs	r2, #0
  403884:	e7f8      	b.n	403878 <ff_wtoupper+0x1c>
  403886:	bf00      	nop
  403888:	0040de9e 	.word	0x0040de9e
  40388c:	0040e07c 	.word	0x0040e07c

00403890 <USART0_Handler>:
#if SAMD || SAMR21 || SAML21 || SAMR30 || SAMR34 || SAMR35 || WLR089
void USART_HOST_ISR_VECT(uint8_t instance)
#else
USART_HOST_ISR_VECT()
#endif
{
  403890:	b500      	push	{lr}
  403892:	b083      	sub	sp, #12
	uint8_t temp;
#if SAMD || SAMR21 || SAML21 || SAMR30 || SAMR34 || SAMR35 || WLR089
	usart_serial_read_packet(&host_uart_module, &temp, 1);
#elif SAM4E || SAM4S
	usart_serial_read_packet((Usart *)USART_HOST, &temp, 1);
  403894:	2201      	movs	r2, #1
  403896:	f10d 0107 	add.w	r1, sp, #7
  40389a:	4810      	ldr	r0, [pc, #64]	; (4038dc <USART0_Handler+0x4c>)
  40389c:	4b10      	ldr	r3, [pc, #64]	; (4038e0 <USART0_Handler+0x50>)
  40389e:	4798      	blx	r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  4038a0:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  4038a2:	f3bf 8f5f 	dmb	sy
#else
    usart_serial_read_packet(USART_HOST, &temp, 1);
#endif

	/* Introducing critical section to avoid buffer corruption. */
	cpu_irq_disable();
  4038a6:	2200      	movs	r2, #0
  4038a8:	4b0e      	ldr	r3, [pc, #56]	; (4038e4 <USART0_Handler+0x54>)
  4038aa:	701a      	strb	r2, [r3, #0]

	/* The number of data in the receive buffer is incremented and the
	 * buffer is updated. */

	serial_rx_buf[serial_rx_buf_tail] = temp;
  4038ac:	4b0e      	ldr	r3, [pc, #56]	; (4038e8 <USART0_Handler+0x58>)
  4038ae:	781b      	ldrb	r3, [r3, #0]
  4038b0:	f89d 1007 	ldrb.w	r1, [sp, #7]
  4038b4:	4a0d      	ldr	r2, [pc, #52]	; (4038ec <USART0_Handler+0x5c>)
  4038b6:	54d1      	strb	r1, [r2, r3]

	if ((SERIAL_RX_BUF_SIZE_HOST - 1) == serial_rx_buf_tail) {
  4038b8:	2b9b      	cmp	r3, #155	; 0x9b
  4038ba:	d00b      	beq.n	4038d4 <USART0_Handler+0x44>
		/* Reached the end of buffer, revert back to beginning of
		 * buffer. */
		serial_rx_buf_tail = 0x00;
	} else {
		serial_rx_buf_tail++;
  4038bc:	3301      	adds	r3, #1
  4038be:	4a0a      	ldr	r2, [pc, #40]	; (4038e8 <USART0_Handler+0x58>)
  4038c0:	7013      	strb	r3, [r2, #0]
	}

	cpu_irq_enable();
  4038c2:	2201      	movs	r2, #1
  4038c4:	4b07      	ldr	r3, [pc, #28]	; (4038e4 <USART0_Handler+0x54>)
  4038c6:	701a      	strb	r2, [r3, #0]
  4038c8:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4038cc:	b662      	cpsie	i
}
  4038ce:	b003      	add	sp, #12
  4038d0:	f85d fb04 	ldr.w	pc, [sp], #4
		serial_rx_buf_tail = 0x00;
  4038d4:	2200      	movs	r2, #0
  4038d6:	4b04      	ldr	r3, [pc, #16]	; (4038e8 <USART0_Handler+0x58>)
  4038d8:	701a      	strb	r2, [r3, #0]
  4038da:	e7f2      	b.n	4038c2 <USART0_Handler+0x32>
  4038dc:	400a0000 	.word	0x400a0000
  4038e0:	0040a6c1 	.word	0x0040a6c1
  4038e4:	20000018 	.word	0x20000018
  4038e8:	20007610 	.word	0x20007610
  4038ec:	20007574 	.word	0x20007574

004038f0 <_Z9val_ustept>:

/* ============================== Data Validity Checks ============================== */
inline constexpr bool val_enum(uint16_t value, uint16_t size) { return value <= (size - 1); };
inline constexpr bool val_not_equal_to(uint16_t value, uint16_t not_allowed) { return value != not_allowed; };

inline constexpr bool val_ustep(uint16_t value) { return (value <= 256) && (value > 0) && (value & (value - 1)) == 0; };
  4038f0:	1e43      	subs	r3, r0, #1
  4038f2:	b29b      	uxth	r3, r3
  4038f4:	2bff      	cmp	r3, #255	; 0xff
  4038f6:	d804      	bhi.n	403902 <_Z9val_ustept+0x12>
  4038f8:	1e43      	subs	r3, r0, #1
  4038fa:	4218      	tst	r0, r3
  4038fc:	d003      	beq.n	403906 <_Z9val_ustept+0x16>
  4038fe:	2000      	movs	r0, #0
  403900:	4770      	bx	lr
  403902:	2000      	movs	r0, #0
  403904:	4770      	bx	lr
  403906:	2001      	movs	r0, #1
  403908:	4770      	bx	lr

0040390a <_Z7val_12bt>:
inline constexpr bool val_12b(uint16_t value) { return value <= 0xFFF; };
  40390a:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
  40390e:	bfac      	ite	ge
  403910:	2000      	movge	r0, #0
  403912:	2001      	movlt	r0, #1
  403914:	4770      	bx	lr

00403916 <_Z11val_currentt>:
inline constexpr bool val_current(uint16_t value) { return (value >= 1) && (value <= 31); };
  403916:	3801      	subs	r0, #1
  403918:	b280      	uxth	r0, r0
  40391a:	281e      	cmp	r0, #30
  40391c:	bf8c      	ite	hi
  40391e:	2000      	movhi	r0, #0
  403920:	2001      	movls	r0, #1
  403922:	4770      	bx	lr

00403924 <_Z8val_boolt>:
inline constexpr bool val_bool(uint16_t value) { return (value == 0 || value == 1); };
  403924:	2801      	cmp	r0, #1
  403926:	bf8c      	ite	hi
  403928:	2000      	movhi	r0, #0
  40392a:	2001      	movls	r0, #1
  40392c:	4770      	bx	lr

0040392e <_Z14val_followModet>:
inline constexpr bool val_positioningMode(uint16_t value) { return val_enum(value, 2); };
inline constexpr bool val_followMode(uint16_t value) { return val_enum(value, 2); };
  40392e:	2801      	cmp	r0, #1
  403930:	bfcc      	ite	gt
  403932:	2000      	movgt	r0, #0
  403934:	2001      	movle	r0, #1
  403936:	4770      	bx	lr

00403938 <_Z14val_homingModet>:
inline constexpr bool val_homingMode(uint16_t value) { return val_enum(value, 3); };
  403938:	2802      	cmp	r0, #2
  40393a:	bfcc      	ite	gt
  40393c:	2000      	movgt	r0, #0
  40393e:	2001      	movle	r0, #1
  403940:	4770      	bx	lr

00403942 <_Z16val_homingSensort>:
inline constexpr bool val_homingSensor(uint16_t value) { return val_enum(value, 2); };
  403942:	2801      	cmp	r0, #1
  403944:	bfcc      	ite	gt
  403946:	2000      	movgt	r0, #0
  403948:	2001      	movle	r0, #1
  40394a:	4770      	bx	lr

0040394c <_Z11val_posModet>:
inline constexpr bool val_posMode(uint16_t value) { return val_enum(value, 2); };
  40394c:	2801      	cmp	r0, #1
  40394e:	bfcc      	ite	gt
  403950:	2000      	movgt	r0, #0
  403952:	2001      	movle	r0, #1
  403954:	4770      	bx	lr

00403956 <_Z12val_rampModet>:
inline constexpr bool val_rampMode(uint16_t value) { return (value == 0 || value == 4); };
  403956:	b128      	cbz	r0, 403964 <_Z12val_rampModet+0xe>
  403958:	2804      	cmp	r0, #4
  40395a:	d001      	beq.n	403960 <_Z12val_rampModet+0xa>
  40395c:	2000      	movs	r0, #0
  40395e:	4770      	bx	lr
  403960:	2001      	movs	r0, #1
  403962:	4770      	bx	lr
  403964:	2001      	movs	r0, #1
  403966:	4770      	bx	lr

00403968 <_Z12val_rampTypet>:
inline constexpr bool val_rampType(uint16_t value) { return val_enum(value, 3); };
  403968:	2802      	cmp	r0, #2
  40396a:	bfcc      	ite	gt
  40396c:	2000      	movgt	r0, #0
  40396e:	2001      	movle	r0, #1
  403970:	4770      	bx	lr

00403972 <_Z16val_lessThan1000t>:
inline constexpr bool val_lessThan1000(uint16_t value) { return value <= 1000; }
  403972:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
  403976:	bfcc      	ite	gt
  403978:	2000      	movgt	r0, #0
  40397a:	2001      	movle	r0, #1
  40397c:	4770      	bx	lr

0040397e <_Z15val_maxStepperst>:
inline constexpr bool val_maxSteppers(uint16_t value) { return value < MAX_STEPPERS; }
  40397e:	2804      	cmp	r0, #4
  403980:	bfcc      	ite	gt
  403982:	2000      	movgt	r0, #0
  403984:	2001      	movle	r0, #1
  403986:	4770      	bx	lr

00403988 <_Z18val_sequenceNumbert>:
inline constexpr bool val_sequenceNumber(uint16_t value) { return val_not_equal_to(value, 0xFF); }
  403988:	38ff      	subs	r0, #255	; 0xff
  40398a:	bf18      	it	ne
  40398c:	2001      	movne	r0, #1
  40398e:	4770      	bx	lr

00403990 <_Z14val_motionTypet>:
inline constexpr bool val_motionType(uint16_t value) { return val_enum(value, 5); }
  403990:	2804      	cmp	r0, #4
  403992:	bfcc      	ite	gt
  403994:	2000      	movgt	r0, #0
  403996:	2001      	movle	r0, #1
  403998:	4770      	bx	lr

0040399a <_ZZN12CANInterface14execBoardWriteENS_17BoardWritePayloadEENUltE_4_FUNEt>:
    return Response::SUCCESS;
}

/* ---------------------------------------------------------------------------------- */
uint16_t CANInterface::execBoardWrite(BoardWritePayload payload) {
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  40399a:	2001      	movs	r0, #1
  40399c:	4770      	bx	lr

0040399e <_ZZN12CANInterface14execBoardWriteENS_17BoardWritePayloadEENUltE0_4_FUNEt>:
        key = MotionQueue::QueueItemKey::SENSOR_HOME_VALUE;
        break;
    }
    default: {
        key = MotionQueue::QueueItemKey::SENSOR_HOME_VALUE; // Dummy so that compiler doesn't complain
        val = [](uint16_t data) { return false; };
  40399e:	2000      	movs	r0, #0
  4039a0:	4770      	bx	lr
	...

004039a4 <CAN1_Handler>:
extern "C" void CAN1_Handler(void) {
  4039a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    static CANInterface *getInstance() { return p_can_interface; }
  4039a8:	4b38      	ldr	r3, [pc, #224]	; (403a8c <CAN1_Handler+0xe8>)
  4039aa:	681b      	ldr	r3, [r3, #0]
    if (CANInterface::getInstance() == nullptr) return;
  4039ac:	b31b      	cbz	r3, 4039f6 <CAN1_Handler+0x52>
    ul_status_stepper_r = can_mailbox_get_status(CAN1, CANInterface::RX_STEPPER_R_MB);
  4039ae:	4d38      	ldr	r5, [pc, #224]	; (403a90 <CAN1_Handler+0xec>)
  4039b0:	2100      	movs	r1, #0
  4039b2:	4628      	mov	r0, r5
  4039b4:	4c37      	ldr	r4, [pc, #220]	; (403a94 <CAN1_Handler+0xf0>)
  4039b6:	47a0      	blx	r4
  4039b8:	4606      	mov	r6, r0
    ul_status_stepper_w = can_mailbox_get_status(CAN1, CANInterface::RX_STEPPER_W_MB);
  4039ba:	2101      	movs	r1, #1
  4039bc:	4628      	mov	r0, r5
  4039be:	47a0      	blx	r4
  4039c0:	4607      	mov	r7, r0
    ul_status_board_r   = can_mailbox_get_status(CAN1, CANInterface::RX_BOARD_R_MB);
  4039c2:	2103      	movs	r1, #3
  4039c4:	4628      	mov	r0, r5
  4039c6:	47a0      	blx	r4
  4039c8:	4680      	mov	r8, r0
    ul_status_board_w   = can_mailbox_get_status(CAN1, CANInterface::RX_BOARD_W_MB);
  4039ca:	2104      	movs	r1, #4
  4039cc:	4628      	mov	r0, r5
  4039ce:	47a0      	blx	r4
  4039d0:	4681      	mov	r9, r0
    ul_status_buff      = can_mailbox_get_status(CAN1, CANInterface::RX_BUFF_MB);
  4039d2:	2105      	movs	r1, #5
  4039d4:	4628      	mov	r0, r5
  4039d6:	47a0      	blx	r4
    if (ul_status_stepper_r & CAN_MSR_MRDY) {
  4039d8:	f416 0f00 	tst.w	r6, #8388608	; 0x800000
  4039dc:	d10d      	bne.n	4039fa <CAN1_Handler+0x56>
    } else if (ul_status_stepper_w & CAN_MSR_MRDY) {
  4039de:	f417 0f00 	tst.w	r7, #8388608	; 0x800000
  4039e2:	d119      	bne.n	403a18 <CAN1_Handler+0x74>
    } else if (ul_status_board_r & CAN_MSR_MRDY) {
  4039e4:	f418 0f00 	tst.w	r8, #8388608	; 0x800000
  4039e8:	d124      	bne.n	403a34 <CAN1_Handler+0x90>
    } else if (ul_status_board_w & CAN_MSR_MRDY) {
  4039ea:	f419 0f00 	tst.w	r9, #8388608	; 0x800000
  4039ee:	d130      	bne.n	403a52 <CAN1_Handler+0xae>
    } else if (ul_status_buff & CAN_MSR_MRDY) {
  4039f0:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
  4039f4:	d13c      	bne.n	403a70 <CAN1_Handler+0xcc>
  4039f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4039fa:	4c24      	ldr	r4, [pc, #144]	; (403a8c <CAN1_Handler+0xe8>)
  4039fc:	6821      	ldr	r1, [r4, #0]
        can_mailbox_read(CAN1, &CANInterface::getInstance()->rx_stepper_r_mb);
  4039fe:	3104      	adds	r1, #4
  403a00:	4628      	mov	r0, r5
  403a02:	4b25      	ldr	r3, [pc, #148]	; (403a98 <CAN1_Handler+0xf4>)
  403a04:	4798      	blx	r3
  403a06:	6823      	ldr	r3, [r4, #0]
        CANInterface::getInstance()->recv_mailbox = CANInterface::RX_STEPPER_R_MB;
  403a08:	2200      	movs	r2, #0
  403a0a:	f883 20d1 	strb.w	r2, [r3, #209]	; 0xd1
        CANInterface::getInstance()->can_msg_rdy  = true;
  403a0e:	2201      	movs	r2, #1
  403a10:	f883 20d0 	strb.w	r2, [r3, #208]	; 0xd0
  403a14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403a18:	4c1c      	ldr	r4, [pc, #112]	; (403a8c <CAN1_Handler+0xe8>)
  403a1a:	6821      	ldr	r1, [r4, #0]
        can_mailbox_read(CAN1, &CANInterface::getInstance()->rx_stepper_w_mb);
  403a1c:	3124      	adds	r1, #36	; 0x24
  403a1e:	481c      	ldr	r0, [pc, #112]	; (403a90 <CAN1_Handler+0xec>)
  403a20:	4b1d      	ldr	r3, [pc, #116]	; (403a98 <CAN1_Handler+0xf4>)
  403a22:	4798      	blx	r3
  403a24:	6823      	ldr	r3, [r4, #0]
        CANInterface::getInstance()->recv_mailbox = CANInterface::RX_STEPPER_W_MB;
  403a26:	2201      	movs	r2, #1
  403a28:	f883 20d1 	strb.w	r2, [r3, #209]	; 0xd1
        CANInterface::getInstance()->can_msg_rdy  = true;
  403a2c:	f883 20d0 	strb.w	r2, [r3, #208]	; 0xd0
  403a30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403a34:	4c15      	ldr	r4, [pc, #84]	; (403a8c <CAN1_Handler+0xe8>)
  403a36:	6821      	ldr	r1, [r4, #0]
        can_mailbox_read(CAN1, &CANInterface::getInstance()->rx_board_r_mb);
  403a38:	3148      	adds	r1, #72	; 0x48
  403a3a:	4815      	ldr	r0, [pc, #84]	; (403a90 <CAN1_Handler+0xec>)
  403a3c:	4b16      	ldr	r3, [pc, #88]	; (403a98 <CAN1_Handler+0xf4>)
  403a3e:	4798      	blx	r3
  403a40:	6823      	ldr	r3, [r4, #0]
        CANInterface::getInstance()->recv_mailbox = CANInterface::RX_BOARD_R_MB;
  403a42:	2203      	movs	r2, #3
  403a44:	f883 20d1 	strb.w	r2, [r3, #209]	; 0xd1
        CANInterface::getInstance()->can_msg_rdy  = true;
  403a48:	2201      	movs	r2, #1
  403a4a:	f883 20d0 	strb.w	r2, [r3, #208]	; 0xd0
  403a4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403a52:	4c0e      	ldr	r4, [pc, #56]	; (403a8c <CAN1_Handler+0xe8>)
  403a54:	6821      	ldr	r1, [r4, #0]
        can_mailbox_read(CAN1, &CANInterface::getInstance()->rx_board_w_mb);
  403a56:	3168      	adds	r1, #104	; 0x68
  403a58:	480d      	ldr	r0, [pc, #52]	; (403a90 <CAN1_Handler+0xec>)
  403a5a:	4b0f      	ldr	r3, [pc, #60]	; (403a98 <CAN1_Handler+0xf4>)
  403a5c:	4798      	blx	r3
  403a5e:	6823      	ldr	r3, [r4, #0]
        CANInterface::getInstance()->recv_mailbox = CANInterface::RX_BOARD_W_MB;
  403a60:	2204      	movs	r2, #4
  403a62:	f883 20d1 	strb.w	r2, [r3, #209]	; 0xd1
        CANInterface::getInstance()->can_msg_rdy  = true;
  403a66:	2201      	movs	r2, #1
  403a68:	f883 20d0 	strb.w	r2, [r3, #208]	; 0xd0
  403a6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403a70:	4c06      	ldr	r4, [pc, #24]	; (403a8c <CAN1_Handler+0xe8>)
  403a72:	6821      	ldr	r1, [r4, #0]
        can_mailbox_read(CAN1, &CANInterface::getInstance()->rx_buff_mb);
  403a74:	318c      	adds	r1, #140	; 0x8c
  403a76:	4806      	ldr	r0, [pc, #24]	; (403a90 <CAN1_Handler+0xec>)
  403a78:	4b07      	ldr	r3, [pc, #28]	; (403a98 <CAN1_Handler+0xf4>)
  403a7a:	4798      	blx	r3
  403a7c:	6823      	ldr	r3, [r4, #0]
        CANInterface::getInstance()->recv_mailbox = CANInterface::RX_BUFF_MB;
  403a7e:	2205      	movs	r2, #5
  403a80:	f883 20d1 	strb.w	r2, [r3, #209]	; 0xd1
        CANInterface::getInstance()->can_msg_rdy  = true;
  403a84:	2201      	movs	r2, #1
  403a86:	f883 20d0 	strb.w	r2, [r3, #208]	; 0xd0
  403a8a:	e7b4      	b.n	4039f6 <CAN1_Handler+0x52>
  403a8c:	20007614 	.word	0x20007614
  403a90:	40014000 	.word	0x40014000
  403a94:	0040a92d 	.word	0x0040a92d
  403a98:	0040a9d1 	.word	0x0040a9d1

00403a9c <_ZN12CANInterfaceC1Eh>:
CANInterface::CANInterface(uint8_t device_id) : m_device_id(device_id) {
  403a9c:	b5f0      	push	{r4, r5, r6, r7, lr}
  403a9e:	b085      	sub	sp, #20
  403aa0:	4604      	mov	r4, r0
  403aa2:	2500      	movs	r5, #0
  403aa4:	f880 50d0 	strb.w	r5, [r0, #208]	; 0xd0
  403aa8:	f880 50d1 	strb.w	r5, [r0, #209]	; 0xd1
  403aac:	f880 50d2 	strb.w	r5, [r0, #210]	; 0xd2
  403ab0:	f880 50d3 	strb.w	r5, [r0, #211]	; 0xd3
  403ab4:	f880 50d4 	strb.w	r5, [r0, #212]	; 0xd4
  403ab8:	f880 10d5 	strb.w	r1, [r0, #213]	; 0xd5
  403abc:	f44f 7780 	mov.w	r7, #256	; 0x100
  403ac0:	463a      	mov	r2, r7
  403ac2:	4629      	mov	r1, r5
  403ac4:	30f4      	adds	r0, #244	; 0xf4
  403ac6:	4e0e      	ldr	r6, [pc, #56]	; (403b00 <_ZN12CANInterfaceC1Eh+0x64>)
  403ac8:	47b0      	blx	r6
  403aca:	463a      	mov	r2, r7
  403acc:	4629      	mov	r1, r5
  403ace:	f504 70fa 	add.w	r0, r4, #500	; 0x1f4
  403ad2:	47b0      	blx	r6
  403ad4:	f8c4 52f4 	str.w	r5, [r4, #756]	; 0x2f4
  403ad8:	f884 52f8 	strb.w	r5, [r4, #760]	; 0x2f8
  403adc:	f884 52f9 	strb.w	r5, [r4, #761]	; 0x2f9
    );
  403ae0:	9503      	str	r5, [sp, #12]
  403ae2:	9502      	str	r5, [sp, #8]
  403ae4:	9501      	str	r5, [sp, #4]
  403ae6:	2301      	movs	r3, #1
  403ae8:	9300      	str	r3, [sp, #0]
  403aea:	4623      	mov	r3, r4
  403aec:	f44f 6200 	mov.w	r2, #2048	; 0x800
  403af0:	4904      	ldr	r1, [pc, #16]	; (403b04 <_ZN12CANInterfaceC1Eh+0x68>)
  403af2:	4805      	ldr	r0, [pc, #20]	; (403b08 <_ZN12CANInterfaceC1Eh+0x6c>)
  403af4:	4d05      	ldr	r5, [pc, #20]	; (403b0c <_ZN12CANInterfaceC1Eh+0x70>)
  403af6:	47a8      	blx	r5
}
  403af8:	4620      	mov	r0, r4
  403afa:	b005      	add	sp, #20
  403afc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  403afe:	bf00      	nop
  403b00:	0040c287 	.word	0x0040c287
  403b04:	0040e25c 	.word	0x0040e25c
  403b08:	00404d9d 	.word	0x00404d9d
  403b0c:	00409659 	.word	0x00409659

00403b10 <_ZN12CANInterface15transmitMessageEmt>:
    if (!m_configured) return;
  403b10:	f890 30d4 	ldrb.w	r3, [r0, #212]	; 0xd4
  403b14:	b903      	cbnz	r3, 403b18 <_ZN12CANInterface15transmitMessageEmt+0x8>
  403b16:	4770      	bx	lr
void CANInterface::transmitMessage(uint32_t data_l, uint16_t mailbox_id) {
  403b18:	b570      	push	{r4, r5, r6, lr}
  403b1a:	4616      	mov	r6, r2
  403b1c:	460d      	mov	r5, r1
  403b1e:	4604      	mov	r4, r0
    delay_us(200);
  403b20:	f240 505c 	movw	r0, #1372	; 0x55c
  403b24:	4b0c      	ldr	r3, [pc, #48]	; (403b58 <_ZN12CANInterface15transmitMessageEmt+0x48>)
  403b26:	4798      	blx	r3
    tx_response_mb.ul_id     = CAN_MID_MIDvA(mailbox_id);
  403b28:	4a0c      	ldr	r2, [pc, #48]	; (403b5c <_ZN12CANInterface15transmitMessageEmt+0x4c>)
  403b2a:	ea02 4286 	and.w	r2, r2, r6, lsl #18
  403b2e:	f8c4 20c0 	str.w	r2, [r4, #192]	; 0xc0
    tx_response_mb.uc_length = MAX_CAN_FRAME_DATA_LEN;
  403b32:	2604      	movs	r6, #4
  403b34:	f884 60b6 	strb.w	r6, [r4, #182]	; 0xb6
    tx_response_mb.ul_datal  = data_l;
  403b38:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
    tx_response_mb.ul_datah  = 0;
  403b3c:	2300      	movs	r3, #0
  403b3e:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
    can_mailbox_write(CAN1, &tx_response_mb);
  403b42:	4d07      	ldr	r5, [pc, #28]	; (403b60 <_ZN12CANInterface15transmitMessageEmt+0x50>)
  403b44:	f104 01b0 	add.w	r1, r4, #176	; 0xb0
  403b48:	4628      	mov	r0, r5
  403b4a:	4b06      	ldr	r3, [pc, #24]	; (403b64 <_ZN12CANInterface15transmitMessageEmt+0x54>)
  403b4c:	4798      	blx	r3
    can_global_send_transfer_cmd(CAN1, CAN_TCR_MB2);
  403b4e:	4631      	mov	r1, r6
  403b50:	4628      	mov	r0, r5
  403b52:	4b05      	ldr	r3, [pc, #20]	; (403b68 <_ZN12CANInterface15transmitMessageEmt+0x58>)
  403b54:	4798      	blx	r3
  403b56:	bd70      	pop	{r4, r5, r6, pc}
  403b58:	20000001 	.word	0x20000001
  403b5c:	1ffc0000 	.word	0x1ffc0000
  403b60:	40014000 	.word	0x40014000
  403b64:	0040aa29 	.word	0x0040aa29
  403b68:	0040a921 	.word	0x0040a921

00403b6c <_ZN12CANInterface16registerSteppersEPP7Stepper>:
    for (int i = 0; i < MAX_STEPPERS; i++) {
  403b6c:	2300      	movs	r3, #0
  403b6e:	2b04      	cmp	r3, #4
  403b70:	dc0a      	bgt.n	403b88 <_ZN12CANInterface16registerSteppersEPP7Stepper+0x1c>
void CANInterface::registerSteppers(Stepper *steppers[MAX_STEPPERS]) {
  403b72:	b410      	push	{r4}
        m_steppers[i] = steppers[i]; // copy each pointer
  403b74:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
  403b78:	f103 0236 	add.w	r2, r3, #54	; 0x36
  403b7c:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
    for (int i = 0; i < MAX_STEPPERS; i++) {
  403b80:	3301      	adds	r3, #1
  403b82:	2b04      	cmp	r3, #4
  403b84:	ddf6      	ble.n	403b74 <_ZN12CANInterface16registerSteppersEPP7Stepper+0x8>
}
  403b86:	bc10      	pop	{r4}
  403b88:	4770      	bx	lr

00403b8a <_ZN12CANInterface19registerMotionQueueEP11MotionQueue>:
void CANInterface::registerMotionQueue(MotionQueue *motion_queue) { m_motion_queue = motion_queue; }
  403b8a:	f8c0 10f0 	str.w	r1, [r0, #240]	; 0xf0
  403b8e:	4770      	bx	lr

00403b90 <_ZN12CANInterface14registerSdCardEP6SDCard>:
void CANInterface::registerSdCard(SDCard *sd_card) { m_sd_card = sd_card; }
  403b90:	f8c0 10ec 	str.w	r1, [r0, #236]	; 0xec
  403b94:	4770      	bx	lr
	...

00403b98 <_ZN12CANInterface16handleRXStepperREv>:
void CANInterface::handleRXStepperR() {
  403b98:	b530      	push	{r4, r5, lr}
  403b9a:	b083      	sub	sp, #12
  403b9c:	4604      	mov	r4, r0
    payload.driver_num   = rx_stepper_r_mb.ul_datal >> 28;
  403b9e:	69c3      	ldr	r3, [r0, #28]
  403ba0:	0f1a      	lsrs	r2, r3, #28
    payload.register_num = (rx_stepper_r_mb.ul_datal >> 16) & 0xFFF;
  403ba2:	f3c3 430b 	ubfx	r3, r3, #16, #12
    if (m_steppers[payload.driver_num] == nullptr) {
  403ba6:	3236      	adds	r2, #54	; 0x36
  403ba8:	f850 5022 	ldr.w	r5, [r0, r2, lsl #2]
  403bac:	2d00      	cmp	r5, #0
  403bae:	d049      	beq.n	403c44 <_ZN12CANInterface16handleRXStepperREv+0xac>
        switch (payload.register_num) {
  403bb0:	2b06      	cmp	r3, #6
  403bb2:	d854      	bhi.n	403c5e <_ZN12CANInterface16handleRXStepperREv+0xc6>
  403bb4:	e8df f003 	tbb	[pc, r3]
  403bb8:	22180a04 	.word	0x22180a04
  403bbc:	3a2c      	.short	0x3a2c
  403bbe:	40          	.byte	0x40
  403bbf:	00          	.byte	0x00
            response = static_cast<uint32_t>(stepper->getStatus());
  403bc0:	4628      	mov	r0, r5
  403bc2:	4b29      	ldr	r3, [pc, #164]	; (403c68 <_ZN12CANInterface16handleRXStepperREv+0xd0>)
  403bc4:	4798      	blx	r3
  403bc6:	4601      	mov	r1, r0
    bool     read_success = true;
  403bc8:	2301      	movs	r3, #1
            break;
  403bca:	e03e      	b.n	403c4a <_ZN12CANInterface16handleRXStepperREv+0xb2>
            uint32_t readback_value = 0;
  403bcc:	a902      	add	r1, sp, #8
  403bce:	2300      	movs	r3, #0
  403bd0:	f841 3d04 	str.w	r3, [r1, #-4]!
            bool     has_readback   = static_cast<uint32_t>(stepper->getReadback(&readback_value));
  403bd4:	4628      	mov	r0, r5
  403bd6:	4b25      	ldr	r3, [pc, #148]	; (403c6c <_ZN12CANInterface16handleRXStepperREv+0xd4>)
  403bd8:	4798      	blx	r3
            if (!has_readback) {
  403bda:	b108      	cbz	r0, 403be0 <_ZN12CANInterface16handleRXStepperREv+0x48>
                response = readback_value;
  403bdc:	9901      	ldr	r1, [sp, #4]
  403bde:	e001      	b.n	403be4 <_ZN12CANInterface16handleRXStepperREv+0x4c>
                response = Response::READ_FAIL;
  403be0:	f241 0103 	movw	r1, #4099	; 0x1003
    bool     read_success = true;
  403be4:	2301      	movs	r3, #1
  403be6:	e030      	b.n	403c4a <_ZN12CANInterface16handleRXStepperREv+0xb2>
            int32_t driver_pulse = stepper->getInternalPosition();
  403be8:	4628      	mov	r0, r5
  403bea:	4b21      	ldr	r3, [pc, #132]	; (403c70 <_ZN12CANInterface16handleRXStepperREv+0xd8>)
  403bec:	4798      	blx	r3
            int32_t user_units   = stepper->pulseToUnit(driver_pulse);
  403bee:	4601      	mov	r1, r0
  403bf0:	4628      	mov	r0, r5
  403bf2:	4b20      	ldr	r3, [pc, #128]	; (403c74 <_ZN12CANInterface16handleRXStepperREv+0xdc>)
  403bf4:	4798      	blx	r3
  403bf6:	4601      	mov	r1, r0
    bool     read_success = true;
  403bf8:	2301      	movs	r3, #1
            break;
  403bfa:	e026      	b.n	403c4a <_ZN12CANInterface16handleRXStepperREv+0xb2>
            int32_t driver_pulse = stepper->getEncoderPosition();
  403bfc:	4628      	mov	r0, r5
  403bfe:	4b1e      	ldr	r3, [pc, #120]	; (403c78 <_ZN12CANInterface16handleRXStepperREv+0xe0>)
  403c00:	4798      	blx	r3
            int32_t user_units   = stepper->pulseToUnit(driver_pulse);
  403c02:	4601      	mov	r1, r0
  403c04:	4628      	mov	r0, r5
  403c06:	4b1b      	ldr	r3, [pc, #108]	; (403c74 <_ZN12CANInterface16handleRXStepperREv+0xdc>)
  403c08:	4798      	blx	r3
  403c0a:	4601      	mov	r1, r0
    bool     read_success = true;
  403c0c:	2301      	movs	r3, #1
            break;
  403c0e:	e01c      	b.n	403c4a <_ZN12CANInterface16handleRXStepperREv+0xb2>
            int32_t driver_pulse = stepper->getCurrentSpeed();
  403c10:	4628      	mov	r0, r5
  403c12:	4b1a      	ldr	r3, [pc, #104]	; (403c7c <_ZN12CANInterface16handleRXStepperREv+0xe4>)
  403c14:	4798      	blx	r3
            int32_t user_units   = stepper->pulseToUnit(driver_pulse);
  403c16:	4601      	mov	r1, r0
  403c18:	4628      	mov	r0, r5
  403c1a:	4b16      	ldr	r3, [pc, #88]	; (403c74 <_ZN12CANInterface16handleRXStepperREv+0xdc>)
  403c1c:	4798      	blx	r3
            response = static_cast<uint32_t>(user_units / 6);
  403c1e:	4918      	ldr	r1, [pc, #96]	; (403c80 <_ZN12CANInterface16handleRXStepperREv+0xe8>)
  403c20:	fb81 3100 	smull	r3, r1, r1, r0
  403c24:	eba1 71e0 	sub.w	r1, r1, r0, asr #31
    bool     read_success = true;
  403c28:	2301      	movs	r3, #1
            break;
  403c2a:	e00e      	b.n	403c4a <_ZN12CANInterface16handleRXStepperREv+0xb2>
            response = static_cast<uint32_t>(stepper->getSensorReading());
  403c2c:	4628      	mov	r0, r5
  403c2e:	4b15      	ldr	r3, [pc, #84]	; (403c84 <_ZN12CANInterface16handleRXStepperREv+0xec>)
  403c30:	4798      	blx	r3
  403c32:	4601      	mov	r1, r0
    bool     read_success = true;
  403c34:	2301      	movs	r3, #1
            break;
  403c36:	e008      	b.n	403c4a <_ZN12CANInterface16handleRXStepperREv+0xb2>
            response = stepper->getEncoderPosDev();
  403c38:	4628      	mov	r0, r5
  403c3a:	4b13      	ldr	r3, [pc, #76]	; (403c88 <_ZN12CANInterface16handleRXStepperREv+0xf0>)
  403c3c:	4798      	blx	r3
  403c3e:	4601      	mov	r1, r0
    bool     read_success = true;
  403c40:	2301      	movs	r3, #1
            break;
  403c42:	e002      	b.n	403c4a <_ZN12CANInterface16handleRXStepperREv+0xb2>
        read_success = false;
  403c44:	2300      	movs	r3, #0
        response     = Response::DRIVER_IS_NULL;
  403c46:	f241 0105 	movw	r1, #4101	; 0x1005
    if (!read_success) {
  403c4a:	b913      	cbnz	r3, 403c52 <_ZN12CANInterface16handleRXStepperREv+0xba>
        word = rx_stepper_w_mb.ul_datal & 0xFFFF0000;
  403c4c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        word |= static_cast<uint32_t>(response);
  403c4e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    transmitMessage(word, rx_stepper_r_mbid);
  403c52:	8822      	ldrh	r2, [r4, #0]
  403c54:	4620      	mov	r0, r4
  403c56:	4b0d      	ldr	r3, [pc, #52]	; (403c8c <_ZN12CANInterface16handleRXStepperREv+0xf4>)
  403c58:	4798      	blx	r3
}
  403c5a:	b003      	add	sp, #12
  403c5c:	bd30      	pop	{r4, r5, pc}
            read_success = false;
  403c5e:	2300      	movs	r3, #0
            response     = Response::UNKNOWN;
  403c60:	f241 0107 	movw	r1, #4103	; 0x1007
  403c64:	e7f1      	b.n	403c4a <_ZN12CANInterface16handleRXStepperREv+0xb2>
  403c66:	bf00      	nop
  403c68:	004052f5 	.word	0x004052f5
  403c6c:	00405501 	.word	0x00405501
  403c70:	00406915 	.word	0x00406915
  403c74:	0040551d 	.word	0x0040551d
  403c78:	00406961 	.word	0x00406961
  403c7c:	00406979 	.word	0x00406979
  403c80:	2aaaaaab 	.word	0x2aaaaaab
  403c84:	004063f1 	.word	0x004063f1
  403c88:	00406991 	.word	0x00406991
  403c8c:	00403b11 	.word	0x00403b11

00403c90 <_ZN12CANInterface10handleBuffEv>:
void CANInterface::handleBuff() {
  403c90:	b510      	push	{r4, lr}
    uint32_t data     = rx_buff_mb.ul_datal;
  403c92:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
    if (data == START_WORD) {
  403c96:	4a1d      	ldr	r2, [pc, #116]	; (403d0c <_ZN12CANInterface10handleBuffEv+0x7c>)
  403c98:	4293      	cmp	r3, r2
  403c9a:	d01f      	beq.n	403cdc <_ZN12CANInterface10handleBuffEv+0x4c>
    } else if (data == END_WORD) {
  403c9c:	4a1c      	ldr	r2, [pc, #112]	; (403d10 <_ZN12CANInterface10handleBuffEv+0x80>)
  403c9e:	4293      	cmp	r3, r2
  403ca0:	d027      	beq.n	403cf2 <_ZN12CANInterface10handleBuffEv+0x62>
        if (buffer_listen_start) {
  403ca2:	f890 22f8 	ldrb.w	r2, [r0, #760]	; 0x2f8
  403ca6:	b31a      	cbz	r2, 403cf0 <_ZN12CANInterface10handleBuffEv+0x60>
            buffer[buffer_len++] = (data >> 0) & 0xFF;
  403ca8:	f8d0 12f4 	ldr.w	r1, [r0, #756]	; 0x2f4
  403cac:	1c4a      	adds	r2, r1, #1
  403cae:	4401      	add	r1, r0
  403cb0:	f881 30f4 	strb.w	r3, [r1, #244]	; 0xf4
            buffer[buffer_len++] = (data >> 8) & 0xFF;
  403cb4:	1c51      	adds	r1, r2, #1
  403cb6:	f3c3 2407 	ubfx	r4, r3, #8, #8
  403cba:	4402      	add	r2, r0
  403cbc:	f882 40f4 	strb.w	r4, [r2, #244]	; 0xf4
            buffer[buffer_len++] = (data >> 16) & 0xFF;
  403cc0:	1c4a      	adds	r2, r1, #1
  403cc2:	f3c3 4407 	ubfx	r4, r3, #16, #8
  403cc6:	4401      	add	r1, r0
  403cc8:	f881 40f4 	strb.w	r4, [r1, #244]	; 0xf4
            buffer[buffer_len++] = (data >> 24) & 0xFF;
  403ccc:	1c51      	adds	r1, r2, #1
  403cce:	f8c0 12f4 	str.w	r1, [r0, #756]	; 0x2f4
  403cd2:	0e1b      	lsrs	r3, r3, #24
  403cd4:	4410      	add	r0, r2
  403cd6:	f880 30f4 	strb.w	r3, [r0, #244]	; 0xf4
  403cda:	bd10      	pop	{r4, pc}
        if (buffer_listen_end) {
  403cdc:	f890 32f9 	ldrb.w	r3, [r0, #761]	; 0x2f9
  403ce0:	b973      	cbnz	r3, 403d00 <_ZN12CANInterface10handleBuffEv+0x70>
            buffer_listen_start = true;
  403ce2:	2101      	movs	r1, #1
  403ce4:	f880 12f8 	strb.w	r1, [r0, #760]	; 0x2f8
    transmitMessage(static_cast<uint32_t>(response), rx_buff_mbid);
  403ce8:	f8b0 2088 	ldrh.w	r2, [r0, #136]	; 0x88
  403cec:	4b09      	ldr	r3, [pc, #36]	; (403d14 <_ZN12CANInterface10handleBuffEv+0x84>)
  403cee:	4798      	blx	r3
  403cf0:	bd10      	pop	{r4, pc}
        if (!buffer_listen_start) {
  403cf2:	f890 32f8 	ldrb.w	r3, [r0, #760]	; 0x2f8
  403cf6:	b133      	cbz	r3, 403d06 <_ZN12CANInterface10handleBuffEv+0x76>
            buffer_listen_end = true;
  403cf8:	2101      	movs	r1, #1
  403cfa:	f880 12f9 	strb.w	r1, [r0, #761]	; 0x2f9
  403cfe:	e7f3      	b.n	403ce8 <_ZN12CANInterface10handleBuffEv+0x58>
            response = Response::WRITE_FAIL;
  403d00:	f241 0102 	movw	r1, #4098	; 0x1002
  403d04:	e7f0      	b.n	403ce8 <_ZN12CANInterface10handleBuffEv+0x58>
            response = Response::WRITE_FAIL;
  403d06:	f241 0102 	movw	r1, #4098	; 0x1002
  403d0a:	e7ed      	b.n	403ce8 <_ZN12CANInterface10handleBuffEv+0x58>
  403d0c:	0a0b0c0d 	.word	0x0a0b0c0d
  403d10:	0d0c0b0a 	.word	0x0d0c0b0a
  403d14:	00403b11 	.word	0x00403b11

00403d18 <_ZN12CANInterface10createRxIdEh>:
uint32_t CANInterface::createRxId(uint8_t mailbox_id) { return (mailbox_id << 8) | m_device_id; }
  403d18:	f890 00d5 	ldrb.w	r0, [r0, #213]	; 0xd5
  403d1c:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
  403d20:	4770      	bx	lr

00403d22 <_ZN12CANInterface16resetMailboxConfEP13can_mb_conf_t>:
    p_mailbox->ul_mb_idx   = 0;
  403d22:	2300      	movs	r3, #0
  403d24:	6003      	str	r3, [r0, #0]
    p_mailbox->uc_obj_type = 0;
  403d26:	7103      	strb	r3, [r0, #4]
    p_mailbox->uc_id_ver   = 0;
  403d28:	7143      	strb	r3, [r0, #5]
    p_mailbox->uc_length   = 0;
  403d2a:	7183      	strb	r3, [r0, #6]
    p_mailbox->uc_tx_prio  = 0;
  403d2c:	71c3      	strb	r3, [r0, #7]
    p_mailbox->ul_status   = 0;
  403d2e:	6083      	str	r3, [r0, #8]
    p_mailbox->ul_id_msk   = 0;
  403d30:	60c3      	str	r3, [r0, #12]
    p_mailbox->ul_id       = 0;
  403d32:	6103      	str	r3, [r0, #16]
    p_mailbox->ul_fid      = 0;
  403d34:	6143      	str	r3, [r0, #20]
    p_mailbox->ul_datal    = 0;
  403d36:	6183      	str	r3, [r0, #24]
    p_mailbox->ul_datah    = 0;
  403d38:	61c3      	str	r3, [r0, #28]
  403d3a:	4770      	bx	lr

00403d3c <_ZN12CANInterface13initRxMailboxEP13can_mb_conf_tht>:
void CANInterface::initRxMailbox(can_mb_conf_t *p_mailbox, uint8_t mailbox_id, uint16_t rx_id) {
  403d3c:	b570      	push	{r4, r5, r6, lr}
  403d3e:	460c      	mov	r4, r1
  403d40:	4616      	mov	r6, r2
  403d42:	461d      	mov	r5, r3
    resetMailboxConf(p_mailbox);
  403d44:	4608      	mov	r0, r1
  403d46:	4b09      	ldr	r3, [pc, #36]	; (403d6c <_ZN12CANInterface13initRxMailboxEP13can_mb_conf_tht+0x30>)
  403d48:	4798      	blx	r3
    p_mailbox->ul_mb_idx   = mailbox_id;
  403d4a:	6026      	str	r6, [r4, #0]
    p_mailbox->uc_obj_type = CAN_MB_RX_MODE;
  403d4c:	2301      	movs	r3, #1
  403d4e:	7123      	strb	r3, [r4, #4]
    p_mailbox->uc_length   = MAX_CAN_FRAME_DATA_LEN;
  403d50:	2304      	movs	r3, #4
  403d52:	71a3      	strb	r3, [r4, #6]
    p_mailbox->ul_id_msk   = CAN_MAM_MIDvA_Msk | CAN_MAM_MIDvB_Msk;
  403d54:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
  403d58:	60e3      	str	r3, [r4, #12]
    p_mailbox->ul_id       = CAN_MID_MIDvA(rx_id);
  403d5a:	4b05      	ldr	r3, [pc, #20]	; (403d70 <_ZN12CANInterface13initRxMailboxEP13can_mb_conf_tht+0x34>)
  403d5c:	ea03 4385 	and.w	r3, r3, r5, lsl #18
  403d60:	6123      	str	r3, [r4, #16]
    can_mailbox_init(CAN1, p_mailbox);
  403d62:	4621      	mov	r1, r4
  403d64:	4803      	ldr	r0, [pc, #12]	; (403d74 <_ZN12CANInterface13initRxMailboxEP13can_mb_conf_tht+0x38>)
  403d66:	4b04      	ldr	r3, [pc, #16]	; (403d78 <_ZN12CANInterface13initRxMailboxEP13can_mb_conf_tht+0x3c>)
  403d68:	4798      	blx	r3
  403d6a:	bd70      	pop	{r4, r5, r6, pc}
  403d6c:	00403d23 	.word	0x00403d23
  403d70:	1ffc0000 	.word	0x1ffc0000
  403d74:	40014000 	.word	0x40014000
  403d78:	0040a94f 	.word	0x0040a94f

00403d7c <_ZN12CANInterface13initTxMailboxEP13can_mb_conf_th>:
void CANInterface::initTxMailbox(can_mb_conf_t *p_mailbox, uint8_t mailbox_id) {
  403d7c:	b538      	push	{r3, r4, r5, lr}
  403d7e:	460c      	mov	r4, r1
  403d80:	4615      	mov	r5, r2
    resetMailboxConf(p_mailbox);
  403d82:	4608      	mov	r0, r1
  403d84:	4b07      	ldr	r3, [pc, #28]	; (403da4 <_ZN12CANInterface13initTxMailboxEP13can_mb_conf_th+0x28>)
  403d86:	4798      	blx	r3
    p_mailbox->ul_mb_idx   = mailbox_id;
  403d88:	6025      	str	r5, [r4, #0]
    p_mailbox->uc_obj_type = CAN_MB_TX_MODE;
  403d8a:	2303      	movs	r3, #3
  403d8c:	7123      	strb	r3, [r4, #4]
    p_mailbox->uc_tx_prio  = CAN_TX_PRIO;
  403d8e:	230f      	movs	r3, #15
  403d90:	71e3      	strb	r3, [r4, #7]
    p_mailbox->uc_id_ver   = 0;
  403d92:	2300      	movs	r3, #0
  403d94:	7163      	strb	r3, [r4, #5]
    p_mailbox->ul_id_msk   = 0;
  403d96:	60e3      	str	r3, [r4, #12]
    can_mailbox_init(CAN1, p_mailbox);
  403d98:	4621      	mov	r1, r4
  403d9a:	4803      	ldr	r0, [pc, #12]	; (403da8 <_ZN12CANInterface13initTxMailboxEP13can_mb_conf_th+0x2c>)
  403d9c:	4b03      	ldr	r3, [pc, #12]	; (403dac <_ZN12CANInterface13initTxMailboxEP13can_mb_conf_th+0x30>)
  403d9e:	4798      	blx	r3
  403da0:	bd38      	pop	{r3, r4, r5, pc}
  403da2:	bf00      	nop
  403da4:	00403d23 	.word	0x00403d23
  403da8:	40014000 	.word	0x40014000
  403dac:	0040a94f 	.word	0x0040a94f

00403db0 <_ZN12CANInterface4initEv>:
void CANInterface::init() {
  403db0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  403db4:	4604      	mov	r4, r0
    pmc_enable_periph_clk(ID_CAN1);
  403db6:	2026      	movs	r0, #38	; 0x26
  403db8:	4b3a      	ldr	r3, [pc, #232]	; (403ea4 <_ZN12CANInterface4initEv+0xf4>)
  403dba:	4798      	blx	r3
    if (!can_init(CAN1, ul_sysclk, CAN_BPS_500K)) {
  403dbc:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  403dc0:	4939      	ldr	r1, [pc, #228]	; (403ea8 <_ZN12CANInterface4initEv+0xf8>)
  403dc2:	483a      	ldr	r0, [pc, #232]	; (403eac <_ZN12CANInterface4initEv+0xfc>)
  403dc4:	4b3a      	ldr	r3, [pc, #232]	; (403eb0 <_ZN12CANInterface4initEv+0x100>)
  403dc6:	4798      	blx	r3
  403dc8:	b930      	cbnz	r0, 403dd8 <_ZN12CANInterface4initEv+0x28>
        m_configured    = false;
  403dca:	2300      	movs	r3, #0
  403dcc:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
        p_can_interface = nullptr;
  403dd0:	4a38      	ldr	r2, [pc, #224]	; (403eb4 <_ZN12CANInterface4initEv+0x104>)
  403dd2:	6013      	str	r3, [r2, #0]
        return;
  403dd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    p_can_interface = this;
  403dd8:	4b36      	ldr	r3, [pc, #216]	; (403eb4 <_ZN12CANInterface4initEv+0x104>)
  403dda:	601c      	str	r4, [r3, #0]
    m_configured    = true;
  403ddc:	2701      	movs	r7, #1
  403dde:	f884 70d4 	strb.w	r7, [r4, #212]	; 0xd4
    can_disable_interrupt(CAN1, CAN_DISABLE_ALL_INTERRUPT_MASK);
  403de2:	4d32      	ldr	r5, [pc, #200]	; (403eac <_ZN12CANInterface4initEv+0xfc>)
  403de4:	f04f 31ff 	mov.w	r1, #4294967295
  403de8:	4628      	mov	r0, r5
  403dea:	4b33      	ldr	r3, [pc, #204]	; (403eb8 <_ZN12CANInterface4initEv+0x108>)
  403dec:	4798      	blx	r3
    can_reset_all_mailbox(CAN1);
  403dee:	4628      	mov	r0, r5
  403df0:	4b32      	ldr	r3, [pc, #200]	; (403ebc <_ZN12CANInterface4initEv+0x10c>)
  403df2:	4798      	blx	r3
    rx_stepper_r_mbid = createRxId(RX_STEPPER_R_MB);
  403df4:	2100      	movs	r1, #0
  403df6:	4620      	mov	r0, r4
  403df8:	4e31      	ldr	r6, [pc, #196]	; (403ec0 <_ZN12CANInterface4initEv+0x110>)
  403dfa:	47b0      	blx	r6
  403dfc:	fa1f f880 	uxth.w	r8, r0
  403e00:	f8a4 8000 	strh.w	r8, [r4]
    rx_stepper_w_mbid = createRxId(RX_STEPPER_W_MB);
  403e04:	4639      	mov	r1, r7
  403e06:	4620      	mov	r0, r4
  403e08:	47b0      	blx	r6
  403e0a:	8060      	strh	r0, [r4, #2]
    rx_board_r_mbid   = createRxId(RX_BOARD_R_MB);
  403e0c:	2103      	movs	r1, #3
  403e0e:	4620      	mov	r0, r4
  403e10:	47b0      	blx	r6
  403e12:	f8a4 0044 	strh.w	r0, [r4, #68]	; 0x44
    rx_board_w_mbid   = createRxId(RX_BOARD_W_MB);
  403e16:	2104      	movs	r1, #4
  403e18:	4620      	mov	r0, r4
  403e1a:	47b0      	blx	r6
  403e1c:	f8a4 0046 	strh.w	r0, [r4, #70]	; 0x46
    rx_buff_mbid      = createRxId(RX_BUFF_MB);
  403e20:	2105      	movs	r1, #5
  403e22:	4620      	mov	r0, r4
  403e24:	47b0      	blx	r6
  403e26:	f8a4 0088 	strh.w	r0, [r4, #136]	; 0x88
    initRxMailbox(&rx_stepper_r_mb, RX_STEPPER_R_MB, rx_stepper_r_mbid);
  403e2a:	4643      	mov	r3, r8
  403e2c:	2200      	movs	r2, #0
  403e2e:	1d21      	adds	r1, r4, #4
  403e30:	4620      	mov	r0, r4
  403e32:	4e24      	ldr	r6, [pc, #144]	; (403ec4 <_ZN12CANInterface4initEv+0x114>)
  403e34:	47b0      	blx	r6
    initRxMailbox(&rx_stepper_w_mb, RX_STEPPER_W_MB, rx_stepper_w_mbid);
  403e36:	8863      	ldrh	r3, [r4, #2]
  403e38:	463a      	mov	r2, r7
  403e3a:	f104 0124 	add.w	r1, r4, #36	; 0x24
  403e3e:	4620      	mov	r0, r4
  403e40:	47b0      	blx	r6
    initRxMailbox(&rx_board_r_mb, RX_BOARD_R_MB, rx_board_r_mbid);
  403e42:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
  403e46:	2203      	movs	r2, #3
  403e48:	f104 0148 	add.w	r1, r4, #72	; 0x48
  403e4c:	4620      	mov	r0, r4
  403e4e:	47b0      	blx	r6
    initRxMailbox(&rx_board_w_mb, RX_BOARD_W_MB, rx_board_w_mbid);
  403e50:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  403e54:	2204      	movs	r2, #4
  403e56:	f104 0168 	add.w	r1, r4, #104	; 0x68
  403e5a:	4620      	mov	r0, r4
  403e5c:	47b0      	blx	r6
    initRxMailbox(&rx_buff_mb, RX_BUFF_MB, rx_buff_mbid);
  403e5e:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
  403e62:	2205      	movs	r2, #5
  403e64:	f104 018c 	add.w	r1, r4, #140	; 0x8c
  403e68:	4620      	mov	r0, r4
  403e6a:	47b0      	blx	r6
    initTxMailbox(&tx_response_mb, TX_RESPONSE_MB);
  403e6c:	2202      	movs	r2, #2
  403e6e:	f104 01b0 	add.w	r1, r4, #176	; 0xb0
  403e72:	4620      	mov	r0, r4
  403e74:	4b14      	ldr	r3, [pc, #80]	; (403ec8 <_ZN12CANInterface4initEv+0x118>)
  403e76:	4798      	blx	r3
    can_enable_interrupt(CAN1, 1 << RX_STEPPER_R_MB);
  403e78:	4639      	mov	r1, r7
  403e7a:	4628      	mov	r0, r5
  403e7c:	4c13      	ldr	r4, [pc, #76]	; (403ecc <_ZN12CANInterface4initEv+0x11c>)
  403e7e:	47a0      	blx	r4
    can_enable_interrupt(CAN1, 1 << RX_STEPPER_W_MB);
  403e80:	2102      	movs	r1, #2
  403e82:	4628      	mov	r0, r5
  403e84:	47a0      	blx	r4
    can_enable_interrupt(CAN1, 1 << RX_BOARD_R_MB);
  403e86:	2108      	movs	r1, #8
  403e88:	4628      	mov	r0, r5
  403e8a:	47a0      	blx	r4
    can_enable_interrupt(CAN1, 1 << RX_BOARD_W_MB);
  403e8c:	2110      	movs	r1, #16
  403e8e:	4628      	mov	r0, r5
  403e90:	47a0      	blx	r4
    can_enable_interrupt(CAN1, 1 << RX_BUFF_MB);
  403e92:	2120      	movs	r1, #32
  403e94:	4628      	mov	r0, r5
  403e96:	47a0      	blx	r4
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  403e98:	2240      	movs	r2, #64	; 0x40
  403e9a:	4b0d      	ldr	r3, [pc, #52]	; (403ed0 <_ZN12CANInterface4initEv+0x120>)
  403e9c:	605a      	str	r2, [r3, #4]
  403e9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  403ea2:	bf00      	nop
  403ea4:	0040ad6d 	.word	0x0040ad6d
  403ea8:	05b8d800 	.word	0x05b8d800
  403eac:	40014000 	.word	0x40014000
  403eb0:	0040aab5 	.word	0x0040aab5
  403eb4:	20007614 	.word	0x20007614
  403eb8:	0040a91d 	.word	0x0040a91d
  403ebc:	0040aa91 	.word	0x0040aa91
  403ec0:	00403d19 	.word	0x00403d19
  403ec4:	00403d3d 	.word	0x00403d3d
  403ec8:	00403d7d 	.word	0x00403d7d
  403ecc:	0040a919 	.word	0x0040a919
  403ed0:	e000e100 	.word	0xe000e100

00403ed4 <_ZN12CANInterface14transmitFramesEPKc>:
void CANInterface::transmitFrames(const char *content) {
  403ed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  403ed6:	4607      	mov	r7, r0
  403ed8:	460e      	mov	r6, r1
    transmitMessage(START_WORD, rx_board_w_mbid);
  403eda:	f8b0 2046 	ldrh.w	r2, [r0, #70]	; 0x46
  403ede:	4912      	ldr	r1, [pc, #72]	; (403f28 <_ZN12CANInterface14transmitFramesEPKc+0x54>)
  403ee0:	4b12      	ldr	r3, [pc, #72]	; (403f2c <_ZN12CANInterface14transmitFramesEPKc+0x58>)
  403ee2:	4798      	blx	r3
    size_t len = strlen(content);
  403ee4:	4630      	mov	r0, r6
  403ee6:	4b12      	ldr	r3, [pc, #72]	; (403f30 <_ZN12CANInterface14transmitFramesEPKc+0x5c>)
  403ee8:	4798      	blx	r3
  403eea:	4605      	mov	r5, r0
    size_t i   = 0;
  403eec:	2400      	movs	r4, #0
  403eee:	e004      	b.n	403efa <_ZN12CANInterface14transmitFramesEPKc+0x26>
        transmitMessage(word, rx_board_w_mbid);
  403ef0:	f8b7 2046 	ldrh.w	r2, [r7, #70]	; 0x46
  403ef4:	4638      	mov	r0, r7
  403ef6:	4b0d      	ldr	r3, [pc, #52]	; (403f2c <_ZN12CANInterface14transmitFramesEPKc+0x58>)
  403ef8:	4798      	blx	r3
    while (i < len) {
  403efa:	42ac      	cmp	r4, r5
  403efc:	d20c      	bcs.n	403f18 <_ZN12CANInterface14transmitFramesEPKc+0x44>
  403efe:	2300      	movs	r3, #0
  403f00:	4619      	mov	r1, r3
        for (int b = 0; b < 4; b++) {
  403f02:	2b03      	cmp	r3, #3
  403f04:	dcf4      	bgt.n	403ef0 <_ZN12CANInterface14transmitFramesEPKc+0x1c>
            word |= (uint32_t)(uint8_t)content[i] << (8 * b);
  403f06:	5d32      	ldrb	r2, [r6, r4]
  403f08:	00d8      	lsls	r0, r3, #3
  403f0a:	4082      	lsls	r2, r0
  403f0c:	4311      	orrs	r1, r2
            if (i < len)
  403f0e:	42ac      	cmp	r4, r5
  403f10:	d2ee      	bcs.n	403ef0 <_ZN12CANInterface14transmitFramesEPKc+0x1c>
                i++;
  403f12:	3401      	adds	r4, #1
        for (int b = 0; b < 4; b++) {
  403f14:	3301      	adds	r3, #1
  403f16:	e7f4      	b.n	403f02 <_ZN12CANInterface14transmitFramesEPKc+0x2e>
    transmitMessage(END_WORD, rx_board_w_mbid);
  403f18:	f8b7 2046 	ldrh.w	r2, [r7, #70]	; 0x46
  403f1c:	4905      	ldr	r1, [pc, #20]	; (403f34 <_ZN12CANInterface14transmitFramesEPKc+0x60>)
  403f1e:	4638      	mov	r0, r7
  403f20:	4b02      	ldr	r3, [pc, #8]	; (403f2c <_ZN12CANInterface14transmitFramesEPKc+0x58>)
  403f22:	4798      	blx	r3
  403f24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  403f26:	bf00      	nop
  403f28:	0a0b0c0d 	.word	0x0a0b0c0d
  403f2c:	00403b11 	.word	0x00403b11
  403f30:	0040c78b 	.word	0x0040c78b
  403f34:	0d0c0b0a 	.word	0x0d0c0b0a

00403f38 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE>:
uint16_t CANInterface::execWriteControl(StepperWritePayload payload) {
  403f38:	b530      	push	{r4, r5, lr}
  403f3a:	b083      	sub	sp, #12
  403f3c:	4605      	mov	r5, r0
  403f3e:	ab02      	add	r3, sp, #8
  403f40:	e903 0006 	stmdb	r3, {r1, r2}
    bool     stepper_used_by_queue = m_motion_queue->isStepperUsedInQueue(payload.driver_num);
  403f44:	f89d 4000 	ldrb.w	r4, [sp]
  403f48:	4621      	mov	r1, r4
  403f4a:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  403f4e:	4b3d      	ldr	r3, [pc, #244]	; (404044 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x10c>)
  403f50:	4798      	blx	r3
    Stepper *stepper               = m_steppers[payload.driver_num];
  403f52:	3436      	adds	r4, #54	; 0x36
  403f54:	f855 4024 	ldr.w	r4, [r5, r4, lsl #2]
    if (payload.data == ControlWord::EMERGENCY_STOP) {
  403f58:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  403f5c:	f242 0201 	movw	r2, #8193	; 0x2001
  403f60:	4293      	cmp	r3, r2
  403f62:	d004      	beq.n	403f6e <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x36>
    if (stepper_used_by_queue) { return Response::USED_BY_QUEUE; }
  403f64:	b170      	cbz	r0, 403f84 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x4c>
  403f66:	f241 0006 	movw	r0, #4102	; 0x1006
}
  403f6a:	b003      	add	sp, #12
  403f6c:	bd30      	pop	{r4, r5, pc}
        if (stepper_used_by_queue) { m_motion_queue->abortQueue(); } // abort whole queue
  403f6e:	b920      	cbnz	r0, 403f7a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x42>
        stepper->d_emStop();
  403f70:	4620      	mov	r0, r4
  403f72:	4b35      	ldr	r3, [pc, #212]	; (404048 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x110>)
  403f74:	4798      	blx	r3
        return Response::SUCCESS;
  403f76:	2001      	movs	r0, #1
  403f78:	e7f7      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        if (stepper_used_by_queue) { m_motion_queue->abortQueue(); } // abort whole queue
  403f7a:	f8d5 00f0 	ldr.w	r0, [r5, #240]	; 0xf0
  403f7e:	4b33      	ldr	r3, [pc, #204]	; (40404c <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x114>)
  403f80:	4798      	blx	r3
  403f82:	e7f5      	b.n	403f70 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x38>
    switch (payload.data) {
  403f84:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  403f88:	d043      	beq.n	404012 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xda>
  403f8a:	d911      	bls.n	403fb0 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x78>
  403f8c:	f241 0203 	movw	r2, #4099	; 0x1003
  403f90:	4293      	cmp	r3, r2
  403f92:	d048      	beq.n	404026 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xee>
  403f94:	d81a      	bhi.n	403fcc <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x94>
  403f96:	f241 0201 	movw	r2, #4097	; 0x1001
  403f9a:	4293      	cmp	r3, r2
  403f9c:	d03e      	beq.n	40401c <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xe4>
  403f9e:	f241 0202 	movw	r2, #4098	; 0x1002
  403fa2:	4293      	cmp	r3, r2
  403fa4:	d14b      	bne.n	40403e <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x106>
        return static_cast<uint16_t>(stepper->moveInverseTime());
  403fa6:	4620      	mov	r0, r4
  403fa8:	4b29      	ldr	r3, [pc, #164]	; (404050 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x118>)
  403faa:	4798      	blx	r3
  403fac:	b280      	uxth	r0, r0
  403fae:	e7dc      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
    switch (payload.data) {
  403fb0:	2b01      	cmp	r3, #1
  403fb2:	d01e      	beq.n	403ff2 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xba>
  403fb4:	b1c3      	cbz	r3, 403fe8 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xb0>
  403fb6:	2b02      	cmp	r3, #2
  403fb8:	d020      	beq.n	403ffc <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xc4>
  403fba:	2b03      	cmp	r3, #3
  403fbc:	d13f      	bne.n	40403e <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x106>
        return stepper->d_releaseDriver() ? Response::SUCCESS : Response::WRITE_FAIL;
  403fbe:	4620      	mov	r0, r4
  403fc0:	4b24      	ldr	r3, [pc, #144]	; (404054 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x11c>)
  403fc2:	4798      	blx	r3
  403fc4:	bb18      	cbnz	r0, 40400e <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xd6>
  403fc6:	f241 0002 	movw	r0, #4098	; 0x1002
  403fca:	e7ce      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
    switch (payload.data) {
  403fcc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  403fd0:	d02e      	beq.n	404030 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xf8>
  403fd2:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
  403fd6:	d132      	bne.n	40403e <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x106>
        return stepper->d_setPosition(0) ? Response::SUCCESS : Response::WRITE_FAIL;
  403fd8:	2100      	movs	r1, #0
  403fda:	4620      	mov	r0, r4
  403fdc:	4b1e      	ldr	r3, [pc, #120]	; (404058 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x120>)
  403fde:	4798      	blx	r3
  403fe0:	bb58      	cbnz	r0, 40403a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x102>
  403fe2:	f241 0002 	movw	r0, #4098	; 0x1002
  403fe6:	e7c0      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        return static_cast<uint16_t>(stepper->initController());
  403fe8:	4620      	mov	r0, r4
  403fea:	4b1c      	ldr	r3, [pc, #112]	; (40405c <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x124>)
  403fec:	4798      	blx	r3
  403fee:	b280      	uxth	r0, r0
  403ff0:	e7bb      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        return static_cast<uint16_t>(stepper->setMotion());
  403ff2:	4620      	mov	r0, r4
  403ff4:	4b1a      	ldr	r3, [pc, #104]	; (404060 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x128>)
  403ff6:	4798      	blx	r3
  403ff8:	b280      	uxth	r0, r0
  403ffa:	e7b6      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        return stepper->d_enableDriver() ? Response::SUCCESS : Response::WRITE_FAIL;
  403ffc:	4620      	mov	r0, r4
  403ffe:	4b19      	ldr	r3, [pc, #100]	; (404064 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x12c>)
  404000:	4798      	blx	r3
  404002:	b910      	cbnz	r0, 40400a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0xd2>
  404004:	f241 0002 	movw	r0, #4098	; 0x1002
  404008:	e7af      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
  40400a:	2001      	movs	r0, #1
  40400c:	e7ad      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        return stepper->d_releaseDriver() ? Response::SUCCESS : Response::WRITE_FAIL;
  40400e:	2001      	movs	r0, #1
  404010:	e7ab      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        return static_cast<uint16_t>(stepper->move());
  404012:	4620      	mov	r0, r4
  404014:	4b14      	ldr	r3, [pc, #80]	; (404068 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x130>)
  404016:	4798      	blx	r3
  404018:	b280      	uxth	r0, r0
  40401a:	e7a6      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        return static_cast<uint16_t>(stepper->moveHoming());
  40401c:	4620      	mov	r0, r4
  40401e:	4b13      	ldr	r3, [pc, #76]	; (40406c <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x134>)
  404020:	4798      	blx	r3
  404022:	b280      	uxth	r0, r0
  404024:	e7a1      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        return static_cast<uint16_t>(stepper->moveVibration());
  404026:	4620      	mov	r0, r4
  404028:	4b11      	ldr	r3, [pc, #68]	; (404070 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x138>)
  40402a:	4798      	blx	r3
  40402c:	b280      	uxth	r0, r0
  40402e:	e79c      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        stepper->d_rampStop();
  404030:	4620      	mov	r0, r4
  404032:	4b10      	ldr	r3, [pc, #64]	; (404074 <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x13c>)
  404034:	4798      	blx	r3
        return Response::SUCCESS;
  404036:	2001      	movs	r0, #1
  404038:	e797      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
        return stepper->d_setPosition(0) ? Response::SUCCESS : Response::WRITE_FAIL;
  40403a:	2001      	movs	r0, #1
  40403c:	e795      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
    default: return Response::INVALID_INPUT;
  40403e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  404042:	e792      	b.n	403f6a <_ZN12CANInterface16execWriteControlENS_19StepperWritePayloadE+0x32>
  404044:	00407361 	.word	0x00407361
  404048:	00405261 	.word	0x00405261
  40404c:	00407373 	.word	0x00407373
  404050:	004056b9 	.word	0x004056b9
  404054:	004052d5 	.word	0x004052d5
  404058:	00405291 	.word	0x00405291
  40405c:	00405441 	.word	0x00405441
  404060:	004054a1 	.word	0x004054a1
  404064:	004052b5 	.word	0x004052b5
  404068:	00405635 	.word	0x00405635
  40406c:	004053e5 	.word	0x004053e5
  404070:	00405779 	.word	0x00405779
  404074:	00405279 	.word	0x00405279

00404078 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb>:
                                        bool can_write_while_running) {
  404078:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40407c:	b082      	sub	sp, #8
  40407e:	a802      	add	r0, sp, #8
  404080:	e900 000c 	stmdb	r0, {r2, r3}
  404084:	f8bd 5020 	ldrh.w	r5, [sp, #32]
  404088:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40408a:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
  40408e:	f89d 702c 	ldrb.w	r7, [sp, #44]	; 0x2c
  404092:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    if (cmd_fnc == nullptr) return Response::UNKNOWN;
  404096:	9a00      	ldr	r2, [sp, #0]
  404098:	b14a      	cbz	r2, 4040ae <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x36>
  40409a:	460c      	mov	r4, r1
    bool valid_value = (val_fnc != nullptr) ? val_fnc(value) : true;
  40409c:	b173      	cbz	r3, 4040bc <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x44>
  40409e:	4628      	mov	r0, r5
  4040a0:	4798      	blx	r3
    if (!valid_value) return Response::INVALID_INPUT;
  4040a2:	b968      	cbnz	r0, 4040c0 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x48>
  4040a4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
}
  4040a8:	b002      	add	sp, #8
  4040aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (cmd_fnc == nullptr) return Response::UNKNOWN;
  4040ae:	9a01      	ldr	r2, [sp, #4]
  4040b0:	f012 0f01 	tst.w	r2, #1
  4040b4:	d1f1      	bne.n	40409a <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x22>
  4040b6:	f241 0007 	movw	r0, #4103	; 0x1007
  4040ba:	e7f5      	b.n	4040a8 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x30>
    bool valid_value = (val_fnc != nullptr) ? val_fnc(value) : true;
  4040bc:	2001      	movs	r0, #1
  4040be:	e7f0      	b.n	4040a2 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x2a>
    if (!can_write_while_running && stepper->isRunning()) return Response::BUSY;
  4040c0:	b126      	cbz	r6, 4040cc <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x54>
  4040c2:	2000      	movs	r0, #0
  4040c4:	b130      	cbz	r0, 4040d4 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x5c>
  4040c6:	f241 0004 	movw	r0, #4100	; 0x1004
  4040ca:	e7ed      	b.n	4040a8 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x30>
  4040cc:	4620      	mov	r0, r4
  4040ce:	4b10      	ldr	r3, [pc, #64]	; (404110 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x98>)
  4040d0:	4798      	blx	r3
  4040d2:	e7f7      	b.n	4040c4 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x4c>
    (stepper->*cmd_fnc)(value);
  4040d4:	9801      	ldr	r0, [sp, #4]
  4040d6:	f010 0f01 	tst.w	r0, #1
  4040da:	d10a      	bne.n	4040f2 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x7a>
  4040dc:	9b00      	ldr	r3, [sp, #0]
  4040de:	4629      	mov	r1, r5
  4040e0:	eb04 0060 	add.w	r0, r4, r0, asr #1
  4040e4:	4798      	blx	r3
    if (rst_drv) stepper->rstDrvFlag();
  4040e6:	f1b8 0f00 	cmp.w	r8, #0
  4040ea:	d107      	bne.n	4040fc <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x84>
    if (rst_motion) stepper->rstMotionFlag();
  4040ec:	b957      	cbnz	r7, 404104 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x8c>
    return Response::SUCCESS;
  4040ee:	2001      	movs	r0, #1
  4040f0:	e7da      	b.n	4040a8 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x30>
    (stepper->*cmd_fnc)(value);
  4040f2:	1043      	asrs	r3, r0, #1
  4040f4:	58e2      	ldr	r2, [r4, r3]
  4040f6:	9b00      	ldr	r3, [sp, #0]
  4040f8:	58d3      	ldr	r3, [r2, r3]
  4040fa:	e7f0      	b.n	4040de <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x66>
    if (rst_drv) stepper->rstDrvFlag();
  4040fc:	4620      	mov	r0, r4
  4040fe:	4b05      	ldr	r3, [pc, #20]	; (404114 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x9c>)
  404100:	4798      	blx	r3
  404102:	e7f3      	b.n	4040ec <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x74>
    if (rst_motion) stepper->rstMotionFlag();
  404104:	4620      	mov	r0, r4
  404106:	4b04      	ldr	r3, [pc, #16]	; (404118 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0xa0>)
  404108:	4798      	blx	r3
    return Response::SUCCESS;
  40410a:	2001      	movs	r0, #1
  40410c:	e7cc      	b.n	4040a8 <_ZN12CANInterface16execWriteCommandEP7StepperMS0_FvtEtPFbtEbbb+0x30>
  40410e:	bf00      	nop
  404110:	004063e5 	.word	0x004063e5
  404114:	004053d5 	.word	0x004053d5
  404118:	004053dd 	.word	0x004053dd

0040411c <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE>:
uint16_t CANInterface::execWriteDriver(StepperWritePayload payload) {
  40411c:	b530      	push	{r4, r5, lr}
  40411e:	b08b      	sub	sp, #44	; 0x2c
  404120:	4605      	mov	r5, r0
  404122:	ab06      	add	r3, sp, #24
  404124:	e883 0006 	stmia.w	r3, {r1, r2}
    bool                  stepper_used_by_queue = m_motion_queue->isStepperUsedInQueue(payload.driver_num);
  404128:	f89d 4018 	ldrb.w	r4, [sp, #24]
  40412c:	4621      	mov	r1, r4
  40412e:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  404132:	4b2c      	ldr	r3, [pc, #176]	; (4041e4 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xc8>)
  404134:	4798      	blx	r3
    Stepper              *stepper               = m_steppers[payload.driver_num];
  404136:	3436      	adds	r4, #54	; 0x36
  404138:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
    commandFunctionPtr    cmd_fnc               = nullptr;
  40413c:	2300      	movs	r3, #0
  40413e:	9308      	str	r3, [sp, #32]
  404140:	9309      	str	r3, [sp, #36]	; 0x24
    if (stepper_used_by_queue) { return Response::USED_BY_QUEUE; }
  404142:	b118      	cbz	r0, 40414c <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x30>
  404144:	f241 0006 	movw	r0, #4102	; 0x1006
}
  404148:	b00b      	add	sp, #44	; 0x2c
  40414a:	bd30      	pop	{r4, r5, pc}
    switch (payload.register_num) {
  40414c:	f8bd 301a 	ldrh.w	r3, [sp, #26]
  404150:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
  404154:	2b0a      	cmp	r3, #10
  404156:	d842      	bhi.n	4041de <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xc2>
  404158:	e8df f003 	tbb	[pc, r3]
  40415c:	211d1906 	.word	0x211d1906
  404160:	352d2925 	.word	0x352d2925
  404164:	3139      	.short	0x3139
  404166:	3d          	.byte	0x3d
  404167:	00          	.byte	0x00
        cmd_fnc = &Stepper::setDrv_mstepPerFs;
  404168:	4b1f      	ldr	r3, [pc, #124]	; (4041e8 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xcc>)
  40416a:	9308      	str	r3, [sp, #32]
        val_fnc = val_ustep;
  40416c:	481f      	ldr	r0, [pc, #124]	; (4041ec <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xd0>)
    return execWriteCommand(stepper, cmd_fnc, payload.data, val_fnc, rst_drv, rst_motion);
  40416e:	f8bd 201c 	ldrh.w	r2, [sp, #28]
  404172:	2300      	movs	r3, #0
  404174:	9304      	str	r3, [sp, #16]
  404176:	9303      	str	r3, [sp, #12]
  404178:	2301      	movs	r3, #1
  40417a:	9302      	str	r3, [sp, #8]
  40417c:	9001      	str	r0, [sp, #4]
  40417e:	9200      	str	r2, [sp, #0]
  404180:	ab0a      	add	r3, sp, #40	; 0x28
  404182:	e913 000c 	ldmdb	r3, {r2, r3}
  404186:	4628      	mov	r0, r5
  404188:	4c19      	ldr	r4, [pc, #100]	; (4041f0 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xd4>)
  40418a:	47a0      	blx	r4
  40418c:	e7dc      	b.n	404148 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x2c>
        cmd_fnc = &Stepper::setDrv_fsPerRev;
  40418e:	4b19      	ldr	r3, [pc, #100]	; (4041f4 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xd8>)
  404190:	9308      	str	r3, [sp, #32]
        val_fnc = val_12b;
  404192:	4819      	ldr	r0, [pc, #100]	; (4041f8 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xdc>)
        break;
  404194:	e7eb      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setCurrent_iHold;
  404196:	4b19      	ldr	r3, [pc, #100]	; (4041fc <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xe0>)
  404198:	9308      	str	r3, [sp, #32]
        val_fnc = val_current;
  40419a:	4819      	ldr	r0, [pc, #100]	; (404200 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xe4>)
        break;
  40419c:	e7e7      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setCurrent_iRun;
  40419e:	4b19      	ldr	r3, [pc, #100]	; (404204 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xe8>)
  4041a0:	9308      	str	r3, [sp, #32]
        val_fnc = val_current;
  4041a2:	4817      	ldr	r0, [pc, #92]	; (404200 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xe4>)
        break;
  4041a4:	e7e3      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setStopOnStall_enable;
  4041a6:	4b18      	ldr	r3, [pc, #96]	; (404208 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xec>)
  4041a8:	9308      	str	r3, [sp, #32]
        val_fnc = val_bool;
  4041aa:	4818      	ldr	r0, [pc, #96]	; (40420c <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xf0>)
        break;
  4041ac:	e7df      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setStopOnStall_thresh;
  4041ae:	4b18      	ldr	r3, [pc, #96]	; (404210 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xf4>)
  4041b0:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc               = nullptr;
  4041b2:	2000      	movs	r0, #0
        break;
  4041b4:	e7db      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setClosedLoop_enable;
  4041b6:	4b17      	ldr	r3, [pc, #92]	; (404214 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xf8>)
  4041b8:	9308      	str	r3, [sp, #32]
        val_fnc = val_bool;
  4041ba:	4814      	ldr	r0, [pc, #80]	; (40420c <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xf0>)
        break;
  4041bc:	e7d7      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setClosedLoop_usePID;
  4041be:	4b16      	ldr	r3, [pc, #88]	; (404218 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xfc>)
  4041c0:	9308      	str	r3, [sp, #32]
        val_fnc = val_bool;
  4041c2:	4812      	ldr	r0, [pc, #72]	; (40420c <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0xf0>)
        break;
  4041c4:	e7d3      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setClosedLoop_encInRes;
  4041c6:	4b15      	ldr	r3, [pc, #84]	; (40421c <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x100>)
  4041c8:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc               = nullptr;
  4041ca:	2000      	movs	r0, #0
        break;
  4041cc:	e7cf      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setClosedLoop_tolerance;
  4041ce:	4b14      	ldr	r3, [pc, #80]	; (404220 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x104>)
  4041d0:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc               = nullptr;
  4041d2:	2000      	movs	r0, #0
        break;
  4041d4:	e7cb      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
        cmd_fnc = &Stepper::setStealthChopThreshold;
  4041d6:	4b13      	ldr	r3, [pc, #76]	; (404224 <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x108>)
  4041d8:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc               = nullptr;
  4041da:	2000      	movs	r0, #0
        break;
  4041dc:	e7c7      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
    validationFunctionPtr val_fnc               = nullptr;
  4041de:	2000      	movs	r0, #0
  4041e0:	e7c5      	b.n	40416e <_ZN12CANInterface15execWriteDriverENS_19StepperWritePayloadE+0x52>
  4041e2:	bf00      	nop
  4041e4:	00407361 	.word	0x00407361
  4041e8:	00406479 	.word	0x00406479
  4041ec:	004038f1 	.word	0x004038f1
  4041f0:	00404079 	.word	0x00404079
  4041f4:	0040647d 	.word	0x0040647d
  4041f8:	0040390b 	.word	0x0040390b
  4041fc:	00406481 	.word	0x00406481
  404200:	00403917 	.word	0x00403917
  404204:	00406485 	.word	0x00406485
  404208:	00406489 	.word	0x00406489
  40420c:	00403925 	.word	0x00403925
  404210:	00406493 	.word	0x00406493
  404214:	00406497 	.word	0x00406497
  404218:	004064a1 	.word	0x004064a1
  40421c:	004064ab 	.word	0x004064ab
  404220:	004064af 	.word	0x004064af
  404224:	004064b3 	.word	0x004064b3

00404228 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE>:
uint16_t CANInterface::execWriteMotionParam(StepperWritePayload payload) {
  404228:	b530      	push	{r4, r5, lr}
  40422a:	b08b      	sub	sp, #44	; 0x2c
  40422c:	4605      	mov	r5, r0
  40422e:	ab06      	add	r3, sp, #24
  404230:	e883 0006 	stmia.w	r3, {r1, r2}
    bool                  stepper_used_by_queue   = m_motion_queue->isStepperUsedInQueue(payload.driver_num);
  404234:	f89d 4018 	ldrb.w	r4, [sp, #24]
  404238:	4621      	mov	r1, r4
  40423a:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  40423e:	4b5f      	ldr	r3, [pc, #380]	; (4043bc <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x194>)
  404240:	4798      	blx	r3
    Stepper              *stepper                 = m_steppers[payload.driver_num];
  404242:	3436      	adds	r4, #54	; 0x36
  404244:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
    commandFunctionPtr    cmd_fnc                 = nullptr;
  404248:	2300      	movs	r3, #0
  40424a:	9308      	str	r3, [sp, #32]
  40424c:	9309      	str	r3, [sp, #36]	; 0x24
    if (stepper_used_by_queue) { return Response::USED_BY_QUEUE; }
  40424e:	b118      	cbz	r0, 404258 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x30>
  404250:	f241 0006 	movw	r0, #4102	; 0x1006
}
  404254:	b00b      	add	sp, #44	; 0x2c
  404256:	bd30      	pop	{r4, r5, pc}
  404258:	4602      	mov	r2, r0
    switch (payload.register_num) {
  40425a:	f8bd 301a 	ldrh.w	r3, [sp, #26]
  40425e:	f5a3 7300 	sub.w	r3, r3, #512	; 0x200
  404262:	2b20      	cmp	r3, #32
  404264:	f200 80a7 	bhi.w	4043b6 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x18e>
  404268:	e8df f003 	tbb	[pc, r3]
  40426c:	2d292411 	.word	0x2d292411
  404270:	3d393531 	.word	0x3d393531
  404274:	4d494541 	.word	0x4d494541
  404278:	5d595551 	.word	0x5d595551
  40427c:	6d696561 	.word	0x6d696561
  404280:	7d797571 	.word	0x7d797571
  404284:	8d898581 	.word	0x8d898581
  404288:	9d999591 	.word	0x9d999591
  40428c:	a1          	.byte	0xa1
  40428d:	00          	.byte	0x00
        cmd_fnc                 = &Stepper::setTargetUnitsHigh;
  40428e:	4b4c      	ldr	r3, [pc, #304]	; (4043c0 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x198>)
  404290:	9308      	str	r3, [sp, #32]
        can_write_while_running = true;
  404292:	2201      	movs	r2, #1
    validationFunctionPtr val_fnc                 = nullptr;
  404294:	2400      	movs	r4, #0
    return execWriteCommand(stepper, cmd_fnc, payload.data, val_fnc, rst_drv, rst_motion, can_write_while_running);
  404296:	f8bd 001c 	ldrh.w	r0, [sp, #28]
  40429a:	9204      	str	r2, [sp, #16]
  40429c:	2300      	movs	r3, #0
  40429e:	9303      	str	r3, [sp, #12]
  4042a0:	9302      	str	r3, [sp, #8]
  4042a2:	9401      	str	r4, [sp, #4]
  4042a4:	9000      	str	r0, [sp, #0]
  4042a6:	ab0a      	add	r3, sp, #40	; 0x28
  4042a8:	e913 000c 	ldmdb	r3, {r2, r3}
  4042ac:	4628      	mov	r0, r5
  4042ae:	4c45      	ldr	r4, [pc, #276]	; (4043c4 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x19c>)
  4042b0:	47a0      	blx	r4
  4042b2:	e7cf      	b.n	404254 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x2c>
        cmd_fnc                 = &Stepper::setTargetUnitsLow;
  4042b4:	4b44      	ldr	r3, [pc, #272]	; (4043c8 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1a0>)
  4042b6:	9308      	str	r3, [sp, #32]
        can_write_while_running = true;
  4042b8:	2201      	movs	r2, #1
    validationFunctionPtr val_fnc                 = nullptr;
  4042ba:	2400      	movs	r4, #0
        break;
  4042bc:	e7eb      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::setTimeMsHigh;
  4042be:	4b43      	ldr	r3, [pc, #268]	; (4043cc <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1a4>)
  4042c0:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4042c2:	2400      	movs	r4, #0
        break;
  4042c4:	e7e7      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::setTimeMsLow;
  4042c6:	4b42      	ldr	r3, [pc, #264]	; (4043d0 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1a8>)
  4042c8:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4042ca:	2400      	movs	r4, #0
        break;
  4042cc:	e7e3      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::setVibrationIterations;
  4042ce:	4b41      	ldr	r3, [pc, #260]	; (4043d4 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1ac>)
  4042d0:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4042d2:	2400      	movs	r4, #0
        break;
  4042d4:	e7df      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::setDiminishingFactor;
  4042d6:	4b40      	ldr	r3, [pc, #256]	; (4043d8 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1b0>)
  4042d8:	9308      	str	r3, [sp, #32]
        val_fnc = val_lessThan1000;
  4042da:	4c40      	ldr	r4, [pc, #256]	; (4043dc <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1b4>)
        break;
  4042dc:	e7db      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::setLoop;
  4042de:	4b40      	ldr	r3, [pc, #256]	; (4043e0 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1b8>)
  4042e0:	9308      	str	r3, [sp, #32]
        val_fnc = val_bool;
  4042e2:	4c40      	ldr	r4, [pc, #256]	; (4043e4 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1bc>)
        break;
  4042e4:	e7d7      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confMove_resetMotionConfAfterEachMove;
  4042e6:	4b40      	ldr	r3, [pc, #256]	; (4043e8 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1c0>)
  4042e8:	9308      	str	r3, [sp, #32]
        val_fnc = val_bool;
  4042ea:	4c3e      	ldr	r4, [pc, #248]	; (4043e4 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1bc>)
        break;
  4042ec:	e7d3      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confMove_allowWriteMotionWhenBusy;
  4042ee:	4b3f      	ldr	r3, [pc, #252]	; (4043ec <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1c4>)
  4042f0:	9308      	str	r3, [sp, #32]
        val_fnc = val_bool;
  4042f2:	4c3c      	ldr	r4, [pc, #240]	; (4043e4 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1bc>)
        break;
  4042f4:	e7cf      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confSpeed_maxSpeed_h;
  4042f6:	4b3e      	ldr	r3, [pc, #248]	; (4043f0 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1c8>)
  4042f8:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4042fa:	2400      	movs	r4, #0
        break;
  4042fc:	e7cb      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confSpeed_maxSpeed_l;
  4042fe:	4b3d      	ldr	r3, [pc, #244]	; (4043f4 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1cc>)
  404300:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404302:	2400      	movs	r4, #0
        break;
  404304:	e7c7      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confSpeed_startSpeed_h;
  404306:	4b3c      	ldr	r3, [pc, #240]	; (4043f8 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1d0>)
  404308:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40430a:	2400      	movs	r4, #0
        break;
  40430c:	e7c3      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confSpeed_startSpeed_l;
  40430e:	4b3b      	ldr	r3, [pc, #236]	; (4043fc <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1d4>)
  404310:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404312:	2400      	movs	r4, #0
        break;
  404314:	e7bf      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confSpeed_stopSpeed_h;
  404316:	4b3a      	ldr	r3, [pc, #232]	; (404400 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1d8>)
  404318:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40431a:	2400      	movs	r4, #0
        break;
  40431c:	e7bb      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confSpeed_stopSpeed_l;
  40431e:	4b39      	ldr	r3, [pc, #228]	; (404404 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1dc>)
  404320:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404322:	2400      	movs	r4, #0
        break;
  404324:	e7b7      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confSpeed_breakSpeed_h;
  404326:	4b38      	ldr	r3, [pc, #224]	; (404408 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1e0>)
  404328:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40432a:	2400      	movs	r4, #0
        break;
  40432c:	e7b3      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confSpeed_breakSpeed_l;
  40432e:	4b37      	ldr	r3, [pc, #220]	; (40440c <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1e4>)
  404330:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404332:	2400      	movs	r4, #0
        break;
  404334:	e7af      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confAccel_maxAccel_h;
  404336:	4b36      	ldr	r3, [pc, #216]	; (404410 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1e8>)
  404338:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40433a:	2400      	movs	r4, #0
        break;
  40433c:	e7ab      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confAccel_maxAccel_l;
  40433e:	4b35      	ldr	r3, [pc, #212]	; (404414 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1ec>)
  404340:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404342:	2400      	movs	r4, #0
        break;
  404344:	e7a7      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confAccel_maxDecel_h;
  404346:	4b34      	ldr	r3, [pc, #208]	; (404418 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1f0>)
  404348:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40434a:	2400      	movs	r4, #0
        break;
  40434c:	e7a3      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confAccel_maxDecel_l;
  40434e:	4b33      	ldr	r3, [pc, #204]	; (40441c <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1f4>)
  404350:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404352:	2400      	movs	r4, #0
        break;
  404354:	e79f      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confAccel_startAccel_h;
  404356:	4b32      	ldr	r3, [pc, #200]	; (404420 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1f8>)
  404358:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40435a:	2400      	movs	r4, #0
        break;
  40435c:	e79b      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confAccel_startAccel_l;
  40435e:	4b31      	ldr	r3, [pc, #196]	; (404424 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x1fc>)
  404360:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404362:	2400      	movs	r4, #0
        break;
  404364:	e797      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confAccel_finalDecel_h;
  404366:	4b30      	ldr	r3, [pc, #192]	; (404428 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x200>)
  404368:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40436a:	2400      	movs	r4, #0
        break;
  40436c:	e793      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confAccel_finalDecel_l;
  40436e:	4b2f      	ldr	r3, [pc, #188]	; (40442c <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x204>)
  404370:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404372:	2400      	movs	r4, #0
        break;
  404374:	e78f      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confBow_bow1_h;
  404376:	4b2e      	ldr	r3, [pc, #184]	; (404430 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x208>)
  404378:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40437a:	2400      	movs	r4, #0
        break;
  40437c:	e78b      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confBow_bow1_l;
  40437e:	4b2d      	ldr	r3, [pc, #180]	; (404434 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x20c>)
  404380:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404382:	2400      	movs	r4, #0
        break;
  404384:	e787      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confBow_bow2_h;
  404386:	4b2c      	ldr	r3, [pc, #176]	; (404438 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x210>)
  404388:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40438a:	2400      	movs	r4, #0
        break;
  40438c:	e783      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confBow_bow2_l;
  40438e:	4b2b      	ldr	r3, [pc, #172]	; (40443c <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x214>)
  404390:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404392:	2400      	movs	r4, #0
        break;
  404394:	e77f      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confBow_bow3_h;
  404396:	4b2a      	ldr	r3, [pc, #168]	; (404440 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x218>)
  404398:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40439a:	2400      	movs	r4, #0
        break;
  40439c:	e77b      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confBow_bow3_l;
  40439e:	4b29      	ldr	r3, [pc, #164]	; (404444 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x21c>)
  4043a0:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4043a2:	2400      	movs	r4, #0
        break;
  4043a4:	e777      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confBow_bow4_h;
  4043a6:	4b28      	ldr	r3, [pc, #160]	; (404448 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x220>)
  4043a8:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4043aa:	2400      	movs	r4, #0
        break;
  4043ac:	e773      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
        cmd_fnc = &Stepper::confBow_bow4_l;
  4043ae:	4b27      	ldr	r3, [pc, #156]	; (40444c <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x224>)
  4043b0:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4043b2:	2400      	movs	r4, #0
        break;
  4043b4:	e76f      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
    validationFunctionPtr val_fnc                 = nullptr;
  4043b6:	2400      	movs	r4, #0
  4043b8:	e76d      	b.n	404296 <_ZN12CANInterface20execWriteMotionParamENS_19StepperWritePayloadE+0x6e>
  4043ba:	bf00      	nop
  4043bc:	00407361 	.word	0x00407361
  4043c0:	004053a5 	.word	0x004053a5
  4043c4:	00404079 	.word	0x00404079
  4043c8:	004053ab 	.word	0x004053ab
  4043cc:	004053b1 	.word	0x004053b1
  4043d0:	004053b7 	.word	0x004053b7
  4043d4:	004053bd 	.word	0x004053bd
  4043d8:	004053c3 	.word	0x004053c3
  4043dc:	00403973 	.word	0x00403973
  4043e0:	004053c9 	.word	0x004053c9
  4043e4:	00403925 	.word	0x00403925
  4043e8:	004050a9 	.word	0x004050a9
  4043ec:	004050b5 	.word	0x004050b5
  4043f0:	00405197 	.word	0x00405197
  4043f4:	0040519d 	.word	0x0040519d
  4043f8:	004051a3 	.word	0x004051a3
  4043fc:	004051a9 	.word	0x004051a9
  404400:	004051af 	.word	0x004051af
  404404:	004051b5 	.word	0x004051b5
  404408:	004051bb 	.word	0x004051bb
  40440c:	004051c1 	.word	0x004051c1
  404410:	004051e3 	.word	0x004051e3
  404414:	004051e9 	.word	0x004051e9
  404418:	004051ef 	.word	0x004051ef
  40441c:	004051f5 	.word	0x004051f5
  404420:	004051fb 	.word	0x004051fb
  404424:	00405201 	.word	0x00405201
  404428:	00405207 	.word	0x00405207
  40442c:	0040520d 	.word	0x0040520d
  404430:	0040522f 	.word	0x0040522f
  404434:	00405235 	.word	0x00405235
  404438:	0040523b 	.word	0x0040523b
  40443c:	00405241 	.word	0x00405241
  404440:	00405247 	.word	0x00405247
  404444:	0040524d 	.word	0x0040524d
  404448:	00405253 	.word	0x00405253
  40444c:	00405259 	.word	0x00405259

00404450 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE>:
uint16_t CANInterface::execWriteHoming(StepperWritePayload payload) {
  404450:	b530      	push	{r4, r5, lr}
  404452:	b08b      	sub	sp, #44	; 0x2c
  404454:	4605      	mov	r5, r0
  404456:	ab06      	add	r3, sp, #24
  404458:	e883 0006 	stmia.w	r3, {r1, r2}
    bool                  stepper_used_by_queue   = m_motion_queue->isStepperUsedInQueue(payload.driver_num);
  40445c:	f89d 4018 	ldrb.w	r4, [sp, #24]
  404460:	4621      	mov	r1, r4
  404462:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  404466:	4b35      	ldr	r3, [pc, #212]	; (40453c <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0xec>)
  404468:	4798      	blx	r3
    Stepper              *stepper                 = m_steppers[payload.driver_num];
  40446a:	3436      	adds	r4, #54	; 0x36
  40446c:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
    commandFunctionPtr    cmd_fnc                 = nullptr;
  404470:	2300      	movs	r3, #0
  404472:	9308      	str	r3, [sp, #32]
  404474:	9309      	str	r3, [sp, #36]	; 0x24
    if (stepper_used_by_queue) { return Response::USED_BY_QUEUE; }
  404476:	b118      	cbz	r0, 404480 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x30>
  404478:	f241 0006 	movw	r0, #4102	; 0x1006
}
  40447c:	b00b      	add	sp, #44	; 0x2c
  40447e:	bd30      	pop	{r4, r5, pc}
    switch (payload.register_num) {
  404480:	f8bd 301a 	ldrh.w	r3, [sp, #26]
  404484:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
  404488:	2b0e      	cmp	r3, #14
  40448a:	d854      	bhi.n	404536 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0xe6>
  40448c:	e8df f003 	tbb	[pc, r3]
  404490:	231f1b08 	.word	0x231f1b08
  404494:	332f2b27 	.word	0x332f2b27
  404498:	433f3b37 	.word	0x433f3b37
  40449c:	4b47      	.short	0x4b47
  40449e:	4f          	.byte	0x4f
  40449f:	00          	.byte	0x00
        cmd_fnc = &Stepper::confHome_homingMode;
  4044a0:	4b27      	ldr	r3, [pc, #156]	; (404540 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0xf0>)
  4044a2:	9308      	str	r3, [sp, #32]
        val_fnc = val_homingMode;
  4044a4:	4827      	ldr	r0, [pc, #156]	; (404544 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0xf4>)
    return execWriteCommand(stepper, cmd_fnc, payload.data, val_fnc, rst_drv, rst_motion, can_write_while_running);
  4044a6:	f8bd 201c 	ldrh.w	r2, [sp, #28]
  4044aa:	2301      	movs	r3, #1
  4044ac:	9304      	str	r3, [sp, #16]
  4044ae:	2300      	movs	r3, #0
  4044b0:	9303      	str	r3, [sp, #12]
  4044b2:	9302      	str	r3, [sp, #8]
  4044b4:	9001      	str	r0, [sp, #4]
  4044b6:	9200      	str	r2, [sp, #0]
  4044b8:	ab0a      	add	r3, sp, #40	; 0x28
  4044ba:	e913 000c 	ldmdb	r3, {r2, r3}
  4044be:	4628      	mov	r0, r5
  4044c0:	4c21      	ldr	r4, [pc, #132]	; (404548 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0xf8>)
  4044c2:	47a0      	blx	r4
  4044c4:	e7da      	b.n	40447c <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x2c>
        cmd_fnc = &Stepper::confHome_homingSensor;
  4044c6:	4b21      	ldr	r3, [pc, #132]	; (40454c <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0xfc>)
  4044c8:	9308      	str	r3, [sp, #32]
        val_fnc = val_homingSensor;
  4044ca:	4821      	ldr	r0, [pc, #132]	; (404550 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x100>)
        break;
  4044cc:	e7eb      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_sensorHomeValue;
  4044ce:	4b21      	ldr	r3, [pc, #132]	; (404554 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x104>)
  4044d0:	9308      	str	r3, [sp, #32]
        val_fnc = val_bool;
  4044d2:	4821      	ldr	r0, [pc, #132]	; (404558 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x108>)
        break;
  4044d4:	e7e7      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_maxFind_h;
  4044d6:	4b21      	ldr	r3, [pc, #132]	; (40455c <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x10c>)
  4044d8:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4044da:	2000      	movs	r0, #0
        break;
  4044dc:	e7e3      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_maxFind_l;
  4044de:	4b20      	ldr	r3, [pc, #128]	; (404560 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x110>)
  4044e0:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4044e2:	2000      	movs	r0, #0
        break;
  4044e4:	e7df      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_maxSpeed_h;
  4044e6:	4b1f      	ldr	r3, [pc, #124]	; (404564 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x114>)
  4044e8:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4044ea:	2000      	movs	r0, #0
        break;
  4044ec:	e7db      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_maxSpeed_l;
  4044ee:	4b1e      	ldr	r3, [pc, #120]	; (404568 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x118>)
  4044f0:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4044f2:	2000      	movs	r0, #0
        break;
  4044f4:	e7d7      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_maxAccel_h;
  4044f6:	4b1d      	ldr	r3, [pc, #116]	; (40456c <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x11c>)
  4044f8:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  4044fa:	2000      	movs	r0, #0
        break;
  4044fc:	e7d3      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_maxAccel_l;
  4044fe:	4b1c      	ldr	r3, [pc, #112]	; (404570 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x120>)
  404500:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404502:	2000      	movs	r0, #0
        break;
  404504:	e7cf      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_maxDecel_h;
  404506:	4b1b      	ldr	r3, [pc, #108]	; (404574 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x124>)
  404508:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40450a:	2000      	movs	r0, #0
        break;
  40450c:	e7cb      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_maxDecel_l;
  40450e:	4b1a      	ldr	r3, [pc, #104]	; (404578 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x128>)
  404510:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404512:	2000      	movs	r0, #0
        break;
  404514:	e7c7      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_offset_h;
  404516:	4b19      	ldr	r3, [pc, #100]	; (40457c <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x12c>)
  404518:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40451a:	2000      	movs	r0, #0
        break;
  40451c:	e7c3      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_offset_l;
  40451e:	4b18      	ldr	r3, [pc, #96]	; (404580 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x130>)
  404520:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404522:	2000      	movs	r0, #0
        break;
  404524:	e7bf      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_timeout_h;
  404526:	4b17      	ldr	r3, [pc, #92]	; (404584 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x134>)
  404528:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  40452a:	2000      	movs	r0, #0
        break;
  40452c:	e7bb      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
        cmd_fnc = &Stepper::confHome_timeout_l;
  40452e:	4b16      	ldr	r3, [pc, #88]	; (404588 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x138>)
  404530:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc                 = nullptr;
  404532:	2000      	movs	r0, #0
        break;
  404534:	e7b7      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
    validationFunctionPtr val_fnc                 = nullptr;
  404536:	2000      	movs	r0, #0
  404538:	e7b5      	b.n	4044a6 <_ZN12CANInterface15execWriteHomingENS_19StepperWritePayloadE+0x56>
  40453a:	bf00      	nop
  40453c:	00407361 	.word	0x00407361
  404540:	004050f3 	.word	0x004050f3
  404544:	00403939 	.word	0x00403939
  404548:	00404079 	.word	0x00404079
  40454c:	004050f9 	.word	0x004050f9
  404550:	00403943 	.word	0x00403943
  404554:	004050ff 	.word	0x004050ff
  404558:	00403925 	.word	0x00403925
  40455c:	0040510b 	.word	0x0040510b
  404560:	00405111 	.word	0x00405111
  404564:	00405117 	.word	0x00405117
  404568:	0040511d 	.word	0x0040511d
  40456c:	00405123 	.word	0x00405123
  404570:	00405129 	.word	0x00405129
  404574:	0040512f 	.word	0x0040512f
  404578:	00405135 	.word	0x00405135
  40457c:	0040513b 	.word	0x0040513b
  404580:	00405141 	.word	0x00405141
  404584:	00405147 	.word	0x00405147
  404588:	0040514d 	.word	0x0040514d

0040458c <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE>:
uint16_t CANInterface::execWriteMotionSettings(StepperWritePayload payload) {
  40458c:	b530      	push	{r4, r5, lr}
  40458e:	b08b      	sub	sp, #44	; 0x2c
  404590:	4605      	mov	r5, r0
  404592:	ab06      	add	r3, sp, #24
  404594:	e883 0006 	stmia.w	r3, {r1, r2}
    bool                  stepper_used_by_queue = m_motion_queue->isStepperUsedInQueue(payload.driver_num);
  404598:	f89d 4018 	ldrb.w	r4, [sp, #24]
  40459c:	4621      	mov	r1, r4
  40459e:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  4045a2:	4b1e      	ldr	r3, [pc, #120]	; (40461c <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x90>)
  4045a4:	4798      	blx	r3
    Stepper              *stepper               = m_steppers[payload.driver_num];
  4045a6:	3436      	adds	r4, #54	; 0x36
  4045a8:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
    commandFunctionPtr    cmd_fnc               = nullptr;
  4045ac:	2300      	movs	r3, #0
  4045ae:	9308      	str	r3, [sp, #32]
  4045b0:	9309      	str	r3, [sp, #36]	; 0x24
    if (stepper_used_by_queue) { return Response::USED_BY_QUEUE; }
  4045b2:	b118      	cbz	r0, 4045bc <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x30>
  4045b4:	f241 0006 	movw	r0, #4102	; 0x1006
}
  4045b8:	b00b      	add	sp, #44	; 0x2c
  4045ba:	bd30      	pop	{r4, r5, pc}
    switch (payload.register_num) {
  4045bc:	f8bd 301a 	ldrh.w	r3, [sp, #26]
  4045c0:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
  4045c4:	2b04      	cmp	r3, #4
  4045c6:	d827      	bhi.n	404618 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x8c>
  4045c8:	e8df f003 	tbb	[pc, r3]
  4045cc:	1e1a1603 	.word	0x1e1a1603
  4045d0:	22          	.byte	0x22
  4045d1:	00          	.byte	0x00
        cmd_fnc = &Stepper::confPositioning_posMode;
  4045d2:	4b13      	ldr	r3, [pc, #76]	; (404620 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x94>)
  4045d4:	9308      	str	r3, [sp, #32]
        val_fnc = val_posMode;
  4045d6:	4c13      	ldr	r4, [pc, #76]	; (404624 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x98>)
    return execWriteCommand(stepper, cmd_fnc, payload.data, val_fnc, rst_drv, rst_motion);
  4045d8:	f8bd 201c 	ldrh.w	r2, [sp, #28]
  4045dc:	2300      	movs	r3, #0
  4045de:	9304      	str	r3, [sp, #16]
  4045e0:	2001      	movs	r0, #1
  4045e2:	9003      	str	r0, [sp, #12]
  4045e4:	9302      	str	r3, [sp, #8]
  4045e6:	9401      	str	r4, [sp, #4]
  4045e8:	9200      	str	r2, [sp, #0]
  4045ea:	ab0a      	add	r3, sp, #40	; 0x28
  4045ec:	e913 000c 	ldmdb	r3, {r2, r3}
  4045f0:	4628      	mov	r0, r5
  4045f2:	4c0d      	ldr	r4, [pc, #52]	; (404628 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x9c>)
  4045f4:	47a0      	blx	r4
  4045f6:	e7df      	b.n	4045b8 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x2c>
        cmd_fnc = &Stepper::confPositioning_followMode;
  4045f8:	4b0c      	ldr	r3, [pc, #48]	; (40462c <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0xa0>)
  4045fa:	9308      	str	r3, [sp, #32]
        val_fnc = val_followMode;
  4045fc:	4c0c      	ldr	r4, [pc, #48]	; (404630 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0xa4>)
        break;
  4045fe:	e7eb      	b.n	4045d8 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x4c>
        cmd_fnc    = &Stepper::confPositioning_unitPerRev;
  404600:	4b0c      	ldr	r3, [pc, #48]	; (404634 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0xa8>)
  404602:	9308      	str	r3, [sp, #32]
    validationFunctionPtr val_fnc               = nullptr;
  404604:	2400      	movs	r4, #0
        break;
  404606:	e7e7      	b.n	4045d8 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x4c>
        cmd_fnc = &Stepper::confRamp_rampMode;
  404608:	4b0b      	ldr	r3, [pc, #44]	; (404638 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0xac>)
  40460a:	9308      	str	r3, [sp, #32]
        val_fnc = val_rampMode;
  40460c:	4c0b      	ldr	r4, [pc, #44]	; (40463c <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0xb0>)
        break;
  40460e:	e7e3      	b.n	4045d8 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x4c>
        cmd_fnc = &Stepper::confRamp_rampType;
  404610:	4b0b      	ldr	r3, [pc, #44]	; (404640 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0xb4>)
  404612:	9308      	str	r3, [sp, #32]
        val_fnc = val_rampType;
  404614:	4c0b      	ldr	r4, [pc, #44]	; (404644 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0xb8>)
        break;
  404616:	e7df      	b.n	4045d8 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x4c>
    validationFunctionPtr val_fnc               = nullptr;
  404618:	2400      	movs	r4, #0
  40461a:	e7dd      	b.n	4045d8 <_ZN12CANInterface23execWriteMotionSettingsENS_19StepperWritePayloadE+0x4c>
  40461c:	00407361 	.word	0x00407361
  404620:	00405153 	.word	0x00405153
  404624:	0040394d 	.word	0x0040394d
  404628:	00404079 	.word	0x00404079
  40462c:	00405159 	.word	0x00405159
  404630:	0040392f 	.word	0x0040392f
  404634:	0040515f 	.word	0x0040515f
  404638:	0040516f 	.word	0x0040516f
  40463c:	00403957 	.word	0x00403957
  404640:	00405175 	.word	0x00405175
  404644:	00403969 	.word	0x00403969

00404648 <_ZN12CANInterface16handleRXStepperWEv>:
void CANInterface::handleRXStepperW() {
  404648:	b510      	push	{r4, lr}
  40464a:	b082      	sub	sp, #8
  40464c:	4604      	mov	r4, r0
    payload.driver_num   = rx_stepper_w_mb.ul_datal >> 28;
  40464e:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  404650:	0f0b      	lsrs	r3, r1, #28
  404652:	f88d 3000 	strb.w	r3, [sp]
    payload.register_num = (rx_stepper_w_mb.ul_datal >> 16) & 0xFFF;
  404656:	f3c1 420b 	ubfx	r2, r1, #16, #12
  40465a:	f8ad 2002 	strh.w	r2, [sp, #2]
    payload.data         = rx_stepper_w_mb.ul_datal & 0xFFFF;
  40465e:	f8ad 1004 	strh.w	r1, [sp, #4]
    if (m_steppers[payload.driver_num] == nullptr)
  404662:	3336      	adds	r3, #54	; 0x36
  404664:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
  404668:	2b00      	cmp	r3, #0
  40466a:	d036      	beq.n	4046da <_ZN12CANInterface16handleRXStepperWEv+0x92>
    else if (payload.register_num <= REG_WRITE_CONTROL_MAX)
  40466c:	2aff      	cmp	r2, #255	; 0xff
  40466e:	dd16      	ble.n	40469e <_ZN12CANInterface16handleRXStepperWEv+0x56>
    else if (payload.register_num <= REG_WRITE_DRIVER_MAX)
  404670:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  404674:	db19      	blt.n	4046aa <_ZN12CANInterface16handleRXStepperWEv+0x62>
    else if (payload.register_num <= REG_WRITE_MOTION_PARAM_MAX)
  404676:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
  40467a:	db1c      	blt.n	4046b6 <_ZN12CANInterface16handleRXStepperWEv+0x6e>
    else if (payload.register_num <= REG_WRITE_HOME_MAX)
  40467c:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
  404680:	db1f      	blt.n	4046c2 <_ZN12CANInterface16handleRXStepperWEv+0x7a>
    else if (payload.register_num <= REG_WRITE_MOTION_SETTINGS_MAX)
  404682:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
  404686:	db22      	blt.n	4046ce <_ZN12CANInterface16handleRXStepperWEv+0x86>
        response = Response::UNKNOWN;
  404688:	f241 0007 	movw	r0, #4103	; 0x1007
    word = rx_stepper_w_mb.ul_datal & 0xFFFF0000;
  40468c:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
    transmitMessage(word, rx_stepper_w_mbid);
  40468e:	8862      	ldrh	r2, [r4, #2]
  404690:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  404694:	4620      	mov	r0, r4
  404696:	4b12      	ldr	r3, [pc, #72]	; (4046e0 <_ZN12CANInterface16handleRXStepperWEv+0x98>)
  404698:	4798      	blx	r3
}
  40469a:	b002      	add	sp, #8
  40469c:	bd10      	pop	{r4, pc}
        response = execWriteControl(payload);
  40469e:	ab02      	add	r3, sp, #8
  4046a0:	e913 0006 	ldmdb	r3, {r1, r2}
  4046a4:	4b0f      	ldr	r3, [pc, #60]	; (4046e4 <_ZN12CANInterface16handleRXStepperWEv+0x9c>)
  4046a6:	4798      	blx	r3
  4046a8:	e7f0      	b.n	40468c <_ZN12CANInterface16handleRXStepperWEv+0x44>
        response = execWriteDriver(payload);
  4046aa:	ab02      	add	r3, sp, #8
  4046ac:	e913 0006 	ldmdb	r3, {r1, r2}
  4046b0:	4b0d      	ldr	r3, [pc, #52]	; (4046e8 <_ZN12CANInterface16handleRXStepperWEv+0xa0>)
  4046b2:	4798      	blx	r3
  4046b4:	e7ea      	b.n	40468c <_ZN12CANInterface16handleRXStepperWEv+0x44>
        response = execWriteMotionParam(payload);
  4046b6:	ab02      	add	r3, sp, #8
  4046b8:	e913 0006 	ldmdb	r3, {r1, r2}
  4046bc:	4b0b      	ldr	r3, [pc, #44]	; (4046ec <_ZN12CANInterface16handleRXStepperWEv+0xa4>)
  4046be:	4798      	blx	r3
  4046c0:	e7e4      	b.n	40468c <_ZN12CANInterface16handleRXStepperWEv+0x44>
        response = execWriteHoming(payload);
  4046c2:	ab02      	add	r3, sp, #8
  4046c4:	e913 0006 	ldmdb	r3, {r1, r2}
  4046c8:	4b09      	ldr	r3, [pc, #36]	; (4046f0 <_ZN12CANInterface16handleRXStepperWEv+0xa8>)
  4046ca:	4798      	blx	r3
  4046cc:	e7de      	b.n	40468c <_ZN12CANInterface16handleRXStepperWEv+0x44>
        response = execWriteMotionSettings(payload);
  4046ce:	ab02      	add	r3, sp, #8
  4046d0:	e913 0006 	ldmdb	r3, {r1, r2}
  4046d4:	4b07      	ldr	r3, [pc, #28]	; (4046f4 <_ZN12CANInterface16handleRXStepperWEv+0xac>)
  4046d6:	4798      	blx	r3
  4046d8:	e7d8      	b.n	40468c <_ZN12CANInterface16handleRXStepperWEv+0x44>
        response = Response::DRIVER_IS_NULL;
  4046da:	f241 0005 	movw	r0, #4101	; 0x1005
  4046de:	e7d5      	b.n	40468c <_ZN12CANInterface16handleRXStepperWEv+0x44>
  4046e0:	00403b11 	.word	0x00403b11
  4046e4:	00403f39 	.word	0x00403f39
  4046e8:	0040411d 	.word	0x0040411d
  4046ec:	00404229 	.word	0x00404229
  4046f0:	00404451 	.word	0x00404451
  4046f4:	0040458d 	.word	0x0040458d

004046f8 <_ZN12CANInterface20selectMotionAndQueueEt>:
    uint8_t motion_num = static_cast<uint8_t>((data >> 8) & 0xFF);
  4046f8:	0a0a      	lsrs	r2, r1, #8
    uint8_t item_num   = static_cast<uint8_t>(data & 0xFF);
  4046fa:	b2c9      	uxtb	r1, r1
    if ((motion_num > MAX_MOTIONS && motion_num != TEST_MOTION_NUM) || (item_num > MAX_ITEMS_PER_MOTION)) {
  4046fc:	f1a2 0310 	sub.w	r3, r2, #16
  404700:	b2db      	uxtb	r3, r3
  404702:	2bee      	cmp	r3, #238	; 0xee
  404704:	d802      	bhi.n	40470c <_ZN12CANInterface20selectMotionAndQueueEt+0x14>
        return Response::VALUE_OUT_OF_BOUNDS;
  404706:	f241 0001 	movw	r0, #4097	; 0x1001
  40470a:	4770      	bx	lr
    if ((motion_num > MAX_MOTIONS && motion_num != TEST_MOTION_NUM) || (item_num > MAX_ITEMS_PER_MOTION)) {
  40470c:	2920      	cmp	r1, #32
  40470e:	dd02      	ble.n	404716 <_ZN12CANInterface20selectMotionAndQueueEt+0x1e>
        return Response::VALUE_OUT_OF_BOUNDS;
  404710:	f241 0001 	movw	r0, #4097	; 0x1001
}
  404714:	4770      	bx	lr
    m_motion_sel = motion_num;
  404716:	f880 20d2 	strb.w	r2, [r0, #210]	; 0xd2
    m_item_sel   = item_num;
  40471a:	f880 10d3 	strb.w	r1, [r0, #211]	; 0xd3
    return Response::SUCCESS;
  40471e:	2001      	movs	r0, #1
  404720:	4770      	bx	lr
	...

00404724 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE>:
uint16_t CANInterface::execBoardWrite(BoardWritePayload payload) {
  404724:	b570      	push	{r4, r5, r6, lr}
  404726:	b084      	sub	sp, #16
  404728:	4604      	mov	r4, r0
  40472a:	9103      	str	r1, [sp, #12]
    uint16_t queue_status       = m_motion_queue->getQueueStatus();
  40472c:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  404730:	4b6f      	ldr	r3, [pc, #444]	; (4048f0 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1cc>)
  404732:	4798      	blx	r3
    if (queue_is_executing) { return Response::USED_BY_QUEUE; }
  404734:	f410 4f00 	tst.w	r0, #32768	; 0x8000
  404738:	f040 80d7 	bne.w	4048ea <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1c6>
    switch (payload.register_num) {
  40473c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
  404740:	f5b3 7f42 	cmp.w	r3, #776	; 0x308
  404744:	f000 80a1 	beq.w	40488a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x166>
  404748:	d91a      	bls.n	404780 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x5c>
  40474a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  40474e:	f000 80ab 	beq.w	4048a8 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x184>
  404752:	d94a      	bls.n	4047ea <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0xc6>
  404754:	f240 6201 	movw	r2, #1537	; 0x601
  404758:	4293      	cmp	r3, r2
  40475a:	f000 80b1 	beq.w	4048c0 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x19c>
  40475e:	d864      	bhi.n	40482a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x106>
  404760:	f240 5201 	movw	r2, #1281	; 0x501
  404764:	4293      	cmp	r3, r2
  404766:	f000 80a5 	beq.w	4048b4 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x190>
  40476a:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
  40476e:	f000 80a4 	beq.w	4048ba <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x196>
  404772:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
  404776:	f000 809a 	beq.w	4048ae <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x18a>
        key = MotionQueue::QueueItemKey::SENSOR_HOME_VALUE; // Dummy so that compiler doesn't complain
  40477a:	2609      	movs	r6, #9
        val = [](uint16_t data) { return false; };
  40477c:	4b5d      	ldr	r3, [pc, #372]	; (4048f4 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1d0>)
        break;
  40477e:	e062      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
    switch (payload.register_num) {
  404780:	f240 3201 	movw	r2, #769	; 0x301
  404784:	4293      	cmp	r3, r2
  404786:	d071      	beq.n	40486c <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x148>
  404788:	d818      	bhi.n	4047bc <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x98>
  40478a:	f240 2202 	movw	r2, #514	; 0x202
  40478e:	4293      	cmp	r3, r2
  404790:	d063      	beq.n	40485a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x136>
  404792:	d909      	bls.n	4047a8 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x84>
  404794:	f5b3 7f01 	cmp.w	r3, #516	; 0x204
  404798:	d065      	beq.n	404866 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x142>
  40479a:	d361      	bcc.n	404860 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x13c>
  40479c:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
  4047a0:	d1eb      	bne.n	40477a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x56>
        key = MotionQueue::QueueItemKey::RAMP_TYPE;
  4047a2:	260a      	movs	r6, #10
        val = val_rampType;
  4047a4:	4b54      	ldr	r3, [pc, #336]	; (4048f8 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1d4>)
        break;
  4047a6:	e04e      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
    switch (payload.register_num) {
  4047a8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  4047ac:	d049      	beq.n	404842 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x11e>
  4047ae:	f240 2201 	movw	r2, #513	; 0x201
  4047b2:	4293      	cmp	r3, r2
  4047b4:	d1e1      	bne.n	40477a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x56>
        key = MotionQueue::QueueItemKey::MOTION_TYPE;
  4047b6:	2600      	movs	r6, #0
        val = val_motionType;
  4047b8:	4b50      	ldr	r3, [pc, #320]	; (4048fc <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1d8>)
  4047ba:	e044      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
    switch (payload.register_num) {
  4047bc:	f5b3 7f41 	cmp.w	r3, #772	; 0x304
  4047c0:	d05a      	beq.n	404878 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x154>
  4047c2:	d907      	bls.n	4047d4 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0xb0>
  4047c4:	f240 3206 	movw	r2, #774	; 0x306
  4047c8:	4293      	cmp	r3, r2
  4047ca:	d058      	beq.n	40487e <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x15a>
  4047cc:	d85a      	bhi.n	404884 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x160>
        key = MotionQueue::QueueItemKey::MAX_DECEL_H;
  4047ce:	260f      	movs	r6, #15
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  4047d0:	4b4b      	ldr	r3, [pc, #300]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  4047d2:	e038      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
    switch (payload.register_num) {
  4047d4:	f240 3202 	movw	r2, #770	; 0x302
  4047d8:	4293      	cmp	r3, r2
  4047da:	d04a      	beq.n	404872 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x14e>
  4047dc:	f240 3203 	movw	r2, #771	; 0x303
  4047e0:	4293      	cmp	r3, r2
  4047e2:	d1ca      	bne.n	40477a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x56>
        key = MotionQueue::QueueItemKey::MAX_ACCEL_H;
  4047e4:	260d      	movs	r6, #13
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  4047e6:	4b46      	ldr	r3, [pc, #280]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  4047e8:	e02d      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
    switch (payload.register_num) {
  4047ea:	f240 320b 	movw	r2, #779	; 0x30b
  4047ee:	4293      	cmp	r3, r2
  4047f0:	d051      	beq.n	404896 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x172>
  4047f2:	f5b3 7f43 	cmp.w	r3, #780	; 0x30c
  4047f6:	d30d      	bcc.n	404814 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0xf0>
  4047f8:	f240 320d 	movw	r2, #781	; 0x30d
  4047fc:	4293      	cmp	r3, r2
  4047fe:	d050      	beq.n	4048a2 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x17e>
  404800:	f5b3 7f43 	cmp.w	r3, #780	; 0x30c
  404804:	d94a      	bls.n	40489c <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x178>
  404806:	f240 320e 	movw	r2, #782	; 0x30e
  40480a:	4293      	cmp	r3, r2
  40480c:	d1b5      	bne.n	40477a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x56>
        key = MotionQueue::QueueItemKey::BOW4_L;
  40480e:	2618      	movs	r6, #24
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404810:	4b3b      	ldr	r3, [pc, #236]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  404812:	e018      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
    switch (payload.register_num) {
  404814:	f240 3209 	movw	r2, #777	; 0x309
  404818:	4293      	cmp	r3, r2
  40481a:	d039      	beq.n	404890 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x16c>
  40481c:	f240 320a 	movw	r2, #778	; 0x30a
  404820:	4293      	cmp	r3, r2
  404822:	d1aa      	bne.n	40477a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x56>
        key = MotionQueue::QueueItemKey::BOW2_L;
  404824:	2614      	movs	r6, #20
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404826:	4b36      	ldr	r3, [pc, #216]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  404828:	e00d      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
    switch (payload.register_num) {
  40482a:	f240 6203 	movw	r2, #1539	; 0x603
  40482e:	4293      	cmp	r3, r2
  404830:	d04c      	beq.n	4048cc <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1a8>
  404832:	d348      	bcc.n	4048c6 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1a2>
  404834:	f240 6204 	movw	r2, #1540	; 0x604
  404838:	4293      	cmp	r3, r2
  40483a:	d19e      	bne.n	40477a <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x56>
        key = MotionQueue::QueueItemKey::SENSOR_HOME_VALUE;
  40483c:	2609      	movs	r6, #9
        val = val_bool;
  40483e:	4b31      	ldr	r3, [pc, #196]	; (404904 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1e0>)
        break;
  404840:	e001      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::DRIVER_NUMBER;
  404842:	2602      	movs	r6, #2
        val = val_maxSteppers;
  404844:	4b30      	ldr	r3, [pc, #192]	; (404908 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1e4>)
    }
    }

    if (!val(payload.data)) {
  404846:	f8bd 500e 	ldrh.w	r5, [sp, #14]
  40484a:	4628      	mov	r0, r5
  40484c:	4798      	blx	r3
  40484e:	2800      	cmp	r0, #0
  404850:	d13f      	bne.n	4048d2 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1ae>
        can_interface_debug("(execBoardWrite) Key %d failed check", key);
        return Response::INVALID_INPUT;
  404852:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    }

    m_motion_queue->writeMotionItem(key, m_motion_sel, m_item_sel, payload.data);
    return Response::SUCCESS;
}
  404856:	b004      	add	sp, #16
  404858:	bd70      	pop	{r4, r5, r6, pc}
        key = MotionQueue::QueueItemKey::SEQUENCE_NUMBER;
  40485a:	2601      	movs	r6, #1
        val = val_sequenceNumber;
  40485c:	4b2b      	ldr	r3, [pc, #172]	; (40490c <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1e8>)
        break;
  40485e:	e7f2      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::POSITION_H;
  404860:	2603      	movs	r6, #3
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404862:	4b27      	ldr	r3, [pc, #156]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  404864:	e7ef      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::POSITION_L;
  404866:	2604      	movs	r6, #4
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404868:	4b25      	ldr	r3, [pc, #148]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  40486a:	e7ec      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::MAX_SPEED_H;
  40486c:	260b      	movs	r6, #11
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  40486e:	4b24      	ldr	r3, [pc, #144]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  404870:	e7e9      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::MAX_SPEED_L;
  404872:	260c      	movs	r6, #12
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404874:	4b22      	ldr	r3, [pc, #136]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  404876:	e7e6      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::MAX_ACCEL_L;
  404878:	260e      	movs	r6, #14
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  40487a:	4b21      	ldr	r3, [pc, #132]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  40487c:	e7e3      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::MAX_DECEL_L;
  40487e:	2610      	movs	r6, #16
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404880:	4b1f      	ldr	r3, [pc, #124]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  404882:	e7e0      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::BOW1_H;
  404884:	2611      	movs	r6, #17
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404886:	4b1e      	ldr	r3, [pc, #120]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  404888:	e7dd      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::BOW1_L;
  40488a:	2612      	movs	r6, #18
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  40488c:	4b1c      	ldr	r3, [pc, #112]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  40488e:	e7da      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::BOW2_H;
  404890:	2613      	movs	r6, #19
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404892:	4b1b      	ldr	r3, [pc, #108]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  404894:	e7d7      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::BOW3_H;
  404896:	2615      	movs	r6, #21
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  404898:	4b19      	ldr	r3, [pc, #100]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  40489a:	e7d4      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::BOW3_L;
  40489c:	2616      	movs	r6, #22
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  40489e:	4b18      	ldr	r3, [pc, #96]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  4048a0:	e7d1      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::BOW4_H;
  4048a2:	2617      	movs	r6, #23
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  4048a4:	4b16      	ldr	r3, [pc, #88]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  4048a6:	e7ce      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::USE_INVERSE_TIME;
  4048a8:	2619      	movs	r6, #25
        val = val_bool;
  4048aa:	4b16      	ldr	r3, [pc, #88]	; (404904 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1e0>)
        break;
  4048ac:	e7cb      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::TIME_H;
  4048ae:	261a      	movs	r6, #26
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  4048b0:	4b13      	ldr	r3, [pc, #76]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  4048b2:	e7c8      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::TIME_L;
  4048b4:	261b      	movs	r6, #27
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  4048b6:	4b12      	ldr	r3, [pc, #72]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  4048b8:	e7c5      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::OFFSET_H;
  4048ba:	2605      	movs	r6, #5
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  4048bc:	4b10      	ldr	r3, [pc, #64]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  4048be:	e7c2      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::OFFSET_L;
  4048c0:	2606      	movs	r6, #6
    validationFunctionPtr     val = [](uint16_t data) { return true; };
  4048c2:	4b0f      	ldr	r3, [pc, #60]	; (404900 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1dc>)
        break;
  4048c4:	e7bf      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::HOMING_MODE;
  4048c6:	2607      	movs	r6, #7
        val = val_homingMode;
  4048c8:	4b11      	ldr	r3, [pc, #68]	; (404910 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1ec>)
        break;
  4048ca:	e7bc      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
        key = MotionQueue::QueueItemKey::HOMING_SENSOR;
  4048cc:	2608      	movs	r6, #8
        val = val_homingSensor;
  4048ce:	4b11      	ldr	r3, [pc, #68]	; (404914 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1f0>)
        break;
  4048d0:	e7b9      	b.n	404846 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x122>
    m_motion_queue->writeMotionItem(key, m_motion_sel, m_item_sel, payload.data);
  4048d2:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
  4048d6:	f894 20d2 	ldrb.w	r2, [r4, #210]	; 0xd2
  4048da:	f894 30d3 	ldrb.w	r3, [r4, #211]	; 0xd3
  4048de:	9500      	str	r5, [sp, #0]
  4048e0:	4631      	mov	r1, r6
  4048e2:	4c0d      	ldr	r4, [pc, #52]	; (404918 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x1f4>)
  4048e4:	47a0      	blx	r4
    return Response::SUCCESS;
  4048e6:	2001      	movs	r0, #1
  4048e8:	e7b5      	b.n	404856 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x132>
    if (queue_is_executing) { return Response::USED_BY_QUEUE; }
  4048ea:	f241 0006 	movw	r0, #4102	; 0x1006
  4048ee:	e7b2      	b.n	404856 <_ZN12CANInterface14execBoardWriteENS_17BoardWritePayloadE+0x132>
  4048f0:	00407339 	.word	0x00407339
  4048f4:	0040399f 	.word	0x0040399f
  4048f8:	00403969 	.word	0x00403969
  4048fc:	00403991 	.word	0x00403991
  404900:	0040399b 	.word	0x0040399b
  404904:	00403925 	.word	0x00403925
  404908:	0040397f 	.word	0x0040397f
  40490c:	00403989 	.word	0x00403989
  404910:	00403939 	.word	0x00403939
  404914:	00403943 	.word	0x00403943
  404918:	0040738b 	.word	0x0040738b

0040491c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE>:

/* ---------------------------------------------------------------------------------- */
void CANInterface::execSDRead(BoardWritePayload payload) {
  40491c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  404920:	b0c5      	sub	sp, #276	; 0x114
  404922:	4604      	mov	r4, r0
  404924:	9101      	str	r1, [sp, #4]
    uint16_t response = Response::UNKNOWN;

    switch (payload.register_num) {
  404926:	b28d      	uxth	r5, r1
  404928:	f5a5 63e0 	sub.w	r3, r5, #1792	; 0x700
  40492c:	2b09      	cmp	r3, #9
  40492e:	f200 80f0 	bhi.w	404b12 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x1f6>
  404932:	e8df f013 	tbh	[pc, r3, lsl #1]
  404936:	000a      	.short	0x000a
  404938:	008e0036 	.word	0x008e0036
  40493c:	00b500ee 	.word	0x00b500ee
  404940:	00c100ee 	.word	0x00c100ee
  404944:	00ee00c6 	.word	0x00ee00c6
  404948:	00cb      	.short	0x00cb
    // -------- Transmit driver config file from SD Card
    case Registers_Board::SD_FETCH_DRV_CONFIG: {
        if (payload.data >= MAX_STEPPERS) {
  40494a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
  40494e:	2b04      	cmp	r3, #4
  404950:	dd02      	ble.n	404958 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x3c>
            response = Response::VALUE_OUT_OF_BOUNDS;
  404952:	f241 0101 	movw	r1, #4097	; 0x1001
  404956:	e0a5      	b.n	404aa4 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x188>
            break;
        }

        char  file_name[64];
        char *file_contents = NULL;
  404958:	2200      	movs	r2, #0
  40495a:	9214      	str	r2, [sp, #80]	; 0x50
        snprintf(file_name, 64, "config/%d", payload.data);
  40495c:	4a6e      	ldr	r2, [pc, #440]	; (404b18 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x1fc>)
  40495e:	2140      	movs	r1, #64	; 0x40
  404960:	a824      	add	r0, sp, #144	; 0x90
  404962:	4e6e      	ldr	r6, [pc, #440]	; (404b1c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x200>)
  404964:	47b0      	blx	r6
        can_interface_debug("file_name: %s\n", file_name);

        m_sd_card->mount();
  404966:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  40496a:	4b6d      	ldr	r3, [pc, #436]	; (404b20 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x204>)
  40496c:	4798      	blx	r3
        bool file_read = m_sd_card->readFile(file_name, &file_contents);
  40496e:	aa14      	add	r2, sp, #80	; 0x50
  404970:	a924      	add	r1, sp, #144	; 0x90
  404972:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404976:	4b6b      	ldr	r3, [pc, #428]	; (404b24 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x208>)
  404978:	4798      	blx	r3
  40497a:	4606      	mov	r6, r0
        m_sd_card->unmount();
  40497c:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404980:	4b69      	ldr	r3, [pc, #420]	; (404b28 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x20c>)
  404982:	4798      	blx	r3

        if (!file_read) {
  404984:	b92e      	cbnz	r6, 404992 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x76>
            response = Response::READ_FAIL;
            free(file_contents);
  404986:	9814      	ldr	r0, [sp, #80]	; 0x50
  404988:	4b68      	ldr	r3, [pc, #416]	; (404b2c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x210>)
  40498a:	4798      	blx	r3
            response = Response::READ_FAIL;
  40498c:	f241 0103 	movw	r1, #4099	; 0x1003
            break;
  404990:	e088      	b.n	404aa4 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x188>
        }

        transmitFrames(file_contents);
  404992:	9914      	ldr	r1, [sp, #80]	; 0x50
  404994:	4620      	mov	r0, r4
  404996:	4b66      	ldr	r3, [pc, #408]	; (404b30 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x214>)
  404998:	4798      	blx	r3

        free(file_contents);
  40499a:	9814      	ldr	r0, [sp, #80]	; 0x50
  40499c:	4b63      	ldr	r3, [pc, #396]	; (404b2c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x210>)
  40499e:	4798      	blx	r3
  4049a0:	e087      	b.n	404ab2 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x196>
    // -------- Transmit motion file from SD Card with file name appended
    case Registers_Board::SD_FETCH_MOTION_CONFIG: {
        // Get motion file name
        char motion_file_name[64];

        m_sd_card->mount();
  4049a2:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
  4049a6:	4b5e      	ldr	r3, [pc, #376]	; (404b20 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x204>)
  4049a8:	4798      	blx	r3
        bool motion_file_exist = parse_motionFileName(m_sd_card, payload.data, motion_file_name);
  4049aa:	aa04      	add	r2, sp, #16
  4049ac:	f89d 1006 	ldrb.w	r1, [sp, #6]
  4049b0:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  4049b4:	4b5f      	ldr	r3, [pc, #380]	; (404b34 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x218>)
  4049b6:	4798      	blx	r3
  4049b8:	4606      	mov	r6, r0
        m_sd_card->unmount();
  4049ba:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  4049be:	4b5a      	ldr	r3, [pc, #360]	; (404b28 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x20c>)
  4049c0:	4798      	blx	r3

        if (!motion_file_exist) {
  4049c2:	b916      	cbnz	r6, 4049ca <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0xae>
            response = Response::READ_FAIL;
            break;
  4049c4:	f241 0103 	movw	r1, #4099	; 0x1003
  4049c8:	e06c      	b.n	404aa4 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x188>
        }

        // Get content from file name
        char file_name[64];
        snprintf(file_name, 64, "motion/%s", motion_file_name);
  4049ca:	ab04      	add	r3, sp, #16
  4049cc:	4a5a      	ldr	r2, [pc, #360]	; (404b38 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x21c>)
  4049ce:	2140      	movs	r1, #64	; 0x40
  4049d0:	a814      	add	r0, sp, #80	; 0x50
  4049d2:	4e52      	ldr	r6, [pc, #328]	; (404b1c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x200>)
  4049d4:	47b0      	blx	r6

        can_interface_debug("file_name: %s\n", file_name);

        char *file_contents = NULL;
  4049d6:	2300      	movs	r3, #0
  4049d8:	9303      	str	r3, [sp, #12]
        m_sd_card->mount();
  4049da:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  4049de:	4b50      	ldr	r3, [pc, #320]	; (404b20 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x204>)
  4049e0:	4798      	blx	r3
        bool file_read = m_sd_card->readFile(file_name, &file_contents);
  4049e2:	aa03      	add	r2, sp, #12
  4049e4:	a914      	add	r1, sp, #80	; 0x50
  4049e6:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  4049ea:	4b4e      	ldr	r3, [pc, #312]	; (404b24 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x208>)
  4049ec:	4798      	blx	r3
  4049ee:	4606      	mov	r6, r0
        m_sd_card->unmount();
  4049f0:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  4049f4:	4b4c      	ldr	r3, [pc, #304]	; (404b28 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x20c>)
  4049f6:	4798      	blx	r3

        if (!file_read) {
  4049f8:	b91e      	cbnz	r6, 404a02 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0xe6>
            response = Response::READ_FAIL;
            free(file_contents);
  4049fa:	9803      	ldr	r0, [sp, #12]
  4049fc:	4b4b      	ldr	r3, [pc, #300]	; (404b2c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x210>)
  4049fe:	4798      	blx	r3
            break;
  404a00:	e7e0      	b.n	4049c4 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0xa8>
        }

        // Append filename
        char prefix[128];
        snprintf(prefix, sizeof(prefix), "\nFILE_NAME=%s\n", motion_file_name);
  404a02:	ab04      	add	r3, sp, #16
  404a04:	4a4d      	ldr	r2, [pc, #308]	; (404b3c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x220>)
  404a06:	2180      	movs	r1, #128	; 0x80
  404a08:	a824      	add	r0, sp, #144	; 0x90
  404a0a:	4d44      	ldr	r5, [pc, #272]	; (404b1c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x200>)
  404a0c:	47a8      	blx	r5

        size_t prefix_len  = strlen(prefix);
  404a0e:	a824      	add	r0, sp, #144	; 0x90
  404a10:	4d4b      	ldr	r5, [pc, #300]	; (404b40 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x224>)
  404a12:	47a8      	blx	r5
  404a14:	4606      	mov	r6, r0
        size_t content_len = strlen(file_contents);
  404a16:	9803      	ldr	r0, [sp, #12]
  404a18:	47a8      	blx	r5
  404a1a:	4681      	mov	r9, r0

        char *new_contents = new char[prefix_len + content_len + 1]; // +1 for null terminator
  404a1c:	1837      	adds	r7, r6, r0
  404a1e:	1c78      	adds	r0, r7, #1
  404a20:	4b48      	ldr	r3, [pc, #288]	; (404b44 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x228>)
  404a22:	4798      	blx	r3
  404a24:	4605      	mov	r5, r0

        memcpy(new_contents, prefix, prefix_len);
  404a26:	4632      	mov	r2, r6
  404a28:	a924      	add	r1, sp, #144	; 0x90
  404a2a:	f8df 8124 	ldr.w	r8, [pc, #292]	; 404b50 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x234>
  404a2e:	47c0      	blx	r8
        memcpy(new_contents + prefix_len, file_contents, content_len);
  404a30:	464a      	mov	r2, r9
  404a32:	9903      	ldr	r1, [sp, #12]
  404a34:	19a8      	adds	r0, r5, r6
  404a36:	47c0      	blx	r8
        new_contents[prefix_len + content_len] = '\0';
  404a38:	2300      	movs	r3, #0
  404a3a:	55eb      	strb	r3, [r5, r7]

        free(file_contents);
  404a3c:	9803      	ldr	r0, [sp, #12]
  404a3e:	4e3b      	ldr	r6, [pc, #236]	; (404b2c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x210>)
  404a40:	47b0      	blx	r6
        file_contents = new_contents;
  404a42:	9503      	str	r5, [sp, #12]

        // Transmit content
        transmitFrames(file_contents);
  404a44:	4629      	mov	r1, r5
  404a46:	4620      	mov	r0, r4
  404a48:	4b39      	ldr	r3, [pc, #228]	; (404b30 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x214>)
  404a4a:	4798      	blx	r3

        free(file_contents);
  404a4c:	9803      	ldr	r0, [sp, #12]
  404a4e:	47b0      	blx	r6
  404a50:	e02f      	b.n	404ab2 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x196>
        return;
    }
    // -------- Transmit sequence file from SD Card
    case Registers_Board::SD_FETCH_SEQUENCE: {
        char  file_name[64];
        char *file_contents = NULL;
  404a52:	2300      	movs	r3, #0
  404a54:	9314      	str	r3, [sp, #80]	; 0x50
        snprintf(file_name, 64, "sequence/%d", payload.data);
  404a56:	f8bd 3006 	ldrh.w	r3, [sp, #6]
  404a5a:	4a3b      	ldr	r2, [pc, #236]	; (404b48 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x22c>)
  404a5c:	2140      	movs	r1, #64	; 0x40
  404a5e:	a824      	add	r0, sp, #144	; 0x90
  404a60:	4e2e      	ldr	r6, [pc, #184]	; (404b1c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x200>)
  404a62:	47b0      	blx	r6
        can_interface_debug("file_name: %s\n", file_name);

        m_sd_card->mount();
  404a64:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404a68:	4b2d      	ldr	r3, [pc, #180]	; (404b20 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x204>)
  404a6a:	4798      	blx	r3
        bool file_read = m_sd_card->readFile(file_name, &file_contents);
  404a6c:	aa14      	add	r2, sp, #80	; 0x50
  404a6e:	a924      	add	r1, sp, #144	; 0x90
  404a70:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404a74:	4b2b      	ldr	r3, [pc, #172]	; (404b24 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x208>)
  404a76:	4798      	blx	r3
  404a78:	4606      	mov	r6, r0
        m_sd_card->unmount();
  404a7a:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404a7e:	4b2a      	ldr	r3, [pc, #168]	; (404b28 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x20c>)
  404a80:	4798      	blx	r3

        if (!file_read) {
  404a82:	b92e      	cbnz	r6, 404a90 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x174>
            response = Response::READ_FAIL;
            free(file_contents);
  404a84:	9814      	ldr	r0, [sp, #80]	; 0x50
  404a86:	4b29      	ldr	r3, [pc, #164]	; (404b2c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x210>)
  404a88:	4798      	blx	r3
            response = Response::READ_FAIL;
  404a8a:	f241 0103 	movw	r1, #4099	; 0x1003
  404a8e:	e009      	b.n	404aa4 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x188>
            break;
        }

        transmitFrames(file_contents);
  404a90:	9914      	ldr	r1, [sp, #80]	; 0x50
  404a92:	4620      	mov	r0, r4
  404a94:	4b26      	ldr	r3, [pc, #152]	; (404b30 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x214>)
  404a96:	4798      	blx	r3

        free(file_contents);
  404a98:	9814      	ldr	r0, [sp, #80]	; 0x50
  404a9a:	4b24      	ldr	r3, [pc, #144]	; (404b2c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x210>)
  404a9c:	4798      	blx	r3
  404a9e:	e008      	b.n	404ab2 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x196>

        return;
    }
    // -------- Current length of buffer (multiple of 4)
    case Registers_Board::BUF_LEN: {
        response = buffer_len;
  404aa0:	f8b0 12f4 	ldrh.w	r1, [r0, #756]	; 0x2f4
    // Create word
    uint32_t word;
    word = payload.register_num << 16;
    word |= static_cast<uint32_t>(response);

    transmitMessage(word, rx_board_w_mbid);
  404aa4:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
  404aa8:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
  404aac:	4620      	mov	r0, r4
  404aae:	4b27      	ldr	r3, [pc, #156]	; (404b4c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x230>)
  404ab0:	4798      	blx	r3
}
  404ab2:	b045      	add	sp, #276	; 0x114
  404ab4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        transmitFrames(buffer);
  404ab8:	f100 01f4 	add.w	r1, r0, #244	; 0xf4
  404abc:	4b1c      	ldr	r3, [pc, #112]	; (404b30 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x214>)
  404abe:	4798      	blx	r3
        return;
  404ac0:	e7f7      	b.n	404ab2 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x196>
        transmitFrames(path);
  404ac2:	f500 71fa 	add.w	r1, r0, #500	; 0x1f4
  404ac6:	4b1a      	ldr	r3, [pc, #104]	; (404b30 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x214>)
  404ac8:	4798      	blx	r3
        return;
  404aca:	e7f2      	b.n	404ab2 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x196>
        char *file_contents = NULL;
  404acc:	ae44      	add	r6, sp, #272	; 0x110
  404ace:	2300      	movs	r3, #0
  404ad0:	f846 3d80 	str.w	r3, [r6, #-128]!
        m_sd_card->mount();
  404ad4:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
  404ad8:	4b11      	ldr	r3, [pc, #68]	; (404b20 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x204>)
  404ada:	4798      	blx	r3
        bool file_read = m_sd_card->readFile(path, &file_contents);
  404adc:	4632      	mov	r2, r6
  404ade:	f504 71fa 	add.w	r1, r4, #500	; 0x1f4
  404ae2:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404ae6:	4b0f      	ldr	r3, [pc, #60]	; (404b24 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x208>)
  404ae8:	4798      	blx	r3
  404aea:	4606      	mov	r6, r0
        m_sd_card->unmount();
  404aec:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404af0:	4b0d      	ldr	r3, [pc, #52]	; (404b28 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x20c>)
  404af2:	4798      	blx	r3
        if (!file_read) {
  404af4:	b92e      	cbnz	r6, 404b02 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x1e6>
            free(file_contents);
  404af6:	9824      	ldr	r0, [sp, #144]	; 0x90
  404af8:	4b0c      	ldr	r3, [pc, #48]	; (404b2c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x210>)
  404afa:	4798      	blx	r3
            response = Response::READ_FAIL;
  404afc:	f241 0103 	movw	r1, #4099	; 0x1003
  404b00:	e7d0      	b.n	404aa4 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x188>
        transmitFrames(file_contents);
  404b02:	9924      	ldr	r1, [sp, #144]	; 0x90
  404b04:	4620      	mov	r0, r4
  404b06:	4b0a      	ldr	r3, [pc, #40]	; (404b30 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x214>)
  404b08:	4798      	blx	r3
        free(file_contents);
  404b0a:	9824      	ldr	r0, [sp, #144]	; 0x90
  404b0c:	4b07      	ldr	r3, [pc, #28]	; (404b2c <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x210>)
  404b0e:	4798      	blx	r3
  404b10:	e7cf      	b.n	404ab2 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x196>
    uint16_t response = Response::UNKNOWN;
  404b12:	f241 0107 	movw	r1, #4103	; 0x1007
  404b16:	e7c5      	b.n	404aa4 <_ZN12CANInterface10execSDReadENS_17BoardWritePayloadE+0x188>
  404b18:	0040e268 	.word	0x0040e268
  404b1c:	0040c605 	.word	0x0040c605
  404b20:	00407fc5 	.word	0x00407fc5
  404b24:	00408101 	.word	0x00408101
  404b28:	00408031 	.word	0x00408031
  404b2c:	0040c261 	.word	0x0040c261
  404b30:	00403ed5 	.word	0x00403ed5
  404b34:	00408b65 	.word	0x00408b65
  404b38:	0040e274 	.word	0x0040e274
  404b3c:	0040e280 	.word	0x0040e280
  404b40:	0040c78b 	.word	0x0040c78b
  404b44:	0040b2db 	.word	0x0040b2db
  404b48:	0040e290 	.word	0x0040e290
  404b4c:	00403b11 	.word	0x00403b11
  404b50:	0040c271 	.word	0x0040c271

00404b54 <_ZN12CANInterface14handleRXBoardREv>:
void CANInterface::handleRXBoardR() {
  404b54:	b510      	push	{r4, lr}
  404b56:	b082      	sub	sp, #8
  404b58:	4604      	mov	r4, r0
    payload.register_num = (rx_board_r_mb.ul_datal >> 16) & 0xFFF;
  404b5a:	6e02      	ldr	r2, [r0, #96]	; 0x60
  404b5c:	f3c2 430b 	ubfx	r3, r2, #16, #12
  404b60:	f8ad 3004 	strh.w	r3, [sp, #4]
    payload.data         = rx_board_r_mb.ul_datal & 0xFFFF;
  404b64:	f8ad 2006 	strh.w	r2, [sp, #6]
    if (payload.register_num >= 0x700 && payload.register_num <= 0x7FF) {
  404b68:	f5a3 62e0 	sub.w	r2, r3, #1792	; 0x700
  404b6c:	b292      	uxth	r2, r2
  404b6e:	2aff      	cmp	r2, #255	; 0xff
  404b70:	d90b      	bls.n	404b8a <_ZN12CANInterface14handleRXBoardREv+0x36>
    switch (payload.register_num) {
  404b72:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
  404b76:	d010      	beq.n	404b9a <_ZN12CANInterface14handleRXBoardREv+0x46>
  404b78:	f240 1203 	movw	r2, #259	; 0x103
  404b7c:	4293      	cmp	r3, r2
  404b7e:	d01b      	beq.n	404bb8 <_ZN12CANInterface14handleRXBoardREv+0x64>
  404b80:	2b01      	cmp	r3, #1
  404b82:	d006      	beq.n	404b92 <_ZN12CANInterface14handleRXBoardREv+0x3e>
    uint16_t response = Response::UNKNOWN;
  404b84:	f241 0007 	movw	r0, #4103	; 0x1007
  404b88:	e01a      	b.n	404bc0 <_ZN12CANInterface14handleRXBoardREv+0x6c>
        execSDRead(payload);
  404b8a:	9901      	ldr	r1, [sp, #4]
  404b8c:	4b12      	ldr	r3, [pc, #72]	; (404bd8 <_ZN12CANInterface14handleRXBoardREv+0x84>)
  404b8e:	4798      	blx	r3
        return;
  404b90:	e020      	b.n	404bd4 <_ZN12CANInterface14handleRXBoardREv+0x80>
        transmitFrames(FIRMWARE_VERSION);
  404b92:	4912      	ldr	r1, [pc, #72]	; (404bdc <_ZN12CANInterface14handleRXBoardREv+0x88>)
  404b94:	4b12      	ldr	r3, [pc, #72]	; (404be0 <_ZN12CANInterface14handleRXBoardREv+0x8c>)
  404b96:	4798      	blx	r3
        return;
  404b98:	e01c      	b.n	404bd4 <_ZN12CANInterface14handleRXBoardREv+0x80>
        uint32_t readback_value = 0;
  404b9a:	a902      	add	r1, sp, #8
  404b9c:	2300      	movs	r3, #0
  404b9e:	f841 3d08 	str.w	r3, [r1, #-8]!
        bool has_readback = m_motion_queue->getReadback(&readback_value);
  404ba2:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  404ba6:	4b0f      	ldr	r3, [pc, #60]	; (404be4 <_ZN12CANInterface14handleRXBoardREv+0x90>)
  404ba8:	4798      	blx	r3
        if (!has_readback) {
  404baa:	b110      	cbz	r0, 404bb2 <_ZN12CANInterface14handleRXBoardREv+0x5e>
            response = readback_value;
  404bac:	f8bd 0000 	ldrh.w	r0, [sp]
  404bb0:	e006      	b.n	404bc0 <_ZN12CANInterface14handleRXBoardREv+0x6c>
            response = Response::READ_FAIL;
  404bb2:	f241 0003 	movw	r0, #4099	; 0x1003
  404bb6:	e003      	b.n	404bc0 <_ZN12CANInterface14handleRXBoardREv+0x6c>
        response = m_motion_queue->getQueueStatus();
  404bb8:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  404bbc:	4b0a      	ldr	r3, [pc, #40]	; (404be8 <_ZN12CANInterface14handleRXBoardREv+0x94>)
  404bbe:	4798      	blx	r3
    word = rx_board_w_mb.ul_datal & 0x0FFF0000;
  404bc0:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
  404bc4:	4909      	ldr	r1, [pc, #36]	; (404bec <_ZN12CANInterface14handleRXBoardREv+0x98>)
  404bc6:	4011      	ands	r1, r2
    transmitMessage(word, rx_board_w_mbid);
  404bc8:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
  404bcc:	4301      	orrs	r1, r0
  404bce:	4620      	mov	r0, r4
  404bd0:	4b07      	ldr	r3, [pc, #28]	; (404bf0 <_ZN12CANInterface14handleRXBoardREv+0x9c>)
  404bd2:	4798      	blx	r3
}
  404bd4:	b002      	add	sp, #8
  404bd6:	bd10      	pop	{r4, pc}
  404bd8:	0040491d 	.word	0x0040491d
  404bdc:	0040e29c 	.word	0x0040e29c
  404be0:	00403ed5 	.word	0x00403ed5
  404be4:	00407305 	.word	0x00407305
  404be8:	00407339 	.word	0x00407339
  404bec:	0fff0000 	.word	0x0fff0000
  404bf0:	00403b11 	.word	0x00403b11

00404bf4 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE>:

/* ---------------------------------------------------------------------------------- */
uint16_t CANInterface::execSDWrite(BoardWritePayload payload) {
  404bf4:	b530      	push	{r4, r5, lr}
  404bf6:	b083      	sub	sp, #12
  404bf8:	4604      	mov	r4, r0
  404bfa:	9101      	str	r1, [sp, #4]
    uint16_t response = Response::UNKNOWN;

    switch (payload.register_num) {
  404bfc:	b289      	uxth	r1, r1
  404bfe:	f2a1 7103 	subw	r1, r1, #1795	; 0x703
  404c02:	2907      	cmp	r1, #7
  404c04:	d856      	bhi.n	404cb4 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xc0>
  404c06:	e8df f001 	tbb	[pc, r1]
  404c0a:	5504      	.short	0x5504
  404c0c:	25555515 	.word	0x25555515
  404c10:	4155      	.short	0x4155
    // -------- Clear Buffer & Reset Parameters
    case Registers_Board::BUF_CLEAR: {
        memset(buffer, 0, sizeof(buffer));
  404c12:	f44f 7280 	mov.w	r2, #256	; 0x100
  404c16:	2100      	movs	r1, #0
  404c18:	30f4      	adds	r0, #244	; 0xf4
  404c1a:	4b28      	ldr	r3, [pc, #160]	; (404cbc <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xc8>)
  404c1c:	4798      	blx	r3
        buffer_len          = 0;
  404c1e:	2300      	movs	r3, #0
  404c20:	f8c4 32f4 	str.w	r3, [r4, #756]	; 0x2f4
        buffer_listen_start = false;
  404c24:	f884 32f8 	strb.w	r3, [r4, #760]	; 0x2f8
        buffer_listen_end   = false;
  404c28:	f884 32f9 	strb.w	r3, [r4, #761]	; 0x2f9

        response = Response::SUCCESS;
  404c2c:	2501      	movs	r5, #1
        break;
    }
    }

    return response;
}
  404c2e:	4628      	mov	r0, r5
  404c30:	b003      	add	sp, #12
  404c32:	bd30      	pop	{r4, r5, pc}
        if (buffer_listen_end) {
  404c34:	f890 32f9 	ldrb.w	r3, [r0, #761]	; 0x2f9
  404c38:	b913      	cbnz	r3, 404c40 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x4c>
            response = Response::WRITE_FAIL;
  404c3a:	f241 0502 	movw	r5, #4098	; 0x1002
  404c3e:	e7f6      	b.n	404c2e <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x3a>
            memcpy(path, buffer, 256);
  404c40:	f44f 7280 	mov.w	r2, #256	; 0x100
  404c44:	f100 01f4 	add.w	r1, r0, #244	; 0xf4
  404c48:	f500 70fa 	add.w	r0, r0, #500	; 0x1f4
  404c4c:	4b1c      	ldr	r3, [pc, #112]	; (404cc0 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xcc>)
  404c4e:	4798      	blx	r3
            response = Response::SUCCESS;
  404c50:	2501      	movs	r5, #1
  404c52:	e7ec      	b.n	404c2e <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x3a>
        if (buffer_listen_end) {
  404c54:	f890 32f9 	ldrb.w	r3, [r0, #761]	; 0x2f9
  404c58:	b913      	cbnz	r3, 404c60 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x6c>
            response = Response::WRITE_FAIL;
  404c5a:	f241 0502 	movw	r5, #4098	; 0x1002
  404c5e:	e7e6      	b.n	404c2e <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x3a>
            m_sd_card->mount();
  404c60:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
  404c64:	4b17      	ldr	r3, [pc, #92]	; (404cc4 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xd0>)
  404c66:	4798      	blx	r3
            response = m_sd_card->writeFile(path, buffer) ? Response::SUCCESS : Response::WRITE_FAIL;
  404c68:	f104 02f4 	add.w	r2, r4, #244	; 0xf4
  404c6c:	f504 71fa 	add.w	r1, r4, #500	; 0x1f4
  404c70:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404c74:	4b14      	ldr	r3, [pc, #80]	; (404cc8 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xd4>)
  404c76:	4798      	blx	r3
  404c78:	b930      	cbnz	r0, 404c88 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x94>
  404c7a:	f241 0502 	movw	r5, #4098	; 0x1002
            m_sd_card->unmount();
  404c7e:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404c82:	4b12      	ldr	r3, [pc, #72]	; (404ccc <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xd8>)
  404c84:	4798      	blx	r3
  404c86:	e7d2      	b.n	404c2e <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x3a>
            response = m_sd_card->writeFile(path, buffer) ? Response::SUCCESS : Response::WRITE_FAIL;
  404c88:	2501      	movs	r5, #1
  404c8a:	e7f8      	b.n	404c7e <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x8a>
        m_sd_card->mount();
  404c8c:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
  404c90:	4b0c      	ldr	r3, [pc, #48]	; (404cc4 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xd0>)
  404c92:	4798      	blx	r3
        response = m_sd_card->deleteFile(path) ? Response::SUCCESS : Response::WRITE_FAIL;
  404c94:	f504 71fa 	add.w	r1, r4, #500	; 0x1f4
  404c98:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404c9c:	4b0c      	ldr	r3, [pc, #48]	; (404cd0 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xdc>)
  404c9e:	4798      	blx	r3
  404ca0:	b128      	cbz	r0, 404cae <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xba>
  404ca2:	2501      	movs	r5, #1
        m_sd_card->unmount();
  404ca4:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
  404ca8:	4b08      	ldr	r3, [pc, #32]	; (404ccc <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xd8>)
  404caa:	4798      	blx	r3
        break;
  404cac:	e7bf      	b.n	404c2e <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x3a>
        response = m_sd_card->deleteFile(path) ? Response::SUCCESS : Response::WRITE_FAIL;
  404cae:	f241 0502 	movw	r5, #4098	; 0x1002
  404cb2:	e7f7      	b.n	404ca4 <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0xb0>
    uint16_t response = Response::UNKNOWN;
  404cb4:	f241 0507 	movw	r5, #4103	; 0x1007
  404cb8:	e7b9      	b.n	404c2e <_ZN12CANInterface11execSDWriteENS_17BoardWritePayloadE+0x3a>
  404cba:	bf00      	nop
  404cbc:	0040c287 	.word	0x0040c287
  404cc0:	0040c271 	.word	0x0040c271
  404cc4:	00407fc5 	.word	0x00407fc5
  404cc8:	00408051 	.word	0x00408051
  404ccc:	00408031 	.word	0x00408031
  404cd0:	004081d1 	.word	0x004081d1

00404cd4 <_ZN12CANInterface14handleRXBoardWEv>:
void CANInterface::handleRXBoardW() {
  404cd4:	b510      	push	{r4, lr}
  404cd6:	b082      	sub	sp, #8
  404cd8:	4604      	mov	r4, r0
    payload.register_num = (rx_board_w_mb.ul_datal >> 16) & 0xFFF;
  404cda:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
  404cde:	f3c1 430b 	ubfx	r3, r1, #16, #12
  404ce2:	f8ad 3004 	strh.w	r3, [sp, #4]
    payload.data         = rx_board_w_mb.ul_datal & 0xFFFF;
  404ce6:	b289      	uxth	r1, r1
  404ce8:	f8ad 1006 	strh.w	r1, [sp, #6]
    if (payload.register_num == Registers_Board::SELECT_MOTION_AND_QUEUE_ITEM) {
  404cec:	f240 1201 	movw	r2, #257	; 0x101
  404cf0:	4293      	cmp	r3, r2
  404cf2:	d019      	beq.n	404d28 <_ZN12CANInterface14handleRXBoardWEv+0x54>
    } else if (payload.register_num == Registers_Board::MOTION_CONTROL_WORD) {
  404cf4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  404cf8:	d019      	beq.n	404d2e <_ZN12CANInterface14handleRXBoardWEv+0x5a>
    } else if (payload.register_num == Registers_Board::RUN_PRELOAD) {
  404cfa:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  404cfe:	d027      	beq.n	404d50 <_ZN12CANInterface14handleRXBoardWEv+0x7c>
    } else if (payload.register_num >= 0x700 && payload.register_num <= 0x7FF) {
  404d00:	f5a3 63e0 	sub.w	r3, r3, #1792	; 0x700
  404d04:	b29b      	uxth	r3, r3
  404d06:	2bff      	cmp	r3, #255	; 0xff
  404d08:	d931      	bls.n	404d6e <_ZN12CANInterface14handleRXBoardWEv+0x9a>
        response = execBoardWrite(payload);
  404d0a:	9901      	ldr	r1, [sp, #4]
  404d0c:	4b1b      	ldr	r3, [pc, #108]	; (404d7c <_ZN12CANInterface14handleRXBoardWEv+0xa8>)
  404d0e:	4798      	blx	r3
    word = rx_board_w_mb.ul_datal & 0x0FFF0000;
  404d10:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
  404d14:	491a      	ldr	r1, [pc, #104]	; (404d80 <_ZN12CANInterface14handleRXBoardWEv+0xac>)
  404d16:	4011      	ands	r1, r2
    transmitMessage(word, rx_board_w_mbid);
  404d18:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
  404d1c:	4301      	orrs	r1, r0
  404d1e:	4620      	mov	r0, r4
  404d20:	4b18      	ldr	r3, [pc, #96]	; (404d84 <_ZN12CANInterface14handleRXBoardWEv+0xb0>)
  404d22:	4798      	blx	r3
}
  404d24:	b002      	add	sp, #8
  404d26:	bd10      	pop	{r4, pc}
        response = selectMotionAndQueue(payload.data);
  404d28:	4b17      	ldr	r3, [pc, #92]	; (404d88 <_ZN12CANInterface14handleRXBoardWEv+0xb4>)
  404d2a:	4798      	blx	r3
  404d2c:	e7f0      	b.n	404d10 <_ZN12CANInterface14handleRXBoardWEv+0x3c>
        if (payload.data == MotionControlWord::ABORT) {
  404d2e:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
  404d32:	d006      	beq.n	404d42 <_ZN12CANInterface14handleRXBoardWEv+0x6e>
            response = static_cast<uint16_t>(m_motion_queue->queueMotion(static_cast<uint8_t>(payload.data)));
  404d34:	b2c9      	uxtb	r1, r1
  404d36:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  404d3a:	4b14      	ldr	r3, [pc, #80]	; (404d8c <_ZN12CANInterface14handleRXBoardWEv+0xb8>)
  404d3c:	4798      	blx	r3
  404d3e:	b280      	uxth	r0, r0
  404d40:	e7e6      	b.n	404d10 <_ZN12CANInterface14handleRXBoardWEv+0x3c>
            response = m_motion_queue->abortQueue() ? Response::SUCCESS : Response::WRITE_FAIL;
  404d42:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  404d46:	4b12      	ldr	r3, [pc, #72]	; (404d90 <_ZN12CANInterface14handleRXBoardWEv+0xbc>)
  404d48:	4798      	blx	r3
  404d4a:	b1a0      	cbz	r0, 404d76 <_ZN12CANInterface14handleRXBoardWEv+0xa2>
  404d4c:	2001      	movs	r0, #1
  404d4e:	e7df      	b.n	404d10 <_ZN12CANInterface14handleRXBoardWEv+0x3c>
        uint8_t driver_num = 0xF;
  404d50:	aa02      	add	r2, sp, #8
  404d52:	230f      	movs	r3, #15
  404d54:	f802 3d05 	strb.w	r3, [r2, #-5]!
            m_motion_queue->queuePreloadedMotions(static_cast<uint8_t>(payload.data), &driver_num));
  404d58:	b2c9      	uxtb	r1, r1
  404d5a:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
  404d5e:	4b0d      	ldr	r3, [pc, #52]	; (404d94 <_ZN12CANInterface14handleRXBoardWEv+0xc0>)
  404d60:	4798      	blx	r3
        response |= (driver_num << 8);
  404d62:	f89d 3003 	ldrb.w	r3, [sp, #3]
  404d66:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  404d6a:	b280      	uxth	r0, r0
  404d6c:	e7d0      	b.n	404d10 <_ZN12CANInterface14handleRXBoardWEv+0x3c>
        response = execSDWrite(payload);
  404d6e:	9901      	ldr	r1, [sp, #4]
  404d70:	4b09      	ldr	r3, [pc, #36]	; (404d98 <_ZN12CANInterface14handleRXBoardWEv+0xc4>)
  404d72:	4798      	blx	r3
  404d74:	e7cc      	b.n	404d10 <_ZN12CANInterface14handleRXBoardWEv+0x3c>
            response = m_motion_queue->abortQueue() ? Response::SUCCESS : Response::WRITE_FAIL;
  404d76:	f241 0002 	movw	r0, #4098	; 0x1002
  404d7a:	e7c9      	b.n	404d10 <_ZN12CANInterface14handleRXBoardWEv+0x3c>
  404d7c:	00404725 	.word	0x00404725
  404d80:	0fff0000 	.word	0x0fff0000
  404d84:	00403b11 	.word	0x00403b11
  404d88:	004046f9 	.word	0x004046f9
  404d8c:	00407289 	.word	0x00407289
  404d90:	00407373 	.word	0x00407373
  404d94:	004076e9 	.word	0x004076e9
  404d98:	00404bf5 	.word	0x00404bf5

00404d9c <_ZN12CANInterface19task_commandHandlerEPv>:
void CANInterface::task_commandHandler(void *parameters) {
  404d9c:	b508      	push	{r3, lr}
  404d9e:	e006      	b.n	404dae <_ZN12CANInterface19task_commandHandlerEPv+0x12>
                CANInterface::getInstance()->handleRXStepperR();
  404da0:	4b16      	ldr	r3, [pc, #88]	; (404dfc <_ZN12CANInterface19task_commandHandlerEPv+0x60>)
  404da2:	4798      	blx	r3
  404da4:	4b16      	ldr	r3, [pc, #88]	; (404e00 <_ZN12CANInterface19task_commandHandlerEPv+0x64>)
  404da6:	681b      	ldr	r3, [r3, #0]
            CANInterface::getInstance()->can_msg_rdy = false;
  404da8:	2200      	movs	r2, #0
  404daa:	f883 20d0 	strb.w	r2, [r3, #208]	; 0xd0
  404dae:	4b14      	ldr	r3, [pc, #80]	; (404e00 <_ZN12CANInterface19task_commandHandlerEPv+0x64>)
  404db0:	6818      	ldr	r0, [r3, #0]
        if (CANInterface::getInstance()->can_msg_rdy) {
  404db2:	f890 30d0 	ldrb.w	r3, [r0, #208]	; 0xd0
  404db6:	2b00      	cmp	r3, #0
  404db8:	d0f9      	beq.n	404dae <_ZN12CANInterface19task_commandHandlerEPv+0x12>
            switch (CANInterface::getInstance()->recv_mailbox) {
  404dba:	f890 30d1 	ldrb.w	r3, [r0, #209]	; 0xd1
  404dbe:	b2db      	uxtb	r3, r3
  404dc0:	2b05      	cmp	r3, #5
  404dc2:	d8ef      	bhi.n	404da4 <_ZN12CANInterface19task_commandHandlerEPv+0x8>
  404dc4:	a201      	add	r2, pc, #4	; (adr r2, 404dcc <_ZN12CANInterface19task_commandHandlerEPv+0x30>)
  404dc6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  404dca:	bf00      	nop
  404dcc:	00404da1 	.word	0x00404da1
  404dd0:	00404de5 	.word	0x00404de5
  404dd4:	00404da5 	.word	0x00404da5
  404dd8:	00404deb 	.word	0x00404deb
  404ddc:	00404df1 	.word	0x00404df1
  404de0:	00404df7 	.word	0x00404df7
                CANInterface::getInstance()->handleRXStepperW();
  404de4:	4b07      	ldr	r3, [pc, #28]	; (404e04 <_ZN12CANInterface19task_commandHandlerEPv+0x68>)
  404de6:	4798      	blx	r3
                break;
  404de8:	e7dc      	b.n	404da4 <_ZN12CANInterface19task_commandHandlerEPv+0x8>
                CANInterface::getInstance()->handleRXBoardR();
  404dea:	4b07      	ldr	r3, [pc, #28]	; (404e08 <_ZN12CANInterface19task_commandHandlerEPv+0x6c>)
  404dec:	4798      	blx	r3
                break;
  404dee:	e7d9      	b.n	404da4 <_ZN12CANInterface19task_commandHandlerEPv+0x8>
                CANInterface::getInstance()->handleRXBoardW();
  404df0:	4b06      	ldr	r3, [pc, #24]	; (404e0c <_ZN12CANInterface19task_commandHandlerEPv+0x70>)
  404df2:	4798      	blx	r3
                break;
  404df4:	e7d6      	b.n	404da4 <_ZN12CANInterface19task_commandHandlerEPv+0x8>
                CANInterface::getInstance()->handleBuff();
  404df6:	4b06      	ldr	r3, [pc, #24]	; (404e10 <_ZN12CANInterface19task_commandHandlerEPv+0x74>)
  404df8:	4798      	blx	r3
                break;
  404dfa:	e7d3      	b.n	404da4 <_ZN12CANInterface19task_commandHandlerEPv+0x8>
  404dfc:	00403b99 	.word	0x00403b99
  404e00:	20007614 	.word	0x20007614
  404e04:	00404649 	.word	0x00404649
  404e08:	00404b55 	.word	0x00404b55
  404e0c:	00404cd5 	.word	0x00404cd5
  404e10:	00403c91 	.word	0x00403c91

00404e14 <_ZN7Stepper16task_motionQueueEPv>:
    return sensor_status >> homing_sensor & 1;
}

/* ================================ Motion Queue Task =============================== */

void Stepper::task_motionQueue(void *parameters) {
  404e14:	b530      	push	{r4, r5, lr}
  404e16:	b083      	sub	sp, #12
  404e18:	4604      	mov	r4, r0
    auto       *self = static_cast<Stepper *>(parameters);
    MotionItem *motion_item_ptr;
    uint32_t    result = 0;
  404e1a:	2300      	movs	r3, #0
  404e1c:	9300      	str	r3, [sp, #0]
  404e1e:	e01d      	b.n	404e5c <_ZN7Stepper16task_motionQueueEPv+0x48>

    for (;;) {
        if (xQueuePeek(self->m_motion_queue_handle, &motion_item_ptr, 0) == pdTRUE) {
            if (motion_item_ptr->motion_task) {
  404e20:	9a01      	ldr	r2, [sp, #4]
  404e22:	6813      	ldr	r3, [r2, #0]
  404e24:	b33b      	cbz	r3, 404e76 <_ZN7Stepper16task_motionQueueEPv+0x62>
                stepper_debug("Move started.\n");
                result = (self->*motion_item_ptr->motion_task)(&motion_item_ptr);
  404e26:	6850      	ldr	r0, [r2, #4]
  404e28:	f010 0f01 	tst.w	r0, #1
  404e2c:	d002      	beq.n	404e34 <_ZN7Stepper16task_motionQueueEPv+0x20>
  404e2e:	1042      	asrs	r2, r0, #1
  404e30:	58a2      	ldr	r2, [r4, r2]
  404e32:	58d3      	ldr	r3, [r2, r3]
  404e34:	a901      	add	r1, sp, #4
  404e36:	eb04 0060 	add.w	r0, r4, r0, asr #1
  404e3a:	4798      	blx	r3
  404e3c:	a902      	add	r1, sp, #8
  404e3e:	f841 0d08 	str.w	r0, [r1, #-8]!
                // Send result
                xQueueSend(self->m_result_queue_handle, &result, 0);
  404e42:	2300      	movs	r3, #0
  404e44:	461a      	mov	r2, r3
  404e46:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
  404e4a:	4d0d      	ldr	r5, [pc, #52]	; (404e80 <_ZN7Stepper16task_motionQueueEPv+0x6c>)
  404e4c:	47a8      	blx	r5
                // Remove from queue
                xQueueReceive(self->m_motion_queue_handle, &motion_item_ptr, 0);
  404e4e:	2300      	movs	r3, #0
  404e50:	461a      	mov	r2, r3
  404e52:	a901      	add	r1, sp, #4
  404e54:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  404e58:	4d0a      	ldr	r5, [pc, #40]	; (404e84 <_ZN7Stepper16task_motionQueueEPv+0x70>)
  404e5a:	47a8      	blx	r5
        if (xQueuePeek(self->m_motion_queue_handle, &motion_item_ptr, 0) == pdTRUE) {
  404e5c:	2301      	movs	r3, #1
  404e5e:	2200      	movs	r2, #0
  404e60:	a901      	add	r1, sp, #4
  404e62:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  404e66:	4d07      	ldr	r5, [pc, #28]	; (404e84 <_ZN7Stepper16task_motionQueueEPv+0x70>)
  404e68:	47a8      	blx	r5
  404e6a:	2801      	cmp	r0, #1
  404e6c:	d0d8      	beq.n	404e20 <_ZN7Stepper16task_motionQueueEPv+0xc>
                stepper_debug("Move ended.\n");
            }
        } else {
            vTaskDelay(10 / portTICK_RATE_MS);
  404e6e:	200a      	movs	r0, #10
  404e70:	4b05      	ldr	r3, [pc, #20]	; (404e88 <_ZN7Stepper16task_motionQueueEPv+0x74>)
  404e72:	4798      	blx	r3
  404e74:	e7f2      	b.n	404e5c <_ZN7Stepper16task_motionQueueEPv+0x48>
            if (motion_item_ptr->motion_task) {
  404e76:	6851      	ldr	r1, [r2, #4]
  404e78:	f011 0f01 	tst.w	r1, #1
  404e7c:	d0ee      	beq.n	404e5c <_ZN7Stepper16task_motionQueueEPv+0x48>
  404e7e:	e7d2      	b.n	404e26 <_ZN7Stepper16task_motionQueueEPv+0x12>
  404e80:	00409209 	.word	0x00409209
  404e84:	00409421 	.word	0x00409421
  404e88:	00409bd5 	.word	0x00409bd5

00404e8c <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm>:
Stepper::_WaitRes Stepper::waitCondition(Callable payload_factory, bool value, portTickType timeout) {
  404e8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  404e90:	b082      	sub	sp, #8
  404e92:	4680      	mov	r8, r0
  404e94:	460f      	mov	r7, r1
  404e96:	4616      	mov	r6, r2
  404e98:	461d      	mov	r5, r3
    portTickType start_tick = xTaskGetTickCount();
  404e9a:	4b19      	ldr	r3, [pc, #100]	; (404f00 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x74>)
  404e9c:	4798      	blx	r3
  404e9e:	4604      	mov	r4, r0
    _WaitRes     wait_results{false, true};
  404ea0:	2300      	movs	r3, #0
  404ea2:	f88d 3000 	strb.w	r3, [sp]
  404ea6:	2301      	movs	r3, #1
  404ea8:	f88d 3001 	strb.w	r3, [sp, #1]
    while (xTaskGetTickCount() - start_tick < timeout) {
  404eac:	4b14      	ldr	r3, [pc, #80]	; (404f00 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x74>)
  404eae:	4798      	blx	r3
  404eb0:	1b00      	subs	r0, r0, r4
  404eb2:	42a8      	cmp	r0, r5
  404eb4:	d20a      	bcs.n	404ecc <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x40>
        results = waitCondition([&]() { return isFrozen(); }, true, timeout_ticks);
  404eb6:	4638      	mov	r0, r7
  404eb8:	4b12      	ldr	r3, [pc, #72]	; (404f04 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x78>)
  404eba:	4798      	blx	r3
        if (payload_factory() == value) {
  404ebc:	4286      	cmp	r6, r0
  404ebe:	d112      	bne.n	404ee6 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x5a>
            wait_results.condition_met = true;
  404ec0:	2301      	movs	r3, #1
  404ec2:	f88d 3000 	strb.w	r3, [sp]
            wait_results.timed_out     = false;
  404ec6:	2300      	movs	r3, #0
  404ec8:	f88d 3001 	strb.w	r3, [sp, #1]
    return wait_results;
  404ecc:	f8bd 3000 	ldrh.w	r3, [sp]
  404ed0:	2000      	movs	r0, #0
  404ed2:	b2da      	uxtb	r2, r3
  404ed4:	f362 0007 	bfi	r0, r2, #0, #8
  404ed8:	f3c3 2307 	ubfx	r3, r3, #8, #8
  404edc:	f363 200f 	bfi	r0, r3, #8, #8
}
  404ee0:	b002      	add	sp, #8
  404ee2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (!isRunning()) {
  404ee6:	4640      	mov	r0, r8
  404ee8:	4b07      	ldr	r3, [pc, #28]	; (404f08 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x7c>)
  404eea:	4798      	blx	r3
  404eec:	b918      	cbnz	r0, 404ef6 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x6a>
            wait_results.timed_out = false;
  404eee:	2300      	movs	r3, #0
  404ef0:	f88d 3001 	strb.w	r3, [sp, #1]
            break;
  404ef4:	e7ea      	b.n	404ecc <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x40>
        vTaskDelay(STATUS_UPDATE_FREQ_TICKS);
  404ef6:	2005      	movs	r0, #5
  404ef8:	4b04      	ldr	r3, [pc, #16]	; (404f0c <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x80>)
  404efa:	4798      	blx	r3
    while (xTaskGetTickCount() - start_tick < timeout) {
  404efc:	e7d6      	b.n	404eac <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE2_EENS_8_WaitResET_bm+0x20>
  404efe:	bf00      	nop
  404f00:	0040998d 	.word	0x0040998d
  404f04:	004063eb 	.word	0x004063eb
  404f08:	004063e5 	.word	0x004063e5
  404f0c:	00409bd5 	.word	0x00409bd5

00404f10 <_ZN7StepperC1EP3SpiPPvhmhhhh>:
Stepper::Stepper(Spi *spi, xQueueHandle *spi_mutex, uint8_t spi_cs_pin, uint32_t fclk, uint8_t nfreeze_pin,
  404f10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  404f14:	b086      	sub	sp, #24
  404f16:	4604      	mov	r4, r0
    : TMC4361A(spi, spi_mutex, spi_cs_pin, fclk, nfreeze_pin, nrst_pin, intr_pin, drv_en_pin) {
  404f18:	f89d 5040 	ldrb.w	r5, [sp, #64]	; 0x40
  404f1c:	9504      	str	r5, [sp, #16]
  404f1e:	f89d 503c 	ldrb.w	r5, [sp, #60]	; 0x3c
  404f22:	9503      	str	r5, [sp, #12]
  404f24:	f89d 5038 	ldrb.w	r5, [sp, #56]	; 0x38
  404f28:	9502      	str	r5, [sp, #8]
  404f2a:	f89d 5034 	ldrb.w	r5, [sp, #52]	; 0x34
  404f2e:	9501      	str	r5, [sp, #4]
  404f30:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  404f32:	9500      	str	r5, [sp, #0]
  404f34:	4d4e      	ldr	r5, [pc, #312]	; (405070 <_ZN7StepperC1EP3SpiPPvhmhhhh+0x160>)
  404f36:	47a8      	blx	r5
     Require 'setMotion' after every successful 'move' call
     *2. allow_write_motion_when_busy
     Enables 'move' to override target position in running state
     *3. step correction at 360 degrees
     */
    struct MoveSettings {
  404f38:	2500      	movs	r5, #0
  404f3a:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
  404f3e:	f8a4 5048 	strh.w	r5, [r4, #72]	; 0x48
  404f42:	f8a4 504a 	strh.w	r5, [r4, #74]	; 0x4a
  404f46:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
  404f4a:	f8a4 504e 	strh.w	r5, [r4, #78]	; 0x4e
  404f4e:	f8a4 5050 	strh.w	r5, [r4, #80]	; 0x50
  404f52:	2302      	movs	r3, #2
  404f54:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
  404f58:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
  404f5c:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
  404f60:	f884 5055 	strb.w	r5, [r4, #85]	; 0x55
        bool     vib_loop                          = false; // loop vibration forever
        bool     reset_motion_conf_after_each_move = false;
        bool     allow_write_motion_when_busy      = false;
    };

    struct HomeSettings {
  404f64:	f884 5056 	strb.w	r5, [r4, #86]	; 0x56
  404f68:	f884 5057 	strb.w	r5, [r4, #87]	; 0x57
  404f6c:	2601      	movs	r6, #1
  404f6e:	f884 6058 	strb.w	r6, [r4, #88]	; 0x58
  404f72:	f8a4 505a 	strh.w	r5, [r4, #90]	; 0x5a
  404f76:	f8a4 505c 	strh.w	r5, [r4, #92]	; 0x5c
  404f7a:	f8a4 505e 	strh.w	r5, [r4, #94]	; 0x5e
  404f7e:	f8a4 5060 	strh.w	r5, [r4, #96]	; 0x60
  404f82:	f8a4 5062 	strh.w	r5, [r4, #98]	; 0x62
  404f86:	f8a4 5064 	strh.w	r5, [r4, #100]	; 0x64
  404f8a:	f8a4 5066 	strh.w	r5, [r4, #102]	; 0x66
  404f8e:	f8a4 5068 	strh.w	r5, [r4, #104]	; 0x68
  404f92:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
  404f96:	f8a4 506c 	strh.w	r5, [r4, #108]	; 0x6c
  404f9a:	f8a4 506e 	strh.w	r5, [r4, #110]	; 0x6e
  404f9e:	f241 3388 	movw	r3, #5000	; 0x1388
  404fa2:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
        uint16_t     offset_l          = 0;
        uint16_t     timeout_ms_h      = 0;
        uint16_t     timeout_ms_l      = 5000;
    };

    struct PositioningSettings {
  404fa6:	f884 6072 	strb.w	r6, [r4, #114]	; 0x72
  404faa:	f884 5073 	strb.w	r5, [r4, #115]	; 0x73
  404fae:	23c8      	movs	r3, #200	; 0xc8
  404fb0:	f8a4 3074 	strh.w	r3, [r4, #116]	; 0x74
        PositioningMode pos_mode     = PositioningMode::PM_ABSOLUTE;
        FollowMode      follow_mode  = FollowMode::INTERNAL;
        uint16_t        unit_per_rev = 200;
    };

    struct RampSettings {
  404fb4:	f04f 0804 	mov.w	r8, #4
  404fb8:	f884 8076 	strb.w	r8, [r4, #118]	; 0x76
  404fbc:	f884 6077 	strb.w	r6, [r4, #119]	; 0x77
        TMC4361A::RampMode ramp_mode = TMC4361A::RampMode::POSITIONING_MODE;
        TMC4361A::RampType ramp_type = TMC4361A::RampType::TRAPEZOIDAL_RAMP;
    };

    struct SpeedSettings {
  404fc0:	f8a4 5078 	strh.w	r5, [r4, #120]	; 0x78
  404fc4:	f8a4 507a 	strh.w	r5, [r4, #122]	; 0x7a
  404fc8:	f8a4 507c 	strh.w	r5, [r4, #124]	; 0x7c
  404fcc:	f8a4 507e 	strh.w	r5, [r4, #126]	; 0x7e
  404fd0:	f8a4 5080 	strh.w	r5, [r4, #128]	; 0x80
  404fd4:	f8a4 5082 	strh.w	r5, [r4, #130]	; 0x82
  404fd8:	f8a4 5084 	strh.w	r5, [r4, #132]	; 0x84
  404fdc:	f8a4 5086 	strh.w	r5, [r4, #134]	; 0x86
        uint16_t stop_l  = 0;
        uint16_t break_h = 0;
        uint16_t break_l = 0;
    };

    struct AccelerationSettings {
  404fe0:	f8a4 5088 	strh.w	r5, [r4, #136]	; 0x88
  404fe4:	23fa      	movs	r3, #250	; 0xfa
  404fe6:	f8a4 308a 	strh.w	r3, [r4, #138]	; 0x8a
  404fea:	f8a4 508c 	strh.w	r5, [r4, #140]	; 0x8c
  404fee:	f8a4 308e 	strh.w	r3, [r4, #142]	; 0x8e
  404ff2:	f8a4 5090 	strh.w	r5, [r4, #144]	; 0x90
  404ff6:	f8a4 5092 	strh.w	r5, [r4, #146]	; 0x92
  404ffa:	f8a4 5094 	strh.w	r5, [r4, #148]	; 0x94
  404ffe:	f8a4 5096 	strh.w	r5, [r4, #150]	; 0x96
        uint16_t start_accel_l = 0;
        uint16_t final_decel_h = 0;
        uint16_t final_decel_l = 0;
    };

    struct BowSettings {
  405002:	f8a4 5098 	strh.w	r5, [r4, #152]	; 0x98
  405006:	2364      	movs	r3, #100	; 0x64
  405008:	f8a4 309a 	strh.w	r3, [r4, #154]	; 0x9a
  40500c:	f8a4 509c 	strh.w	r5, [r4, #156]	; 0x9c
  405010:	f8a4 309e 	strh.w	r3, [r4, #158]	; 0x9e
  405014:	f8a4 50a0 	strh.w	r5, [r4, #160]	; 0xa0
  405018:	f8a4 30a2 	strh.w	r3, [r4, #162]	; 0xa2
  40501c:	f8a4 50a4 	strh.w	r5, [r4, #164]	; 0xa4
  405020:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
  405024:	f884 50a8 	strb.w	r5, [r4, #168]	; 0xa8
  405028:	f884 50a9 	strb.w	r5, [r4, #169]	; 0xa9
  40502c:	f884 50aa 	strb.w	r5, [r4, #170]	; 0xaa
  405030:	f884 50ab 	strb.w	r5, [r4, #171]	; 0xab
  405034:	f884 60ac 	strb.w	r6, [r4, #172]	; 0xac
    struct MotionItem {
        MotionTask_t motion_task;
        void        *arg;
    };

    xQueueHandle m_motion_queue_handle = xQueueCreate(1, sizeof(MotionItem));
  405038:	462a      	mov	r2, r5
  40503a:	210c      	movs	r1, #12
  40503c:	4630      	mov	r0, r6
  40503e:	4f0d      	ldr	r7, [pc, #52]	; (405074 <_ZN7StepperC1EP3SpiPPvhmhhhh+0x164>)
  405040:	47b8      	blx	r7
  405042:	f8c4 00b0 	str.w	r0, [r4, #176]	; 0xb0
    xQueueHandle m_result_queue_handle = xQueueCreate(1, sizeof(uint32_t));
  405046:	462a      	mov	r2, r5
  405048:	4641      	mov	r1, r8
  40504a:	4630      	mov	r0, r6
  40504c:	47b8      	blx	r7
  40504e:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
    );
  405052:	9503      	str	r5, [sp, #12]
  405054:	9502      	str	r5, [sp, #8]
  405056:	9501      	str	r5, [sp, #4]
  405058:	9600      	str	r6, [sp, #0]
  40505a:	4623      	mov	r3, r4
  40505c:	22d8      	movs	r2, #216	; 0xd8
  40505e:	4906      	ldr	r1, [pc, #24]	; (405078 <_ZN7StepperC1EP3SpiPPvhmhhhh+0x168>)
  405060:	4806      	ldr	r0, [pc, #24]	; (40507c <_ZN7StepperC1EP3SpiPPvhmhhhh+0x16c>)
  405062:	4d07      	ldr	r5, [pc, #28]	; (405080 <_ZN7StepperC1EP3SpiPPvhmhhhh+0x170>)
  405064:	47a8      	blx	r5
}
  405066:	4620      	mov	r0, r4
  405068:	b006      	add	sp, #24
  40506a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40506e:	bf00      	nop
  405070:	004065a5 	.word	0x004065a5
  405074:	004091b5 	.word	0x004091b5
  405078:	0040e2a4 	.word	0x0040e2a4
  40507c:	00404e15 	.word	0x00404e15
  405080:	00409659 	.word	0x00409659

00405084 <_ZN7Stepper8confMoveENS_12MoveSettingsE>:
void Stepper::confMove(MoveSettings move_s) { m_move_s = move_s; }
  405084:	b084      	sub	sp, #16
  405086:	b470      	push	{r4, r5, r6}
  405088:	4606      	mov	r6, r0
  40508a:	ac04      	add	r4, sp, #16
  40508c:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  405090:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  405092:	f8c6 0046 	str.w	r0, [r6, #70]	; 0x46
  405096:	f8c6 104a 	str.w	r1, [r6, #74]	; 0x4a
  40509a:	f8c6 204e 	str.w	r2, [r6, #78]	; 0x4e
  40509e:	f8c6 3052 	str.w	r3, [r6, #82]	; 0x52
  4050a2:	bc70      	pop	{r4, r5, r6}
  4050a4:	b004      	add	sp, #16
  4050a6:	4770      	bx	lr

004050a8 <_ZN7Stepper37confMove_resetMotionConfAfterEachMoveEt>:
    m_move_s.reset_motion_conf_after_each_move = (bool)enable;
  4050a8:	3100      	adds	r1, #0
  4050aa:	bf18      	it	ne
  4050ac:	2101      	movne	r1, #1
  4050ae:	f880 1054 	strb.w	r1, [r0, #84]	; 0x54
  4050b2:	4770      	bx	lr

004050b4 <_ZN7Stepper33confMove_allowWriteMotionWhenBusyEt>:
    m_move_s.allow_write_motion_when_busy = (bool)enable;
  4050b4:	3100      	adds	r1, #0
  4050b6:	bf18      	it	ne
  4050b8:	2101      	movne	r1, #1
  4050ba:	f880 1055 	strb.w	r1, [r0, #85]	; 0x55
  4050be:	4770      	bx	lr

004050c0 <_ZN7Stepper8confHomeENS_12HomeSettingsE>:
void Stepper::confHome(HomeSettings home_s) { m_home_s = home_s; }
  4050c0:	b084      	sub	sp, #16
  4050c2:	b470      	push	{r4, r5, r6}
  4050c4:	4606      	mov	r6, r0
  4050c6:	ac04      	add	r4, sp, #16
  4050c8:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  4050cc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  4050ce:	f8c6 0056 	str.w	r0, [r6, #86]	; 0x56
  4050d2:	f8c6 105a 	str.w	r1, [r6, #90]	; 0x5a
  4050d6:	f8c6 205e 	str.w	r2, [r6, #94]	; 0x5e
  4050da:	f8c6 3062 	str.w	r3, [r6, #98]	; 0x62
  4050de:	cc07      	ldmia	r4!, {r0, r1, r2}
  4050e0:	f8c6 0066 	str.w	r0, [r6, #102]	; 0x66
  4050e4:	f8c6 106a 	str.w	r1, [r6, #106]	; 0x6a
  4050e8:	f8c6 206e 	str.w	r2, [r6, #110]	; 0x6e
  4050ec:	bc70      	pop	{r4, r5, r6}
  4050ee:	b004      	add	sp, #16
  4050f0:	4770      	bx	lr

004050f2 <_ZN7Stepper19confHome_homingModeEt>:
void Stepper::confHome_homingMode(uint16_t homing_mode) { m_home_s.homing_mode = (HomingMode)homing_mode; }
  4050f2:	f880 1056 	strb.w	r1, [r0, #86]	; 0x56
  4050f6:	4770      	bx	lr

004050f8 <_ZN7Stepper21confHome_homingSensorEt>:
void Stepper::confHome_homingSensor(uint16_t homing_sensor) { m_home_s.homing_sensor = (HomingSensor)homing_sensor; }
  4050f8:	f880 1057 	strb.w	r1, [r0, #87]	; 0x57
  4050fc:	4770      	bx	lr

004050fe <_ZN7Stepper24confHome_sensorHomeValueEt>:
void Stepper::confHome_sensorHomeValue(uint16_t home_value) { m_home_s.sensor_home_value = (bool)home_value; }
  4050fe:	3100      	adds	r1, #0
  405100:	bf18      	it	ne
  405102:	2101      	movne	r1, #1
  405104:	f880 1058 	strb.w	r1, [r0, #88]	; 0x58
  405108:	4770      	bx	lr

0040510a <_ZN7Stepper18confHome_maxFind_hEt>:
void Stepper::confHome_maxFind_h(uint16_t max_find_h) { m_home_s.max_find_h = max_find_h; }
  40510a:	f8a0 105a 	strh.w	r1, [r0, #90]	; 0x5a
  40510e:	4770      	bx	lr

00405110 <_ZN7Stepper18confHome_maxFind_lEt>:
void Stepper::confHome_maxFind_l(uint16_t max_find_l) { m_home_s.max_find_l = max_find_l; }
  405110:	f8a0 105c 	strh.w	r1, [r0, #92]	; 0x5c
  405114:	4770      	bx	lr

00405116 <_ZN7Stepper19confHome_maxSpeed_hEt>:
void Stepper::confHome_maxSpeed_h(uint16_t max_speed_h) { m_home_s.max_speed_h = max_speed_h; }
  405116:	f8a0 105e 	strh.w	r1, [r0, #94]	; 0x5e
  40511a:	4770      	bx	lr

0040511c <_ZN7Stepper19confHome_maxSpeed_lEt>:
void Stepper::confHome_maxSpeed_l(uint16_t max_speed_l) { m_home_s.max_speed_l = max_speed_l; }
  40511c:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
  405120:	4770      	bx	lr

00405122 <_ZN7Stepper19confHome_maxAccel_hEt>:
void Stepper::confHome_maxAccel_h(uint16_t max_accel_h) { m_home_s.max_accel_h = max_accel_h; }
  405122:	f8a0 1062 	strh.w	r1, [r0, #98]	; 0x62
  405126:	4770      	bx	lr

00405128 <_ZN7Stepper19confHome_maxAccel_lEt>:
void Stepper::confHome_maxAccel_l(uint16_t max_accel_l) { m_home_s.max_accel_l = max_accel_l; }
  405128:	f8a0 1064 	strh.w	r1, [r0, #100]	; 0x64
  40512c:	4770      	bx	lr

0040512e <_ZN7Stepper19confHome_maxDecel_hEt>:
void Stepper::confHome_maxDecel_h(uint16_t max_decel_h) { m_home_s.max_decel_h = max_decel_h; }
  40512e:	f8a0 1066 	strh.w	r1, [r0, #102]	; 0x66
  405132:	4770      	bx	lr

00405134 <_ZN7Stepper19confHome_maxDecel_lEt>:
void Stepper::confHome_maxDecel_l(uint16_t max_decel_l) { m_home_s.max_decel_l = max_decel_l; }
  405134:	f8a0 1068 	strh.w	r1, [r0, #104]	; 0x68
  405138:	4770      	bx	lr

0040513a <_ZN7Stepper17confHome_offset_hEt>:
void Stepper::confHome_offset_h(uint16_t offset_h) { m_home_s.offset_h = offset_h; }
  40513a:	f8a0 106a 	strh.w	r1, [r0, #106]	; 0x6a
  40513e:	4770      	bx	lr

00405140 <_ZN7Stepper17confHome_offset_lEt>:
void Stepper::confHome_offset_l(uint16_t offset_l) { m_home_s.offset_l = offset_l; }
  405140:	f8a0 106c 	strh.w	r1, [r0, #108]	; 0x6c
  405144:	4770      	bx	lr

00405146 <_ZN7Stepper18confHome_timeout_hEt>:
void Stepper::confHome_timeout_h(uint16_t timeout_ms_h) { m_home_s.timeout_ms_h = timeout_ms_h; }
  405146:	f8a0 106e 	strh.w	r1, [r0, #110]	; 0x6e
  40514a:	4770      	bx	lr

0040514c <_ZN7Stepper18confHome_timeout_lEt>:
void Stepper::confHome_timeout_l(uint16_t timeout_ms_l) { m_home_s.timeout_ms_l = timeout_ms_l; }
  40514c:	f8a0 1070 	strh.w	r1, [r0, #112]	; 0x70
  405150:	4770      	bx	lr

00405152 <_ZN7Stepper23confPositioning_posModeEt>:
void Stepper::confPositioning_posMode(uint16_t pos_mode) { m_pos_s.pos_mode = (PositioningMode)pos_mode; }
  405152:	f880 1072 	strb.w	r1, [r0, #114]	; 0x72
  405156:	4770      	bx	lr

00405158 <_ZN7Stepper26confPositioning_followModeEt>:
void Stepper::confPositioning_followMode(uint16_t follow_mode) { m_pos_s.follow_mode = (FollowMode)follow_mode; }
  405158:	f880 1073 	strb.w	r1, [r0, #115]	; 0x73
  40515c:	4770      	bx	lr

0040515e <_ZN7Stepper26confPositioning_unitPerRevEt>:
void Stepper::confPositioning_unitPerRev(uint16_t unit_per_rev) { m_pos_s.unit_per_rev = unit_per_rev; }
  40515e:	f8a0 1074 	strh.w	r1, [r0, #116]	; 0x74
  405162:	4770      	bx	lr

00405164 <_ZN7Stepper8confRampENS_12RampSettingsE>:
void Stepper::confRamp(RampSettings ramp_s) { m_ramp_s = ramp_s; }
  405164:	b082      	sub	sp, #8
  405166:	f8a0 1076 	strh.w	r1, [r0, #118]	; 0x76
  40516a:	b002      	add	sp, #8
  40516c:	4770      	bx	lr

0040516e <_ZN7Stepper17confRamp_rampModeEt>:
void Stepper::confRamp_rampMode(uint16_t ramp_mode) { m_ramp_s.ramp_mode = (RampMode)ramp_mode; }
  40516e:	f880 1076 	strb.w	r1, [r0, #118]	; 0x76
  405172:	4770      	bx	lr

00405174 <_ZN7Stepper17confRamp_rampTypeEt>:
void Stepper::confRamp_rampType(uint16_t ramp_type) { m_ramp_s.ramp_type = (RampType)ramp_type; }
  405174:	f880 1077 	strb.w	r1, [r0, #119]	; 0x77
  405178:	4770      	bx	lr

0040517a <_ZN7Stepper9confSpeedENS_13SpeedSettingsE>:
void Stepper::confSpeed(SpeedSettings speed_s) { m_spd_s = speed_s; }
  40517a:	b084      	sub	sp, #16
  40517c:	b430      	push	{r4, r5}
  40517e:	ac03      	add	r4, sp, #12
  405180:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  405184:	f100 0578 	add.w	r5, r0, #120	; 0x78
  405188:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  40518c:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  405190:	bc30      	pop	{r4, r5}
  405192:	b004      	add	sp, #16
  405194:	4770      	bx	lr

00405196 <_ZN7Stepper20confSpeed_maxSpeed_hEt>:
void Stepper::confSpeed_maxSpeed_h(uint16_t max_h) { m_spd_s.max_h = max_h; }
  405196:	f8a0 1078 	strh.w	r1, [r0, #120]	; 0x78
  40519a:	4770      	bx	lr

0040519c <_ZN7Stepper20confSpeed_maxSpeed_lEt>:
void Stepper::confSpeed_maxSpeed_l(uint16_t max_l) { m_spd_s.max_l = max_l; }
  40519c:	f8a0 107a 	strh.w	r1, [r0, #122]	; 0x7a
  4051a0:	4770      	bx	lr

004051a2 <_ZN7Stepper22confSpeed_startSpeed_hEt>:
void Stepper::confSpeed_startSpeed_h(uint16_t start_h) { m_spd_s.start_h = start_h; }
  4051a2:	f8a0 107c 	strh.w	r1, [r0, #124]	; 0x7c
  4051a6:	4770      	bx	lr

004051a8 <_ZN7Stepper22confSpeed_startSpeed_lEt>:
void Stepper::confSpeed_startSpeed_l(uint16_t start_l) { m_spd_s.start_l = start_l; }
  4051a8:	f8a0 107e 	strh.w	r1, [r0, #126]	; 0x7e
  4051ac:	4770      	bx	lr

004051ae <_ZN7Stepper21confSpeed_stopSpeed_hEt>:
void Stepper::confSpeed_stopSpeed_h(uint16_t stop_h) { m_spd_s.stop_h = stop_h; }
  4051ae:	f8a0 1080 	strh.w	r1, [r0, #128]	; 0x80
  4051b2:	4770      	bx	lr

004051b4 <_ZN7Stepper21confSpeed_stopSpeed_lEt>:
void Stepper::confSpeed_stopSpeed_l(uint16_t stop_l) { m_spd_s.stop_l = stop_l; }
  4051b4:	f8a0 1082 	strh.w	r1, [r0, #130]	; 0x82
  4051b8:	4770      	bx	lr

004051ba <_ZN7Stepper22confSpeed_breakSpeed_hEt>:
void Stepper::confSpeed_breakSpeed_h(uint16_t break_h) { m_spd_s.break_h = break_h; }
  4051ba:	f8a0 1084 	strh.w	r1, [r0, #132]	; 0x84
  4051be:	4770      	bx	lr

004051c0 <_ZN7Stepper22confSpeed_breakSpeed_lEt>:
void Stepper::confSpeed_breakSpeed_l(uint16_t break_l) { m_spd_s.break_l = break_l; }
  4051c0:	f8a0 1086 	strh.w	r1, [r0, #134]	; 0x86
  4051c4:	4770      	bx	lr

004051c6 <_ZN7Stepper9confAccelENS_20AccelerationSettingsE>:
void Stepper::confAccel(AccelerationSettings accel_s) { m_accel_s = accel_s; }
  4051c6:	b084      	sub	sp, #16
  4051c8:	b430      	push	{r4, r5}
  4051ca:	ac03      	add	r4, sp, #12
  4051cc:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  4051d0:	f100 0588 	add.w	r5, r0, #136	; 0x88
  4051d4:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  4051d8:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  4051dc:	bc30      	pop	{r4, r5}
  4051de:	b004      	add	sp, #16
  4051e0:	4770      	bx	lr

004051e2 <_ZN7Stepper20confAccel_maxAccel_hEt>:
void Stepper::confAccel_maxAccel_h(uint16_t max_accel_h) { m_accel_s.max_accel_h = max_accel_h; }
  4051e2:	f8a0 1088 	strh.w	r1, [r0, #136]	; 0x88
  4051e6:	4770      	bx	lr

004051e8 <_ZN7Stepper20confAccel_maxAccel_lEt>:
void Stepper::confAccel_maxAccel_l(uint16_t max_accel_l) { m_accel_s.max_accel_l = max_accel_l; }
  4051e8:	f8a0 108a 	strh.w	r1, [r0, #138]	; 0x8a
  4051ec:	4770      	bx	lr

004051ee <_ZN7Stepper20confAccel_maxDecel_hEt>:
void Stepper::confAccel_maxDecel_h(uint16_t max_decel_h) { m_accel_s.max_decel_h = max_decel_h; }
  4051ee:	f8a0 108c 	strh.w	r1, [r0, #140]	; 0x8c
  4051f2:	4770      	bx	lr

004051f4 <_ZN7Stepper20confAccel_maxDecel_lEt>:
void Stepper::confAccel_maxDecel_l(uint16_t max_decel_l) { m_accel_s.max_decel_l = max_decel_l; }
  4051f4:	f8a0 108e 	strh.w	r1, [r0, #142]	; 0x8e
  4051f8:	4770      	bx	lr

004051fa <_ZN7Stepper22confAccel_startAccel_hEt>:
void Stepper::confAccel_startAccel_h(uint16_t start_accel_h) { m_accel_s.start_accel_h = start_accel_h; }
  4051fa:	f8a0 1090 	strh.w	r1, [r0, #144]	; 0x90
  4051fe:	4770      	bx	lr

00405200 <_ZN7Stepper22confAccel_startAccel_lEt>:
void Stepper::confAccel_startAccel_l(uint16_t start_accel_l) { m_accel_s.start_accel_l = start_accel_l; }
  405200:	f8a0 1092 	strh.w	r1, [r0, #146]	; 0x92
  405204:	4770      	bx	lr

00405206 <_ZN7Stepper22confAccel_finalDecel_hEt>:
void Stepper::confAccel_finalDecel_h(uint16_t final_decel_h) { m_accel_s.final_decel_h = final_decel_h; }
  405206:	f8a0 1094 	strh.w	r1, [r0, #148]	; 0x94
  40520a:	4770      	bx	lr

0040520c <_ZN7Stepper22confAccel_finalDecel_lEt>:
void Stepper::confAccel_finalDecel_l(uint16_t final_decel_l) { m_accel_s.final_decel_l = final_decel_l; }
  40520c:	f8a0 1096 	strh.w	r1, [r0, #150]	; 0x96
  405210:	4770      	bx	lr

00405212 <_ZN7Stepper7confBowENS_11BowSettingsE>:
void Stepper::confBow(BowSettings bow_s) { m_bow_s = bow_s; }
  405212:	b084      	sub	sp, #16
  405214:	b430      	push	{r4, r5}
  405216:	ac03      	add	r4, sp, #12
  405218:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  40521c:	f100 0598 	add.w	r5, r0, #152	; 0x98
  405220:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  405224:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  405228:	bc30      	pop	{r4, r5}
  40522a:	b004      	add	sp, #16
  40522c:	4770      	bx	lr

0040522e <_ZN7Stepper14confBow_bow1_hEt>:
void Stepper::confBow_bow1_h(uint16_t bow1_h) { m_bow_s.bow1_h = bow1_h; }
  40522e:	f8a0 1098 	strh.w	r1, [r0, #152]	; 0x98
  405232:	4770      	bx	lr

00405234 <_ZN7Stepper14confBow_bow1_lEt>:
void Stepper::confBow_bow1_l(uint16_t bow1_l) { m_bow_s.bow1_l = bow1_l; }
  405234:	f8a0 109a 	strh.w	r1, [r0, #154]	; 0x9a
  405238:	4770      	bx	lr

0040523a <_ZN7Stepper14confBow_bow2_hEt>:
void Stepper::confBow_bow2_h(uint16_t bow2_h) { m_bow_s.bow2_h = bow2_h; }
  40523a:	f8a0 109c 	strh.w	r1, [r0, #156]	; 0x9c
  40523e:	4770      	bx	lr

00405240 <_ZN7Stepper14confBow_bow2_lEt>:
void Stepper::confBow_bow2_l(uint16_t bow2_l) { m_bow_s.bow2_l = bow2_l; }
  405240:	f8a0 109e 	strh.w	r1, [r0, #158]	; 0x9e
  405244:	4770      	bx	lr

00405246 <_ZN7Stepper14confBow_bow3_hEt>:
void Stepper::confBow_bow3_h(uint16_t bow3_h) { m_bow_s.bow3_h = bow3_h; }
  405246:	f8a0 10a0 	strh.w	r1, [r0, #160]	; 0xa0
  40524a:	4770      	bx	lr

0040524c <_ZN7Stepper14confBow_bow3_lEt>:
void Stepper::confBow_bow3_l(uint16_t bow3_l) { m_bow_s.bow3_l = bow3_l; }
  40524c:	f8a0 10a2 	strh.w	r1, [r0, #162]	; 0xa2
  405250:	4770      	bx	lr

00405252 <_ZN7Stepper14confBow_bow4_hEt>:
void Stepper::confBow_bow4_h(uint16_t bow4_h) { m_bow_s.bow4_h = bow4_h; }
  405252:	f8a0 10a4 	strh.w	r1, [r0, #164]	; 0xa4
  405256:	4770      	bx	lr

00405258 <_ZN7Stepper14confBow_bow4_lEt>:
void Stepper::confBow_bow4_l(uint16_t bow4_l) { m_bow_s.bow4_l = bow4_l; }
  405258:	f8a0 10a6 	strh.w	r1, [r0, #166]	; 0xa6
  40525c:	4770      	bx	lr
	...

00405260 <_ZN7Stepper8d_emStopEv>:
void Stepper::d_emStop() {
  405260:	b508      	push	{r3, lr}
    m_ctrl_init = false;
  405262:	2200      	movs	r2, #0
  405264:	f880 20aa 	strb.w	r2, [r0, #170]	; 0xaa
    m_run_task  = false;
  405268:	f880 20ac 	strb.w	r2, [r0, #172]	; 0xac
    emStop(FreezeEvent::USER);
  40526c:	2101      	movs	r1, #1
  40526e:	4b01      	ldr	r3, [pc, #4]	; (405274 <_ZN7Stepper8d_emStopEv+0x14>)
  405270:	4798      	blx	r3
  405272:	bd08      	pop	{r3, pc}
  405274:	0040692d 	.word	0x0040692d

00405278 <_ZN7Stepper10d_rampStopEv>:
void Stepper::d_rampStop() {
  405278:	b508      	push	{r3, lr}
    m_motion_conf = false;
  40527a:	2200      	movs	r2, #0
  40527c:	f880 20ab 	strb.w	r2, [r0, #171]	; 0xab
    m_run_task    = false;
  405280:	f880 20ac 	strb.w	r2, [r0, #172]	; 0xac
    rampStop();
  405284:	4b01      	ldr	r3, [pc, #4]	; (40528c <_ZN7Stepper10d_rampStopEv+0x14>)
  405286:	4798      	blx	r3
  405288:	bd08      	pop	{r3, pc}
  40528a:	bf00      	nop
  40528c:	00406cbd 	.word	0x00406cbd

00405290 <_ZN7Stepper13d_setPositionEl>:
bool Stepper::d_setPosition(int32_t pos) {
  405290:	b538      	push	{r3, r4, r5, lr}
  405292:	4604      	mov	r4, r0
  405294:	460d      	mov	r5, r1
    if (isRunning()) return false;
  405296:	4b05      	ldr	r3, [pc, #20]	; (4052ac <_ZN7Stepper13d_setPositionEl+0x1c>)
  405298:	4798      	blx	r3
  40529a:	b108      	cbz	r0, 4052a0 <_ZN7Stepper13d_setPositionEl+0x10>
  40529c:	2000      	movs	r0, #0
}
  40529e:	bd38      	pop	{r3, r4, r5, pc}
    setPosition(pos);
  4052a0:	4629      	mov	r1, r5
  4052a2:	4620      	mov	r0, r4
  4052a4:	4b02      	ldr	r3, [pc, #8]	; (4052b0 <_ZN7Stepper13d_setPositionEl+0x20>)
  4052a6:	4798      	blx	r3
    return true;
  4052a8:	2001      	movs	r0, #1
  4052aa:	bd38      	pop	{r3, r4, r5, pc}
  4052ac:	004063e5 	.word	0x004063e5
  4052b0:	00406ccd 	.word	0x00406ccd

004052b4 <_ZN7Stepper14d_enableDriverEv>:
bool Stepper::d_enableDriver() {
  4052b4:	b510      	push	{r4, lr}
  4052b6:	4604      	mov	r4, r0
    if (isRunning()) return false;
  4052b8:	4b04      	ldr	r3, [pc, #16]	; (4052cc <_ZN7Stepper14d_enableDriverEv+0x18>)
  4052ba:	4798      	blx	r3
  4052bc:	b108      	cbz	r0, 4052c2 <_ZN7Stepper14d_enableDriverEv+0xe>
  4052be:	2000      	movs	r0, #0
}
  4052c0:	bd10      	pop	{r4, pc}
    enableDriver();
  4052c2:	4620      	mov	r0, r4
  4052c4:	4b02      	ldr	r3, [pc, #8]	; (4052d0 <_ZN7Stepper14d_enableDriverEv+0x1c>)
  4052c6:	4798      	blx	r3
    return true;
  4052c8:	2001      	movs	r0, #1
  4052ca:	bd10      	pop	{r4, pc}
  4052cc:	004063e5 	.word	0x004063e5
  4052d0:	0040643d 	.word	0x0040643d

004052d4 <_ZN7Stepper15d_releaseDriverEv>:
bool Stepper::d_releaseDriver() {
  4052d4:	b510      	push	{r4, lr}
  4052d6:	4604      	mov	r4, r0
    if (isRunning()) return false;
  4052d8:	4b04      	ldr	r3, [pc, #16]	; (4052ec <_ZN7Stepper15d_releaseDriverEv+0x18>)
  4052da:	4798      	blx	r3
  4052dc:	b108      	cbz	r0, 4052e2 <_ZN7Stepper15d_releaseDriverEv+0xe>
  4052de:	2000      	movs	r0, #0
}
  4052e0:	bd10      	pop	{r4, pc}
    releaseDriver();
  4052e2:	4620      	mov	r0, r4
  4052e4:	4b02      	ldr	r3, [pc, #8]	; (4052f0 <_ZN7Stepper15d_releaseDriverEv+0x1c>)
  4052e6:	4798      	blx	r3
    return true;
  4052e8:	2001      	movs	r0, #1
  4052ea:	bd10      	pop	{r4, pc}
  4052ec:	004063e5 	.word	0x004063e5
  4052f0:	004063fd 	.word	0x004063fd

004052f4 <_ZN7Stepper9getStatusEv>:
Stepper::Status Stepper::getStatus() {
  4052f4:	b510      	push	{r4, lr}
  4052f6:	4604      	mov	r4, r0
    if (isFrozen()) {
  4052f8:	4b1e      	ldr	r3, [pc, #120]	; (405374 <_ZN7Stepper9getStatusEv+0x80>)
  4052fa:	4798      	blx	r3
  4052fc:	b920      	cbnz	r0, 405308 <_ZN7Stepper9getStatusEv+0x14>
        if (m_is_homing)
  4052fe:	f894 30a9 	ldrb.w	r3, [r4, #169]	; 0xa9
  405302:	b1eb      	cbz	r3, 405340 <_ZN7Stepper9getStatusEv+0x4c>
            return Stepper::Status::HOMING;
  405304:	2003      	movs	r0, #3
  405306:	bd10      	pop	{r4, pc}
        FreezeEvent freeze_event = whyFrozen();
  405308:	4620      	mov	r0, r4
  40530a:	4b1b      	ldr	r3, [pc, #108]	; (405378 <_ZN7Stepper9getStatusEv+0x84>)
  40530c:	4798      	blx	r3
        switch (freeze_event) {
  40530e:	3801      	subs	r0, #1
  405310:	2807      	cmp	r0, #7
  405312:	d813      	bhi.n	40533c <_ZN7Stepper9getStatusEv+0x48>
  405314:	e8df f000 	tbb	[pc, r0]
  405318:	08290406 	.word	0x08290406
  40531c:	100e0c0a 	.word	0x100e0c0a
        case FreezeEvent::STALL            : return Stepper::Status::STALL; break;
  405320:	2007      	movs	r0, #7
  405322:	bd10      	pop	{r4, pc}
        case FreezeEvent::USER             : return Stepper::Status::STOPPED; break;
  405324:	2009      	movs	r0, #9
  405326:	bd10      	pop	{r4, pc}
        case FreezeEvent::COIL_OL          : return Stepper::Status::COIL_OL; break;
  405328:	200a      	movs	r0, #10
  40532a:	bd10      	pop	{r4, pc}
        case FreezeEvent::COIL_SHORT       : return Stepper::Status::COIL_SHORT; break;
  40532c:	200b      	movs	r0, #11
  40532e:	bd10      	pop	{r4, pc}
        case FreezeEvent::OVERTEMP         : return Stepper::Status::OVERTEMP; break;
  405330:	200c      	movs	r0, #12
  405332:	bd10      	pop	{r4, pc}
        case FreezeEvent::TMC4361A_COMM_ERR: return Stepper::Status::TMC4361A_COMM_ERR; break;
  405334:	200d      	movs	r0, #13
  405336:	bd10      	pop	{r4, pc}
        case FreezeEvent::TMC5160_COMM_ERR : return Stepper::Status::TMC5160_COMM_ERR; break;
  405338:	200e      	movs	r0, #14
  40533a:	bd10      	pop	{r4, pc}
        default                            : return Stepper::Status::UNDEFINED; break;
  40533c:	200f      	movs	r0, #15
  40533e:	bd10      	pop	{r4, pc}
        else if (m_is_vibrating)
  405340:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
  405344:	b10b      	cbz	r3, 40534a <_ZN7Stepper9getStatusEv+0x56>
            return Stepper::Status::VIBRATING;
  405346:	2004      	movs	r0, #4
  405348:	bd10      	pop	{r4, pc}
        else if (!m_ctrl_init)
  40534a:	f894 30aa 	ldrb.w	r3, [r4, #170]	; 0xaa
  40534e:	b90b      	cbnz	r3, 405354 <_ZN7Stepper9getStatusEv+0x60>
            return Stepper::Status::CTRL_NOT_INIT;
  405350:	2005      	movs	r0, #5
  405352:	bd10      	pop	{r4, pc}
        else if (isRunning())
  405354:	4620      	mov	r0, r4
  405356:	4b09      	ldr	r3, [pc, #36]	; (40537c <_ZN7Stepper9getStatusEv+0x88>)
  405358:	4798      	blx	r3
  40535a:	b108      	cbz	r0, 405360 <_ZN7Stepper9getStatusEv+0x6c>
            return Stepper::Status::BUSY;
  40535c:	2002      	movs	r0, #2
  40535e:	bd10      	pop	{r4, pc}
        else if (!m_motion_conf)
  405360:	f894 30ab 	ldrb.w	r3, [r4, #171]	; 0xab
  405364:	b91b      	cbnz	r3, 40536e <_ZN7Stepper9getStatusEv+0x7a>
            return Stepper::Status::MOTION_NOT_INIT;
  405366:	2006      	movs	r0, #6
  405368:	bd10      	pop	{r4, pc}
        case FreezeEvent::POS_ERR          : return Stepper::Status::POS_ERR; break;
  40536a:	2008      	movs	r0, #8
  40536c:	bd10      	pop	{r4, pc}
            return Stepper::Status::READY;
  40536e:	2001      	movs	r0, #1
}
  405370:	bd10      	pop	{r4, pc}
  405372:	bf00      	nop
  405374:	004063eb 	.word	0x004063eb
  405378:	004063f7 	.word	0x004063f7
  40537c:	004063e5 	.word	0x004063e5

00405380 <_ZN7Stepper15waitCompleteRunEv>:
void Stepper::waitCompleteRun() {
  405380:	b510      	push	{r4, lr}
  405382:	4604      	mov	r4, r0
    vTaskDelay(STATUS_UPDATE_FREQ_TICKS);
  405384:	2005      	movs	r0, #5
  405386:	4b05      	ldr	r3, [pc, #20]	; (40539c <_ZN7Stepper15waitCompleteRunEv+0x1c>)
  405388:	4798      	blx	r3
    while (isRunning())
  40538a:	4620      	mov	r0, r4
  40538c:	4b04      	ldr	r3, [pc, #16]	; (4053a0 <_ZN7Stepper15waitCompleteRunEv+0x20>)
  40538e:	4798      	blx	r3
  405390:	b118      	cbz	r0, 40539a <_ZN7Stepper15waitCompleteRunEv+0x1a>
        vTaskDelay(STATUS_UPDATE_FREQ_TICKS);
  405392:	2005      	movs	r0, #5
  405394:	4b01      	ldr	r3, [pc, #4]	; (40539c <_ZN7Stepper15waitCompleteRunEv+0x1c>)
  405396:	4798      	blx	r3
    while (isRunning())
  405398:	e7f7      	b.n	40538a <_ZN7Stepper15waitCompleteRunEv+0xa>
  40539a:	bd10      	pop	{r4, pc}
  40539c:	00409bd5 	.word	0x00409bd5
  4053a0:	004063e5 	.word	0x004063e5

004053a4 <_ZN7Stepper18setTargetUnitsHighEt>:
void Stepper::setTargetUnitsHigh(uint16_t unit_high) { m_move_s.unit_high = unit_high; }
  4053a4:	f8a0 1046 	strh.w	r1, [r0, #70]	; 0x46
  4053a8:	4770      	bx	lr

004053aa <_ZN7Stepper17setTargetUnitsLowEt>:
void Stepper::setTargetUnitsLow(uint16_t unit_low) { m_move_s.unit_low = unit_low; }
  4053aa:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
  4053ae:	4770      	bx	lr

004053b0 <_ZN7Stepper13setTimeMsHighEt>:
void Stepper::setTimeMsHigh(uint16_t time_ms_high) { m_move_s.time_ms_high = time_ms_high; }
  4053b0:	f8a0 104a 	strh.w	r1, [r0, #74]	; 0x4a
  4053b4:	4770      	bx	lr

004053b6 <_ZN7Stepper12setTimeMsLowEt>:
void Stepper::setTimeMsLow(uint16_t time_ms_low) { m_move_s.time_ms_low = time_ms_low; }
  4053b6:	f8a0 104c 	strh.w	r1, [r0, #76]	; 0x4c
  4053ba:	4770      	bx	lr

004053bc <_ZN7Stepper22setVibrationIterationsEt>:
void Stepper::setVibrationIterations(uint16_t vib_i) { m_move_s.vib_i = vib_i; }
  4053bc:	f8a0 104e 	strh.w	r1, [r0, #78]	; 0x4e
  4053c0:	4770      	bx	lr

004053c2 <_ZN7Stepper20setDiminishingFactorEt>:
void Stepper::setDiminishingFactor(uint16_t vib_dim_factor) { m_move_s.vib_dim_factor = vib_dim_factor; }
  4053c2:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
  4053c6:	4770      	bx	lr

004053c8 <_ZN7Stepper7setLoopEt>:
void Stepper::setLoop(uint16_t vib_loop) { m_move_s.vib_loop = (bool)vib_loop; }
  4053c8:	3100      	adds	r1, #0
  4053ca:	bf18      	it	ne
  4053cc:	2101      	movne	r1, #1
  4053ce:	f880 1053 	strb.w	r1, [r0, #83]	; 0x53
  4053d2:	4770      	bx	lr

004053d4 <_ZN7Stepper10rstDrvFlagEv>:
void Stepper::rstDrvFlag() { m_ctrl_init = false; }
  4053d4:	2300      	movs	r3, #0
  4053d6:	f880 30aa 	strb.w	r3, [r0, #170]	; 0xaa
  4053da:	4770      	bx	lr

004053dc <_ZN7Stepper13rstMotionFlagEv>:
void Stepper::rstMotionFlag() { m_motion_conf = false; }
  4053dc:	2300      	movs	r3, #0
  4053de:	f880 30ab 	strb.w	r3, [r0, #171]	; 0xab
  4053e2:	4770      	bx	lr

004053e4 <_ZN7Stepper10moveHomingEv>:
Stepper::PutQueueRes Stepper::moveHoming() {
  4053e4:	b510      	push	{r4, lr}
  4053e6:	b082      	sub	sp, #8
  4053e8:	4604      	mov	r4, r0
    if (uxQueueMessagesWaiting(m_result_queue_handle) != 0) return PutQueueRes::Q_RESULTS_PENDING;
  4053ea:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
  4053ee:	4b0f      	ldr	r3, [pc, #60]	; (40542c <_ZN7Stepper10moveHomingEv+0x48>)
  4053f0:	4798      	blx	r3
  4053f2:	b110      	cbz	r0, 4053fa <_ZN7Stepper10moveHomingEv+0x16>
  4053f4:	2003      	movs	r0, #3
}
  4053f6:	b002      	add	sp, #8
  4053f8:	bd10      	pop	{r4, pc}
    MotionItem *motion_item  = new MotionItem;
  4053fa:	200c      	movs	r0, #12
  4053fc:	4b0c      	ldr	r3, [pc, #48]	; (405430 <_ZN7Stepper10moveHomingEv+0x4c>)
  4053fe:	4798      	blx	r3
  405400:	a902      	add	r1, sp, #8
  405402:	f841 0d04 	str.w	r0, [r1, #-4]!
    motion_item->motion_task = &Stepper::moveHomingWrapper;
  405406:	4b0b      	ldr	r3, [pc, #44]	; (405434 <_ZN7Stepper10moveHomingEv+0x50>)
  405408:	6003      	str	r3, [r0, #0]
  40540a:	2200      	movs	r2, #0
  40540c:	6042      	str	r2, [r0, #4]
    if (xQueueSend(m_motion_queue_handle, &motion_item, 0) == pdTRUE)
  40540e:	4613      	mov	r3, r2
  405410:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  405414:	4c08      	ldr	r4, [pc, #32]	; (405438 <_ZN7Stepper10moveHomingEv+0x54>)
  405416:	47a0      	blx	r4
  405418:	2801      	cmp	r0, #1
  40541a:	d005      	beq.n	405428 <_ZN7Stepper10moveHomingEv+0x44>
        delete motion_item; // free heap
  40541c:	210c      	movs	r1, #12
  40541e:	9801      	ldr	r0, [sp, #4]
  405420:	4b06      	ldr	r3, [pc, #24]	; (40543c <_ZN7Stepper10moveHomingEv+0x58>)
  405422:	4798      	blx	r3
        return PutQueueRes::Q_FULL;
  405424:	2002      	movs	r0, #2
  405426:	e7e6      	b.n	4053f6 <_ZN7Stepper10moveHomingEv+0x12>
        return PutQueueRes::Q_SUCCESS;
  405428:	2001      	movs	r0, #1
  40542a:	e7e4      	b.n	4053f6 <_ZN7Stepper10moveHomingEv+0x12>
  40542c:	00409589 	.word	0x00409589
  405430:	0040b2b9 	.word	0x0040b2b9
  405434:	004063b9 	.word	0x004063b9
  405438:	00409209 	.word	0x00409209
  40543c:	0040b2b5 	.word	0x0040b2b5

00405440 <_ZN7Stepper14initControllerEv>:
Stepper::PutQueueRes Stepper::initController() {
  405440:	b510      	push	{r4, lr}
  405442:	b082      	sub	sp, #8
  405444:	4604      	mov	r4, r0
    if (uxQueueMessagesWaiting(m_result_queue_handle) != 0) return PutQueueRes::Q_RESULTS_PENDING;
  405446:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
  40544a:	4b10      	ldr	r3, [pc, #64]	; (40548c <_ZN7Stepper14initControllerEv+0x4c>)
  40544c:	4798      	blx	r3
  40544e:	b110      	cbz	r0, 405456 <_ZN7Stepper14initControllerEv+0x16>
  405450:	2003      	movs	r0, #3
}
  405452:	b002      	add	sp, #8
  405454:	bd10      	pop	{r4, pc}
    MotionItem *motion_item  = new MotionItem;
  405456:	200c      	movs	r0, #12
  405458:	4b0d      	ldr	r3, [pc, #52]	; (405490 <_ZN7Stepper14initControllerEv+0x50>)
  40545a:	4798      	blx	r3
  40545c:	a902      	add	r1, sp, #8
  40545e:	f841 0d04 	str.w	r0, [r1, #-4]!
    motion_item->motion_task = &Stepper::execInitControllerWrapper; // special case for initController
  405462:	4b0c      	ldr	r3, [pc, #48]	; (405494 <_ZN7Stepper14initControllerEv+0x54>)
  405464:	6003      	str	r3, [r0, #0]
  405466:	2200      	movs	r2, #0
  405468:	6042      	str	r2, [r0, #4]
    motion_item->arg         = nullptr;
  40546a:	6082      	str	r2, [r0, #8]
    if (xQueueSend(m_motion_queue_handle, &motion_item, 0) == pdTRUE)
  40546c:	4613      	mov	r3, r2
  40546e:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  405472:	4c09      	ldr	r4, [pc, #36]	; (405498 <_ZN7Stepper14initControllerEv+0x58>)
  405474:	47a0      	blx	r4
  405476:	2801      	cmp	r0, #1
  405478:	d005      	beq.n	405486 <_ZN7Stepper14initControllerEv+0x46>
        delete motion_item; // free heap
  40547a:	210c      	movs	r1, #12
  40547c:	9801      	ldr	r0, [sp, #4]
  40547e:	4b07      	ldr	r3, [pc, #28]	; (40549c <_ZN7Stepper14initControllerEv+0x5c>)
  405480:	4798      	blx	r3
        return PutQueueRes::Q_FULL;
  405482:	2002      	movs	r0, #2
  405484:	e7e5      	b.n	405452 <_ZN7Stepper14initControllerEv+0x12>
        return PutQueueRes::Q_SUCCESS;
  405486:	2001      	movs	r0, #1
  405488:	e7e3      	b.n	405452 <_ZN7Stepper14initControllerEv+0x12>
  40548a:	bf00      	nop
  40548c:	00409589 	.word	0x00409589
  405490:	0040b2b9 	.word	0x0040b2b9
  405494:	004055c1 	.word	0x004055c1
  405498:	00409209 	.word	0x00409209
  40549c:	0040b2b5 	.word	0x0040b2b5

004054a0 <_ZN7Stepper9setMotionEv>:
Stepper::PutQueueRes Stepper::setMotion() {
  4054a0:	b510      	push	{r4, lr}
  4054a2:	b082      	sub	sp, #8
  4054a4:	4604      	mov	r4, r0
    if (uxQueueMessagesWaiting(m_result_queue_handle) != 0) return PutQueueRes::Q_RESULTS_PENDING;
  4054a6:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
  4054aa:	4b10      	ldr	r3, [pc, #64]	; (4054ec <_ZN7Stepper9setMotionEv+0x4c>)
  4054ac:	4798      	blx	r3
  4054ae:	b110      	cbz	r0, 4054b6 <_ZN7Stepper9setMotionEv+0x16>
  4054b0:	2003      	movs	r0, #3
}
  4054b2:	b002      	add	sp, #8
  4054b4:	bd10      	pop	{r4, pc}
    MotionItem *motion_item  = new MotionItem;
  4054b6:	200c      	movs	r0, #12
  4054b8:	4b0d      	ldr	r3, [pc, #52]	; (4054f0 <_ZN7Stepper9setMotionEv+0x50>)
  4054ba:	4798      	blx	r3
  4054bc:	a902      	add	r1, sp, #8
  4054be:	f841 0d04 	str.w	r0, [r1, #-4]!
    motion_item->motion_task = &Stepper::execSetMotionWrapper; // special case for setMotion
  4054c2:	4b0c      	ldr	r3, [pc, #48]	; (4054f4 <_ZN7Stepper9setMotionEv+0x54>)
  4054c4:	6003      	str	r3, [r0, #0]
  4054c6:	2200      	movs	r2, #0
  4054c8:	6042      	str	r2, [r0, #4]
    motion_item->arg         = nullptr;
  4054ca:	6082      	str	r2, [r0, #8]
    if (xQueueSend(m_motion_queue_handle, &motion_item, 0) == pdTRUE)
  4054cc:	4613      	mov	r3, r2
  4054ce:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  4054d2:	4c09      	ldr	r4, [pc, #36]	; (4054f8 <_ZN7Stepper9setMotionEv+0x58>)
  4054d4:	47a0      	blx	r4
  4054d6:	2801      	cmp	r0, #1
  4054d8:	d005      	beq.n	4054e6 <_ZN7Stepper9setMotionEv+0x46>
        delete motion_item; // free heap
  4054da:	210c      	movs	r1, #12
  4054dc:	9801      	ldr	r0, [sp, #4]
  4054de:	4b07      	ldr	r3, [pc, #28]	; (4054fc <_ZN7Stepper9setMotionEv+0x5c>)
  4054e0:	4798      	blx	r3
        return PutQueueRes::Q_FULL;
  4054e2:	2002      	movs	r0, #2
  4054e4:	e7e5      	b.n	4054b2 <_ZN7Stepper9setMotionEv+0x12>
        return PutQueueRes::Q_SUCCESS;
  4054e6:	2001      	movs	r0, #1
  4054e8:	e7e3      	b.n	4054b2 <_ZN7Stepper9setMotionEv+0x12>
  4054ea:	bf00      	nop
  4054ec:	00409589 	.word	0x00409589
  4054f0:	0040b2b9 	.word	0x0040b2b9
  4054f4:	00405981 	.word	0x00405981
  4054f8:	00409209 	.word	0x00409209
  4054fc:	0040b2b5 	.word	0x0040b2b5

00405500 <_ZN7Stepper11getReadbackEPm>:
bool Stepper::getReadback(uint32_t *readback) {
  405500:	b510      	push	{r4, lr}
    bool has_readback = xQueueReceive(m_result_queue_handle, readback, 0) == pdTRUE;
  405502:	2300      	movs	r3, #0
  405504:	461a      	mov	r2, r3
  405506:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
  40550a:	4c03      	ldr	r4, [pc, #12]	; (405518 <_ZN7Stepper11getReadbackEPm+0x18>)
  40550c:	47a0      	blx	r4
}
  40550e:	2801      	cmp	r0, #1
  405510:	bf14      	ite	ne
  405512:	2000      	movne	r0, #0
  405514:	2001      	moveq	r0, #1
  405516:	bd10      	pop	{r4, pc}
  405518:	00409421 	.word	0x00409421

0040551c <_ZN7Stepper11pulseToUnitEl>:
int32_t Stepper::pulseToUnit(int32_t pulse) {
  40551c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  405520:	4605      	mov	r5, r0
  405522:	460e      	mov	r6, r1
    float mstep_per_fs = static_cast<float>(m_drv_s.mstep_per_fs);
  405524:	4c13      	ldr	r4, [pc, #76]	; (405574 <_ZN7Stepper11pulseToUnitEl+0x58>)
  405526:	8800      	ldrh	r0, [r0, #0]
  405528:	47a0      	blx	r4
  40552a:	4680      	mov	r8, r0
    float unit_per_rev = static_cast<float>(m_pos_s.unit_per_rev);
  40552c:	f8b5 0074 	ldrh.w	r0, [r5, #116]	; 0x74
  405530:	47a0      	blx	r4
  405532:	4607      	mov	r7, r0
    float fs_per_rev   = static_cast<float>(m_drv_s.fs_per_rev);
  405534:	8868      	ldrh	r0, [r5, #2]
  405536:	47a0      	blx	r4
  405538:	4681      	mov	r9, r0
    float f_pulse      = static_cast<float>(pulse);
  40553a:	4630      	mov	r0, r6
  40553c:	4b0e      	ldr	r3, [pc, #56]	; (405578 <_ZN7Stepper11pulseToUnitEl+0x5c>)
  40553e:	4798      	blx	r3
  405540:	4605      	mov	r5, r0
    float unit = f_pulse * (unit_per_rev / (mstep_per_fs * fs_per_rev));
  405542:	4c0e      	ldr	r4, [pc, #56]	; (40557c <_ZN7Stepper11pulseToUnitEl+0x60>)
  405544:	4649      	mov	r1, r9
  405546:	4640      	mov	r0, r8
  405548:	47a0      	blx	r4
  40554a:	4601      	mov	r1, r0
  40554c:	4638      	mov	r0, r7
  40554e:	4b0c      	ldr	r3, [pc, #48]	; (405580 <_ZN7Stepper11pulseToUnitEl+0x64>)
  405550:	4798      	blx	r3
  405552:	4601      	mov	r1, r0
  405554:	4628      	mov	r0, r5
  405556:	47a0      	blx	r4
  405558:	4601      	mov	r1, r0
    return static_cast<int32_t>(unit + (is_negative ? -0.5f : 0.5f));
  40555a:	2e00      	cmp	r6, #0
  40555c:	db07      	blt.n	40556e <_ZN7Stepper11pulseToUnitEl+0x52>
  40555e:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
  405562:	4b08      	ldr	r3, [pc, #32]	; (405584 <_ZN7Stepper11pulseToUnitEl+0x68>)
  405564:	4798      	blx	r3
  405566:	4b08      	ldr	r3, [pc, #32]	; (405588 <_ZN7Stepper11pulseToUnitEl+0x6c>)
  405568:	4798      	blx	r3
}
  40556a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return static_cast<int32_t>(unit + (is_negative ? -0.5f : 0.5f));
  40556e:	f04f 403f 	mov.w	r0, #3204448256	; 0xbf000000
  405572:	e7f6      	b.n	405562 <_ZN7Stepper11pulseToUnitEl+0x46>
  405574:	0040bd31 	.word	0x0040bd31
  405578:	0040bd39 	.word	0x0040bd39
  40557c:	0040bde1 	.word	0x0040bde1
  405580:	0040bf49 	.word	0x0040bf49
  405584:	0040bbd1 	.word	0x0040bbd1
  405588:	0040c16d 	.word	0x0040c16d

0040558c <_ZN7Stepper18execInitControllerEv>:
bool Stepper::execInitController() {
  40558c:	b510      	push	{r4, lr}
  40558e:	4604      	mov	r4, r0
    FreezeEvent freeze_event = whyFrozen();
  405590:	4b08      	ldr	r3, [pc, #32]	; (4055b4 <_ZN7Stepper18execInitControllerEv+0x28>)
  405592:	4798      	blx	r3
    if (freeze_event > 3) return false; // require reboot
  405594:	2803      	cmp	r0, #3
  405596:	dd01      	ble.n	40559c <_ZN7Stepper18execInitControllerEv+0x10>
  405598:	2000      	movs	r0, #0
}
  40559a:	bd10      	pop	{r4, pc}
    hardReset();
  40559c:	4620      	mov	r0, r4
  40559e:	4b06      	ldr	r3, [pc, #24]	; (4055b8 <_ZN7Stepper18execInitControllerEv+0x2c>)
  4055a0:	4798      	blx	r3
    m_ctrl_init   = initialize();
  4055a2:	4620      	mov	r0, r4
  4055a4:	4b05      	ldr	r3, [pc, #20]	; (4055bc <_ZN7Stepper18execInitControllerEv+0x30>)
  4055a6:	4798      	blx	r3
  4055a8:	f884 00aa 	strb.w	r0, [r4, #170]	; 0xaa
    m_motion_conf = false;
  4055ac:	2300      	movs	r3, #0
  4055ae:	f884 30ab 	strb.w	r3, [r4, #171]	; 0xab
    return m_ctrl_init;
  4055b2:	bd10      	pop	{r4, pc}
  4055b4:	004063f7 	.word	0x004063f7
  4055b8:	004066e5 	.word	0x004066e5
  4055bc:	00407081 	.word	0x00407081

004055c0 <_ZN7Stepper25execInitControllerWrapperEPv>:
uint32_t Stepper::execInitControllerWrapper(void *args) {
  4055c0:	b538      	push	{r3, r4, r5, lr}
    MotionItem *motion_item     = *motion_item_ptr;
  4055c2:	680d      	ldr	r5, [r1, #0]
    bool exec = execInitController();
  4055c4:	4b04      	ldr	r3, [pc, #16]	; (4055d8 <_ZN7Stepper25execInitControllerWrapperEPv+0x18>)
  4055c6:	4798      	blx	r3
  4055c8:	4604      	mov	r4, r0
    delete motion_item; // free heap
  4055ca:	210c      	movs	r1, #12
  4055cc:	4628      	mov	r0, r5
  4055ce:	4b03      	ldr	r3, [pc, #12]	; (4055dc <_ZN7Stepper25execInitControllerWrapperEPv+0x1c>)
  4055d0:	4798      	blx	r3
}
  4055d2:	4620      	mov	r0, r4
  4055d4:	bd38      	pop	{r3, r4, r5, pc}
  4055d6:	bf00      	nop
  4055d8:	0040558d 	.word	0x0040558d
  4055dc:	0040b2b5 	.word	0x0040b2b5

004055e0 <_ZN7Stepper20setMotionInverseTimeEff>:
bool Stepper::setMotionInverseTime(float max_speed, float max_accel) {
  4055e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4055e4:	b083      	sub	sp, #12
  4055e6:	4681      	mov	r9, r0
  4055e8:	4688      	mov	r8, r1
  4055ea:	4617      	mov	r7, r2
    conf &= setRampMode(default_ramp_s.ramp_mode, default_ramp_s.ramp_type);
  4055ec:	2201      	movs	r2, #1
  4055ee:	2104      	movs	r1, #4
  4055f0:	4b0b      	ldr	r3, [pc, #44]	; (405620 <_ZN7Stepper20setMotionInverseTimeEff+0x40>)
  4055f2:	4798      	blx	r3
  4055f4:	4604      	mov	r4, r0
    conf &= setSpeeds(max_speed, 0.0, 0.0, 0.0);
  4055f6:	2500      	movs	r5, #0
  4055f8:	9500      	str	r5, [sp, #0]
  4055fa:	462b      	mov	r3, r5
  4055fc:	462a      	mov	r2, r5
  4055fe:	4641      	mov	r1, r8
  405600:	4648      	mov	r0, r9
  405602:	4e08      	ldr	r6, [pc, #32]	; (405624 <_ZN7Stepper20setMotionInverseTimeEff+0x44>)
  405604:	47b0      	blx	r6
  405606:	4004      	ands	r4, r0
  405608:	b2e4      	uxtb	r4, r4
    conf &= setAccelerations(max_accel, max_accel, 0.0, 0.0);
  40560a:	9500      	str	r5, [sp, #0]
  40560c:	462b      	mov	r3, r5
  40560e:	463a      	mov	r2, r7
  405610:	4639      	mov	r1, r7
  405612:	4648      	mov	r0, r9
  405614:	4d04      	ldr	r5, [pc, #16]	; (405628 <_ZN7Stepper20setMotionInverseTimeEff+0x48>)
  405616:	47a8      	blx	r5
}
  405618:	4020      	ands	r0, r4
  40561a:	b003      	add	sp, #12
  40561c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  405620:	00406b31 	.word	0x00406b31
  405624:	00406b41 	.word	0x00406b41
  405628:	00406bb9 	.word	0x00406bb9

0040562c <_ZN7Stepper11combineWordEtt>:
}
  40562c:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
  405630:	4770      	bx	lr
	...

00405634 <_ZN7Stepper4moveEv>:
Stepper::PutQueueRes Stepper::move() {
  405634:	b570      	push	{r4, r5, r6, lr}
  405636:	b082      	sub	sp, #8
  405638:	4604      	mov	r4, r0
    if (uxQueueMessagesWaiting(m_result_queue_handle) != 0) return PutQueueRes::Q_RESULTS_PENDING;
  40563a:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
  40563e:	4b18      	ldr	r3, [pc, #96]	; (4056a0 <_ZN7Stepper4moveEv+0x6c>)
  405640:	4798      	blx	r3
  405642:	b110      	cbz	r0, 40564a <_ZN7Stepper4moveEv+0x16>
  405644:	2003      	movs	r0, #3
}
  405646:	b002      	add	sp, #8
  405648:	bd70      	pop	{r4, r5, r6, pc}
    units = static_cast<int32_t>(combineWord(m_move_s.unit_high, m_move_s.unit_low));
  40564a:	f8b4 1048 	ldrh.w	r1, [r4, #72]	; 0x48
  40564e:	f8b4 0046 	ldrh.w	r0, [r4, #70]	; 0x46
  405652:	4b14      	ldr	r3, [pc, #80]	; (4056a4 <_ZN7Stepper4moveEv+0x70>)
  405654:	4798      	blx	r3
  405656:	4606      	mov	r6, r0
    MotionItem *motion_item = new MotionItem;
  405658:	200c      	movs	r0, #12
  40565a:	4d13      	ldr	r5, [pc, #76]	; (4056a8 <_ZN7Stepper4moveEv+0x74>)
  40565c:	47a8      	blx	r5
  40565e:	9001      	str	r0, [sp, #4]
    int32_t    *arg         = new int32_t(units);
  405660:	2004      	movs	r0, #4
  405662:	47a8      	blx	r5
  405664:	4605      	mov	r5, r0
  405666:	6006      	str	r6, [r0, #0]
    motion_item->motion_task = &Stepper::moveWrapper;
  405668:	9b01      	ldr	r3, [sp, #4]
  40566a:	4a10      	ldr	r2, [pc, #64]	; (4056ac <_ZN7Stepper4moveEv+0x78>)
  40566c:	601a      	str	r2, [r3, #0]
  40566e:	2200      	movs	r2, #0
  405670:	605a      	str	r2, [r3, #4]
    motion_item->arg         = arg;
  405672:	a902      	add	r1, sp, #8
  405674:	f851 3d04 	ldr.w	r3, [r1, #-4]!
  405678:	6098      	str	r0, [r3, #8]
    if (xQueueSend(m_motion_queue_handle, &motion_item, 0) == pdTRUE)
  40567a:	4613      	mov	r3, r2
  40567c:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  405680:	4c0b      	ldr	r4, [pc, #44]	; (4056b0 <_ZN7Stepper4moveEv+0x7c>)
  405682:	47a0      	blx	r4
  405684:	2801      	cmp	r0, #1
  405686:	d008      	beq.n	40569a <_ZN7Stepper4moveEv+0x66>
        delete motion_item; // free heap
  405688:	210c      	movs	r1, #12
  40568a:	9801      	ldr	r0, [sp, #4]
  40568c:	4c09      	ldr	r4, [pc, #36]	; (4056b4 <_ZN7Stepper4moveEv+0x80>)
  40568e:	47a0      	blx	r4
        delete arg;
  405690:	2104      	movs	r1, #4
  405692:	4628      	mov	r0, r5
  405694:	47a0      	blx	r4
        return PutQueueRes::Q_FULL;
  405696:	2002      	movs	r0, #2
  405698:	e7d5      	b.n	405646 <_ZN7Stepper4moveEv+0x12>
        return PutQueueRes::Q_SUCCESS;
  40569a:	2001      	movs	r0, #1
  40569c:	e7d3      	b.n	405646 <_ZN7Stepper4moveEv+0x12>
  40569e:	bf00      	nop
  4056a0:	00409589 	.word	0x00409589
  4056a4:	0040562d 	.word	0x0040562d
  4056a8:	0040b2b9 	.word	0x0040b2b9
  4056ac:	00405bb1 	.word	0x00405bb1
  4056b0:	00409209 	.word	0x00409209
  4056b4:	0040b2b5 	.word	0x0040b2b5

004056b8 <_ZN7Stepper15moveInverseTimeEv>:
Stepper::PutQueueRes Stepper::moveInverseTime() {
  4056b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4056bc:	b082      	sub	sp, #8
  4056be:	4604      	mov	r4, r0
    if (uxQueueMessagesWaiting(m_result_queue_handle) != 0) return PutQueueRes::Q_RESULTS_PENDING;
  4056c0:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
  4056c4:	4b1b      	ldr	r3, [pc, #108]	; (405734 <_ZN7Stepper15moveInverseTimeEv+0x7c>)
  4056c6:	4798      	blx	r3
  4056c8:	b118      	cbz	r0, 4056d2 <_ZN7Stepper15moveInverseTimeEv+0x1a>
  4056ca:	2003      	movs	r0, #3
}
  4056cc:	b002      	add	sp, #8
  4056ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    time_ms_int = combineWord(m_move_s.time_ms_high, m_move_s.time_ms_low);
  4056d2:	f8b4 104c 	ldrh.w	r1, [r4, #76]	; 0x4c
  4056d6:	f8b4 004a 	ldrh.w	r0, [r4, #74]	; 0x4a
  4056da:	4f17      	ldr	r7, [pc, #92]	; (405738 <_ZN7Stepper15moveInverseTimeEv+0x80>)
  4056dc:	47b8      	blx	r7
  4056de:	4680      	mov	r8, r0
    _IvtArgs *arg = new _IvtArgs;
  4056e0:	2008      	movs	r0, #8
  4056e2:	4e16      	ldr	r6, [pc, #88]	; (40573c <_ZN7Stepper15moveInverseTimeEv+0x84>)
  4056e4:	47b0      	blx	r6
  4056e6:	4605      	mov	r5, r0
    arg->units    = static_cast<int32_t>(combineWord(m_move_s.unit_high, m_move_s.unit_low));
  4056e8:	f8b4 1048 	ldrh.w	r1, [r4, #72]	; 0x48
  4056ec:	f8b4 0046 	ldrh.w	r0, [r4, #70]	; 0x46
  4056f0:	47b8      	blx	r7
  4056f2:	6028      	str	r0, [r5, #0]
    arg->time_ms = static_cast<float>(time_ms_int);
  4056f4:	4640      	mov	r0, r8
  4056f6:	4b12      	ldr	r3, [pc, #72]	; (405740 <_ZN7Stepper15moveInverseTimeEv+0x88>)
  4056f8:	4798      	blx	r3
  4056fa:	6068      	str	r0, [r5, #4]
    MotionItem *motion_item  = new MotionItem;
  4056fc:	200c      	movs	r0, #12
  4056fe:	47b0      	blx	r6
  405700:	a902      	add	r1, sp, #8
  405702:	f841 0d04 	str.w	r0, [r1, #-4]!
    motion_item->motion_task = &Stepper::moveInverseTimeWrapper;
  405706:	4b0f      	ldr	r3, [pc, #60]	; (405744 <_ZN7Stepper15moveInverseTimeEv+0x8c>)
  405708:	6003      	str	r3, [r0, #0]
  40570a:	2200      	movs	r2, #0
  40570c:	6042      	str	r2, [r0, #4]
    motion_item->arg         = arg;
  40570e:	6085      	str	r5, [r0, #8]
    if (xQueueSend(m_motion_queue_handle, &motion_item, 0) == pdTRUE)
  405710:	4613      	mov	r3, r2
  405712:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  405716:	4c0c      	ldr	r4, [pc, #48]	; (405748 <_ZN7Stepper15moveInverseTimeEv+0x90>)
  405718:	47a0      	blx	r4
  40571a:	2801      	cmp	r0, #1
  40571c:	d008      	beq.n	405730 <_ZN7Stepper15moveInverseTimeEv+0x78>
        delete motion_item; // free heap
  40571e:	210c      	movs	r1, #12
  405720:	9801      	ldr	r0, [sp, #4]
  405722:	4c0a      	ldr	r4, [pc, #40]	; (40574c <_ZN7Stepper15moveInverseTimeEv+0x94>)
  405724:	47a0      	blx	r4
        delete arg;
  405726:	2108      	movs	r1, #8
  405728:	4628      	mov	r0, r5
  40572a:	47a0      	blx	r4
        return PutQueueRes::Q_FULL;
  40572c:	2002      	movs	r0, #2
  40572e:	e7cd      	b.n	4056cc <_ZN7Stepper15moveInverseTimeEv+0x14>
        return PutQueueRes::Q_SUCCESS;
  405730:	2001      	movs	r0, #1
  405732:	e7cb      	b.n	4056cc <_ZN7Stepper15moveInverseTimeEv+0x14>
  405734:	00409589 	.word	0x00409589
  405738:	0040562d 	.word	0x0040562d
  40573c:	0040b2b9 	.word	0x0040b2b9
  405740:	0040bd31 	.word	0x0040bd31
  405744:	00405cf9 	.word	0x00405cf9
  405748:	00409209 	.word	0x00409209
  40574c:	0040b2b5 	.word	0x0040b2b5

00405750 <_ZN7Stepper11uintTofloatEmh>:
float Stepper::uintTofloat(uint32_t val, uint8_t sign) {
  405750:	b508      	push	{r3, lr}
    if (sign) {
  405752:	b929      	cbnz	r1, 405760 <_ZN7Stepper11uintTofloatEmh+0x10>
        f = static_cast<float>(val);
  405754:	4b04      	ldr	r3, [pc, #16]	; (405768 <_ZN7Stepper11uintTofloatEmh+0x18>)
  405756:	4798      	blx	r3
    return f / FLOAT_DIVISOR;
  405758:	4904      	ldr	r1, [pc, #16]	; (40576c <_ZN7Stepper11uintTofloatEmh+0x1c>)
  40575a:	4b05      	ldr	r3, [pc, #20]	; (405770 <_ZN7Stepper11uintTofloatEmh+0x20>)
  40575c:	4798      	blx	r3
}
  40575e:	bd08      	pop	{r3, pc}
        f                 = static_cast<float>(signedVal);
  405760:	4b04      	ldr	r3, [pc, #16]	; (405774 <_ZN7Stepper11uintTofloatEmh+0x24>)
  405762:	4798      	blx	r3
  405764:	e7f8      	b.n	405758 <_ZN7Stepper11uintTofloatEmh+0x8>
  405766:	bf00      	nop
  405768:	0040bd31 	.word	0x0040bd31
  40576c:	447a0000 	.word	0x447a0000
  405770:	0040bf49 	.word	0x0040bf49
  405774:	0040bd39 	.word	0x0040bd39

00405778 <_ZN7Stepper13moveVibrationEv>:
Stepper::PutQueueRes Stepper::moveVibration() {
  405778:	b570      	push	{r4, r5, r6, lr}
  40577a:	b082      	sub	sp, #8
  40577c:	4604      	mov	r4, r0
    if (uxQueueMessagesWaiting(m_result_queue_handle) != 0) return PutQueueRes::Q_RESULTS_PENDING;
  40577e:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
  405782:	4b1c      	ldr	r3, [pc, #112]	; (4057f4 <_ZN7Stepper13moveVibrationEv+0x7c>)
  405784:	4798      	blx	r3
  405786:	b110      	cbz	r0, 40578e <_ZN7Stepper13moveVibrationEv+0x16>
  405788:	2003      	movs	r0, #3
}
  40578a:	b002      	add	sp, #8
  40578c:	bd70      	pop	{r4, r5, r6, pc}
    _VibrationArgs *arg     = new _VibrationArgs;
  40578e:	2010      	movs	r0, #16
  405790:	4e19      	ldr	r6, [pc, #100]	; (4057f8 <_ZN7Stepper13moveVibrationEv+0x80>)
  405792:	47b0      	blx	r6
  405794:	4605      	mov	r5, r0
    arg->units              = combineWord(m_move_s.unit_high, m_move_s.unit_low);
  405796:	f8b4 1048 	ldrh.w	r1, [r4, #72]	; 0x48
  40579a:	f8b4 0046 	ldrh.w	r0, [r4, #70]	; 0x46
  40579e:	4b17      	ldr	r3, [pc, #92]	; (4057fc <_ZN7Stepper13moveVibrationEv+0x84>)
  4057a0:	4798      	blx	r3
  4057a2:	6028      	str	r0, [r5, #0]
    arg->iterations         = (uint32_t)m_move_s.vib_i;
  4057a4:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
  4057a8:	606b      	str	r3, [r5, #4]
    arg->diminishing_factor = uintTofloat(m_move_s.vib_dim_factor, 0);
  4057aa:	2100      	movs	r1, #0
  4057ac:	f8b4 0050 	ldrh.w	r0, [r4, #80]	; 0x50
  4057b0:	4b13      	ldr	r3, [pc, #76]	; (405800 <_ZN7Stepper13moveVibrationEv+0x88>)
  4057b2:	4798      	blx	r3
  4057b4:	60a8      	str	r0, [r5, #8]
    arg->loop               = m_move_s.vib_loop;
  4057b6:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
  4057ba:	732b      	strb	r3, [r5, #12]
    MotionItem *motion_item  = new MotionItem;
  4057bc:	200c      	movs	r0, #12
  4057be:	47b0      	blx	r6
  4057c0:	a902      	add	r1, sp, #8
  4057c2:	f841 0d04 	str.w	r0, [r1, #-4]!
    motion_item->motion_task = &Stepper::moveVibrationWrapper;
  4057c6:	4b0f      	ldr	r3, [pc, #60]	; (405804 <_ZN7Stepper13moveVibrationEv+0x8c>)
  4057c8:	6003      	str	r3, [r0, #0]
  4057ca:	2200      	movs	r2, #0
  4057cc:	6042      	str	r2, [r0, #4]
    motion_item->arg         = arg;
  4057ce:	6085      	str	r5, [r0, #8]
    if (xQueueSend(m_motion_queue_handle, &motion_item, 0) == pdTRUE)
  4057d0:	4613      	mov	r3, r2
  4057d2:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  4057d6:	4c0c      	ldr	r4, [pc, #48]	; (405808 <_ZN7Stepper13moveVibrationEv+0x90>)
  4057d8:	47a0      	blx	r4
  4057da:	2801      	cmp	r0, #1
  4057dc:	d008      	beq.n	4057f0 <_ZN7Stepper13moveVibrationEv+0x78>
        delete motion_item; // free heap
  4057de:	210c      	movs	r1, #12
  4057e0:	9801      	ldr	r0, [sp, #4]
  4057e2:	4c0a      	ldr	r4, [pc, #40]	; (40580c <_ZN7Stepper13moveVibrationEv+0x94>)
  4057e4:	47a0      	blx	r4
        delete arg;
  4057e6:	2110      	movs	r1, #16
  4057e8:	4628      	mov	r0, r5
  4057ea:	47a0      	blx	r4
        return PutQueueRes::Q_FULL;
  4057ec:	2002      	movs	r0, #2
  4057ee:	e7cc      	b.n	40578a <_ZN7Stepper13moveVibrationEv+0x12>
        return PutQueueRes::Q_SUCCESS;
  4057f0:	2001      	movs	r0, #1
  4057f2:	e7ca      	b.n	40578a <_ZN7Stepper13moveVibrationEv+0x12>
  4057f4:	00409589 	.word	0x00409589
  4057f8:	0040b2b9 	.word	0x0040b2b9
  4057fc:	0040562d 	.word	0x0040562d
  405800:	00405751 	.word	0x00405751
  405804:	00405f49 	.word	0x00405f49
  405808:	00409209 	.word	0x00409209
  40580c:	0040b2b5 	.word	0x0040b2b5

00405810 <_ZN7Stepper13execSetMotionEv>:
bool Stepper::execSetMotion() {
  405810:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405814:	b083      	sub	sp, #12
    if (!m_ctrl_init) return false;
  405816:	f890 50aa 	ldrb.w	r5, [r0, #170]	; 0xaa
  40581a:	b91d      	cbnz	r5, 405824 <_ZN7Stepper13execSetMotionEv+0x14>
}
  40581c:	4628      	mov	r0, r5
  40581e:	b003      	add	sp, #12
  405820:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405824:	4604      	mov	r4, r0
    conf &= setRampMode(m_ramp_s.ramp_mode, m_ramp_s.ramp_type);
  405826:	f890 2077 	ldrb.w	r2, [r0, #119]	; 0x77
  40582a:	f890 1076 	ldrb.w	r1, [r0, #118]	; 0x76
  40582e:	4b4e      	ldr	r3, [pc, #312]	; (405968 <_ZN7Stepper13execSetMotionEv+0x158>)
  405830:	4798      	blx	r3
  405832:	4605      	mov	r5, r0
    uint32_t max_speed   = combineWord(m_spd_s.max_h, m_spd_s.max_l);
  405834:	f8b4 107a 	ldrh.w	r1, [r4, #122]	; 0x7a
  405838:	f8b4 0078 	ldrh.w	r0, [r4, #120]	; 0x78
  40583c:	4e4b      	ldr	r6, [pc, #300]	; (40596c <_ZN7Stepper13execSetMotionEv+0x15c>)
  40583e:	47b0      	blx	r6
  405840:	4607      	mov	r7, r0
    uint32_t start_speed = combineWord(m_spd_s.start_h, m_spd_s.start_l);
  405842:	f8b4 107e 	ldrh.w	r1, [r4, #126]	; 0x7e
  405846:	f8b4 007c 	ldrh.w	r0, [r4, #124]	; 0x7c
  40584a:	47b0      	blx	r6
  40584c:	4680      	mov	r8, r0
    uint32_t stop_speed  = combineWord(m_spd_s.stop_h, m_spd_s.stop_l);
  40584e:	f8b4 1082 	ldrh.w	r1, [r4, #130]	; 0x82
  405852:	f8b4 0080 	ldrh.w	r0, [r4, #128]	; 0x80
  405856:	47b0      	blx	r6
  405858:	4681      	mov	r9, r0
    uint32_t break_speed = combineWord(m_spd_s.break_h, m_spd_s.break_l);
  40585a:	f8b4 1086 	ldrh.w	r1, [r4, #134]	; 0x86
  40585e:	f8b4 0084 	ldrh.w	r0, [r4, #132]	; 0x84
  405862:	47b0      	blx	r6
  405864:	4682      	mov	sl, r0
    float max_speed_f   = uintTofloat((max_speed), 1);
  405866:	2101      	movs	r1, #1
  405868:	4638      	mov	r0, r7
  40586a:	4e41      	ldr	r6, [pc, #260]	; (405970 <_ZN7Stepper13execSetMotionEv+0x160>)
  40586c:	47b0      	blx	r6
  40586e:	4607      	mov	r7, r0
    float start_speed_f = uintTofloat((start_speed), 1);
  405870:	2101      	movs	r1, #1
  405872:	4640      	mov	r0, r8
  405874:	47b0      	blx	r6
  405876:	4680      	mov	r8, r0
    float stop_speed_f  = uintTofloat((stop_speed), 1);
  405878:	2101      	movs	r1, #1
  40587a:	4648      	mov	r0, r9
  40587c:	47b0      	blx	r6
  40587e:	4681      	mov	r9, r0
    float break_speed_f = uintTofloat((break_speed), 1);
  405880:	2101      	movs	r1, #1
  405882:	4650      	mov	r0, sl
  405884:	47b0      	blx	r6
    conf &= setSpeeds(m_ramp_s.ramp_mode == TMC4361A::RampMode::VELOCITY_MODE ? 0 : max_speed_f, start_speed_f,
  405886:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
  40588a:	b903      	cbnz	r3, 40588e <_ZN7Stepper13execSetMotionEv+0x7e>
  40588c:	2700      	movs	r7, #0
  40588e:	9000      	str	r0, [sp, #0]
  405890:	464b      	mov	r3, r9
  405892:	4642      	mov	r2, r8
  405894:	4639      	mov	r1, r7
  405896:	4620      	mov	r0, r4
  405898:	4e36      	ldr	r6, [pc, #216]	; (405974 <_ZN7Stepper13execSetMotionEv+0x164>)
  40589a:	47b0      	blx	r6
  40589c:	4005      	ands	r5, r0
  40589e:	b2ed      	uxtb	r5, r5
    uint32_t max_accel   = combineWord(m_accel_s.max_accel_h, m_accel_s.max_accel_l);
  4058a0:	f8b4 108a 	ldrh.w	r1, [r4, #138]	; 0x8a
  4058a4:	f8b4 0088 	ldrh.w	r0, [r4, #136]	; 0x88
  4058a8:	4e30      	ldr	r6, [pc, #192]	; (40596c <_ZN7Stepper13execSetMotionEv+0x15c>)
  4058aa:	47b0      	blx	r6
  4058ac:	4607      	mov	r7, r0
    uint32_t max_decel   = combineWord(m_accel_s.max_decel_h, m_accel_s.max_decel_l);
  4058ae:	f8b4 108e 	ldrh.w	r1, [r4, #142]	; 0x8e
  4058b2:	f8b4 008c 	ldrh.w	r0, [r4, #140]	; 0x8c
  4058b6:	47b0      	blx	r6
  4058b8:	4681      	mov	r9, r0
    uint32_t start_accel = combineWord(m_accel_s.start_accel_h, m_accel_s.start_accel_l);
  4058ba:	f8b4 1092 	ldrh.w	r1, [r4, #146]	; 0x92
  4058be:	f8b4 0090 	ldrh.w	r0, [r4, #144]	; 0x90
  4058c2:	47b0      	blx	r6
  4058c4:	4682      	mov	sl, r0
    uint32_t final_decel = combineWord(m_accel_s.final_decel_h, m_accel_s.final_decel_l);
  4058c6:	f8b4 1096 	ldrh.w	r1, [r4, #150]	; 0x96
  4058ca:	f8b4 0094 	ldrh.w	r0, [r4, #148]	; 0x94
  4058ce:	47b0      	blx	r6
  4058d0:	4683      	mov	fp, r0
    float max_accel_f   = uintTofloat((max_accel), 0);
  4058d2:	2100      	movs	r1, #0
  4058d4:	4638      	mov	r0, r7
  4058d6:	4f26      	ldr	r7, [pc, #152]	; (405970 <_ZN7Stepper13execSetMotionEv+0x160>)
  4058d8:	47b8      	blx	r7
  4058da:	4680      	mov	r8, r0
    float max_decel_f   = uintTofloat((max_decel), 0);
  4058dc:	2100      	movs	r1, #0
  4058de:	4648      	mov	r0, r9
  4058e0:	47b8      	blx	r7
  4058e2:	4681      	mov	r9, r0
    float start_accel_f = uintTofloat((start_accel), 0);
  4058e4:	2100      	movs	r1, #0
  4058e6:	4650      	mov	r0, sl
  4058e8:	47b8      	blx	r7
  4058ea:	4682      	mov	sl, r0
    float final_decel_f = uintTofloat((final_decel), 0);
  4058ec:	2100      	movs	r1, #0
  4058ee:	4658      	mov	r0, fp
  4058f0:	47b8      	blx	r7
    conf &= setAccelerations(max_accel_f, max_decel_f, start_accel_f, final_decel_f);
  4058f2:	9000      	str	r0, [sp, #0]
  4058f4:	4653      	mov	r3, sl
  4058f6:	464a      	mov	r2, r9
  4058f8:	4641      	mov	r1, r8
  4058fa:	4620      	mov	r0, r4
  4058fc:	f8df 807c 	ldr.w	r8, [pc, #124]	; 40597c <_ZN7Stepper13execSetMotionEv+0x16c>
  405900:	47c0      	blx	r8
  405902:	4005      	ands	r5, r0
    uint32_t bow1 = combineWord(m_bow_s.bow1_h, m_bow_s.bow1_l);
  405904:	f8b4 109a 	ldrh.w	r1, [r4, #154]	; 0x9a
  405908:	f8b4 0098 	ldrh.w	r0, [r4, #152]	; 0x98
  40590c:	47b0      	blx	r6
  40590e:	4683      	mov	fp, r0
    uint32_t bow2 = combineWord(m_bow_s.bow2_h, m_bow_s.bow2_l);
  405910:	f8b4 109e 	ldrh.w	r1, [r4, #158]	; 0x9e
  405914:	f8b4 009c 	ldrh.w	r0, [r4, #156]	; 0x9c
  405918:	47b0      	blx	r6
  40591a:	4680      	mov	r8, r0
    uint32_t bow3 = combineWord(m_bow_s.bow3_h, m_bow_s.bow3_l);
  40591c:	f8b4 10a2 	ldrh.w	r1, [r4, #162]	; 0xa2
  405920:	f8b4 00a0 	ldrh.w	r0, [r4, #160]	; 0xa0
  405924:	47b0      	blx	r6
  405926:	4681      	mov	r9, r0
    uint32_t bow4 = combineWord(m_bow_s.bow4_h, m_bow_s.bow4_l);
  405928:	f8b4 10a6 	ldrh.w	r1, [r4, #166]	; 0xa6
  40592c:	f8b4 00a4 	ldrh.w	r0, [r4, #164]	; 0xa4
  405930:	47b0      	blx	r6
  405932:	4682      	mov	sl, r0
    float bow1_f = uintTofloat((bow1), 0);
  405934:	2100      	movs	r1, #0
  405936:	4658      	mov	r0, fp
  405938:	47b8      	blx	r7
  40593a:	4606      	mov	r6, r0
    float bow2_f = uintTofloat((bow2), 0);
  40593c:	2100      	movs	r1, #0
  40593e:	4640      	mov	r0, r8
  405940:	47b8      	blx	r7
  405942:	4680      	mov	r8, r0
    float bow3_f = uintTofloat((bow3), 0);
  405944:	2100      	movs	r1, #0
  405946:	4648      	mov	r0, r9
  405948:	47b8      	blx	r7
  40594a:	4681      	mov	r9, r0
    float bow4_f = uintTofloat((bow4), 0);
  40594c:	2100      	movs	r1, #0
  40594e:	4650      	mov	r0, sl
  405950:	47b8      	blx	r7
    conf &= setBowValues(bow1_f, bow2_f, bow3_f, bow4_f);
  405952:	9000      	str	r0, [sp, #0]
  405954:	464b      	mov	r3, r9
  405956:	4642      	mov	r2, r8
  405958:	4631      	mov	r1, r6
  40595a:	4620      	mov	r0, r4
  40595c:	4e06      	ldr	r6, [pc, #24]	; (405978 <_ZN7Stepper13execSetMotionEv+0x168>)
  40595e:	47b0      	blx	r6
  405960:	4005      	ands	r5, r0
    m_motion_conf = conf;
  405962:	f884 50ab 	strb.w	r5, [r4, #171]	; 0xab
    return conf;
  405966:	e759      	b.n	40581c <_ZN7Stepper13execSetMotionEv+0xc>
  405968:	00406b31 	.word	0x00406b31
  40596c:	0040562d 	.word	0x0040562d
  405970:	00405751 	.word	0x00405751
  405974:	00406b41 	.word	0x00406b41
  405978:	00406c45 	.word	0x00406c45
  40597c:	00406bb9 	.word	0x00406bb9

00405980 <_ZN7Stepper20execSetMotionWrapperEPv>:
uint32_t Stepper::execSetMotionWrapper(void *args) {
  405980:	b538      	push	{r3, r4, r5, lr}
    MotionItem *motion_item     = *motion_item_ptr;
  405982:	680d      	ldr	r5, [r1, #0]
    bool exec = execSetMotion();
  405984:	4b04      	ldr	r3, [pc, #16]	; (405998 <_ZN7Stepper20execSetMotionWrapperEPv+0x18>)
  405986:	4798      	blx	r3
  405988:	4604      	mov	r4, r0
    delete motion_item; // free heap
  40598a:	210c      	movs	r1, #12
  40598c:	4628      	mov	r0, r5
  40598e:	4b03      	ldr	r3, [pc, #12]	; (40599c <_ZN7Stepper20execSetMotionWrapperEPv+0x1c>)
  405990:	4798      	blx	r3
}
  405992:	4620      	mov	r0, r4
  405994:	bd38      	pop	{r3, r4, r5, pc}
  405996:	bf00      	nop
  405998:	00405811 	.word	0x00405811
  40599c:	0040b2b5 	.word	0x0040b2b5

004059a0 <_ZN7Stepper11unitToPulseEl>:
int32_t Stepper::unitToPulse(int32_t unit) {
  4059a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4059a4:	4605      	mov	r5, r0
  4059a6:	460e      	mov	r6, r1
    float mstep_per_fs = static_cast<float>(m_drv_s.mstep_per_fs);
  4059a8:	4c13      	ldr	r4, [pc, #76]	; (4059f8 <_ZN7Stepper11unitToPulseEl+0x58>)
  4059aa:	8800      	ldrh	r0, [r0, #0]
  4059ac:	47a0      	blx	r4
  4059ae:	4680      	mov	r8, r0
    float unit_per_rev = static_cast<float>(m_pos_s.unit_per_rev);
  4059b0:	f8b5 0074 	ldrh.w	r0, [r5, #116]	; 0x74
  4059b4:	47a0      	blx	r4
  4059b6:	4681      	mov	r9, r0
    float fs_per_rev   = static_cast<float>(m_drv_s.fs_per_rev);
  4059b8:	8868      	ldrh	r0, [r5, #2]
  4059ba:	47a0      	blx	r4
  4059bc:	4605      	mov	r5, r0
    float f_unit       = static_cast<float>(unit);
  4059be:	4630      	mov	r0, r6
  4059c0:	4b0e      	ldr	r3, [pc, #56]	; (4059fc <_ZN7Stepper11unitToPulseEl+0x5c>)
  4059c2:	4798      	blx	r3
  4059c4:	4607      	mov	r7, r0
    float pulse = f_unit * (mstep_per_fs / unit_per_rev) * fs_per_rev;
  4059c6:	4649      	mov	r1, r9
  4059c8:	4640      	mov	r0, r8
  4059ca:	4b0d      	ldr	r3, [pc, #52]	; (405a00 <_ZN7Stepper11unitToPulseEl+0x60>)
  4059cc:	4798      	blx	r3
  4059ce:	4c0d      	ldr	r4, [pc, #52]	; (405a04 <_ZN7Stepper11unitToPulseEl+0x64>)
  4059d0:	4601      	mov	r1, r0
  4059d2:	4638      	mov	r0, r7
  4059d4:	47a0      	blx	r4
  4059d6:	4601      	mov	r1, r0
  4059d8:	4628      	mov	r0, r5
  4059da:	47a0      	blx	r4
  4059dc:	4601      	mov	r1, r0
    return static_cast<int32_t>(pulse + (is_negative ? -0.5f : 0.5f)); // round
  4059de:	2e00      	cmp	r6, #0
  4059e0:	db07      	blt.n	4059f2 <_ZN7Stepper11unitToPulseEl+0x52>
  4059e2:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
  4059e6:	4b08      	ldr	r3, [pc, #32]	; (405a08 <_ZN7Stepper11unitToPulseEl+0x68>)
  4059e8:	4798      	blx	r3
  4059ea:	4b08      	ldr	r3, [pc, #32]	; (405a0c <_ZN7Stepper11unitToPulseEl+0x6c>)
  4059ec:	4798      	blx	r3
}
  4059ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return static_cast<int32_t>(pulse + (is_negative ? -0.5f : 0.5f)); // round
  4059f2:	f04f 403f 	mov.w	r0, #3204448256	; 0xbf000000
  4059f6:	e7f6      	b.n	4059e6 <_ZN7Stepper11unitToPulseEl+0x46>
  4059f8:	0040bd31 	.word	0x0040bd31
  4059fc:	0040bd39 	.word	0x0040bd39
  405a00:	0040bf49 	.word	0x0040bf49
  405a04:	0040bde1 	.word	0x0040bde1
  405a08:	0040bbd1 	.word	0x0040bbd1
  405a0c:	0040c16d 	.word	0x0040c16d

00405a10 <_ZN7Stepper22correctRotationalPulseEl>:
int32_t Stepper::correctRotationalPulse(int32_t pulse) {
  405a10:	b570      	push	{r4, r5, r6, lr}
  405a12:	460d      	mov	r5, r1
    int32_t correction_pulse    = m_move_s.fs_per_correction * m_drv_s.mstep_per_fs;
  405a14:	f890 4052 	ldrb.w	r4, [r0, #82]	; 0x52
  405a18:	8800      	ldrh	r0, [r0, #0]
  405a1a:	fb04 f400 	mul.w	r4, r4, r0
    int32_t correction_thresh_l = (int32_t)((float)correction_pulse * 0.01f); // 1% dev
  405a1e:	4620      	mov	r0, r4
  405a20:	4b0e      	ldr	r3, [pc, #56]	; (405a5c <_ZN7Stepper22correctRotationalPulseEl+0x4c>)
  405a22:	4798      	blx	r3
  405a24:	490e      	ldr	r1, [pc, #56]	; (405a60 <_ZN7Stepper22correctRotationalPulseEl+0x50>)
  405a26:	4b0f      	ldr	r3, [pc, #60]	; (405a64 <_ZN7Stepper22correctRotationalPulseEl+0x54>)
  405a28:	4798      	blx	r3
  405a2a:	4b0f      	ldr	r3, [pc, #60]	; (405a68 <_ZN7Stepper22correctRotationalPulseEl+0x58>)
  405a2c:	4798      	blx	r3
    int32_t correction_thresh_h = correction_pulse - correction_thresh_l;
  405a2e:	1a26      	subs	r6, r4, r0
    int32_t remainder = pulse % correction_pulse;
  405a30:	fb95 f2f4 	sdiv	r2, r5, r4
  405a34:	fb04 5312 	mls	r3, r4, r2, r5
    int32_t quotient  = pulse / correction_pulse;
  405a38:	4611      	mov	r1, r2
    if (remainder < 0) {
  405a3a:	2b00      	cmp	r3, #0
  405a3c:	db06      	blt.n	405a4c <_ZN7Stepper22correctRotationalPulseEl+0x3c>
    if (remainder < correction_thresh_l) {
  405a3e:	4283      	cmp	r3, r0
  405a40:	db07      	blt.n	405a52 <_ZN7Stepper22correctRotationalPulseEl+0x42>
    if (remainder > correction_thresh_h) {
  405a42:	42b3      	cmp	r3, r6
  405a44:	dd08      	ble.n	405a58 <_ZN7Stepper22correctRotationalPulseEl+0x48>
        return (quotient + 1) * correction_pulse; // snap up
  405a46:	fb01 4004 	mla	r0, r1, r4, r4
  405a4a:	bd70      	pop	{r4, r5, r6, pc}
        remainder += correction_pulse;
  405a4c:	4423      	add	r3, r4
        quotient -= 1;
  405a4e:	1e51      	subs	r1, r2, #1
  405a50:	e7f5      	b.n	405a3e <_ZN7Stepper22correctRotationalPulseEl+0x2e>
        return quotient * correction_pulse; // snap down
  405a52:	fb04 f001 	mul.w	r0, r4, r1
  405a56:	bd70      	pop	{r4, r5, r6, pc}
    return pulse;
  405a58:	4628      	mov	r0, r5
}
  405a5a:	bd70      	pop	{r4, r5, r6, pc}
  405a5c:	0040bd39 	.word	0x0040bd39
  405a60:	3c23d70a 	.word	0x3c23d70a
  405a64:	0040bde1 	.word	0x0040bde1
  405a68:	0040c16d 	.word	0x0040c16d

00405a6c <_ZN7Stepper18computeTargetPulseEl>:
int32_t Stepper::computeTargetPulse(int32_t pulses) {
  405a6c:	b538      	push	{r3, r4, r5, lr}
  405a6e:	460c      	mov	r4, r1
    if (m_pos_s.pos_mode == PositioningMode::PM_ABSOLUTE) {
  405a70:	f890 3072 	ldrb.w	r3, [r0, #114]	; 0x72
  405a74:	2b01      	cmp	r3, #1
  405a76:	d029      	beq.n	405acc <_ZN7Stepper18computeTargetPulseEl+0x60>
  405a78:	4605      	mov	r5, r0
        int32_t pos_ref = (m_pos_s.follow_mode == FollowMode::ENCODER) ? getEncoderPosition() : getInternalPosition();
  405a7a:	f890 3073 	ldrb.w	r3, [r0, #115]	; 0x73
  405a7e:	2b01      	cmp	r3, #1
  405a80:	d012      	beq.n	405aa8 <_ZN7Stepper18computeTargetPulseEl+0x3c>
  405a82:	4b13      	ldr	r3, [pc, #76]	; (405ad0 <_ZN7Stepper18computeTargetPulseEl+0x64>)
  405a84:	4798      	blx	r3
            (pulses > 0 && pos_ref > INT32_MAX - pulses) || (pulses < 0 && pos_ref < INT32_MIN - pulses);
  405a86:	2c00      	cmp	r4, #0
  405a88:	dd04      	ble.n	405a94 <_ZN7Stepper18computeTargetPulseEl+0x28>
  405a8a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
  405a8e:	1b1b      	subs	r3, r3, r4
  405a90:	4298      	cmp	r0, r3
  405a92:	dc12      	bgt.n	405aba <_ZN7Stepper18computeTargetPulseEl+0x4e>
  405a94:	2c00      	cmp	r4, #0
  405a96:	db0a      	blt.n	405aae <_ZN7Stepper18computeTargetPulseEl+0x42>
  405a98:	2300      	movs	r3, #0
        if (will_overflow) {
  405a9a:	b993      	cbnz	r3, 405ac2 <_ZN7Stepper18computeTargetPulseEl+0x56>
            target_pulse = pos_ref + pulses;
  405a9c:	4404      	add	r4, r0
        target_pulse = correctRotationalPulse(target_pulse);
  405a9e:	4621      	mov	r1, r4
  405aa0:	4628      	mov	r0, r5
  405aa2:	4b0c      	ldr	r3, [pc, #48]	; (405ad4 <_ZN7Stepper18computeTargetPulseEl+0x68>)
  405aa4:	4798      	blx	r3
  405aa6:	bd38      	pop	{r3, r4, r5, pc}
        int32_t pos_ref = (m_pos_s.follow_mode == FollowMode::ENCODER) ? getEncoderPosition() : getInternalPosition();
  405aa8:	4b0b      	ldr	r3, [pc, #44]	; (405ad8 <_ZN7Stepper18computeTargetPulseEl+0x6c>)
  405aaa:	4798      	blx	r3
  405aac:	e7eb      	b.n	405a86 <_ZN7Stepper18computeTargetPulseEl+0x1a>
            (pulses > 0 && pos_ref > INT32_MAX - pulses) || (pulses < 0 && pos_ref < INT32_MIN - pulses);
  405aae:	f1c4 4300 	rsb	r3, r4, #2147483648	; 0x80000000
  405ab2:	4298      	cmp	r0, r3
  405ab4:	db03      	blt.n	405abe <_ZN7Stepper18computeTargetPulseEl+0x52>
  405ab6:	2300      	movs	r3, #0
  405ab8:	e7ef      	b.n	405a9a <_ZN7Stepper18computeTargetPulseEl+0x2e>
  405aba:	2301      	movs	r3, #1
  405abc:	e7ed      	b.n	405a9a <_ZN7Stepper18computeTargetPulseEl+0x2e>
  405abe:	2301      	movs	r3, #1
  405ac0:	e7eb      	b.n	405a9a <_ZN7Stepper18computeTargetPulseEl+0x2e>
            setPosition(0);
  405ac2:	2100      	movs	r1, #0
  405ac4:	4628      	mov	r0, r5
  405ac6:	4b05      	ldr	r3, [pc, #20]	; (405adc <_ZN7Stepper18computeTargetPulseEl+0x70>)
  405ac8:	4798      	blx	r3
  405aca:	e7e8      	b.n	405a9e <_ZN7Stepper18computeTargetPulseEl+0x32>
        target_pulse = pulses;
  405acc:	4608      	mov	r0, r1
}
  405ace:	bd38      	pop	{r3, r4, r5, pc}
  405ad0:	00406915 	.word	0x00406915
  405ad4:	00405a11 	.word	0x00405a11
  405ad8:	00406961 	.word	0x00406961
  405adc:	00406ccd 	.word	0x00406ccd

00405ae0 <_ZN7Stepper8execMoveEl>:
    if (!m_ctrl_init) return ExecCode::E_CTRL_NOT_INIT;
  405ae0:	f890 30aa 	ldrb.w	r3, [r0, #170]	; 0xaa
  405ae4:	b90b      	cbnz	r3, 405aea <_ZN7Stepper8execMoveEl+0xa>
  405ae6:	2003      	movs	r0, #3
  405ae8:	4770      	bx	lr
    if (!m_motion_conf) return ExecCode::E_MOTION_NOT_INIT;
  405aea:	f890 30ab 	ldrb.w	r3, [r0, #171]	; 0xab
  405aee:	b90b      	cbnz	r3, 405af4 <_ZN7Stepper8execMoveEl+0x14>
  405af0:	2004      	movs	r0, #4
  405af2:	4770      	bx	lr
Stepper::ExecCode Stepper::execMove(int32_t units) {
  405af4:	b570      	push	{r4, r5, r6, lr}
  405af6:	b082      	sub	sp, #8
  405af8:	460d      	mov	r5, r1
  405afa:	4604      	mov	r4, r0
    if (isFrozen()) return ExecCode::E_IS_FROZEN;
  405afc:	4b23      	ldr	r3, [pc, #140]	; (405b8c <_ZN7Stepper8execMoveEl+0xac>)
  405afe:	4798      	blx	r3
  405b00:	4606      	mov	r6, r0
  405b02:	b110      	cbz	r0, 405b0a <_ZN7Stepper8execMoveEl+0x2a>
  405b04:	2005      	movs	r0, #5
}
  405b06:	b002      	add	sp, #8
  405b08:	bd70      	pop	{r4, r5, r6, pc}
    enableDriver();
  405b0a:	4620      	mov	r0, r4
  405b0c:	4b20      	ldr	r3, [pc, #128]	; (405b90 <_ZN7Stepper8execMoveEl+0xb0>)
  405b0e:	4798      	blx	r3
    if (m_ramp_s.ramp_mode == TMC4361A::RampMode::POSITIONING_MODE) {
  405b10:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
  405b14:	2b04      	cmp	r3, #4
  405b16:	d00e      	beq.n	405b36 <_ZN7Stepper8execMoveEl+0x56>
        success &= setSpeeds((float)units);
  405b18:	2600      	movs	r6, #0
  405b1a:	4628      	mov	r0, r5
  405b1c:	4b1d      	ldr	r3, [pc, #116]	; (405b94 <_ZN7Stepper8execMoveEl+0xb4>)
  405b1e:	4798      	blx	r3
  405b20:	9600      	str	r6, [sp, #0]
  405b22:	4633      	mov	r3, r6
  405b24:	4632      	mov	r2, r6
  405b26:	4601      	mov	r1, r0
  405b28:	4620      	mov	r0, r4
  405b2a:	4d1b      	ldr	r5, [pc, #108]	; (405b98 <_ZN7Stepper8execMoveEl+0xb8>)
  405b2c:	47a8      	blx	r5
  405b2e:	4605      	mov	r5, r0
    if (!success) return ExecCode::E_WRITE_FAIL;
  405b30:	bb15      	cbnz	r5, 405b78 <_ZN7Stepper8execMoveEl+0x98>
  405b32:	2002      	movs	r0, #2
  405b34:	e7e7      	b.n	405b06 <_ZN7Stepper8execMoveEl+0x26>
        int32_t pulses = unitToPulse(units);
  405b36:	4629      	mov	r1, r5
  405b38:	4620      	mov	r0, r4
  405b3a:	4b18      	ldr	r3, [pc, #96]	; (405b9c <_ZN7Stepper8execMoveEl+0xbc>)
  405b3c:	4798      	blx	r3
  405b3e:	4605      	mov	r5, r0
        if (!m_move_s.allow_write_motion_when_busy && isRunning()) return ExecCode::E_IS_BUSY;
  405b40:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
  405b44:	b113      	cbz	r3, 405b4c <_ZN7Stepper8execMoveEl+0x6c>
  405b46:	b136      	cbz	r6, 405b56 <_ZN7Stepper8execMoveEl+0x76>
  405b48:	2006      	movs	r0, #6
  405b4a:	e7dc      	b.n	405b06 <_ZN7Stepper8execMoveEl+0x26>
  405b4c:	4620      	mov	r0, r4
  405b4e:	4b14      	ldr	r3, [pc, #80]	; (405ba0 <_ZN7Stepper8execMoveEl+0xc0>)
  405b50:	4798      	blx	r3
  405b52:	4606      	mov	r6, r0
  405b54:	e7f7      	b.n	405b46 <_ZN7Stepper8execMoveEl+0x66>
        int32_t target_pulse = computeTargetPulse(pulses);
  405b56:	4629      	mov	r1, r5
  405b58:	4620      	mov	r0, r4
  405b5a:	4b12      	ldr	r3, [pc, #72]	; (405ba4 <_ZN7Stepper8execMoveEl+0xc4>)
  405b5c:	4798      	blx	r3
        success &= setTargetPosition(target_pulse);
  405b5e:	4601      	mov	r1, r0
  405b60:	4620      	mov	r0, r4
  405b62:	4b11      	ldr	r3, [pc, #68]	; (405ba8 <_ZN7Stepper8execMoveEl+0xc8>)
  405b64:	4798      	blx	r3
  405b66:	4605      	mov	r5, r0
        if (!m_move_s.allow_write_motion_when_busy) waitCompleteRun();
  405b68:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
  405b6c:	2b00      	cmp	r3, #0
  405b6e:	d1df      	bne.n	405b30 <_ZN7Stepper8execMoveEl+0x50>
  405b70:	4620      	mov	r0, r4
  405b72:	4b0e      	ldr	r3, [pc, #56]	; (405bac <_ZN7Stepper8execMoveEl+0xcc>)
  405b74:	4798      	blx	r3
  405b76:	e7db      	b.n	405b30 <_ZN7Stepper8execMoveEl+0x50>
    if (m_move_s.reset_motion_conf_after_each_move) m_motion_conf = false;
  405b78:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
  405b7c:	b123      	cbz	r3, 405b88 <_ZN7Stepper8execMoveEl+0xa8>
  405b7e:	2300      	movs	r3, #0
  405b80:	f884 30ab 	strb.w	r3, [r4, #171]	; 0xab
    return ExecCode::E_SUCCESS;
  405b84:	2001      	movs	r0, #1
  405b86:	e7be      	b.n	405b06 <_ZN7Stepper8execMoveEl+0x26>
  405b88:	2001      	movs	r0, #1
  405b8a:	e7bc      	b.n	405b06 <_ZN7Stepper8execMoveEl+0x26>
  405b8c:	004063eb 	.word	0x004063eb
  405b90:	0040643d 	.word	0x0040643d
  405b94:	0040bd39 	.word	0x0040bd39
  405b98:	00406b41 	.word	0x00406b41
  405b9c:	004059a1 	.word	0x004059a1
  405ba0:	004063e5 	.word	0x004063e5
  405ba4:	00405a6d 	.word	0x00405a6d
  405ba8:	00406cad 	.word	0x00406cad
  405bac:	00405381 	.word	0x00405381

00405bb0 <_ZN7Stepper11moveWrapperEPv>:
uint32_t Stepper::moveWrapper(void *args) {
  405bb0:	b570      	push	{r4, r5, r6, lr}
    MotionItem *motion_item     = *motion_item_ptr;
  405bb2:	680c      	ldr	r4, [r1, #0]
    int32_t    *units           = static_cast<int32_t *>(motion_item->arg);
  405bb4:	68a5      	ldr	r5, [r4, #8]
    ExecCode exec_code = execMove(*units);
  405bb6:	6829      	ldr	r1, [r5, #0]
  405bb8:	4b05      	ldr	r3, [pc, #20]	; (405bd0 <_ZN7Stepper11moveWrapperEPv+0x20>)
  405bba:	4798      	blx	r3
  405bbc:	4606      	mov	r6, r0
    delete motion_item; // free heap
  405bbe:	210c      	movs	r1, #12
  405bc0:	4620      	mov	r0, r4
  405bc2:	4c04      	ldr	r4, [pc, #16]	; (405bd4 <_ZN7Stepper11moveWrapperEPv+0x24>)
  405bc4:	47a0      	blx	r4
    delete units;
  405bc6:	2104      	movs	r1, #4
  405bc8:	4628      	mov	r0, r5
  405bca:	47a0      	blx	r4
}
  405bcc:	4630      	mov	r0, r6
  405bce:	bd70      	pop	{r4, r5, r6, pc}
  405bd0:	00405ae1 	.word	0x00405ae1
  405bd4:	0040b2b5 	.word	0x0040b2b5

00405bd8 <_ZN7Stepper19execMoveInverseTimeElf>:
Stepper::ExecCode Stepper::execMoveInverseTime(int32_t units, float time_ms) {
  405bd8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if (!m_ctrl_init) return ExecCode::E_CTRL_NOT_INIT;
  405bdc:	f890 30aa 	ldrb.w	r3, [r0, #170]	; 0xaa
  405be0:	b913      	cbnz	r3, 405be8 <_ZN7Stepper19execMoveInverseTimeElf+0x10>
  405be2:	2003      	movs	r0, #3
  405be4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  405be8:	4616      	mov	r6, r2
  405bea:	460d      	mov	r5, r1
  405bec:	4604      	mov	r4, r0
    if (isFrozen()) return ExecCode::E_IS_FROZEN;
  405bee:	4b31      	ldr	r3, [pc, #196]	; (405cb4 <_ZN7Stepper19execMoveInverseTimeElf+0xdc>)
  405bf0:	4798      	blx	r3
  405bf2:	b110      	cbz	r0, 405bfa <_ZN7Stepper19execMoveInverseTimeElf+0x22>
  405bf4:	2005      	movs	r0, #5
  405bf6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (isRunning()) return ExecCode::E_IS_BUSY;
  405bfa:	4620      	mov	r0, r4
  405bfc:	4b2e      	ldr	r3, [pc, #184]	; (405cb8 <_ZN7Stepper19execMoveInverseTimeElf+0xe0>)
  405bfe:	4798      	blx	r3
  405c00:	b110      	cbz	r0, 405c08 <_ZN7Stepper19execMoveInverseTimeElf+0x30>
  405c02:	2006      	movs	r0, #6
  405c04:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (m_ramp_s.ramp_mode != TMC4361A::RampMode::POSITIONING_MODE) return ExecCode::E_BAD_SETTINGS;
  405c08:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
  405c0c:	2b04      	cmp	r3, #4
  405c0e:	d002      	beq.n	405c16 <_ZN7Stepper19execMoveInverseTimeElf+0x3e>
  405c10:	2007      	movs	r0, #7
  405c12:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    enableDriver();
  405c16:	4620      	mov	r0, r4
  405c18:	4b28      	ldr	r3, [pc, #160]	; (405cbc <_ZN7Stepper19execMoveInverseTimeElf+0xe4>)
  405c1a:	4798      	blx	r3
    int32_t pulses        = unitToPulse(units);
  405c1c:	4629      	mov	r1, r5
  405c1e:	4620      	mov	r0, r4
  405c20:	4b27      	ldr	r3, [pc, #156]	; (405cc0 <_ZN7Stepper19execMoveInverseTimeElf+0xe8>)
  405c22:	4798      	blx	r3
    int32_t target_pulse  = computeTargetPulse(pulses);
  405c24:	4601      	mov	r1, r0
  405c26:	4620      	mov	r0, r4
  405c28:	4b26      	ldr	r3, [pc, #152]	; (405cc4 <_ZN7Stepper19execMoveInverseTimeElf+0xec>)
  405c2a:	4798      	blx	r3
  405c2c:	4680      	mov	r8, r0
    int32_t current_pulse = (m_pos_s.follow_mode == FollowMode::ENCODER) ? getEncoderPosition() : getInternalPosition();
  405c2e:	f894 3073 	ldrb.w	r3, [r4, #115]	; 0x73
  405c32:	2b01      	cmp	r3, #1
  405c34:	d033      	beq.n	405c9e <_ZN7Stepper19execMoveInverseTimeElf+0xc6>
  405c36:	4620      	mov	r0, r4
  405c38:	4b23      	ldr	r3, [pc, #140]	; (405cc8 <_ZN7Stepper19execMoveInverseTimeElf+0xf0>)
  405c3a:	4798      	blx	r3
    uint32_t delta_pulse       = abs(target_pulse - current_pulse);
  405c3c:	eba8 0000 	sub.w	r0, r8, r0
  using ::wctomb;
#endif // _GLIBCXX_USE_WCHAR_T

#ifndef __CORRECT_ISO_CPP_STDLIB_H_PROTO
  inline long
  abs(long __i) { return __builtin_labs(__i); }
  405c40:	ea80 75e0 	eor.w	r5, r0, r0, asr #31
  405c44:	eba5 75e0 	sub.w	r5, r5, r0, asr #31
    float    time_s_f          = (time_ms / 1000.0f); // total time in seconds
  405c48:	4f20      	ldr	r7, [pc, #128]	; (405ccc <_ZN7Stepper19execMoveInverseTimeElf+0xf4>)
  405c4a:	4921      	ldr	r1, [pc, #132]	; (405cd0 <_ZN7Stepper19execMoveInverseTimeElf+0xf8>)
  405c4c:	4630      	mov	r0, r6
  405c4e:	47b8      	blx	r7
    float    time_s_f_adjusted = time_s_f * magic_number;
  405c50:	4920      	ldr	r1, [pc, #128]	; (405cd4 <_ZN7Stepper19execMoveInverseTimeElf+0xfc>)
  405c52:	4b21      	ldr	r3, [pc, #132]	; (405cd8 <_ZN7Stepper19execMoveInverseTimeElf+0x100>)
  405c54:	4798      	blx	r3
  405c56:	4606      	mov	r6, r0
    float vel_f = 2.0f * static_cast<float>(delta_pulse) / time_s_f_adjusted;
  405c58:	4628      	mov	r0, r5
  405c5a:	4b20      	ldr	r3, [pc, #128]	; (405cdc <_ZN7Stepper19execMoveInverseTimeElf+0x104>)
  405c5c:	4798      	blx	r3
  405c5e:	4d20      	ldr	r5, [pc, #128]	; (405ce0 <_ZN7Stepper19execMoveInverseTimeElf+0x108>)
  405c60:	4601      	mov	r1, r0
  405c62:	47a8      	blx	r5
  405c64:	4631      	mov	r1, r6
  405c66:	47b8      	blx	r7
    float vel_f_scaled = spdToRpm(vel_f);
  405c68:	4601      	mov	r1, r0
  405c6a:	4620      	mov	r0, r4
  405c6c:	4b1d      	ldr	r3, [pc, #116]	; (405ce4 <_ZN7Stepper19execMoveInverseTimeElf+0x10c>)
  405c6e:	4798      	blx	r3
  405c70:	4681      	mov	r9, r0
    float acel_f_scaled = 2.0f * vel_f_scaled / time_s_f_adjusted;
  405c72:	4601      	mov	r1, r0
  405c74:	47a8      	blx	r5
  405c76:	4631      	mov	r1, r6
  405c78:	47b8      	blx	r7
    m_motion_conf = false;
  405c7a:	2300      	movs	r3, #0
  405c7c:	f884 30ab 	strb.w	r3, [r4, #171]	; 0xab
    success &= setMotionInverseTime(vel_f_scaled, acel_f_scaled);
  405c80:	4602      	mov	r2, r0
  405c82:	4649      	mov	r1, r9
  405c84:	4620      	mov	r0, r4
  405c86:	4b18      	ldr	r3, [pc, #96]	; (405ce8 <_ZN7Stepper19execMoveInverseTimeElf+0x110>)
  405c88:	4798      	blx	r3
  405c8a:	4605      	mov	r5, r0
    success &= setTargetPosition(static_cast<uint32_t>(target_pulse));
  405c8c:	4641      	mov	r1, r8
  405c8e:	4620      	mov	r0, r4
  405c90:	4b16      	ldr	r3, [pc, #88]	; (405cec <_ZN7Stepper19execMoveInverseTimeElf+0x114>)
  405c92:	4798      	blx	r3
    if (!success) return ExecCode::E_WRITE_FAIL;
  405c94:	b105      	cbz	r5, 405c98 <_ZN7Stepper19execMoveInverseTimeElf+0xc0>
  405c96:	b930      	cbnz	r0, 405ca6 <_ZN7Stepper19execMoveInverseTimeElf+0xce>
  405c98:	2002      	movs	r0, #2
}
  405c9a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    int32_t current_pulse = (m_pos_s.follow_mode == FollowMode::ENCODER) ? getEncoderPosition() : getInternalPosition();
  405c9e:	4620      	mov	r0, r4
  405ca0:	4b13      	ldr	r3, [pc, #76]	; (405cf0 <_ZN7Stepper19execMoveInverseTimeElf+0x118>)
  405ca2:	4798      	blx	r3
  405ca4:	e7ca      	b.n	405c3c <_ZN7Stepper19execMoveInverseTimeElf+0x64>
    waitCompleteRun();
  405ca6:	4620      	mov	r0, r4
  405ca8:	4b12      	ldr	r3, [pc, #72]	; (405cf4 <_ZN7Stepper19execMoveInverseTimeElf+0x11c>)
  405caa:	4798      	blx	r3
    return ExecCode::E_SUCCESS;
  405cac:	2001      	movs	r0, #1
  405cae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  405cb2:	bf00      	nop
  405cb4:	004063eb 	.word	0x004063eb
  405cb8:	004063e5 	.word	0x004063e5
  405cbc:	0040643d 	.word	0x0040643d
  405cc0:	004059a1 	.word	0x004059a1
  405cc4:	00405a6d 	.word	0x00405a6d
  405cc8:	00406915 	.word	0x00406915
  405ccc:	0040bf49 	.word	0x0040bf49
  405cd0:	447a0000 	.word	0x447a0000
  405cd4:	3fe02b0a 	.word	0x3fe02b0a
  405cd8:	0040bde1 	.word	0x0040bde1
  405cdc:	0040bd31 	.word	0x0040bd31
  405ce0:	0040bbd1 	.word	0x0040bbd1
  405ce4:	004064b9 	.word	0x004064b9
  405ce8:	004055e1 	.word	0x004055e1
  405cec:	00406cad 	.word	0x00406cad
  405cf0:	00406961 	.word	0x00406961
  405cf4:	00405381 	.word	0x00405381

00405cf8 <_ZN7Stepper22moveInverseTimeWrapperEPv>:
uint32_t Stepper::moveInverseTimeWrapper(void *args) {
  405cf8:	b570      	push	{r4, r5, r6, lr}
    MotionItem *motion_item     = *motion_item_ptr;
  405cfa:	680d      	ldr	r5, [r1, #0]
    _IvtArgs   *ivt_args        = static_cast<_IvtArgs *>(motion_item->arg);
  405cfc:	68ac      	ldr	r4, [r5, #8]
    ExecCode exec_code = execMoveInverseTime(ivt_args->units, ivt_args->time_ms);
  405cfe:	6862      	ldr	r2, [r4, #4]
  405d00:	6821      	ldr	r1, [r4, #0]
  405d02:	4b06      	ldr	r3, [pc, #24]	; (405d1c <_ZN7Stepper22moveInverseTimeWrapperEPv+0x24>)
  405d04:	4798      	blx	r3
  405d06:	4606      	mov	r6, r0
    delete motion_item; // free heap
  405d08:	210c      	movs	r1, #12
  405d0a:	4628      	mov	r0, r5
  405d0c:	4d04      	ldr	r5, [pc, #16]	; (405d20 <_ZN7Stepper22moveInverseTimeWrapperEPv+0x28>)
  405d0e:	47a8      	blx	r5
    delete ivt_args;
  405d10:	2108      	movs	r1, #8
  405d12:	4620      	mov	r0, r4
  405d14:	47a8      	blx	r5
}
  405d16:	4630      	mov	r0, r6
  405d18:	bd70      	pop	{r4, r5, r6, pc}
  405d1a:	bf00      	nop
  405d1c:	00405bd9 	.word	0x00405bd9
  405d20:	0040b2b5 	.word	0x0040b2b5

00405d24 <_ZN7Stepper15setHomingMotionEv>:
bool Stepper::setHomingMotion() {
  405d24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  405d28:	b082      	sub	sp, #8
  405d2a:	4604      	mov	r4, r0
    uint32_t max_speed   = combineWord(m_home_s.max_speed_h, m_home_s.max_speed_l);
  405d2c:	f8b0 1060 	ldrh.w	r1, [r0, #96]	; 0x60
  405d30:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
  405d34:	4e18      	ldr	r6, [pc, #96]	; (405d98 <_ZN7Stepper15setHomingMotionEv+0x74>)
  405d36:	47b0      	blx	r6
    float    max_speed_f = uintTofloat((max_speed), 1);
  405d38:	2101      	movs	r1, #1
  405d3a:	4d18      	ldr	r5, [pc, #96]	; (405d9c <_ZN7Stepper15setHomingMotionEv+0x78>)
  405d3c:	47a8      	blx	r5
  405d3e:	4681      	mov	r9, r0
    uint32_t max_accel   = combineWord(m_home_s.max_accel_h, m_home_s.max_accel_l);
  405d40:	f8b4 1064 	ldrh.w	r1, [r4, #100]	; 0x64
  405d44:	f8b4 0062 	ldrh.w	r0, [r4, #98]	; 0x62
  405d48:	47b0      	blx	r6
    float    max_accel_f = uintTofloat((max_accel), 1);
  405d4a:	2101      	movs	r1, #1
  405d4c:	47a8      	blx	r5
  405d4e:	4682      	mov	sl, r0
    uint32_t max_decel   = combineWord(m_home_s.max_decel_h, m_home_s.max_decel_l);
  405d50:	f8b4 1068 	ldrh.w	r1, [r4, #104]	; 0x68
  405d54:	f8b4 0066 	ldrh.w	r0, [r4, #102]	; 0x66
  405d58:	47b0      	blx	r6
    float    max_decel_f = uintTofloat((max_decel), 1);
  405d5a:	2101      	movs	r1, #1
  405d5c:	47a8      	blx	r5
  405d5e:	4680      	mov	r8, r0
    success &= setRampMode(default_ramp_s.ramp_mode, default_ramp_s.ramp_type);
  405d60:	2201      	movs	r2, #1
  405d62:	2104      	movs	r1, #4
  405d64:	4620      	mov	r0, r4
  405d66:	4b0e      	ldr	r3, [pc, #56]	; (405da0 <_ZN7Stepper15setHomingMotionEv+0x7c>)
  405d68:	4798      	blx	r3
  405d6a:	4605      	mov	r5, r0
    success &= setSpeeds(max_speed_f);
  405d6c:	2600      	movs	r6, #0
  405d6e:	9600      	str	r6, [sp, #0]
  405d70:	4633      	mov	r3, r6
  405d72:	4632      	mov	r2, r6
  405d74:	4649      	mov	r1, r9
  405d76:	4620      	mov	r0, r4
  405d78:	4f0a      	ldr	r7, [pc, #40]	; (405da4 <_ZN7Stepper15setHomingMotionEv+0x80>)
  405d7a:	47b8      	blx	r7
  405d7c:	4005      	ands	r5, r0
  405d7e:	b2ed      	uxtb	r5, r5
    success &= setAccelerations(max_accel_f, max_decel_f);
  405d80:	9600      	str	r6, [sp, #0]
  405d82:	4633      	mov	r3, r6
  405d84:	4642      	mov	r2, r8
  405d86:	4651      	mov	r1, sl
  405d88:	4620      	mov	r0, r4
  405d8a:	4c07      	ldr	r4, [pc, #28]	; (405da8 <_ZN7Stepper15setHomingMotionEv+0x84>)
  405d8c:	47a0      	blx	r4
}
  405d8e:	4028      	ands	r0, r5
  405d90:	b002      	add	sp, #8
  405d92:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  405d96:	bf00      	nop
  405d98:	0040562d 	.word	0x0040562d
  405d9c:	00405751 	.word	0x00405751
  405da0:	00406b31 	.word	0x00406b31
  405da4:	00406b41 	.word	0x00406b41
  405da8:	00406bb9 	.word	0x00406bb9

00405dac <_ZN7Stepper18setVibratingMotionEv>:
bool Stepper::setVibratingMotion() {
  405dac:	b5f0      	push	{r4, r5, r6, r7, lr}
  405dae:	b083      	sub	sp, #12
  405db0:	4606      	mov	r6, r0
    success &= setRampMode(ramp_mode, ramp_type);
  405db2:	2201      	movs	r2, #1
  405db4:	2104      	movs	r1, #4
  405db6:	4b0b      	ldr	r3, [pc, #44]	; (405de4 <_ZN7Stepper18setVibratingMotionEv+0x38>)
  405db8:	4798      	blx	r3
  405dba:	4604      	mov	r4, r0
    success &= setSpeeds(dummy_rpm);
  405dbc:	2500      	movs	r5, #0
  405dbe:	9500      	str	r5, [sp, #0]
  405dc0:	462b      	mov	r3, r5
  405dc2:	462a      	mov	r2, r5
  405dc4:	4908      	ldr	r1, [pc, #32]	; (405de8 <_ZN7Stepper18setVibratingMotionEv+0x3c>)
  405dc6:	4630      	mov	r0, r6
  405dc8:	4f08      	ldr	r7, [pc, #32]	; (405dec <_ZN7Stepper18setVibratingMotionEv+0x40>)
  405dca:	47b8      	blx	r7
  405dcc:	4004      	ands	r4, r0
  405dce:	b2e4      	uxtb	r4, r4
    success &= setAccelerations(dummy_accel, dummy_accel);
  405dd0:	4907      	ldr	r1, [pc, #28]	; (405df0 <_ZN7Stepper18setVibratingMotionEv+0x44>)
  405dd2:	9500      	str	r5, [sp, #0]
  405dd4:	462b      	mov	r3, r5
  405dd6:	460a      	mov	r2, r1
  405dd8:	4630      	mov	r0, r6
  405dda:	4d06      	ldr	r5, [pc, #24]	; (405df4 <_ZN7Stepper18setVibratingMotionEv+0x48>)
  405ddc:	47a8      	blx	r5
}
  405dde:	4020      	ands	r0, r4
  405de0:	b003      	add	sp, #12
  405de2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  405de4:	00406b31 	.word	0x00406b31
  405de8:	44e10000 	.word	0x44e10000
  405dec:	00406b41 	.word	0x00406b41
  405df0:	46831200 	.word	0x46831200
  405df4:	00406bb9 	.word	0x00406bb9

00405df8 <_ZN7Stepper15execMoveVibrateEmmfb>:
Stepper::ExecCode Stepper::execMoveVibrate(uint32_t units, uint32_t iterations, float diminishing_factor, bool loop) {
  405df8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405dfc:	b085      	sub	sp, #20
  405dfe:	f89d 8038 	ldrb.w	r8, [sp, #56]	; 0x38
    if (!m_ctrl_init) return ExecCode::E_CTRL_NOT_INIT;
  405e02:	f890 40aa 	ldrb.w	r4, [r0, #170]	; 0xaa
  405e06:	b91c      	cbnz	r4, 405e10 <_ZN7Stepper15execMoveVibrateEmmfb+0x18>
  405e08:	2003      	movs	r0, #3
}
  405e0a:	b005      	add	sp, #20
  405e0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405e10:	461d      	mov	r5, r3
  405e12:	4617      	mov	r7, r2
  405e14:	460e      	mov	r6, r1
  405e16:	4604      	mov	r4, r0
    if (isFrozen()) return ExecCode::E_IS_FROZEN;
  405e18:	4681      	mov	r9, r0
  405e1a:	4b3f      	ldr	r3, [pc, #252]	; (405f18 <_ZN7Stepper15execMoveVibrateEmmfb+0x120>)
  405e1c:	4798      	blx	r3
  405e1e:	b108      	cbz	r0, 405e24 <_ZN7Stepper15execMoveVibrateEmmfb+0x2c>
  405e20:	2005      	movs	r0, #5
  405e22:	e7f2      	b.n	405e0a <_ZN7Stepper15execMoveVibrateEmmfb+0x12>
    if (isRunning()) return ExecCode::E_IS_BUSY;
  405e24:	4620      	mov	r0, r4
  405e26:	4b3d      	ldr	r3, [pc, #244]	; (405f1c <_ZN7Stepper15execMoveVibrateEmmfb+0x124>)
  405e28:	4798      	blx	r3
  405e2a:	b108      	cbz	r0, 405e30 <_ZN7Stepper15execMoveVibrateEmmfb+0x38>
  405e2c:	2006      	movs	r0, #6
  405e2e:	e7ec      	b.n	405e0a <_ZN7Stepper15execMoveVibrateEmmfb+0x12>
    if (m_cl_s.enable) return ExecCode::E_BAD_SETTINGS;
  405e30:	7ba3      	ldrb	r3, [r4, #14]
  405e32:	b10b      	cbz	r3, 405e38 <_ZN7Stepper15execMoveVibrateEmmfb+0x40>
  405e34:	2007      	movs	r0, #7
  405e36:	e7e8      	b.n	405e0a <_ZN7Stepper15execMoveVibrateEmmfb+0x12>
    if (m_stall_s.stop_on_stall) return ExecCode::E_BAD_SETTINGS;
  405e38:	7aa3      	ldrb	r3, [r4, #10]
  405e3a:	b10b      	cbz	r3, 405e40 <_ZN7Stepper15execMoveVibrateEmmfb+0x48>
  405e3c:	2007      	movs	r0, #7
  405e3e:	e7e4      	b.n	405e0a <_ZN7Stepper15execMoveVibrateEmmfb+0x12>
    if (diminishing_factor > 1.0f) return ExecCode::E_BAD_SETTINGS;
  405e40:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
  405e44:	4628      	mov	r0, r5
  405e46:	4b36      	ldr	r3, [pc, #216]	; (405f20 <_ZN7Stepper15execMoveVibrateEmmfb+0x128>)
  405e48:	4798      	blx	r3
  405e4a:	b108      	cbz	r0, 405e50 <_ZN7Stepper15execMoveVibrateEmmfb+0x58>
  405e4c:	2007      	movs	r0, #7
  405e4e:	e7dc      	b.n	405e0a <_ZN7Stepper15execMoveVibrateEmmfb+0x12>
    if (!setVibratingMotion()) return ExecCode::E_WRITE_FAIL;
  405e50:	4620      	mov	r0, r4
  405e52:	4b34      	ldr	r3, [pc, #208]	; (405f24 <_ZN7Stepper15execMoveVibrateEmmfb+0x12c>)
  405e54:	4798      	blx	r3
  405e56:	b908      	cbnz	r0, 405e5c <_ZN7Stepper15execMoveVibrateEmmfb+0x64>
  405e58:	2002      	movs	r0, #2
  405e5a:	e7d6      	b.n	405e0a <_ZN7Stepper15execMoveVibrateEmmfb+0x12>
    enableDriver();
  405e5c:	4620      	mov	r0, r4
  405e5e:	4b32      	ldr	r3, [pc, #200]	; (405f28 <_ZN7Stepper15execMoveVibrateEmmfb+0x130>)
  405e60:	4798      	blx	r3
    m_motion_conf          = false;
  405e62:	2300      	movs	r3, #0
  405e64:	f884 30ab 	strb.w	r3, [r4, #171]	; 0xab
    m_is_vibrating         = true;
  405e68:	2301      	movs	r3, #1
  405e6a:	f884 30a8 	strb.w	r3, [r4, #168]	; 0xa8
    int32_t  ref_pos       = getInternalPosition();
  405e6e:	4620      	mov	r0, r4
  405e70:	4b2e      	ldr	r3, [pc, #184]	; (405f2c <_ZN7Stepper15execMoveVibrateEmmfb+0x134>)
  405e72:	4798      	blx	r3
  405e74:	9002      	str	r0, [sp, #8]
  405e76:	9503      	str	r5, [sp, #12]
  405e78:	e00c      	b.n	405e94 <_ZN7Stepper15execMoveVibrateEmmfb+0x9c>
  405e7a:	f8dd 8004 	ldr.w	r8, [sp, #4]
  405e7e:	4656      	mov	r6, sl
                m_run_task = false;
  405e80:	2300      	movs	r3, #0
  405e82:	f884 30ac 	strb.w	r3, [r4, #172]	; 0xac
        if (!loop) break;
  405e86:	f1b8 0f00 	cmp.w	r8, #0
  405e8a:	d03f      	beq.n	405f0c <_ZN7Stepper15execMoveVibrateEmmfb+0x114>
    } while (m_run_task);
  405e8c:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
  405e90:	2b00      	cmp	r3, #0
  405e92:	d03b      	beq.n	405f0c <_ZN7Stepper15execMoveVibrateEmmfb+0x114>
        int32_t current_magnitude = unitToPulse(units / 2);
  405e94:	0871      	lsrs	r1, r6, #1
  405e96:	4620      	mov	r0, r4
  405e98:	4b25      	ldr	r3, [pc, #148]	; (405f30 <_ZN7Stepper15execMoveVibrateEmmfb+0x138>)
  405e9a:	4798      	blx	r3
  405e9c:	4605      	mov	r5, r0
        for (uint32_t i = 0; i < iterations && m_run_task && current_magnitude != 0; ++i) {
  405e9e:	f04f 0b00 	mov.w	fp, #0
  405ea2:	f8cd 8004 	str.w	r8, [sp, #4]
  405ea6:	46b2      	mov	sl, r6
  405ea8:	45bb      	cmp	fp, r7
  405eaa:	d223      	bcs.n	405ef4 <_ZN7Stepper15execMoveVibrateEmmfb+0xfc>
  405eac:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
  405eb0:	b323      	cbz	r3, 405efc <_ZN7Stepper15execMoveVibrateEmmfb+0x104>
  405eb2:	b33d      	cbz	r5, 405f04 <_ZN7Stepper15execMoveVibrateEmmfb+0x10c>
            setTargetPosition(write_pos);
  405eb4:	9b02      	ldr	r3, [sp, #8]
  405eb6:	18e9      	adds	r1, r5, r3
  405eb8:	4648      	mov	r0, r9
  405eba:	4e1e      	ldr	r6, [pc, #120]	; (405f34 <_ZN7Stepper15execMoveVibrateEmmfb+0x13c>)
  405ebc:	47b0      	blx	r6
            waitCompleteRun();
  405ebe:	4620      	mov	r0, r4
  405ec0:	f8df 8080 	ldr.w	r8, [pc, #128]	; 405f44 <_ZN7Stepper15execMoveVibrateEmmfb+0x14c>
  405ec4:	47c0      	blx	r8
            setTargetPosition(write_pos);
  405ec6:	9b02      	ldr	r3, [sp, #8]
  405ec8:	1b59      	subs	r1, r3, r5
  405eca:	4648      	mov	r0, r9
  405ecc:	47b0      	blx	r6
            waitCompleteRun();
  405ece:	4620      	mov	r0, r4
  405ed0:	47c0      	blx	r8
            current_magnitude *= diminishing_factor;
  405ed2:	4628      	mov	r0, r5
  405ed4:	4b18      	ldr	r3, [pc, #96]	; (405f38 <_ZN7Stepper15execMoveVibrateEmmfb+0x140>)
  405ed6:	4798      	blx	r3
  405ed8:	9903      	ldr	r1, [sp, #12]
  405eda:	4b18      	ldr	r3, [pc, #96]	; (405f3c <_ZN7Stepper15execMoveVibrateEmmfb+0x144>)
  405edc:	4798      	blx	r3
  405ede:	4b18      	ldr	r3, [pc, #96]	; (405f40 <_ZN7Stepper15execMoveVibrateEmmfb+0x148>)
  405ee0:	4798      	blx	r3
  405ee2:	4605      	mov	r5, r0
            if (isFrozen()) {
  405ee4:	4648      	mov	r0, r9
  405ee6:	4b0c      	ldr	r3, [pc, #48]	; (405f18 <_ZN7Stepper15execMoveVibrateEmmfb+0x120>)
  405ee8:	4798      	blx	r3
  405eea:	2800      	cmp	r0, #0
  405eec:	d1c5      	bne.n	405e7a <_ZN7Stepper15execMoveVibrateEmmfb+0x82>
        for (uint32_t i = 0; i < iterations && m_run_task && current_magnitude != 0; ++i) {
  405eee:	f10b 0b01 	add.w	fp, fp, #1
  405ef2:	e7d9      	b.n	405ea8 <_ZN7Stepper15execMoveVibrateEmmfb+0xb0>
  405ef4:	f8dd 8004 	ldr.w	r8, [sp, #4]
  405ef8:	4656      	mov	r6, sl
  405efa:	e7c4      	b.n	405e86 <_ZN7Stepper15execMoveVibrateEmmfb+0x8e>
  405efc:	f8dd 8004 	ldr.w	r8, [sp, #4]
  405f00:	4656      	mov	r6, sl
  405f02:	e7c0      	b.n	405e86 <_ZN7Stepper15execMoveVibrateEmmfb+0x8e>
  405f04:	f8dd 8004 	ldr.w	r8, [sp, #4]
  405f08:	4656      	mov	r6, sl
  405f0a:	e7bc      	b.n	405e86 <_ZN7Stepper15execMoveVibrateEmmfb+0x8e>
    m_is_vibrating = false;
  405f0c:	2300      	movs	r3, #0
  405f0e:	f884 30a8 	strb.w	r3, [r4, #168]	; 0xa8
    return ExecCode::E_SUCCESS;
  405f12:	2001      	movs	r0, #1
  405f14:	e779      	b.n	405e0a <_ZN7Stepper15execMoveVibrateEmmfb+0x12>
  405f16:	bf00      	nop
  405f18:	004063eb 	.word	0x004063eb
  405f1c:	004063e5 	.word	0x004063e5
  405f20:	0040c159 	.word	0x0040c159
  405f24:	00405dad 	.word	0x00405dad
  405f28:	0040643d 	.word	0x0040643d
  405f2c:	00406915 	.word	0x00406915
  405f30:	004059a1 	.word	0x004059a1
  405f34:	00406cad 	.word	0x00406cad
  405f38:	0040bd39 	.word	0x0040bd39
  405f3c:	0040bde1 	.word	0x0040bde1
  405f40:	0040c16d 	.word	0x0040c16d
  405f44:	00405381 	.word	0x00405381

00405f48 <_ZN7Stepper20moveVibrationWrapperEPv>:
uint32_t Stepper::moveVibrationWrapper(void *args) {
  405f48:	b570      	push	{r4, r5, r6, lr}
  405f4a:	b082      	sub	sp, #8
    MotionItem     *motion_item     = *motion_item_ptr;
  405f4c:	680d      	ldr	r5, [r1, #0]
    _VibrationArgs *vib_args        = static_cast<_VibrationArgs *>(motion_item->arg);
  405f4e:	68ac      	ldr	r4, [r5, #8]
    m_run_task                      = true;
  405f50:	2301      	movs	r3, #1
  405f52:	f880 30ac 	strb.w	r3, [r0, #172]	; 0xac
        execMoveVibrate(vib_args->units, vib_args->iterations, vib_args->diminishing_factor, vib_args->loop);
  405f56:	6821      	ldr	r1, [r4, #0]
  405f58:	6862      	ldr	r2, [r4, #4]
  405f5a:	68a3      	ldr	r3, [r4, #8]
  405f5c:	7b26      	ldrb	r6, [r4, #12]
  405f5e:	9600      	str	r6, [sp, #0]
  405f60:	4e06      	ldr	r6, [pc, #24]	; (405f7c <_ZN7Stepper20moveVibrationWrapperEPv+0x34>)
  405f62:	47b0      	blx	r6
  405f64:	4606      	mov	r6, r0
    delete motion_item; // free heap
  405f66:	210c      	movs	r1, #12
  405f68:	4628      	mov	r0, r5
  405f6a:	4d05      	ldr	r5, [pc, #20]	; (405f80 <_ZN7Stepper20moveVibrationWrapperEPv+0x38>)
  405f6c:	47a8      	blx	r5
    delete vib_args;
  405f6e:	2110      	movs	r1, #16
  405f70:	4620      	mov	r0, r4
  405f72:	47a8      	blx	r5
}
  405f74:	4630      	mov	r0, r6
  405f76:	b002      	add	sp, #8
  405f78:	bd70      	pop	{r4, r5, r6, pc}
  405f7a:	bf00      	nop
  405f7c:	00405df9 	.word	0x00405df9
  405f80:	0040b2b5 	.word	0x0040b2b5

00405f84 <_ZN7Stepper10readSensorENS_12HomingSensorE>:
bool Stepper::readSensor(HomingSensor homing_sensor) {
  405f84:	b510      	push	{r4, lr}
  405f86:	460c      	mov	r4, r1
    uint8_t sensor_status = getSensorReading();
  405f88:	4b02      	ldr	r3, [pc, #8]	; (405f94 <_ZN7Stepper10readSensorENS_12HomingSensorE+0x10>)
  405f8a:	4798      	blx	r3
    return sensor_status >> homing_sensor & 1;
  405f8c:	4120      	asrs	r0, r4
  405f8e:	f000 0001 	and.w	r0, r0, #1
}
  405f92:	bd10      	pop	{r4, pc}
  405f94:	004063f1 	.word	0x004063f1

00405f98 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm>:
Stepper::_WaitRes Stepper::waitCondition(Callable payload_factory, bool value, portTickType timeout) {
  405f98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  405f9c:	b082      	sub	sp, #8
  405f9e:	4680      	mov	r8, r0
  405fa0:	460c      	mov	r4, r1
  405fa2:	4617      	mov	r7, r2
  405fa4:	461e      	mov	r6, r3
    portTickType start_tick = xTaskGetTickCount();
  405fa6:	4b1a      	ldr	r3, [pc, #104]	; (406010 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x78>)
  405fa8:	4798      	blx	r3
  405faa:	4605      	mov	r5, r0
    _WaitRes     wait_results{false, true};
  405fac:	2300      	movs	r3, #0
  405fae:	f88d 3000 	strb.w	r3, [sp]
  405fb2:	2301      	movs	r3, #1
  405fb4:	f88d 3001 	strb.w	r3, [sp, #1]
    while (xTaskGetTickCount() - start_tick < timeout) {
  405fb8:	4b15      	ldr	r3, [pc, #84]	; (406010 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x78>)
  405fba:	4798      	blx	r3
  405fbc:	1b40      	subs	r0, r0, r5
  405fbe:	42b0      	cmp	r0, r6
  405fc0:	d20c      	bcs.n	405fdc <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x44>
            results = waitCondition([&]() { return readSensor(m_home_s.homing_sensor); }, m_home_s.sensor_home_value,
  405fc2:	f894 1057 	ldrb.w	r1, [r4, #87]	; 0x57
  405fc6:	4620      	mov	r0, r4
  405fc8:	4b12      	ldr	r3, [pc, #72]	; (406014 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x7c>)
  405fca:	4798      	blx	r3
        if (payload_factory() == value) {
  405fcc:	4287      	cmp	r7, r0
  405fce:	d112      	bne.n	405ff6 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x5e>
            wait_results.condition_met = true;
  405fd0:	2301      	movs	r3, #1
  405fd2:	f88d 3000 	strb.w	r3, [sp]
            wait_results.timed_out     = false;
  405fd6:	2300      	movs	r3, #0
  405fd8:	f88d 3001 	strb.w	r3, [sp, #1]
    return wait_results;
  405fdc:	f8bd 3000 	ldrh.w	r3, [sp]
  405fe0:	2000      	movs	r0, #0
  405fe2:	b2da      	uxtb	r2, r3
  405fe4:	f362 0007 	bfi	r0, r2, #0, #8
  405fe8:	f3c3 2307 	ubfx	r3, r3, #8, #8
  405fec:	f363 200f 	bfi	r0, r3, #8, #8
}
  405ff0:	b002      	add	sp, #8
  405ff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (!isRunning()) {
  405ff6:	4640      	mov	r0, r8
  405ff8:	4b07      	ldr	r3, [pc, #28]	; (406018 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x80>)
  405ffa:	4798      	blx	r3
  405ffc:	b918      	cbnz	r0, 406006 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x6e>
            wait_results.timed_out = false;
  405ffe:	2300      	movs	r3, #0
  406000:	f88d 3001 	strb.w	r3, [sp, #1]
            break;
  406004:	e7ea      	b.n	405fdc <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x44>
        vTaskDelay(STATUS_UPDATE_FREQ_TICKS);
  406006:	2005      	movs	r0, #5
  406008:	4b04      	ldr	r3, [pc, #16]	; (40601c <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x84>)
  40600a:	4798      	blx	r3
    while (xTaskGetTickCount() - start_tick < timeout) {
  40600c:	e7d4      	b.n	405fb8 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE_EENS_8_WaitResET_bm+0x20>
  40600e:	bf00      	nop
  406010:	0040998d 	.word	0x0040998d
  406014:	00405f85 	.word	0x00405f85
  406018:	004063e5 	.word	0x004063e5
  40601c:	00409bd5 	.word	0x00409bd5

00406020 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm>:
Stepper::_WaitRes Stepper::waitCondition(Callable payload_factory, bool value, portTickType timeout) {
  406020:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  406024:	b082      	sub	sp, #8
  406026:	4680      	mov	r8, r0
  406028:	460c      	mov	r4, r1
  40602a:	4617      	mov	r7, r2
  40602c:	461e      	mov	r6, r3
    portTickType start_tick = xTaskGetTickCount();
  40602e:	4b1a      	ldr	r3, [pc, #104]	; (406098 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x78>)
  406030:	4798      	blx	r3
  406032:	4605      	mov	r5, r0
    _WaitRes     wait_results{false, true};
  406034:	2300      	movs	r3, #0
  406036:	f88d 3000 	strb.w	r3, [sp]
  40603a:	2301      	movs	r3, #1
  40603c:	f88d 3001 	strb.w	r3, [sp, #1]
    while (xTaskGetTickCount() - start_tick < timeout) {
  406040:	4b15      	ldr	r3, [pc, #84]	; (406098 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x78>)
  406042:	4798      	blx	r3
  406044:	1b40      	subs	r0, r0, r5
  406046:	42b0      	cmp	r0, r6
  406048:	d20c      	bcs.n	406064 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x44>
        results = waitCondition([&]() { return readSensor(m_home_s.homing_sensor); }, !m_home_s.sensor_home_value,
  40604a:	f894 1057 	ldrb.w	r1, [r4, #87]	; 0x57
  40604e:	4620      	mov	r0, r4
  406050:	4b12      	ldr	r3, [pc, #72]	; (40609c <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x7c>)
  406052:	4798      	blx	r3
        if (payload_factory() == value) {
  406054:	4287      	cmp	r7, r0
  406056:	d112      	bne.n	40607e <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x5e>
            wait_results.condition_met = true;
  406058:	2301      	movs	r3, #1
  40605a:	f88d 3000 	strb.w	r3, [sp]
            wait_results.timed_out     = false;
  40605e:	2300      	movs	r3, #0
  406060:	f88d 3001 	strb.w	r3, [sp, #1]
    return wait_results;
  406064:	f8bd 3000 	ldrh.w	r3, [sp]
  406068:	2000      	movs	r0, #0
  40606a:	b2da      	uxtb	r2, r3
  40606c:	f362 0007 	bfi	r0, r2, #0, #8
  406070:	f3c3 2307 	ubfx	r3, r3, #8, #8
  406074:	f363 200f 	bfi	r0, r3, #8, #8
}
  406078:	b002      	add	sp, #8
  40607a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (!isRunning()) {
  40607e:	4640      	mov	r0, r8
  406080:	4b07      	ldr	r3, [pc, #28]	; (4060a0 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x80>)
  406082:	4798      	blx	r3
  406084:	b918      	cbnz	r0, 40608e <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x6e>
            wait_results.timed_out = false;
  406086:	2300      	movs	r3, #0
  406088:	f88d 3001 	strb.w	r3, [sp, #1]
            break;
  40608c:	e7ea      	b.n	406064 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x44>
        vTaskDelay(STATUS_UPDATE_FREQ_TICKS);
  40608e:	2005      	movs	r0, #5
  406090:	4b04      	ldr	r3, [pc, #16]	; (4060a4 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x84>)
  406092:	4798      	blx	r3
    while (xTaskGetTickCount() - start_tick < timeout) {
  406094:	e7d4      	b.n	406040 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE0_EENS_8_WaitResET_bm+0x20>
  406096:	bf00      	nop
  406098:	0040998d 	.word	0x0040998d
  40609c:	00405f85 	.word	0x00405f85
  4060a0:	004063e5 	.word	0x004063e5
  4060a4:	00409bd5 	.word	0x00409bd5

004060a8 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm>:
Stepper::_WaitRes Stepper::waitCondition(Callable payload_factory, bool value, portTickType timeout) {
  4060a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4060ac:	b082      	sub	sp, #8
  4060ae:	4680      	mov	r8, r0
  4060b0:	460c      	mov	r4, r1
  4060b2:	4617      	mov	r7, r2
  4060b4:	461e      	mov	r6, r3
    portTickType start_tick = xTaskGetTickCount();
  4060b6:	4b1a      	ldr	r3, [pc, #104]	; (406120 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x78>)
  4060b8:	4798      	blx	r3
  4060ba:	4605      	mov	r5, r0
    _WaitRes     wait_results{false, true};
  4060bc:	2300      	movs	r3, #0
  4060be:	f88d 3000 	strb.w	r3, [sp]
  4060c2:	2301      	movs	r3, #1
  4060c4:	f88d 3001 	strb.w	r3, [sp, #1]
    while (xTaskGetTickCount() - start_tick < timeout) {
  4060c8:	4b15      	ldr	r3, [pc, #84]	; (406120 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x78>)
  4060ca:	4798      	blx	r3
  4060cc:	1b40      	subs	r0, r0, r5
  4060ce:	42b0      	cmp	r0, r6
  4060d0:	d20c      	bcs.n	4060ec <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x44>
        results = waitCondition([&]() { return readSensor(m_home_s.homing_sensor); }, m_home_s.sensor_home_value,
  4060d2:	f894 1057 	ldrb.w	r1, [r4, #87]	; 0x57
  4060d6:	4620      	mov	r0, r4
  4060d8:	4b12      	ldr	r3, [pc, #72]	; (406124 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x7c>)
  4060da:	4798      	blx	r3
        if (payload_factory() == value) {
  4060dc:	4287      	cmp	r7, r0
  4060de:	d112      	bne.n	406106 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x5e>
            wait_results.condition_met = true;
  4060e0:	2301      	movs	r3, #1
  4060e2:	f88d 3000 	strb.w	r3, [sp]
            wait_results.timed_out     = false;
  4060e6:	2300      	movs	r3, #0
  4060e8:	f88d 3001 	strb.w	r3, [sp, #1]
    return wait_results;
  4060ec:	f8bd 3000 	ldrh.w	r3, [sp]
  4060f0:	2000      	movs	r0, #0
  4060f2:	b2da      	uxtb	r2, r3
  4060f4:	f362 0007 	bfi	r0, r2, #0, #8
  4060f8:	f3c3 2307 	ubfx	r3, r3, #8, #8
  4060fc:	f363 200f 	bfi	r0, r3, #8, #8
}
  406100:	b002      	add	sp, #8
  406102:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (!isRunning()) {
  406106:	4640      	mov	r0, r8
  406108:	4b07      	ldr	r3, [pc, #28]	; (406128 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x80>)
  40610a:	4798      	blx	r3
  40610c:	b918      	cbnz	r0, 406116 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x6e>
            wait_results.timed_out = false;
  40610e:	2300      	movs	r3, #0
  406110:	f88d 3001 	strb.w	r3, [sp, #1]
            break;
  406114:	e7ea      	b.n	4060ec <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x44>
        vTaskDelay(STATUS_UPDATE_FREQ_TICKS);
  406116:	2005      	movs	r0, #5
  406118:	4b04      	ldr	r3, [pc, #16]	; (40612c <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x84>)
  40611a:	4798      	blx	r3
    while (xTaskGetTickCount() - start_tick < timeout) {
  40611c:	e7d4      	b.n	4060c8 <_ZN7Stepper13waitConditionIZNS_14execMoveHomingEvEUlvE1_EENS_8_WaitResET_bm+0x20>
  40611e:	bf00      	nop
  406120:	0040998d 	.word	0x0040998d
  406124:	00405f85 	.word	0x00405f85
  406128:	004063e5 	.word	0x004063e5
  40612c:	00409bd5 	.word	0x00409bd5

00406130 <_ZN7Stepper14execMoveHomingEv>:
    if (!m_ctrl_init) return HomingCode::H_CTRL_NOT_INIT;
  406130:	f890 30aa 	ldrb.w	r3, [r0, #170]	; 0xaa
  406134:	b90b      	cbnz	r3, 40613a <_ZN7Stepper14execMoveHomingEv+0xa>
  406136:	2003      	movs	r0, #3
  406138:	4770      	bx	lr
Stepper::HomingCode Stepper::execMoveHoming() {
  40613a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40613e:	b082      	sub	sp, #8
  406140:	4604      	mov	r4, r0
    if (isFrozen()) return HomingCode::H_IS_FROZEN;
  406142:	4b8c      	ldr	r3, [pc, #560]	; (406374 <_ZN7Stepper14execMoveHomingEv+0x244>)
  406144:	4798      	blx	r3
  406146:	b118      	cbz	r0, 406150 <_ZN7Stepper14execMoveHomingEv+0x20>
  406148:	2005      	movs	r0, #5
}
  40614a:	b002      	add	sp, #8
  40614c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (isRunning()) return HomingCode::H_IS_BUSY;
  406150:	4620      	mov	r0, r4
  406152:	4b89      	ldr	r3, [pc, #548]	; (406378 <_ZN7Stepper14execMoveHomingEv+0x248>)
  406154:	4798      	blx	r3
  406156:	b108      	cbz	r0, 40615c <_ZN7Stepper14execMoveHomingEv+0x2c>
  406158:	2006      	movs	r0, #6
  40615a:	e7f6      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
    enableDriver();
  40615c:	4620      	mov	r0, r4
  40615e:	4b87      	ldr	r3, [pc, #540]	; (40637c <_ZN7Stepper14execMoveHomingEv+0x24c>)
  406160:	4798      	blx	r3
    max_find_unit      = static_cast<int32_t>(combineWord(m_home_s.max_find_h, m_home_s.max_find_l));
  406162:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
  406166:	f8b4 005a 	ldrh.w	r0, [r4, #90]	; 0x5a
  40616a:	4d85      	ldr	r5, [pc, #532]	; (406380 <_ZN7Stepper14execMoveHomingEv+0x250>)
  40616c:	47a8      	blx	r5
  40616e:	4680      	mov	r8, r0
    homing_offset_unit = static_cast<int32_t>(combineWord(m_home_s.offset_h, m_home_s.offset_l));
  406170:	f8b4 106c 	ldrh.w	r1, [r4, #108]	; 0x6c
  406174:	f8b4 006a 	ldrh.w	r0, [r4, #106]	; 0x6a
  406178:	47a8      	blx	r5
  40617a:	4682      	mov	sl, r0
    timeout_ms         = combineWord(m_home_s.timeout_ms_h, m_home_s.timeout_ms_l);
  40617c:	f8b4 1070 	ldrh.w	r1, [r4, #112]	; 0x70
  406180:	f8b4 006e 	ldrh.w	r0, [r4, #110]	; 0x6e
  406184:	47a8      	blx	r5
  406186:	4606      	mov	r6, r0
    uint32_t     max_find_pulse_w          = static_cast<uint32_t>(unitToPulse(max_find_unit));
  406188:	4641      	mov	r1, r8
  40618a:	4620      	mov	r0, r4
  40618c:	4d7d      	ldr	r5, [pc, #500]	; (406384 <_ZN7Stepper14execMoveHomingEv+0x254>)
  40618e:	47a8      	blx	r5
  406190:	4607      	mov	r7, r0
    uint32_t     max_find_pulse_reversed_w = static_cast<uint32_t>(unitToPulse(-max_find_unit));
  406192:	f1c8 0100 	rsb	r1, r8, #0
  406196:	4620      	mov	r0, r4
  406198:	47a8      	blx	r5
  40619a:	4681      	mov	r9, r0
    uint32_t     homing_offset_w           = static_cast<uint32_t>(unitToPulse(homing_offset_unit));
  40619c:	4651      	mov	r1, sl
  40619e:	4620      	mov	r0, r4
  4061a0:	47a8      	blx	r5
  4061a2:	4680      	mov	r8, r0
    write_success &= setPosition(0);    // Reset position & target
  4061a4:	2100      	movs	r1, #0
  4061a6:	4620      	mov	r0, r4
  4061a8:	4b77      	ldr	r3, [pc, #476]	; (406388 <_ZN7Stepper14execMoveHomingEv+0x258>)
  4061aa:	4798      	blx	r3
  4061ac:	4605      	mov	r5, r0
    write_success &= setHomingMotion(); // Configure motion for homing
  4061ae:	4620      	mov	r0, r4
  4061b0:	4b76      	ldr	r3, [pc, #472]	; (40638c <_ZN7Stepper14execMoveHomingEv+0x25c>)
  4061b2:	4798      	blx	r3
  4061b4:	4005      	ands	r5, r0
    if (!write_success) return HomingCode::H_WRITE_FAIL;
  4061b6:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
  4061ba:	d101      	bne.n	4061c0 <_ZN7Stepper14execMoveHomingEv+0x90>
  4061bc:	2002      	movs	r0, #2
  4061be:	e7c4      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
    if (m_home_s.homing_mode == HomingMode::IMMEDIATE) {
  4061c0:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
  4061c4:	b33b      	cbz	r3, 406216 <_ZN7Stepper14execMoveHomingEv+0xe6>
    else if (m_home_s.homing_mode == HomingMode::SENSOR) {
  4061c6:	2b02      	cmp	r3, #2
  4061c8:	d030      	beq.n	40622c <_ZN7Stepper14execMoveHomingEv+0xfc>
        write_success &= setPosition(0);
  4061ca:	2100      	movs	r1, #0
  4061cc:	4620      	mov	r0, r4
  4061ce:	4b6e      	ldr	r3, [pc, #440]	; (406388 <_ZN7Stepper14execMoveHomingEv+0x258>)
  4061d0:	4798      	blx	r3
  4061d2:	4005      	ands	r5, r0
        write_success &= setTargetPosition(max_find_pulse_w);
  4061d4:	4639      	mov	r1, r7
  4061d6:	4620      	mov	r0, r4
  4061d8:	4b6d      	ldr	r3, [pc, #436]	; (406390 <_ZN7Stepper14execMoveHomingEv+0x260>)
  4061da:	4798      	blx	r3
  4061dc:	4005      	ands	r5, r0
  4061de:	b2ed      	uxtb	r5, r5
        bool ori_stop_on_stall  = m_stall_s.stop_on_stall;
  4061e0:	7aa7      	ldrb	r7, [r4, #10]
        m_stall_s.stop_on_stall = !m_cl_s.enable;
  4061e2:	7ba3      	ldrb	r3, [r4, #14]
  4061e4:	f083 0301 	eor.w	r3, r3, #1
  4061e8:	72a3      	strb	r3, [r4, #10]
        results = waitCondition([&]() { return isFrozen(); }, true, timeout_ticks);
  4061ea:	4633      	mov	r3, r6
  4061ec:	2201      	movs	r2, #1
  4061ee:	4621      	mov	r1, r4
  4061f0:	4620      	mov	r0, r4
  4061f2:	4e68      	ldr	r6, [pc, #416]	; (406394 <_ZN7Stepper14execMoveHomingEv+0x264>)
  4061f4:	47b0      	blx	r6
  4061f6:	f8ad 0004 	strh.w	r0, [sp, #4]
        FreezeEvent freeze_event = whyFrozen();
  4061fa:	4620      	mov	r0, r4
  4061fc:	4b66      	ldr	r3, [pc, #408]	; (406398 <_ZN7Stepper14execMoveHomingEv+0x268>)
  4061fe:	4798      	blx	r3
        if (m_cl_s.enable)
  406200:	7ba3      	ldrb	r3, [r4, #14]
  406202:	2b00      	cmp	r3, #0
  406204:	f000 8086 	beq.w	406314 <_ZN7Stepper14execMoveHomingEv+0x1e4>
            results.condition_met = (freeze_event == FreezeEvent::POS_ERR);
  406208:	2803      	cmp	r0, #3
  40620a:	bf14      	ite	ne
  40620c:	2000      	movne	r0, #0
  40620e:	2001      	moveq	r0, #1
  406210:	f88d 0004 	strb.w	r0, [sp, #4]
        m_stall_s.stop_on_stall = ori_stop_on_stall;
  406214:	72a7      	strb	r7, [r4, #10]
    write_success &= setPosition(0);
  406216:	2100      	movs	r1, #0
  406218:	4620      	mov	r0, r4
  40621a:	4b5b      	ldr	r3, [pc, #364]	; (406388 <_ZN7Stepper14execMoveHomingEv+0x258>)
  40621c:	4798      	blx	r3
  40621e:	4005      	ands	r5, r0
    if (results.timed_out) { return HomingCode::H_TIMEOUT; }
  406220:	f89d 3005 	ldrb.w	r3, [sp, #5]
  406224:	2b00      	cmp	r3, #0
  406226:	d07c      	beq.n	406322 <_ZN7Stepper14execMoveHomingEv+0x1f2>
  406228:	2007      	movs	r0, #7
  40622a:	e78e      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
        if (readSensor(m_home_s.homing_sensor) != m_home_s.sensor_home_value) {
  40622c:	f894 1057 	ldrb.w	r1, [r4, #87]	; 0x57
  406230:	4620      	mov	r0, r4
  406232:	4b5a      	ldr	r3, [pc, #360]	; (40639c <_ZN7Stepper14execMoveHomingEv+0x26c>)
  406234:	4798      	blx	r3
  406236:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
  40623a:	4298      	cmp	r0, r3
  40623c:	d022      	beq.n	406284 <_ZN7Stepper14execMoveHomingEv+0x154>
            write_success &= setPosition(0);
  40623e:	2100      	movs	r1, #0
  406240:	4620      	mov	r0, r4
  406242:	4b51      	ldr	r3, [pc, #324]	; (406388 <_ZN7Stepper14execMoveHomingEv+0x258>)
  406244:	4798      	blx	r3
  406246:	4005      	ands	r5, r0
            write_success &= setTargetPosition(max_find_pulse_w);
  406248:	4639      	mov	r1, r7
  40624a:	4620      	mov	r0, r4
  40624c:	4b50      	ldr	r3, [pc, #320]	; (406390 <_ZN7Stepper14execMoveHomingEv+0x260>)
  40624e:	4798      	blx	r3
  406250:	4005      	ands	r5, r0
            vTaskDelay(STATUS_UPDATE_FREQ_TICKS * 2);
  406252:	200a      	movs	r0, #10
  406254:	4b52      	ldr	r3, [pc, #328]	; (4063a0 <_ZN7Stepper14execMoveHomingEv+0x270>)
  406256:	4798      	blx	r3
                                    timeout_ticks);
  406258:	4633      	mov	r3, r6
  40625a:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
  40625e:	4621      	mov	r1, r4
  406260:	4620      	mov	r0, r4
  406262:	f8df a14c 	ldr.w	sl, [pc, #332]	; 4063b0 <_ZN7Stepper14execMoveHomingEv+0x280>
  406266:	47d0      	blx	sl
  406268:	f8ad 0004 	strh.w	r0, [sp, #4]
            rampStop();
  40626c:	4620      	mov	r0, r4
  40626e:	4b4d      	ldr	r3, [pc, #308]	; (4063a4 <_ZN7Stepper14execMoveHomingEv+0x274>)
  406270:	4798      	blx	r3
            if (results.timed_out) { return HomingCode::H_TIMEOUT; }
  406272:	f89d 3005 	ldrb.w	r3, [sp, #5]
  406276:	2b00      	cmp	r3, #0
  406278:	d175      	bne.n	406366 <_ZN7Stepper14execMoveHomingEv+0x236>
            if (!results.condition_met) { return HomingCode::H_MAX_PULSE_REACHED; }
  40627a:	f89d 3004 	ldrb.w	r3, [sp, #4]
  40627e:	b90b      	cbnz	r3, 406284 <_ZN7Stepper14execMoveHomingEv+0x154>
  406280:	2008      	movs	r0, #8
  406282:	e762      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
        write_success &= setHomingMotion();
  406284:	4620      	mov	r0, r4
  406286:	4b41      	ldr	r3, [pc, #260]	; (40638c <_ZN7Stepper14execMoveHomingEv+0x25c>)
  406288:	4798      	blx	r3
  40628a:	4005      	ands	r5, r0
        write_success &= setPosition(0);
  40628c:	2100      	movs	r1, #0
  40628e:	4620      	mov	r0, r4
  406290:	4b3d      	ldr	r3, [pc, #244]	; (406388 <_ZN7Stepper14execMoveHomingEv+0x258>)
  406292:	4798      	blx	r3
  406294:	4005      	ands	r5, r0
  406296:	b2ed      	uxtb	r5, r5
        write_success &= setTargetPosition(max_find_pulse_reversed_w);
  406298:	4649      	mov	r1, r9
  40629a:	4620      	mov	r0, r4
  40629c:	4b3c      	ldr	r3, [pc, #240]	; (406390 <_ZN7Stepper14execMoveHomingEv+0x260>)
  40629e:	4798      	blx	r3
  4062a0:	4005      	ands	r5, r0
        vTaskDelay(STATUS_UPDATE_FREQ_TICKS * 2);
  4062a2:	200a      	movs	r0, #10
  4062a4:	4b3e      	ldr	r3, [pc, #248]	; (4063a0 <_ZN7Stepper14execMoveHomingEv+0x270>)
  4062a6:	4798      	blx	r3
        results = waitCondition([&]() { return readSensor(m_home_s.homing_sensor); }, !m_home_s.sensor_home_value,
  4062a8:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
                                timeout_ticks);
  4062ac:	4633      	mov	r3, r6
  4062ae:	f082 0201 	eor.w	r2, r2, #1
  4062b2:	4621      	mov	r1, r4
  4062b4:	4620      	mov	r0, r4
  4062b6:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 4063b4 <_ZN7Stepper14execMoveHomingEv+0x284>
  4062ba:	47c8      	blx	r9
  4062bc:	f8ad 0004 	strh.w	r0, [sp, #4]
        rampStop();
  4062c0:	4620      	mov	r0, r4
  4062c2:	4b38      	ldr	r3, [pc, #224]	; (4063a4 <_ZN7Stepper14execMoveHomingEv+0x274>)
  4062c4:	4798      	blx	r3
        if (results.timed_out) { return HomingCode::H_TIMEOUT; }
  4062c6:	f89d 3005 	ldrb.w	r3, [sp, #5]
  4062ca:	b10b      	cbz	r3, 4062d0 <_ZN7Stepper14execMoveHomingEv+0x1a0>
  4062cc:	2007      	movs	r0, #7
  4062ce:	e73c      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
        if (!results.condition_met) { return HomingCode::H_MAX_PULSE_REACHED; }
  4062d0:	f89d 3004 	ldrb.w	r3, [sp, #4]
  4062d4:	2b00      	cmp	r3, #0
  4062d6:	d048      	beq.n	40636a <_ZN7Stepper14execMoveHomingEv+0x23a>
        write_success &= setHomingMotion();
  4062d8:	4620      	mov	r0, r4
  4062da:	4b2c      	ldr	r3, [pc, #176]	; (40638c <_ZN7Stepper14execMoveHomingEv+0x25c>)
  4062dc:	4798      	blx	r3
  4062de:	4005      	ands	r5, r0
        write_success &= setPosition(0);
  4062e0:	2100      	movs	r1, #0
  4062e2:	4620      	mov	r0, r4
  4062e4:	4b28      	ldr	r3, [pc, #160]	; (406388 <_ZN7Stepper14execMoveHomingEv+0x258>)
  4062e6:	4798      	blx	r3
  4062e8:	4005      	ands	r5, r0
        write_success &= setTargetPosition(max_find_pulse_w);
  4062ea:	4639      	mov	r1, r7
  4062ec:	4620      	mov	r0, r4
  4062ee:	4b28      	ldr	r3, [pc, #160]	; (406390 <_ZN7Stepper14execMoveHomingEv+0x260>)
  4062f0:	4798      	blx	r3
  4062f2:	4005      	ands	r5, r0
        vTaskDelay(STATUS_UPDATE_FREQ_TICKS * 2);
  4062f4:	200a      	movs	r0, #10
  4062f6:	4b2a      	ldr	r3, [pc, #168]	; (4063a0 <_ZN7Stepper14execMoveHomingEv+0x270>)
  4062f8:	4798      	blx	r3
                                timeout_ticks);
  4062fa:	4633      	mov	r3, r6
  4062fc:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
  406300:	4621      	mov	r1, r4
  406302:	4620      	mov	r0, r4
  406304:	4e28      	ldr	r6, [pc, #160]	; (4063a8 <_ZN7Stepper14execMoveHomingEv+0x278>)
  406306:	47b0      	blx	r6
  406308:	f8ad 0004 	strh.w	r0, [sp, #4]
        rampStop();
  40630c:	4620      	mov	r0, r4
  40630e:	4b25      	ldr	r3, [pc, #148]	; (4063a4 <_ZN7Stepper14execMoveHomingEv+0x274>)
  406310:	4798      	blx	r3
  406312:	e780      	b.n	406216 <_ZN7Stepper14execMoveHomingEv+0xe6>
            results.condition_met = (freeze_event == FreezeEvent::STALL);
  406314:	2802      	cmp	r0, #2
  406316:	bf14      	ite	ne
  406318:	2000      	movne	r0, #0
  40631a:	2001      	moveq	r0, #1
  40631c:	f88d 0004 	strb.w	r0, [sp, #4]
  406320:	e778      	b.n	406214 <_ZN7Stepper14execMoveHomingEv+0xe4>
    if (!results.condition_met) { return HomingCode::H_MAX_PULSE_REACHED; }
  406322:	f89d 3004 	ldrb.w	r3, [sp, #4]
  406326:	b90b      	cbnz	r3, 40632c <_ZN7Stepper14execMoveHomingEv+0x1fc>
  406328:	2008      	movs	r0, #8
  40632a:	e70e      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
    setHomingMotion();
  40632c:	4620      	mov	r0, r4
  40632e:	4b17      	ldr	r3, [pc, #92]	; (40638c <_ZN7Stepper14execMoveHomingEv+0x25c>)
  406330:	4798      	blx	r3
    write_success &= setTargetPosition(homing_offset_w);
  406332:	4641      	mov	r1, r8
  406334:	4620      	mov	r0, r4
  406336:	4b16      	ldr	r3, [pc, #88]	; (406390 <_ZN7Stepper14execMoveHomingEv+0x260>)
  406338:	4798      	blx	r3
  40633a:	4005      	ands	r5, r0
  40633c:	b2ed      	uxtb	r5, r5
    vTaskDelay(STATUS_UPDATE_FREQ_TICKS * 2);
  40633e:	200a      	movs	r0, #10
  406340:	4b17      	ldr	r3, [pc, #92]	; (4063a0 <_ZN7Stepper14execMoveHomingEv+0x270>)
  406342:	4798      	blx	r3
    waitCompleteRun();
  406344:	4620      	mov	r0, r4
  406346:	4b19      	ldr	r3, [pc, #100]	; (4063ac <_ZN7Stepper14execMoveHomingEv+0x27c>)
  406348:	4798      	blx	r3
    if (isFrozen()) return HomingCode::H_FAILED_MIDWAY;
  40634a:	4620      	mov	r0, r4
  40634c:	4b09      	ldr	r3, [pc, #36]	; (406374 <_ZN7Stepper14execMoveHomingEv+0x244>)
  40634e:	4798      	blx	r3
  406350:	b108      	cbz	r0, 406356 <_ZN7Stepper14execMoveHomingEv+0x226>
  406352:	2009      	movs	r0, #9
  406354:	e6f9      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
    write_success &= setPosition(0);
  406356:	2100      	movs	r1, #0
  406358:	4620      	mov	r0, r4
  40635a:	4b0b      	ldr	r3, [pc, #44]	; (406388 <_ZN7Stepper14execMoveHomingEv+0x258>)
  40635c:	4798      	blx	r3
    if (!write_success) return HomingCode::H_WRITE_FAIL;
  40635e:	b105      	cbz	r5, 406362 <_ZN7Stepper14execMoveHomingEv+0x232>
  406360:	b928      	cbnz	r0, 40636e <_ZN7Stepper14execMoveHomingEv+0x23e>
  406362:	2002      	movs	r0, #2
  406364:	e6f1      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
            if (results.timed_out) { return HomingCode::H_TIMEOUT; }
  406366:	2007      	movs	r0, #7
  406368:	e6ef      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
        if (!results.condition_met) { return HomingCode::H_MAX_PULSE_REACHED; }
  40636a:	2008      	movs	r0, #8
  40636c:	e6ed      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
    return HomingCode::H_SUCCESS;
  40636e:	2001      	movs	r0, #1
  406370:	e6eb      	b.n	40614a <_ZN7Stepper14execMoveHomingEv+0x1a>
  406372:	bf00      	nop
  406374:	004063eb 	.word	0x004063eb
  406378:	004063e5 	.word	0x004063e5
  40637c:	0040643d 	.word	0x0040643d
  406380:	0040562d 	.word	0x0040562d
  406384:	004059a1 	.word	0x004059a1
  406388:	00406ccd 	.word	0x00406ccd
  40638c:	00405d25 	.word	0x00405d25
  406390:	00406cad 	.word	0x00406cad
  406394:	00404e8d 	.word	0x00404e8d
  406398:	004063f7 	.word	0x004063f7
  40639c:	00405f85 	.word	0x00405f85
  4063a0:	00409bd5 	.word	0x00409bd5
  4063a4:	00406cbd 	.word	0x00406cbd
  4063a8:	004060a9 	.word	0x004060a9
  4063ac:	00405381 	.word	0x00405381
  4063b0:	00405f99 	.word	0x00405f99
  4063b4:	00406021 	.word	0x00406021

004063b8 <_ZN7Stepper17moveHomingWrapperEPv>:
uint32_t Stepper::moveHomingWrapper(void *args) {
  4063b8:	b570      	push	{r4, r5, r6, lr}
  4063ba:	4604      	mov	r4, r0
    MotionItem *motion_item     = *motion_item_ptr;
  4063bc:	680e      	ldr	r6, [r1, #0]
    m_is_homing            = true;
  4063be:	2301      	movs	r3, #1
  4063c0:	f880 30a9 	strb.w	r3, [r0, #169]	; 0xa9
    HomingCode homing_code = execMoveHoming();
  4063c4:	4b05      	ldr	r3, [pc, #20]	; (4063dc <_ZN7Stepper17moveHomingWrapperEPv+0x24>)
  4063c6:	4798      	blx	r3
  4063c8:	4605      	mov	r5, r0
    m_is_homing            = false;
  4063ca:	2300      	movs	r3, #0
  4063cc:	f884 30a9 	strb.w	r3, [r4, #169]	; 0xa9
    delete motion_item; // free heap
  4063d0:	210c      	movs	r1, #12
  4063d2:	4630      	mov	r0, r6
  4063d4:	4b02      	ldr	r3, [pc, #8]	; (4063e0 <_ZN7Stepper17moveHomingWrapperEPv+0x28>)
  4063d6:	4798      	blx	r3
}
  4063d8:	4628      	mov	r0, r5
  4063da:	bd70      	pop	{r4, r5, r6, pc}
  4063dc:	00406131 	.word	0x00406131
  4063e0:	0040b2b5 	.word	0x0040b2b5

004063e4 <_ZN8TMC4361A9isRunningEv>:
/* ================================================================================== */
/*                                        Query                                       */
/* ================================================================================== */
bool                  TMC4361A::isTargetReached() { return m_target_reached; }
bool                  TMC4361A::isStalled() { return m_is_stalled; }
bool                  TMC4361A::isRunning() { return m_is_running; }
  4063e4:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
  4063e8:	4770      	bx	lr

004063ea <_ZN8TMC4361A8isFrozenEv>:
bool                  TMC4361A::isFrozen() { return m_is_frozen; }
  4063ea:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
  4063ee:	4770      	bx	lr

004063f0 <_ZN8TMC4361A16getSensorReadingEv>:
uint8_t               TMC4361A::getSensorReading() { return m_sensor_status; }
  4063f0:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
  4063f4:	4770      	bx	lr

004063f6 <_ZN8TMC4361A9whyFrozenEv>:
bool                  TMC4361A::hasPositionError() { return m_has_position_error; }
TMC4361A::FreezeEvent TMC4361A::whyFrozen() { return m_freeze_event; }
  4063f6:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
  4063fa:	4770      	bx	lr

004063fc <_ZN8TMC4361A13releaseDriverEv>:
    return succeed;
}

/* ---------------------------------------------------------------------------------- */
void TMC4361A::releaseDriver() {
    if (m_drv_enabled) {
  4063fc:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
  406400:	b903      	cbnz	r3, 406404 <_ZN8TMC4361A13releaseDriverEv+0x8>
  406402:	4770      	bx	lr
void TMC4361A::releaseDriver() {
  406404:	b510      	push	{r4, lr}
  406406:	4604      	mov	r4, r0
        ioport_set_pin_level(m_drv_en_pin, true);
  406408:	f890 2033 	ldrb.w	r2, [r0, #51]	; 0x33
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  40640c:	0953      	lsrs	r3, r2, #5
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (IOPORT_PIO_OFFSET * port));
  40640e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  406412:	f203 7307 	addw	r3, r3, #1799	; 0x707
  406416:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  406418:	f002 021f 	and.w	r2, r2, #31
  40641c:	2101      	movs	r1, #1
  40641e:	fa01 f202 	lsl.w	r2, r1, r2
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  406422:	631a      	str	r2, [r3, #48]	; 0x30
        delay_ms(20);
  406424:	4803      	ldr	r0, [pc, #12]	; (406434 <_ZN8TMC4361A13releaseDriverEv+0x38>)
  406426:	4b04      	ldr	r3, [pc, #16]	; (406438 <_ZN8TMC4361A13releaseDriverEv+0x3c>)
  406428:	4798      	blx	r3
        m_drv_enabled = false;
  40642a:	2300      	movs	r3, #0
  40642c:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
  406430:	bd10      	pop	{r4, pc}
  406432:	bf00      	nop
  406434:	000217b7 	.word	0x000217b7
  406438:	20000001 	.word	0x20000001

0040643c <_ZN8TMC4361A12enableDriverEv>:
    }
}

/* ---------------------------------------------------------------------------------- */
void TMC4361A::enableDriver() {
  40643c:	b538      	push	{r3, r4, r5, lr}
    if (!m_drv_enabled) {
  40643e:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
  406442:	b103      	cbz	r3, 406446 <_ZN8TMC4361A12enableDriverEv+0xa>
  406444:	bd38      	pop	{r3, r4, r5, pc}
  406446:	4604      	mov	r4, r0
        ioport_set_pin_level(m_drv_en_pin, false);
  406448:	f890 2033 	ldrb.w	r2, [r0, #51]	; 0x33
	return pin >> 5;
  40644c:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  40644e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  406452:	f203 7307 	addw	r3, r3, #1799	; 0x707
  406456:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  406458:	f002 021f 	and.w	r2, r2, #31
  40645c:	2501      	movs	r5, #1
  40645e:	fa05 f202 	lsl.w	r2, r5, r2
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  406462:	635a      	str	r2, [r3, #52]	; 0x34
        delay_ms(20);
  406464:	4802      	ldr	r0, [pc, #8]	; (406470 <_ZN8TMC4361A12enableDriverEv+0x34>)
  406466:	4b03      	ldr	r3, [pc, #12]	; (406474 <_ZN8TMC4361A12enableDriverEv+0x38>)
  406468:	4798      	blx	r3
        m_drv_enabled = true;
  40646a:	f884 5036 	strb.w	r5, [r4, #54]	; 0x36
    }
}
  40646e:	e7e9      	b.n	406444 <_ZN8TMC4361A12enableDriverEv+0x8>
  406470:	000217b7 	.word	0x000217b7
  406474:	20000001 	.word	0x20000001

00406478 <_ZN8TMC4361A17setDrv_mstepPerFsEt>:
    toggleNRST();
}

/* ---------------------------------------------------------------------------------- */
void TMC4361A::setDrv(TMC4361A::DrvSettings drv_s) { m_drv_s = drv_s; }
void TMC4361A::setDrv_mstepPerFs(uint16_t mstep_per_fs) { m_drv_s.mstep_per_fs = mstep_per_fs; }
  406478:	8001      	strh	r1, [r0, #0]
  40647a:	4770      	bx	lr

0040647c <_ZN8TMC4361A15setDrv_fsPerRevEt>:
void TMC4361A::setDrv_fsPerRev(uint16_t fs_per_rev) { m_drv_s.fs_per_rev = fs_per_rev; }
  40647c:	8041      	strh	r1, [r0, #2]
  40647e:	4770      	bx	lr

00406480 <_ZN8TMC4361A16setCurrent_iHoldEt>:

/* ---------------------------------------------------------------------------------- */
void TMC4361A::setCurrent(TMC4361A::CurrentSettings current_s) { m_current_s = current_s; }
void TMC4361A::setCurrent_iHold(uint16_t i_hold) { m_current_s.i_hold = (uint8_t)i_hold; }
  406480:	7181      	strb	r1, [r0, #6]
  406482:	4770      	bx	lr

00406484 <_ZN8TMC4361A15setCurrent_iRunEt>:
void TMC4361A::setCurrent_iRun(uint16_t i_run) { m_current_s.i_run = (uint8_t)i_run; }
  406484:	71c1      	strb	r1, [r0, #7]
  406486:	4770      	bx	lr

00406488 <_ZN8TMC4361A21setStopOnStall_enableEt>:

/* ---------------------------------------------------------------------------------- */
void TMC4361A::setStopOnStall(StallSettings stall_s) { m_stall_s = stall_s; }
void TMC4361A::setStopOnStall_enable(uint16_t enable) { m_stall_s.stop_on_stall = (bool)enable; }
  406488:	3100      	adds	r1, #0
  40648a:	bf18      	it	ne
  40648c:	2101      	movne	r1, #1
  40648e:	7281      	strb	r1, [r0, #10]
  406490:	4770      	bx	lr

00406492 <_ZN8TMC4361A21setStopOnStall_threshEt>:
void TMC4361A::setStopOnStall_thresh(uint16_t rpm) { m_stall_s.stall_thresh_rpm = rpm; }
  406492:	8181      	strh	r1, [r0, #12]
  406494:	4770      	bx	lr

00406496 <_ZN8TMC4361A20setClosedLoop_enableEt>:

/* ---------------------------------------------------------------------------------- */
void TMC4361A::setClosedLoop(ClosedLoopSettings cl_s) { m_cl_s = cl_s; }
void TMC4361A::setClosedLoop_enable(uint16_t enable) { m_cl_s.enable = (bool)enable; }
  406496:	3100      	adds	r1, #0
  406498:	bf18      	it	ne
  40649a:	2101      	movne	r1, #1
  40649c:	7381      	strb	r1, [r0, #14]
  40649e:	4770      	bx	lr

004064a0 <_ZN8TMC4361A20setClosedLoop_usePIDEt>:
void TMC4361A::setClosedLoop_usePID(uint16_t enable_pid) { m_cl_s.enable_pid = (bool)enable_pid; }
  4064a0:	3100      	adds	r1, #0
  4064a2:	bf18      	it	ne
  4064a4:	2101      	movne	r1, #1
  4064a6:	73c1      	strb	r1, [r0, #15]
  4064a8:	4770      	bx	lr

004064aa <_ZN8TMC4361A22setClosedLoop_encInResEt>:
void TMC4361A::setClosedLoop_encInRes(uint16_t enc_in_res) { m_cl_s.enc_in_res = enc_in_res; }
  4064aa:	8241      	strh	r1, [r0, #18]
  4064ac:	4770      	bx	lr

004064ae <_ZN8TMC4361A23setClosedLoop_toleranceEt>:
void TMC4361A::setClosedLoop_tolerance(uint16_t cl_tolerance) { m_cl_s.cl_tolerance = cl_tolerance; }
  4064ae:	8201      	strh	r1, [r0, #16]
  4064b0:	4770      	bx	lr

004064b2 <_ZN8TMC4361A23setStealthChopThresholdEt>:

/* ---------------------------------------------------------------------------------- */
void TMC4361A::setStealthChopThreshold(uint16_t rpm) { m_stealthchop_thresh_rpm = rpm; }
  4064b2:	8281      	strh	r1, [r0, #20]
  4064b4:	4770      	bx	lr
	...

004064b8 <_ZN8TMC4361A8spdToRpmEf>:
}

/* ================================================================================== */
/*                                        Maths                                       */
/* ================================================================================== */
float TMC4361A::spdToRpm(float speed) { return speed / m_drv_s.fs_per_rev / m_drv_s.mstep_per_fs * 60.0f; }
  4064b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4064ba:	4606      	mov	r6, r0
  4064bc:	460f      	mov	r7, r1
  4064be:	4d08      	ldr	r5, [pc, #32]	; (4064e0 <_ZN8TMC4361A8spdToRpmEf+0x28>)
  4064c0:	8840      	ldrh	r0, [r0, #2]
  4064c2:	47a8      	blx	r5
  4064c4:	4c07      	ldr	r4, [pc, #28]	; (4064e4 <_ZN8TMC4361A8spdToRpmEf+0x2c>)
  4064c6:	4601      	mov	r1, r0
  4064c8:	4638      	mov	r0, r7
  4064ca:	47a0      	blx	r4
  4064cc:	4607      	mov	r7, r0
  4064ce:	8830      	ldrh	r0, [r6, #0]
  4064d0:	47a8      	blx	r5
  4064d2:	4601      	mov	r1, r0
  4064d4:	4638      	mov	r0, r7
  4064d6:	47a0      	blx	r4
  4064d8:	4903      	ldr	r1, [pc, #12]	; (4064e8 <_ZN8TMC4361A8spdToRpmEf+0x30>)
  4064da:	4b04      	ldr	r3, [pc, #16]	; (4064ec <_ZN8TMC4361A8spdToRpmEf+0x34>)
  4064dc:	4798      	blx	r3
  4064de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4064e0:	0040bd39 	.word	0x0040bd39
  4064e4:	0040bf49 	.word	0x0040bf49
  4064e8:	42700000 	.word	0x42700000
  4064ec:	0040bde1 	.word	0x0040bde1

004064f0 <_ZN8TMC4361A11resetFreezeEv>:
/*                                        Misc                                        */
/* ================================================================================== */
void TMC4361A::raiseStallFlag() { m_stall_detected = true; }

/* ---------------------------------------------------------------------------------- */
void TMC4361A::resetFreeze() {
  4064f0:	b510      	push	{r4, lr}
  4064f2:	4604      	mov	r4, r0
    ioport_set_pin_level(m_nfreeze_pin, true);
  4064f4:	f890 2030 	ldrb.w	r2, [r0, #48]	; 0x30
	return pin >> 5;
  4064f8:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  4064fa:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4064fe:	f203 7307 	addw	r3, r3, #1799	; 0x707
  406502:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  406504:	f002 021f 	and.w	r2, r2, #31
  406508:	2101      	movs	r1, #1
  40650a:	fa01 f202 	lsl.w	r2, r1, r2
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40650e:	631a      	str	r2, [r3, #48]	; 0x30
    delay_ms(20);
  406510:	4803      	ldr	r0, [pc, #12]	; (406520 <_ZN8TMC4361A11resetFreezeEv+0x30>)
  406512:	4b04      	ldr	r3, [pc, #16]	; (406524 <_ZN8TMC4361A11resetFreezeEv+0x34>)
  406514:	4798      	blx	r3
    m_is_frozen = false;
  406516:	2300      	movs	r3, #0
  406518:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  40651c:	bd10      	pop	{r4, pc}
  40651e:	bf00      	nop
  406520:	000217b7 	.word	0x000217b7
  406524:	20000001 	.word	0x20000001

00406528 <_ZN8TMC4361A11raiseFreezeEv>:
}

/* ---------------------------------------------------------------------------------- */
void TMC4361A::raiseFreeze() {
  406528:	b538      	push	{r3, r4, r5, lr}
  40652a:	4604      	mov	r4, r0
    ioport_set_pin_level(m_nfreeze_pin, false);
  40652c:	f890 2030 	ldrb.w	r2, [r0, #48]	; 0x30
	return pin >> 5;
  406530:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  406532:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  406536:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40653a:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  40653c:	f002 021f 	and.w	r2, r2, #31
  406540:	2501      	movs	r5, #1
  406542:	fa05 f202 	lsl.w	r2, r5, r2
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  406546:	635a      	str	r2, [r3, #52]	; 0x34
    delay_ms(20);
  406548:	4802      	ldr	r0, [pc, #8]	; (406554 <_ZN8TMC4361A11raiseFreezeEv+0x2c>)
  40654a:	4b03      	ldr	r3, [pc, #12]	; (406558 <_ZN8TMC4361A11raiseFreezeEv+0x30>)
  40654c:	4798      	blx	r3
    m_is_frozen = true;
  40654e:	f884 5042 	strb.w	r5, [r4, #66]	; 0x42
  406552:	bd38      	pop	{r3, r4, r5, pc}
  406554:	000217b7 	.word	0x000217b7
  406558:	20000001 	.word	0x20000001

0040655c <_ZN8TMC4361A10toggleNRSTEv>:
}

/* ---------------------------------------------------------------------------------- */
void TMC4361A::toggleNRST() {
  40655c:	b538      	push	{r3, r4, r5, lr}
  40655e:	4605      	mov	r5, r0
    ioport_set_pin_level(m_nrst_pin, false);
  406560:	f890 2031 	ldrb.w	r2, [r0, #49]	; 0x31
	return pin >> 5;
  406564:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  406566:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40656a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40656e:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  406570:	f002 021f 	and.w	r2, r2, #31
  406574:	2401      	movs	r4, #1
  406576:	fa04 f202 	lsl.w	r2, r4, r2
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40657a:	635a      	str	r2, [r3, #52]	; 0x34
    delay_ms(20);
  40657c:	4807      	ldr	r0, [pc, #28]	; (40659c <_ZN8TMC4361A10toggleNRSTEv+0x40>)
  40657e:	4b08      	ldr	r3, [pc, #32]	; (4065a0 <_ZN8TMC4361A10toggleNRSTEv+0x44>)
  406580:	4798      	blx	r3
    ioport_set_pin_level(m_nrst_pin, true);
  406582:	f895 2031 	ldrb.w	r2, [r5, #49]	; 0x31
	return pin >> 5;
  406586:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  406588:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40658c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  406590:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  406592:	f002 021f 	and.w	r2, r2, #31
  406596:	4094      	lsls	r4, r2
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  406598:	631c      	str	r4, [r3, #48]	; 0x30
  40659a:	bd38      	pop	{r3, r4, r5, pc}
  40659c:	000217b7 	.word	0x000217b7
  4065a0:	20000001 	.word	0x20000001

004065a4 <_ZN8TMC4361AC1EP3SpiPPvhmhhhh>:
TMC4361A::TMC4361A(Spi *spi, xQueueHandle *spi_mutex, uint8_t spi_cs_pin, uint32_t fclk, uint8_t nfreeze_pin,
  4065a4:	b5f0      	push	{r4, r5, r6, r7, lr}
  4065a6:	b085      	sub	sp, #20
  4065a8:	4604      	mov	r4, r0
  4065aa:	f89d e030 	ldrb.w	lr, [sp, #48]	; 0x30
        OVERTEMP,          // overtemp
        TMC4361A_COMM_ERR, // motion controller communication error
        TMC5160_COMM_ERR,  // motor driver communication error
    };

    struct DrvSettings {
  4065ae:	f44f 7580 	mov.w	r5, #256	; 0x100
  4065b2:	8005      	strh	r5, [r0, #0]
  4065b4:	27c8      	movs	r7, #200	; 0xc8
  4065b6:	8047      	strh	r7, [r0, #2]
  4065b8:	25fb      	movs	r5, #251	; 0xfb
  4065ba:	7105      	strb	r5, [r0, #4]
        uint16_t mstep_per_fs      = 256;
        uint16_t fs_per_rev        = 0x0C8;
        uint8_t  mstatus_selection = 0xFB;
    };

    struct CurrentSettings {
  4065bc:	2500      	movs	r5, #0
  4065be:	7185      	strb	r5, [r0, #6]
  4065c0:	2610      	movs	r6, #16
  4065c2:	71c6      	strb	r6, [r0, #7]
  4065c4:	2604      	movs	r6, #4
  4065c6:	7206      	strb	r6, [r0, #8]
        uint8_t i_hold       = 0;  // default 25%
        uint8_t i_run        = 16; // default 50%
        uint8_t i_hold_delay = 4;
    };

    struct StallSettings {
  4065c8:	7285      	strb	r5, [r0, #10]
  4065ca:	2664      	movs	r6, #100	; 0x64
  4065cc:	8186      	strh	r6, [r0, #12]
        bool     stop_on_stall    = false; // stop / warn only
        uint16_t stall_thresh_rpm = 100;   // min rpm for stallguard to become active
    };

    struct ClosedLoopSettings {
  4065ce:	7385      	strb	r5, [r0, #14]
  4065d0:	73c5      	strb	r5, [r0, #15]
  4065d2:	8207      	strh	r7, [r0, #16]
  4065d4:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
  4065d8:	8246      	strh	r6, [r0, #18]
      m_nrst_pin(nrst_pin), m_intr_pin(intr_pin), m_drv_en_pin(drv_en_pin) {
  4065da:	26b4      	movs	r6, #180	; 0xb4
  4065dc:	8286      	strh	r6, [r0, #20]
  4065de:	6185      	str	r5, [r0, #24]
  4065e0:	61c5      	str	r5, [r0, #28]
  4065e2:	6201      	str	r1, [r0, #32]
  4065e4:	6242      	str	r2, [r0, #36]	; 0x24
  4065e6:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
  4065ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4065ec:	62c3      	str	r3, [r0, #44]	; 0x2c
  4065ee:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
  4065f2:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
  4065f6:	f880 e031 	strb.w	lr, [r0, #49]	; 0x31
  4065fa:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
  4065fe:	f880 3032 	strb.w	r3, [r0, #50]	; 0x32
  406602:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
  406606:	f880 3033 	strb.w	r3, [r0, #51]	; 0x33
  40660a:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  40660e:	f880 5035 	strb.w	r5, [r0, #53]	; 0x35
  406612:	f880 5036 	strb.w	r5, [r0, #54]	; 0x36
  406616:	f880 5037 	strb.w	r5, [r0, #55]	; 0x37
  40661a:	6385      	str	r5, [r0, #56]	; 0x38
  40661c:	f880 503c 	strb.w	r5, [r0, #60]	; 0x3c
  406620:	f880 503d 	strb.w	r5, [r0, #61]	; 0x3d
  406624:	f880 503e 	strb.w	r5, [r0, #62]	; 0x3e
  406628:	f880 503f 	strb.w	r5, [r0, #63]	; 0x3f
  40662c:	f880 5040 	strb.w	r5, [r0, #64]	; 0x40
  406630:	f880 5041 	strb.w	r5, [r0, #65]	; 0x41
  406634:	f880 5042 	strb.w	r5, [r0, #66]	; 0x42
  406638:	f880 5043 	strb.w	r5, [r0, #67]	; 0x43
  40663c:	2601      	movs	r6, #1
  40663e:	f880 6044 	strb.w	r6, [r0, #68]	; 0x44
  406642:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
	return pin >> 5;
  406646:	ea4f 135e 	mov.w	r3, lr, lsr #5
	       (IOPORT_PIO_OFFSET * port));
  40664a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40664e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  406652:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  406654:	f00e 0e1f 	and.w	lr, lr, #31
  406658:	fa06 f20e 	lsl.w	r2, r6, lr
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40665c:	611a      	str	r2, [r3, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40665e:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    ioport_set_pin_dir(m_nfreeze_pin, IOPORT_DIR_OUTPUT);
  406662:	f890 2030 	ldrb.w	r2, [r0, #48]	; 0x30
	return pin >> 5;
  406666:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  406668:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40666c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  406670:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  406672:	f002 021f 	and.w	r2, r2, #31
  406676:	fa06 f202 	lsl.w	r2, r6, r2
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40667a:	611a      	str	r2, [r3, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40667c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    ioport_set_pin_dir(m_drv_en_pin, IOPORT_DIR_OUTPUT);
  406680:	f890 2033 	ldrb.w	r2, [r0, #51]	; 0x33
	return pin >> 5;
  406684:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  406686:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40668a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40668e:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  406690:	f002 021f 	and.w	r2, r2, #31
  406694:	fa06 f202 	lsl.w	r2, r6, r2
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  406698:	611a      	str	r2, [r3, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40669a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    resetFreeze();
  40669e:	4b0b      	ldr	r3, [pc, #44]	; (4066cc <_ZN8TMC4361AC1EP3SpiPPvhmhhhh+0x128>)
  4066a0:	4798      	blx	r3
    toggleNRST();
  4066a2:	4620      	mov	r0, r4
  4066a4:	4b0a      	ldr	r3, [pc, #40]	; (4066d0 <_ZN8TMC4361AC1EP3SpiPPvhmhhhh+0x12c>)
  4066a6:	4798      	blx	r3
    releaseDriver();
  4066a8:	4620      	mov	r0, r4
  4066aa:	4b0a      	ldr	r3, [pc, #40]	; (4066d4 <_ZN8TMC4361AC1EP3SpiPPvhmhhhh+0x130>)
  4066ac:	4798      	blx	r3
    xTaskCreate(TMC4361A::task_stsMonitor,     // function name
  4066ae:	f104 0318 	add.w	r3, r4, #24
    );
  4066b2:	9503      	str	r5, [sp, #12]
  4066b4:	9502      	str	r5, [sp, #8]
  4066b6:	9301      	str	r3, [sp, #4]
  4066b8:	9600      	str	r6, [sp, #0]
  4066ba:	4623      	mov	r3, r4
  4066bc:	463a      	mov	r2, r7
  4066be:	4906      	ldr	r1, [pc, #24]	; (4066d8 <_ZN8TMC4361AC1EP3SpiPPvhmhhhh+0x134>)
  4066c0:	4806      	ldr	r0, [pc, #24]	; (4066dc <_ZN8TMC4361AC1EP3SpiPPvhmhhhh+0x138>)
  4066c2:	4d07      	ldr	r5, [pc, #28]	; (4066e0 <_ZN8TMC4361AC1EP3SpiPPvhmhhhh+0x13c>)
  4066c4:	47a8      	blx	r5
}
  4066c6:	4620      	mov	r0, r4
  4066c8:	b005      	add	sp, #20
  4066ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4066cc:	004064f1 	.word	0x004064f1
  4066d0:	0040655d 	.word	0x0040655d
  4066d4:	004063fd 	.word	0x004063fd
  4066d8:	0040e2b0 	.word	0x0040e2b0
  4066dc:	004069b9 	.word	0x004069b9
  4066e0:	00409659 	.word	0x00409659

004066e4 <_ZN8TMC4361A9hardResetEv>:
void TMC4361A::hardReset() {
  4066e4:	b510      	push	{r4, lr}
  4066e6:	4604      	mov	r4, r0
    resetFreeze();
  4066e8:	4b02      	ldr	r3, [pc, #8]	; (4066f4 <_ZN8TMC4361A9hardResetEv+0x10>)
  4066ea:	4798      	blx	r3
    toggleNRST();
  4066ec:	4620      	mov	r0, r4
  4066ee:	4b02      	ldr	r3, [pc, #8]	; (4066f8 <_ZN8TMC4361A9hardResetEv+0x14>)
  4066f0:	4798      	blx	r3
  4066f2:	bd10      	pop	{r4, pc}
  4066f4:	004064f1 	.word	0x004064f1
  4066f8:	0040655d 	.word	0x0040655d

004066fc <_ZN8TMC4361A21extractStatus_runningEm>:

/* ================================================================================== */
/*                                       Status                                       */
/* ================================================================================== */
bool    TMC4361A::readStatus(uint32_t *response) { return readRegister(TMC4361A_Reg::STATUS, response); }
bool    TMC4361A::extractStatus_running(uint32_t sts_resp) { return (sts_resp & 0x78) != 0; }
  4066fc:	f010 0f78 	tst.w	r0, #120	; 0x78
  406700:	bf14      	ite	ne
  406702:	2001      	movne	r0, #1
  406704:	2000      	moveq	r0, #0
  406706:	4770      	bx	lr

00406708 <_ZN8TMC4361A18extractStatus_flagENS_11StatusFlagsEm>:
bool    TMC4361A::extractStatus_flag(StatusFlags flag, uint32_t sts_resp) { return (sts_resp >> flag) & 1; }
  406708:	fa21 f000 	lsr.w	r0, r1, r0
  40670c:	f000 0001 	and.w	r0, r0, #1
  406710:	4770      	bx	lr

00406712 <_ZN8TMC4361A26extractStatus_driverStatusEm>:
uint8_t TMC4361A::extractStatus_driverStatus(uint32_t sts_resp) { return (sts_resp >> 24) & 0xFF; }
  406712:	0e00      	lsrs	r0, r0, #24
  406714:	4770      	bx	lr

00406716 <_ZN8TMC4361A20extractStatus_sensorEm>:
uint8_t TMC4361A::extractStatus_sensor(uint32_t sts_resp) { return (sts_resp >> 7) & 0x03; }
  406716:	f3c0 10c1 	ubfx	r0, r0, #7, #2
  40671a:	4770      	bx	lr

0040671c <_ZN8TMC4361A22deltaSqRpmToDeltaSqSpdEf>:
void TMC4361A::clearEvents() { writeRegister(TMC4361A_Reg::EVENTS, UINT32_MAX); }

/* ================================================================================== */
/*                                        Maths                                       */
/* ================================================================================== */
uint32_t TMC4361A::deltaSqRpmToDeltaSqSpd(float deltaSq_rpm) {
  40671c:	b510      	push	{r4, lr}
  40671e:	4604      	mov	r4, r0
    return static_cast<uint32_t>(deltaSq_rpm) * m_drv_s.fs_per_rev * m_drv_s.mstep_per_fs / 60 / 1024;
  406720:	4608      	mov	r0, r1
  406722:	4b06      	ldr	r3, [pc, #24]	; (40673c <_ZN8TMC4361A22deltaSqRpmToDeltaSqSpdEf+0x20>)
  406724:	4798      	blx	r3
  406726:	8863      	ldrh	r3, [r4, #2]
  406728:	fb03 f300 	mul.w	r3, r3, r0
  40672c:	8820      	ldrh	r0, [r4, #0]
  40672e:	fb00 f003 	mul.w	r0, r0, r3
  406732:	4b03      	ldr	r3, [pc, #12]	; (406740 <_ZN8TMC4361A22deltaSqRpmToDeltaSqSpdEf+0x24>)
  406734:	fba3 3000 	umull	r3, r0, r3, r0
}
  406738:	0bc0      	lsrs	r0, r0, #15
  40673a:	bd10      	pop	{r4, pc}
  40673c:	0040c1b9 	.word	0x0040c1b9
  406740:	88888889 	.word	0x88888889

00406744 <_ZN8TMC4361A18deltaRpmToDeltaSpdEf>:
uint32_t TMC4361A::deltaRpmToDeltaSpd(float delta_rpm) {
  406744:	b510      	push	{r4, lr}
  406746:	4604      	mov	r4, r0
    return static_cast<uint32_t>(delta_rpm) * m_drv_s.fs_per_rev * m_drv_s.mstep_per_fs / 60 / 1024;
  406748:	4608      	mov	r0, r1
  40674a:	4b06      	ldr	r3, [pc, #24]	; (406764 <_ZN8TMC4361A18deltaRpmToDeltaSpdEf+0x20>)
  40674c:	4798      	blx	r3
  40674e:	8863      	ldrh	r3, [r4, #2]
  406750:	fb03 f300 	mul.w	r3, r3, r0
  406754:	8820      	ldrh	r0, [r4, #0]
  406756:	fb00 f003 	mul.w	r0, r0, r3
  40675a:	4b03      	ldr	r3, [pc, #12]	; (406768 <_ZN8TMC4361A18deltaRpmToDeltaSpdEf+0x24>)
  40675c:	fba3 3000 	umull	r3, r0, r3, r0
}
  406760:	0bc0      	lsrs	r0, r0, #15
  406762:	bd10      	pop	{r4, pc}
  406764:	0040c1b9 	.word	0x0040c1b9
  406768:	88888889 	.word	0x88888889

0040676c <_ZN8TMC4361A8rpmToSpdEf>:
float TMC4361A::rpmToSpd(float rpm) { return rpm * m_drv_s.fs_per_rev * m_drv_s.mstep_per_fs / 60.0f; }
  40676c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40676e:	4606      	mov	r6, r0
  406770:	460f      	mov	r7, r1
  406772:	4d07      	ldr	r5, [pc, #28]	; (406790 <_ZN8TMC4361A8rpmToSpdEf+0x24>)
  406774:	8840      	ldrh	r0, [r0, #2]
  406776:	47a8      	blx	r5
  406778:	4c06      	ldr	r4, [pc, #24]	; (406794 <_ZN8TMC4361A8rpmToSpdEf+0x28>)
  40677a:	4639      	mov	r1, r7
  40677c:	47a0      	blx	r4
  40677e:	4607      	mov	r7, r0
  406780:	8830      	ldrh	r0, [r6, #0]
  406782:	47a8      	blx	r5
  406784:	4639      	mov	r1, r7
  406786:	47a0      	blx	r4
  406788:	4903      	ldr	r1, [pc, #12]	; (406798 <_ZN8TMC4361A8rpmToSpdEf+0x2c>)
  40678a:	4b04      	ldr	r3, [pc, #16]	; (40679c <_ZN8TMC4361A8rpmToSpdEf+0x30>)
  40678c:	4798      	blx	r3
  40678e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406790:	0040bd39 	.word	0x0040bd39
  406794:	0040bde1 	.word	0x0040bde1
  406798:	42700000 	.word	0x42700000
  40679c:	0040bf49 	.word	0x0040bf49

004067a0 <_ZN8TMC4361A12floatToFixedEfh>:

uint32_t TMC4361A::floatToFixed(float value, uint8_t decimalPlaces) {
  4067a0:	b510      	push	{r4, lr}
  4067a2:	4604      	mov	r4, r0
    value *= (float)(1 << decimalPlaces);
  4067a4:	2001      	movs	r0, #1
  4067a6:	4088      	lsls	r0, r1
  4067a8:	4b0e      	ldr	r3, [pc, #56]	; (4067e4 <_ZN8TMC4361A12floatToFixedEfh+0x44>)
  4067aa:	4798      	blx	r3
  4067ac:	4621      	mov	r1, r4
  4067ae:	4b0e      	ldr	r3, [pc, #56]	; (4067e8 <_ZN8TMC4361A12floatToFixedEfh+0x48>)
  4067b0:	4798      	blx	r3
  4067b2:	4604      	mov	r4, r0
    int32_t signed_val = (int32_t)((value > 0.0) ? (value + 0.5) : (value - 0.5));
  4067b4:	2100      	movs	r1, #0
  4067b6:	4b0d      	ldr	r3, [pc, #52]	; (4067ec <_ZN8TMC4361A12floatToFixedEfh+0x4c>)
  4067b8:	4798      	blx	r3
  4067ba:	b148      	cbz	r0, 4067d0 <_ZN8TMC4361A12floatToFixedEfh+0x30>
  4067bc:	4620      	mov	r0, r4
  4067be:	4b0c      	ldr	r3, [pc, #48]	; (4067f0 <_ZN8TMC4361A12floatToFixedEfh+0x50>)
  4067c0:	4798      	blx	r3
  4067c2:	2200      	movs	r2, #0
  4067c4:	4b0b      	ldr	r3, [pc, #44]	; (4067f4 <_ZN8TMC4361A12floatToFixedEfh+0x54>)
  4067c6:	4c0c      	ldr	r4, [pc, #48]	; (4067f8 <_ZN8TMC4361A12floatToFixedEfh+0x58>)
  4067c8:	47a0      	blx	r4
  4067ca:	4b0c      	ldr	r3, [pc, #48]	; (4067fc <_ZN8TMC4361A12floatToFixedEfh+0x5c>)
  4067cc:	4798      	blx	r3
  4067ce:	bd10      	pop	{r4, pc}
  4067d0:	4620      	mov	r0, r4
  4067d2:	4b07      	ldr	r3, [pc, #28]	; (4067f0 <_ZN8TMC4361A12floatToFixedEfh+0x50>)
  4067d4:	4798      	blx	r3
  4067d6:	2200      	movs	r2, #0
  4067d8:	4b06      	ldr	r3, [pc, #24]	; (4067f4 <_ZN8TMC4361A12floatToFixedEfh+0x54>)
  4067da:	4c09      	ldr	r4, [pc, #36]	; (406800 <_ZN8TMC4361A12floatToFixedEfh+0x60>)
  4067dc:	47a0      	blx	r4
  4067de:	4b07      	ldr	r3, [pc, #28]	; (4067fc <_ZN8TMC4361A12floatToFixedEfh+0x5c>)
  4067e0:	4798      	blx	r3

    return static_cast<uint32_t>(signed_val);
}
  4067e2:	bd10      	pop	{r4, pc}
  4067e4:	0040bd39 	.word	0x0040bd39
  4067e8:	0040bde1 	.word	0x0040bde1
  4067ec:	0040c159 	.word	0x0040c159
  4067f0:	0040b609 	.word	0x0040b609
  4067f4:	3fe00000 	.word	0x3fe00000
  4067f8:	0040b34d 	.word	0x0040b34d
  4067fc:	0040bad5 	.word	0x0040bad5
  406800:	0040b349 	.word	0x0040b349

00406804 <_ZN8TMC4361A11spiTransferEhmPm>:
    xSemaphoreGive(*m_spi_mutex);
    return succeed;
}

/* ---------------------------------------------------------------------------------- */
bool TMC4361A::spiTransfer(uint8_t address, uint32_t data, uint32_t *response) {
  406804:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  406808:	b084      	sub	sp, #16
  40680a:	4607      	mov	r7, r0
  40680c:	461c      	mov	r4, r3
    uint8_t       tx_buf[5] = {0};
  40680e:	2300      	movs	r3, #0
    uint8_t       rx_buf[5] = {0};
  406810:	9300      	str	r3, [sp, #0]
  406812:	f88d 3004 	strb.w	r3, [sp, #4]
    status_code_t spi_status;

    tx_buf[0] = address;
  406816:	f88d 1008 	strb.w	r1, [sp, #8]
    tx_buf[1] = (data >> 24) & 0xFF;
  40681a:	0e13      	lsrs	r3, r2, #24
  40681c:	f88d 3009 	strb.w	r3, [sp, #9]
    tx_buf[2] = (data >> 16) & 0xFF;
  406820:	f3c2 4307 	ubfx	r3, r2, #16, #8
  406824:	f88d 300a 	strb.w	r3, [sp, #10]
    tx_buf[3] = (data >> 8) & 0xFF;
  406828:	f3c2 2307 	ubfx	r3, r2, #8, #8
  40682c:	f88d 300b 	strb.w	r3, [sp, #11]
    tx_buf[4] = data & 0xFF;
  406830:	f88d 200c 	strb.w	r2, [sp, #12]

    ioport_set_pin_level(m_spi_cs_pin, false);
  406834:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
	return pin >> 5;
  406838:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  40683a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40683e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  406842:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  406844:	f002 021f 	and.w	r2, r2, #31
  406848:	2601      	movs	r6, #1
  40684a:	fa06 f202 	lsl.w	r2, r6, r2
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40684e:	635a      	str	r2, [r3, #52]	; 0x34
    delay_us(1);
  406850:	2007      	movs	r0, #7
  406852:	f8df 8060 	ldr.w	r8, [pc, #96]	; 4068b4 <_ZN8TMC4361A11spiTransferEhmPm+0xb0>
  406856:	47c0      	blx	r8
    spi_status = spi_transceive_packet(m_spi, tx_buf, rx_buf, 5);
  406858:	2305      	movs	r3, #5
  40685a:	466a      	mov	r2, sp
  40685c:	a902      	add	r1, sp, #8
  40685e:	6a38      	ldr	r0, [r7, #32]
  406860:	4d13      	ldr	r5, [pc, #76]	; (4068b0 <_ZN8TMC4361A11spiTransferEhmPm+0xac>)
  406862:	47a8      	blx	r5
  406864:	4605      	mov	r5, r0
    delay_us(1);
  406866:	2007      	movs	r0, #7
  406868:	47c0      	blx	r8
    ioport_set_pin_level(m_spi_cs_pin, true);
  40686a:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
	return pin >> 5;
  40686e:	0953      	lsrs	r3, r2, #5
	       (IOPORT_PIO_OFFSET * port));
  406870:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  406874:	f203 7307 	addw	r3, r3, #1799	; 0x707
  406878:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
  40687a:	f002 021f 	and.w	r2, r2, #31
  40687e:	4096      	lsls	r6, r2
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  406880:	631e      	str	r6, [r3, #48]	; 0x30

    if (response != nullptr) {
  406882:	b174      	cbz	r4, 4068a2 <_ZN8TMC4361A11spiTransferEhmPm+0x9e>
        *response = ((uint32_t)rx_buf[1] << 24) | ((uint32_t)rx_buf[2] << 16) | ((uint32_t)rx_buf[3] << 8) |
  406884:	f89d 2001 	ldrb.w	r2, [sp, #1]
  406888:	f89d 3002 	ldrb.w	r3, [sp, #2]
  40688c:	041b      	lsls	r3, r3, #16
  40688e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  406892:	f89d 2003 	ldrb.w	r2, [sp, #3]
  406896:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                    (uint32_t)rx_buf[4];
  40689a:	f89d 2004 	ldrb.w	r2, [sp, #4]
        *response = ((uint32_t)rx_buf[1] << 24) | ((uint32_t)rx_buf[2] << 16) | ((uint32_t)rx_buf[3] << 8) |
  40689e:	4313      	orrs	r3, r2
  4068a0:	6023      	str	r3, [r4, #0]
    }

    return spi_status == status_code::STATUS_OK;
}
  4068a2:	fab5 f085 	clz	r0, r5
  4068a6:	0940      	lsrs	r0, r0, #5
  4068a8:	b004      	add	sp, #16
  4068aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4068ae:	bf00      	nop
  4068b0:	0040a835 	.word	0x0040a835
  4068b4:	20000001 	.word	0x20000001

004068b8 <_ZN8TMC4361A12readRegisterEhPm>:
    if (response == nullptr) return false;
  4068b8:	b322      	cbz	r2, 406904 <_ZN8TMC4361A12readRegisterEhPm+0x4c>
bool TMC4361A::readRegister(uint8_t reg_addr, uint32_t *response) {
  4068ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4068bc:	4616      	mov	r6, r2
  4068be:	460d      	mov	r5, r1
  4068c0:	4604      	mov	r4, r0
    xSemaphoreTake(*m_spi_mutex, portMAX_DELAY);
  4068c2:	6a40      	ldr	r0, [r0, #36]	; 0x24
  4068c4:	2300      	movs	r3, #0
  4068c6:	f04f 32ff 	mov.w	r2, #4294967295
  4068ca:	4619      	mov	r1, r3
  4068cc:	6800      	ldr	r0, [r0, #0]
  4068ce:	4f0e      	ldr	r7, [pc, #56]	; (406908 <_ZN8TMC4361A12readRegisterEhPm+0x50>)
  4068d0:	47b8      	blx	r7
    spiTransfer(reg_addr & 0x7F, 0); // dummy call
  4068d2:	f005 057f 	and.w	r5, r5, #127	; 0x7f
  4068d6:	2300      	movs	r3, #0
  4068d8:	461a      	mov	r2, r3
  4068da:	4629      	mov	r1, r5
  4068dc:	4620      	mov	r0, r4
  4068de:	4f0b      	ldr	r7, [pc, #44]	; (40690c <_ZN8TMC4361A12readRegisterEhPm+0x54>)
  4068e0:	47b8      	blx	r7
    spiTransfer(reg_addr & 0x7F, 0, response);
  4068e2:	4633      	mov	r3, r6
  4068e4:	2200      	movs	r2, #0
  4068e6:	4629      	mov	r1, r5
  4068e8:	4620      	mov	r0, r4
  4068ea:	47b8      	blx	r7
    xSemaphoreGive(*m_spi_mutex);
  4068ec:	6a60      	ldr	r0, [r4, #36]	; 0x24
  4068ee:	2300      	movs	r3, #0
  4068f0:	461a      	mov	r2, r3
  4068f2:	4619      	mov	r1, r3
  4068f4:	6800      	ldr	r0, [r0, #0]
  4068f6:	4c06      	ldr	r4, [pc, #24]	; (406910 <_ZN8TMC4361A12readRegisterEhPm+0x58>)
  4068f8:	47a0      	blx	r4
    return *response != 0xFFFFFFFF;
  4068fa:	6830      	ldr	r0, [r6, #0]
  4068fc:	3001      	adds	r0, #1
  4068fe:	bf18      	it	ne
  406900:	2001      	movne	r0, #1
  406902:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (response == nullptr) return false;
  406904:	2000      	movs	r0, #0
  406906:	4770      	bx	lr
  406908:	00409421 	.word	0x00409421
  40690c:	00406805 	.word	0x00406805
  406910:	00409209 	.word	0x00409209

00406914 <_ZN8TMC4361A19getInternalPositionEv>:
int32_t TMC4361A::getInternalPosition() {
  406914:	b500      	push	{lr}
  406916:	b083      	sub	sp, #12
    readRegister(TMC4361A_Reg::XACTUAL, &response);
  406918:	aa01      	add	r2, sp, #4
  40691a:	2121      	movs	r1, #33	; 0x21
  40691c:	4b02      	ldr	r3, [pc, #8]	; (406928 <_ZN8TMC4361A19getInternalPositionEv+0x14>)
  40691e:	4798      	blx	r3
}
  406920:	9801      	ldr	r0, [sp, #4]
  406922:	b003      	add	sp, #12
  406924:	f85d fb04 	ldr.w	pc, [sp], #4
  406928:	004068b9 	.word	0x004068b9

0040692c <_ZN8TMC4361A6emStopENS_11FreezeEventE>:
void TMC4361A::emStop(FreezeEvent freeze_event) {
  40692c:	b538      	push	{r3, r4, r5, lr}
  40692e:	4604      	mov	r4, r0
  406930:	460d      	mov	r5, r1
    raiseFreeze();
  406932:	4b09      	ldr	r3, [pc, #36]	; (406958 <_ZN8TMC4361A6emStopENS_11FreezeEventE+0x2c>)
  406934:	4798      	blx	r3
    m_freeze_event = freeze_event;
  406936:	f884 5043 	strb.w	r5, [r4, #67]	; 0x43
    m_is_running   = false;
  40693a:	2300      	movs	r3, #0
  40693c:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
    if (m_freeze_event == FreezeEvent::USER) {
  406940:	2d01      	cmp	r5, #1
  406942:	d000      	beq.n	406946 <_ZN8TMC4361A6emStopENS_11FreezeEventE+0x1a>
  406944:	bd38      	pop	{r3, r4, r5, pc}
        m_cached_position            = getInternalPosition();
  406946:	4620      	mov	r0, r4
  406948:	4b04      	ldr	r3, [pc, #16]	; (40695c <_ZN8TMC4361A6emStopENS_11FreezeEventE+0x30>)
  40694a:	4798      	blx	r3
  40694c:	63a0      	str	r0, [r4, #56]	; 0x38
        m_write_position_after_reset = true;
  40694e:	2301      	movs	r3, #1
  406950:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
}
  406954:	e7f6      	b.n	406944 <_ZN8TMC4361A6emStopENS_11FreezeEventE+0x18>
  406956:	bf00      	nop
  406958:	00406529 	.word	0x00406529
  40695c:	00406915 	.word	0x00406915

00406960 <_ZN8TMC4361A18getEncoderPositionEv>:
int32_t TMC4361A::getEncoderPosition() {
  406960:	b500      	push	{lr}
  406962:	b083      	sub	sp, #12
    readRegister(TMC4361A_Reg::ENC_POS, &response);
  406964:	aa01      	add	r2, sp, #4
  406966:	2150      	movs	r1, #80	; 0x50
  406968:	4b02      	ldr	r3, [pc, #8]	; (406974 <_ZN8TMC4361A18getEncoderPositionEv+0x14>)
  40696a:	4798      	blx	r3
}
  40696c:	9801      	ldr	r0, [sp, #4]
  40696e:	b003      	add	sp, #12
  406970:	f85d fb04 	ldr.w	pc, [sp], #4
  406974:	004068b9 	.word	0x004068b9

00406978 <_ZN8TMC4361A15getCurrentSpeedEv>:
int32_t TMC4361A::getCurrentSpeed() {
  406978:	b500      	push	{lr}
  40697a:	b083      	sub	sp, #12
    readRegister(TMC4361A_Reg::VACTUAL, &response);
  40697c:	aa01      	add	r2, sp, #4
  40697e:	2122      	movs	r1, #34	; 0x22
  406980:	4b02      	ldr	r3, [pc, #8]	; (40698c <_ZN8TMC4361A15getCurrentSpeedEv+0x14>)
  406982:	4798      	blx	r3
}
  406984:	9801      	ldr	r0, [sp, #4]
  406986:	b003      	add	sp, #12
  406988:	f85d fb04 	ldr.w	pc, [sp], #4
  40698c:	004068b9 	.word	0x004068b9

00406990 <_ZN8TMC4361A16getEncoderPosDevEv>:
uint32_t TMC4361A::getEncoderPosDev() {
  406990:	b500      	push	{lr}
  406992:	b083      	sub	sp, #12
    readRegister(TMC4361A_Reg::ENC_POS_DEV_RD, &response);
  406994:	aa01      	add	r2, sp, #4
  406996:	2152      	movs	r1, #82	; 0x52
  406998:	4b02      	ldr	r3, [pc, #8]	; (4069a4 <_ZN8TMC4361A16getEncoderPosDevEv+0x14>)
  40699a:	4798      	blx	r3
}
  40699c:	9801      	ldr	r0, [sp, #4]
  40699e:	b003      	add	sp, #12
  4069a0:	f85d fb04 	ldr.w	pc, [sp], #4
  4069a4:	004068b9 	.word	0x004068b9

004069a8 <_ZN8TMC4361A10readStatusEPm>:
bool    TMC4361A::readStatus(uint32_t *response) { return readRegister(TMC4361A_Reg::STATUS, response); }
  4069a8:	b508      	push	{r3, lr}
  4069aa:	460a      	mov	r2, r1
  4069ac:	210f      	movs	r1, #15
  4069ae:	4b01      	ldr	r3, [pc, #4]	; (4069b4 <_ZN8TMC4361A10readStatusEPm+0xc>)
  4069b0:	4798      	blx	r3
  4069b2:	bd08      	pop	{r3, pc}
  4069b4:	004068b9 	.word	0x004068b9

004069b8 <_ZN8TMC4361A15task_stsMonitorEPv>:
void TMC4361A::task_stsMonitor(void *parameters) {
  4069b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4069ba:	b083      	sub	sp, #12
  4069bc:	4604      	mov	r4, r0
    self->m_rtos_inited = true;
  4069be:	2301      	movs	r3, #1
  4069c0:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  4069c4:	e047      	b.n	406a56 <_ZN8TMC4361A15task_stsMonitorEPv+0x9e>
        read_success = self->readStatus(&sts_resp);
  4069c6:	a901      	add	r1, sp, #4
  4069c8:	4620      	mov	r0, r4
  4069ca:	4b33      	ldr	r3, [pc, #204]	; (406a98 <_ZN8TMC4361A15task_stsMonitorEPv+0xe0>)
  4069cc:	4798      	blx	r3
        if (!read_success) {
  4069ce:	2800      	cmp	r0, #0
  4069d0:	d03d      	beq.n	406a4e <_ZN8TMC4361A15task_stsMonitorEPv+0x96>
        self->m_is_running = self->extractStatus_running(sts_resp);
  4069d2:	9d01      	ldr	r5, [sp, #4]
  4069d4:	4628      	mov	r0, r5
  4069d6:	4b31      	ldr	r3, [pc, #196]	; (406a9c <_ZN8TMC4361A15task_stsMonitorEPv+0xe4>)
  4069d8:	4798      	blx	r3
  4069da:	f884 003f 	strb.w	r0, [r4, #63]	; 0x3f
        driver_status = self->extractStatus_driverStatus(sts_resp);
  4069de:	4628      	mov	r0, r5
  4069e0:	4b2f      	ldr	r3, [pc, #188]	; (406aa0 <_ZN8TMC4361A15task_stsMonitorEPv+0xe8>)
  4069e2:	4798      	blx	r3
  4069e4:	f000 0310 	and.w	r3, r0, #16
  4069e8:	f000 0504 	and.w	r5, r0, #4
  4069ec:	f000 0602 	and.w	r6, r0, #2
        if (coil_a_short || coil_b_short) { self->emStop(FreezeEvent::COIL_SHORT); }
  4069f0:	f010 0f08 	tst.w	r0, #8
  4069f4:	d100      	bne.n	4069f8 <_ZN8TMC4361A15task_stsMonitorEPv+0x40>
  4069f6:	b11b      	cbz	r3, 406a00 <_ZN8TMC4361A15task_stsMonitorEPv+0x48>
  4069f8:	2105      	movs	r1, #5
  4069fa:	4620      	mov	r0, r4
  4069fc:	4b29      	ldr	r3, [pc, #164]	; (406aa4 <_ZN8TMC4361A15task_stsMonitorEPv+0xec>)
  4069fe:	4798      	blx	r3
        if (overtemp_warning || overtemp_shutdown) { self->emStop(FreezeEvent::OVERTEMP); }
  406a00:	b905      	cbnz	r5, 406a04 <_ZN8TMC4361A15task_stsMonitorEPv+0x4c>
  406a02:	b11e      	cbz	r6, 406a0c <_ZN8TMC4361A15task_stsMonitorEPv+0x54>
  406a04:	2106      	movs	r1, #6
  406a06:	4620      	mov	r0, r4
  406a08:	4b26      	ldr	r3, [pc, #152]	; (406aa4 <_ZN8TMC4361A15task_stsMonitorEPv+0xec>)
  406a0a:	4798      	blx	r3
        self->m_sensor_status  = self->extractStatus_sensor(sts_resp);
  406a0c:	9d01      	ldr	r5, [sp, #4]
  406a0e:	4628      	mov	r0, r5
  406a10:	4b25      	ldr	r3, [pc, #148]	; (406aa8 <_ZN8TMC4361A15task_stsMonitorEPv+0xf0>)
  406a12:	4798      	blx	r3
  406a14:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
        self->m_target_reached = self->extractStatus_flag(TMC4361A::StatusFlags::TARGET_REACHED_F, sts_resp);
  406a18:	4629      	mov	r1, r5
  406a1a:	2000      	movs	r0, #0
  406a1c:	4e23      	ldr	r6, [pc, #140]	; (406aac <_ZN8TMC4361A15task_stsMonitorEPv+0xf4>)
  406a1e:	47b0      	blx	r6
  406a20:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
        self->m_is_stalled         = self->extractStatus_flag(TMC4361A::StatusFlags::ACTIVE_STALL_F, sts_resp);
  406a24:	4629      	mov	r1, r5
  406a26:	200b      	movs	r0, #11
  406a28:	47b0      	blx	r6
  406a2a:	4607      	mov	r7, r0
  406a2c:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
        self->m_has_position_error = self->extractStatus_flag(TMC4361A::StatusFlags::ENC_FAIL_F, sts_resp);
  406a30:	4629      	mov	r1, r5
  406a32:	200e      	movs	r0, #14
  406a34:	47b0      	blx	r6
  406a36:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
        if (self->m_cl_s.enable && self->m_has_position_error) {
  406a3a:	7ba3      	ldrb	r3, [r4, #14]
  406a3c:	b313      	cbz	r3, 406a84 <_ZN8TMC4361A15task_stsMonitorEPv+0xcc>
  406a3e:	b308      	cbz	r0, 406a84 <_ZN8TMC4361A15task_stsMonitorEPv+0xcc>
            if (!self->m_ignore_next_stall) { self->emStop(FreezeEvent::POS_ERR); }
  406a40:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  406a44:	b1cb      	cbz	r3, 406a7a <_ZN8TMC4361A15task_stsMonitorEPv+0xc2>
            self->m_ignore_next_stall = false;
  406a46:	2300      	movs	r3, #0
  406a48:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  406a4c:	e003      	b.n	406a56 <_ZN8TMC4361A15task_stsMonitorEPv+0x9e>
            self->emStop(FreezeEvent::TMC4361A_COMM_ERR);
  406a4e:	2107      	movs	r1, #7
  406a50:	4620      	mov	r0, r4
  406a52:	4b14      	ldr	r3, [pc, #80]	; (406aa4 <_ZN8TMC4361A15task_stsMonitorEPv+0xec>)
  406a54:	4798      	blx	r3
        vTaskDelay(self->STATUS_UPDATE_FREQ_TICKS);
  406a56:	2005      	movs	r0, #5
  406a58:	4b15      	ldr	r3, [pc, #84]	; (406ab0 <_ZN8TMC4361A15task_stsMonitorEPv+0xf8>)
  406a5a:	4798      	blx	r3
        uint32_t sts_resp     = 0;
  406a5c:	2300      	movs	r3, #0
  406a5e:	9301      	str	r3, [sp, #4]
        if (self->m_is_frozen) {
  406a60:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
  406a64:	2b00      	cmp	r3, #0
  406a66:	d1f6      	bne.n	406a56 <_ZN8TMC4361A15task_stsMonitorEPv+0x9e>
        if (self->m_drv_no_comm) {
  406a68:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
  406a6c:	2b00      	cmp	r3, #0
  406a6e:	d0aa      	beq.n	4069c6 <_ZN8TMC4361A15task_stsMonitorEPv+0xe>
            self->emStop(FreezeEvent::TMC5160_COMM_ERR);
  406a70:	2108      	movs	r1, #8
  406a72:	4620      	mov	r0, r4
  406a74:	4b0b      	ldr	r3, [pc, #44]	; (406aa4 <_ZN8TMC4361A15task_stsMonitorEPv+0xec>)
  406a76:	4798      	blx	r3
            continue;
  406a78:	e7ed      	b.n	406a56 <_ZN8TMC4361A15task_stsMonitorEPv+0x9e>
            if (!self->m_ignore_next_stall) { self->emStop(FreezeEvent::POS_ERR); }
  406a7a:	2103      	movs	r1, #3
  406a7c:	4620      	mov	r0, r4
  406a7e:	4b09      	ldr	r3, [pc, #36]	; (406aa4 <_ZN8TMC4361A15task_stsMonitorEPv+0xec>)
  406a80:	4798      	blx	r3
  406a82:	e7e0      	b.n	406a46 <_ZN8TMC4361A15task_stsMonitorEPv+0x8e>
        } else if (self->m_stall_s.stop_on_stall && self->m_is_stalled) {
  406a84:	7aa3      	ldrb	r3, [r4, #10]
  406a86:	2b00      	cmp	r3, #0
  406a88:	d0e5      	beq.n	406a56 <_ZN8TMC4361A15task_stsMonitorEPv+0x9e>
  406a8a:	2f00      	cmp	r7, #0
  406a8c:	d0e3      	beq.n	406a56 <_ZN8TMC4361A15task_stsMonitorEPv+0x9e>
            self->emStop(FreezeEvent::STALL);
  406a8e:	2102      	movs	r1, #2
  406a90:	4620      	mov	r0, r4
  406a92:	4b04      	ldr	r3, [pc, #16]	; (406aa4 <_ZN8TMC4361A15task_stsMonitorEPv+0xec>)
  406a94:	4798      	blx	r3
  406a96:	e7de      	b.n	406a56 <_ZN8TMC4361A15task_stsMonitorEPv+0x9e>
  406a98:	004069a9 	.word	0x004069a9
  406a9c:	004066fd 	.word	0x004066fd
  406aa0:	00406713 	.word	0x00406713
  406aa4:	0040692d 	.word	0x0040692d
  406aa8:	00406717 	.word	0x00406717
  406aac:	00406709 	.word	0x00406709
  406ab0:	00409bd5 	.word	0x00409bd5

00406ab4 <_ZN8TMC4361A9readEventEPm>:
bool TMC4361A::readEvent(uint32_t *response) { return readRegister(TMC4361A_Reg::EVENTS, response); }
  406ab4:	b508      	push	{r3, lr}
  406ab6:	460a      	mov	r2, r1
  406ab8:	210e      	movs	r1, #14
  406aba:	4b01      	ldr	r3, [pc, #4]	; (406ac0 <_ZN8TMC4361A9readEventEPm+0xc>)
  406abc:	4798      	blx	r3
  406abe:	bd08      	pop	{r3, pc}
  406ac0:	004068b9 	.word	0x004068b9

00406ac4 <_ZN8TMC4361A16waitForCoverDoneEv>:
bool TMC4361A::waitForCoverDone() {
  406ac4:	b510      	push	{r4, lr}
  406ac6:	b082      	sub	sp, #8
  406ac8:	4604      	mov	r4, r0
    while (readEvent(&events)) {
  406aca:	a901      	add	r1, sp, #4
  406acc:	4620      	mov	r0, r4
  406ace:	4b05      	ldr	r3, [pc, #20]	; (406ae4 <_ZN8TMC4361A16waitForCoverDoneEv+0x20>)
  406ad0:	4798      	blx	r3
  406ad2:	4602      	mov	r2, r0
  406ad4:	b118      	cbz	r0, 406ade <_ZN8TMC4361A16waitForCoverDoneEv+0x1a>
        if (events & (1 << TMC4361A::Events::COVER_DONE)) { return true; }
  406ad6:	9b01      	ldr	r3, [sp, #4]
  406ad8:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
  406adc:	d0f5      	beq.n	406aca <_ZN8TMC4361A16waitForCoverDoneEv+0x6>
}
  406ade:	4610      	mov	r0, r2
  406ae0:	b002      	add	sp, #8
  406ae2:	bd10      	pop	{r4, pc}
  406ae4:	00406ab5 	.word	0x00406ab5

00406ae8 <_ZN8TMC4361A13writeRegisterEhm>:
bool TMC4361A::writeRegister(uint8_t reg_addr, uint32_t data) {
  406ae8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406aea:	4604      	mov	r4, r0
  406aec:	460d      	mov	r5, r1
  406aee:	4616      	mov	r6, r2
    xSemaphoreTake(*m_spi_mutex, portMAX_DELAY);
  406af0:	6a40      	ldr	r0, [r0, #36]	; 0x24
  406af2:	2300      	movs	r3, #0
  406af4:	f04f 32ff 	mov.w	r2, #4294967295
  406af8:	4619      	mov	r1, r3
  406afa:	6800      	ldr	r0, [r0, #0]
  406afc:	4f09      	ldr	r7, [pc, #36]	; (406b24 <_ZN8TMC4361A13writeRegisterEhm+0x3c>)
  406afe:	47b8      	blx	r7
    bool succeed = spiTransfer(reg_addr | 0x80, data);
  406b00:	2300      	movs	r3, #0
  406b02:	4632      	mov	r2, r6
  406b04:	f045 0180 	orr.w	r1, r5, #128	; 0x80
  406b08:	4620      	mov	r0, r4
  406b0a:	4d07      	ldr	r5, [pc, #28]	; (406b28 <_ZN8TMC4361A13writeRegisterEhm+0x40>)
  406b0c:	47a8      	blx	r5
  406b0e:	4605      	mov	r5, r0
    xSemaphoreGive(*m_spi_mutex);
  406b10:	6a60      	ldr	r0, [r4, #36]	; 0x24
  406b12:	2300      	movs	r3, #0
  406b14:	461a      	mov	r2, r3
  406b16:	4619      	mov	r1, r3
  406b18:	6800      	ldr	r0, [r0, #0]
  406b1a:	4c04      	ldr	r4, [pc, #16]	; (406b2c <_ZN8TMC4361A13writeRegisterEhm+0x44>)
  406b1c:	47a0      	blx	r4
}
  406b1e:	4628      	mov	r0, r5
  406b20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406b22:	bf00      	nop
  406b24:	00409421 	.word	0x00409421
  406b28:	00406805 	.word	0x00406805
  406b2c:	00409209 	.word	0x00409209

00406b30 <_ZN8TMC4361A11setRampModeENS_8RampModeENS_8RampTypeE>:
bool TMC4361A::setRampMode(TMC4361A::RampMode mode, TMC4361A::RampType type) {
  406b30:	b508      	push	{r3, lr}
    return writeRegister(TMC4361A_Reg::RAMPMODE, write_value);
  406b32:	430a      	orrs	r2, r1
  406b34:	2120      	movs	r1, #32
  406b36:	4b01      	ldr	r3, [pc, #4]	; (406b3c <_ZN8TMC4361A11setRampModeENS_8RampModeENS_8RampTypeE+0xc>)
  406b38:	4798      	blx	r3
}
  406b3a:	bd08      	pop	{r3, pc}
  406b3c:	00406ae9 	.word	0x00406ae9

00406b40 <_ZN8TMC4361A9setSpeedsEffff>:
bool TMC4361A::setSpeeds(float max_speed, float start_speed, float stop_speed, float break_speed) {
  406b40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  406b44:	4605      	mov	r5, r0
  406b46:	4690      	mov	r8, r2
  406b48:	461f      	mov	r7, r3
    uint32_t max_speed_w   = floatToFixed(rpmToSpd(max_speed), 8);
  406b4a:	4e18      	ldr	r6, [pc, #96]	; (406bac <_ZN8TMC4361A9setSpeedsEffff+0x6c>)
  406b4c:	47b0      	blx	r6
  406b4e:	2108      	movs	r1, #8
  406b50:	4c17      	ldr	r4, [pc, #92]	; (406bb0 <_ZN8TMC4361A9setSpeedsEffff+0x70>)
  406b52:	47a0      	blx	r4
  406b54:	4682      	mov	sl, r0
    uint32_t start_speed_w = floatToFixed(rpmToSpd(start_speed), 8);
  406b56:	4641      	mov	r1, r8
  406b58:	4628      	mov	r0, r5
  406b5a:	47b0      	blx	r6
  406b5c:	2108      	movs	r1, #8
  406b5e:	47a0      	blx	r4
  406b60:	4681      	mov	r9, r0
    uint32_t stop_speed_w  = floatToFixed(rpmToSpd(stop_speed), 8);
  406b62:	4639      	mov	r1, r7
  406b64:	4628      	mov	r0, r5
  406b66:	47b0      	blx	r6
  406b68:	2108      	movs	r1, #8
  406b6a:	47a0      	blx	r4
  406b6c:	4607      	mov	r7, r0
    uint32_t break_speed_w = floatToFixed(rpmToSpd(break_speed), 8); // Affects trapezoidal only
  406b6e:	9908      	ldr	r1, [sp, #32]
  406b70:	4628      	mov	r0, r5
  406b72:	47b0      	blx	r6
  406b74:	2108      	movs	r1, #8
  406b76:	47a0      	blx	r4
  406b78:	4680      	mov	r8, r0
    succeed &= writeRegister(TMC4361A_Reg::VMAX, max_speed_w);
  406b7a:	4652      	mov	r2, sl
  406b7c:	2124      	movs	r1, #36	; 0x24
  406b7e:	4628      	mov	r0, r5
  406b80:	4e0c      	ldr	r6, [pc, #48]	; (406bb4 <_ZN8TMC4361A9setSpeedsEffff+0x74>)
  406b82:	47b0      	blx	r6
  406b84:	4604      	mov	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::VSTART, start_speed_w);
  406b86:	464a      	mov	r2, r9
  406b88:	2125      	movs	r1, #37	; 0x25
  406b8a:	4628      	mov	r0, r5
  406b8c:	47b0      	blx	r6
  406b8e:	4004      	ands	r4, r0
  406b90:	b2e4      	uxtb	r4, r4
    succeed &= writeRegister(TMC4361A_Reg::VSTOP, stop_speed_w);
  406b92:	463a      	mov	r2, r7
  406b94:	2126      	movs	r1, #38	; 0x26
  406b96:	4628      	mov	r0, r5
  406b98:	47b0      	blx	r6
  406b9a:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::VBREAK, break_speed_w);
  406b9c:	4642      	mov	r2, r8
  406b9e:	2127      	movs	r1, #39	; 0x27
  406ba0:	4628      	mov	r0, r5
  406ba2:	47b0      	blx	r6
}
  406ba4:	4020      	ands	r0, r4
  406ba6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  406baa:	bf00      	nop
  406bac:	0040676d 	.word	0x0040676d
  406bb0:	004067a1 	.word	0x004067a1
  406bb4:	00406ae9 	.word	0x00406ae9

00406bb8 <_ZN8TMC4361A16setAccelerationsEffff>:
bool TMC4361A::setAccelerations(float max_accel, float max_decel, float start_accel, float final_decel) {
  406bb8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406bbc:	4683      	mov	fp, r0
  406bbe:	4691      	mov	r9, r2
  406bc0:	461f      	mov	r7, r3
    uint32_t max_accel_w   = floatToFixed(deltaRpmToDeltaSpd(max_accel), 2) & 0xFFFFFF;
  406bc2:	4d1c      	ldr	r5, [pc, #112]	; (406c34 <_ZN8TMC4361A16setAccelerationsEffff+0x7c>)
  406bc4:	47a8      	blx	r5
  406bc6:	4e1c      	ldr	r6, [pc, #112]	; (406c38 <_ZN8TMC4361A16setAccelerationsEffff+0x80>)
  406bc8:	47b0      	blx	r6
  406bca:	2102      	movs	r1, #2
  406bcc:	4c1b      	ldr	r4, [pc, #108]	; (406c3c <_ZN8TMC4361A16setAccelerationsEffff+0x84>)
  406bce:	47a0      	blx	r4
  406bd0:	f020 4a7f 	bic.w	sl, r0, #4278190080	; 0xff000000
    uint32_t max_decel_w   = floatToFixed(deltaRpmToDeltaSpd(max_decel), 2) & 0xFFFFFF;
  406bd4:	4649      	mov	r1, r9
  406bd6:	4658      	mov	r0, fp
  406bd8:	47a8      	blx	r5
  406bda:	47b0      	blx	r6
  406bdc:	2102      	movs	r1, #2
  406bde:	47a0      	blx	r4
  406be0:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
    uint32_t start_accel_w = floatToFixed(deltaRpmToDeltaSpd(start_accel), 2) & 0xFFFFFF;
  406be4:	4639      	mov	r1, r7
  406be6:	4658      	mov	r0, fp
  406be8:	47a8      	blx	r5
  406bea:	47b0      	blx	r6
  406bec:	2102      	movs	r1, #2
  406bee:	47a0      	blx	r4
  406bf0:	f020 477f 	bic.w	r7, r0, #4278190080	; 0xff000000
    uint32_t final_decel_w = floatToFixed(deltaRpmToDeltaSpd(final_decel), 2) & 0xFFFFFF;
  406bf4:	990a      	ldr	r1, [sp, #40]	; 0x28
  406bf6:	4658      	mov	r0, fp
  406bf8:	47a8      	blx	r5
  406bfa:	47b0      	blx	r6
  406bfc:	2102      	movs	r1, #2
  406bfe:	47a0      	blx	r4
  406c00:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000
    succeed &= writeRegister(TMC4361A_Reg::AMAX, max_accel_w);
  406c04:	4652      	mov	r2, sl
  406c06:	2128      	movs	r1, #40	; 0x28
  406c08:	4658      	mov	r0, fp
  406c0a:	4e0d      	ldr	r6, [pc, #52]	; (406c40 <_ZN8TMC4361A16setAccelerationsEffff+0x88>)
  406c0c:	47b0      	blx	r6
  406c0e:	4604      	mov	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::DMAX, max_decel_w);
  406c10:	464a      	mov	r2, r9
  406c12:	2129      	movs	r1, #41	; 0x29
  406c14:	4658      	mov	r0, fp
  406c16:	47b0      	blx	r6
  406c18:	4004      	ands	r4, r0
  406c1a:	b2e4      	uxtb	r4, r4
    succeed &= writeRegister(TMC4361A_Reg::ASTART, start_accel_w);
  406c1c:	463a      	mov	r2, r7
  406c1e:	212a      	movs	r1, #42	; 0x2a
  406c20:	4658      	mov	r0, fp
  406c22:	47b0      	blx	r6
  406c24:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::DFINAL, final_decel_w);
  406c26:	4642      	mov	r2, r8
  406c28:	212b      	movs	r1, #43	; 0x2b
  406c2a:	4658      	mov	r0, fp
  406c2c:	47b0      	blx	r6
}
  406c2e:	4020      	ands	r0, r4
  406c30:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406c34:	00406745 	.word	0x00406745
  406c38:	0040bd31 	.word	0x0040bd31
  406c3c:	004067a1 	.word	0x004067a1
  406c40:	00406ae9 	.word	0x00406ae9

00406c44 <_ZN8TMC4361A12setBowValuesEffff>:
bool TMC4361A::setBowValues(float bow1, float bow2, float bow3, float bow4) {
  406c44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  406c48:	4605      	mov	r5, r0
  406c4a:	4690      	mov	r8, r2
  406c4c:	461f      	mov	r7, r3
    uint32_t bow1_w = deltaSqRpmToDeltaSqSpd(bow1) & 0xFFFFFF;
  406c4e:	4c15      	ldr	r4, [pc, #84]	; (406ca4 <_ZN8TMC4361A12setBowValuesEffff+0x60>)
  406c50:	47a0      	blx	r4
  406c52:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
    uint32_t bow2_w = deltaSqRpmToDeltaSqSpd(bow2) & 0xFFFFFF;
  406c56:	4641      	mov	r1, r8
  406c58:	4628      	mov	r0, r5
  406c5a:	47a0      	blx	r4
  406c5c:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
    uint32_t bow3_w = deltaSqRpmToDeltaSqSpd(bow3) & 0xFFFFFF;
  406c60:	4639      	mov	r1, r7
  406c62:	4628      	mov	r0, r5
  406c64:	47a0      	blx	r4
  406c66:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000
    uint32_t bow4_w = deltaSqRpmToDeltaSqSpd(bow4) & 0xFFFFFF;
  406c6a:	9908      	ldr	r1, [sp, #32]
  406c6c:	4628      	mov	r0, r5
  406c6e:	47a0      	blx	r4
  406c70:	f020 477f 	bic.w	r7, r0, #4278190080	; 0xff000000
    succeed &= writeRegister(TMC4361A_Reg::BOW1, bow1_w);
  406c74:	4632      	mov	r2, r6
  406c76:	212d      	movs	r1, #45	; 0x2d
  406c78:	4628      	mov	r0, r5
  406c7a:	4e0b      	ldr	r6, [pc, #44]	; (406ca8 <_ZN8TMC4361A12setBowValuesEffff+0x64>)
  406c7c:	47b0      	blx	r6
  406c7e:	4604      	mov	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::BOW2, bow2_w);
  406c80:	464a      	mov	r2, r9
  406c82:	212e      	movs	r1, #46	; 0x2e
  406c84:	4628      	mov	r0, r5
  406c86:	47b0      	blx	r6
  406c88:	4004      	ands	r4, r0
  406c8a:	b2e4      	uxtb	r4, r4
    succeed &= writeRegister(TMC4361A_Reg::BOW3, bow3_w);
  406c8c:	4642      	mov	r2, r8
  406c8e:	212f      	movs	r1, #47	; 0x2f
  406c90:	4628      	mov	r0, r5
  406c92:	47b0      	blx	r6
  406c94:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::BOW4, bow4_w);
  406c96:	463a      	mov	r2, r7
  406c98:	2130      	movs	r1, #48	; 0x30
  406c9a:	4628      	mov	r0, r5
  406c9c:	47b0      	blx	r6
}
  406c9e:	4020      	ands	r0, r4
  406ca0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  406ca4:	0040671d 	.word	0x0040671d
  406ca8:	00406ae9 	.word	0x00406ae9

00406cac <_ZN8TMC4361A17setTargetPositionEm>:
bool TMC4361A::setTargetPosition(uint32_t position) { return writeRegister(TMC4361A_Reg::X_TARGET, position); }
  406cac:	b508      	push	{r3, lr}
  406cae:	460a      	mov	r2, r1
  406cb0:	2137      	movs	r1, #55	; 0x37
  406cb2:	4b01      	ldr	r3, [pc, #4]	; (406cb8 <_ZN8TMC4361A17setTargetPositionEm+0xc>)
  406cb4:	4798      	blx	r3
  406cb6:	bd08      	pop	{r3, pc}
  406cb8:	00406ae9 	.word	0x00406ae9

00406cbc <_ZN8TMC4361A8rampStopEv>:
bool TMC4361A::rampStop() { return writeRegister(TMC4361A_Reg::VMAX, 0); }
  406cbc:	b508      	push	{r3, lr}
  406cbe:	2200      	movs	r2, #0
  406cc0:	2124      	movs	r1, #36	; 0x24
  406cc2:	4b01      	ldr	r3, [pc, #4]	; (406cc8 <_ZN8TMC4361A8rampStopEv+0xc>)
  406cc4:	4798      	blx	r3
  406cc6:	bd08      	pop	{r3, pc}
  406cc8:	00406ae9 	.word	0x00406ae9

00406ccc <_ZN8TMC4361A11setPositionEl>:
bool TMC4361A::setPosition(int32_t pos) {
  406ccc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406cce:	4604      	mov	r4, r0
  406cd0:	460e      	mov	r6, r1
    m_ignore_next_stall |= m_cl_s.enable && (Abs(pos - getEncoderPosition()) > m_cl_s.cl_tolerance);
  406cd2:	7b85      	ldrb	r5, [r0, #14]
  406cd4:	b9b5      	cbnz	r5, 406d04 <_ZN8TMC4361A11setPositionEl+0x38>
  406cd6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  406cda:	431d      	orrs	r5, r3
  406cdc:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
    succeed &= writeRegister(TMC4361A_Reg::XACTUAL, pos_w);
  406ce0:	4632      	mov	r2, r6
  406ce2:	2121      	movs	r1, #33	; 0x21
  406ce4:	4620      	mov	r0, r4
  406ce6:	4f11      	ldr	r7, [pc, #68]	; (406d2c <_ZN8TMC4361A11setPositionEl+0x60>)
  406ce8:	47b8      	blx	r7
  406cea:	4605      	mov	r5, r0
    succeed &= writeRegister(TMC4361A_Reg::X_TARGET, pos_w);
  406cec:	4632      	mov	r2, r6
  406cee:	2137      	movs	r1, #55	; 0x37
  406cf0:	4620      	mov	r0, r4
  406cf2:	47b8      	blx	r7
  406cf4:	4005      	ands	r5, r0
  406cf6:	b2ed      	uxtb	r5, r5
    succeed &= writeRegister(TMC4361A_Reg::ENC_POS, pos_w);
  406cf8:	4632      	mov	r2, r6
  406cfa:	2150      	movs	r1, #80	; 0x50
  406cfc:	4620      	mov	r0, r4
  406cfe:	47b8      	blx	r7
}
  406d00:	4028      	ands	r0, r5
  406d02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    m_ignore_next_stall |= m_cl_s.enable && (Abs(pos - getEncoderPosition()) > m_cl_s.cl_tolerance);
  406d04:	4b0a      	ldr	r3, [pc, #40]	; (406d30 <_ZN8TMC4361A11setPositionEl+0x64>)
  406d06:	4798      	blx	r3
  406d08:	1a30      	subs	r0, r6, r0
  406d0a:	2800      	cmp	r0, #0
  406d0c:	db08      	blt.n	406d20 <_ZN8TMC4361A11setPositionEl+0x54>
  406d0e:	4620      	mov	r0, r4
  406d10:	4b07      	ldr	r3, [pc, #28]	; (406d30 <_ZN8TMC4361A11setPositionEl+0x64>)
  406d12:	4798      	blx	r3
  406d14:	1a30      	subs	r0, r6, r0
  406d16:	8a23      	ldrh	r3, [r4, #16]
  406d18:	4298      	cmp	r0, r3
  406d1a:	dcdc      	bgt.n	406cd6 <_ZN8TMC4361A11setPositionEl+0xa>
  406d1c:	2500      	movs	r5, #0
  406d1e:	e7da      	b.n	406cd6 <_ZN8TMC4361A11setPositionEl+0xa>
  406d20:	4620      	mov	r0, r4
  406d22:	4b03      	ldr	r3, [pc, #12]	; (406d30 <_ZN8TMC4361A11setPositionEl+0x64>)
  406d24:	4798      	blx	r3
  406d26:	1b80      	subs	r0, r0, r6
  406d28:	e7f5      	b.n	406d16 <_ZN8TMC4361A11setPositionEl+0x4a>
  406d2a:	bf00      	nop
  406d2c:	00406ae9 	.word	0x00406ae9
  406d30:	00406961 	.word	0x00406961

00406d34 <_ZN8TMC4361A12setInterruptEv>:
bool TMC4361A::setInterrupt() {
  406d34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406d36:	4606      	mov	r6, r0
    intr_conf_word |= (m_cl_s.enable << Events::CL_FIT);
  406d38:	7b83      	ldrb	r3, [r0, #14]
    intr_conf_word |= (m_stall_s.stop_on_stall << Events::STOP_ON_STALL);
  406d3a:	7a84      	ldrb	r4, [r0, #10]
  406d3c:	0764      	lsls	r4, r4, #29
  406d3e:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
    succeed &= writeRegister(TMC4361A_Reg::INTR_CONF, intr_conf_word);
  406d42:	4622      	mov	r2, r4
  406d44:	210d      	movs	r1, #13
  406d46:	4f05      	ldr	r7, [pc, #20]	; (406d5c <_ZN8TMC4361A12setInterruptEv+0x28>)
  406d48:	47b8      	blx	r7
  406d4a:	4605      	mov	r5, r0
    succeed &= writeRegister(TMC4361A_Reg::EVENT_CLEAR_CONF, intr_conf_word);
  406d4c:	4622      	mov	r2, r4
  406d4e:	210c      	movs	r1, #12
  406d50:	4630      	mov	r0, r6
  406d52:	47b8      	blx	r7
    return succeed;
  406d54:	4028      	ands	r0, r5
}
  406d56:	b2c0      	uxtb	r0, r0
  406d58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406d5a:	bf00      	nop
  406d5c:	00406ae9 	.word	0x00406ae9

00406d60 <_ZN8TMC4361A13setClosedLoopEv>:
    if (!m_cl_s.enable) { return true; }
  406d60:	7b83      	ldrb	r3, [r0, #14]
  406d62:	b90b      	cbnz	r3, 406d68 <_ZN8TMC4361A13setClosedLoopEv+0x8>
  406d64:	2001      	movs	r0, #1
  406d66:	4770      	bx	lr
bool TMC4361A::setClosedLoop() {
  406d68:	b570      	push	{r4, r5, r6, lr}
  406d6a:	4605      	mov	r5, r0
    succeed &= writeRegister(TMC4361A_Reg::ENC_IN_RES_WR, static_cast<uint32_t>(m_cl_s.enc_in_res)); // encoder res
  406d6c:	8a42      	ldrh	r2, [r0, #18]
  406d6e:	2154      	movs	r1, #84	; 0x54
  406d70:	4b21      	ldr	r3, [pc, #132]	; (406df8 <_ZN8TMC4361A13setClosedLoopEv+0x98>)
  406d72:	4798      	blx	r3
  406d74:	4604      	mov	r4, r0
        writeRegister(TMC4361A_Reg::CL_TOLERANCE_WR, min(static_cast<uint32_t>(m_cl_s.enc_in_res / 2), 256)); // cl_fit
  406d76:	8a6a      	ldrh	r2, [r5, #18]
  406d78:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  406d7c:	d239      	bcs.n	406df2 <_ZN8TMC4361A13setClosedLoopEv+0x92>
  406d7e:	0852      	lsrs	r2, r2, #1
  406d80:	215f      	movs	r1, #95	; 0x5f
  406d82:	4628      	mov	r0, r5
  406d84:	4e1c      	ldr	r6, [pc, #112]	; (406df8 <_ZN8TMC4361A13setClosedLoopEv+0x98>)
  406d86:	47b0      	blx	r6
  406d88:	4004      	ands	r4, r0
  406d8a:	b2e4      	uxtb	r4, r4
        writeRegister(TMC4361A_Reg::ENC_POS_DEV_TOL_WR, static_cast<uint32_t>(m_cl_s.cl_tolerance)); // max follow err
  406d8c:	8a2a      	ldrh	r2, [r5, #16]
  406d8e:	2153      	movs	r1, #83	; 0x53
  406d90:	4628      	mov	r0, r5
  406d92:	47b0      	blx	r6
  406d94:	4004      	ands	r4, r0
        writeRegister(TMC4361A_Reg::CL_TR_TOLERANCE_WR, static_cast<uint32_t>(m_cl_s.cl_tolerance)); // target reach
  406d96:	8a2a      	ldrh	r2, [r5, #16]
  406d98:	2152      	movs	r1, #82	; 0x52
  406d9a:	4628      	mov	r0, r5
  406d9c:	47b0      	blx	r6
  406d9e:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::CL_BETA, 255);           // maximum compensation commutation angle
  406da0:	22ff      	movs	r2, #255	; 0xff
  406da2:	211c      	movs	r1, #28
  406da4:	4628      	mov	r0, r5
  406da6:	47b0      	blx	r6
  406da8:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::CL_DELTA_P_WR, 0xFFFF);  // Keep 0xFFFF to minimize jitter
  406daa:	f64f 72ff 	movw	r2, #65535	; 0xffff
  406dae:	215c      	movs	r1, #92	; 0x5c
  406db0:	4628      	mov	r0, r5
  406db2:	47b0      	blx	r6
  406db4:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::CL_VMAX_CALC_P_WR, 2);   // P of PI regulator
  406db6:	2202      	movs	r2, #2
  406db8:	215a      	movs	r1, #90	; 0x5a
  406dba:	4628      	mov	r0, r5
  406dbc:	47b0      	blx	r6
  406dbe:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::CL_VMAX_CALC_I_WR, 3);   // I of PI regulator (min 2)
  406dc0:	2203      	movs	r2, #3
  406dc2:	215b      	movs	r1, #91	; 0x5b
  406dc4:	4628      	mov	r0, r5
  406dc6:	47b0      	blx	r6
  406dc8:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::PID_DV_CLIP_WR, 512000); // 10 rps limit
  406dca:	f44f 22fa 	mov.w	r2, #512000	; 0x7d000
  406dce:	215e      	movs	r1, #94	; 0x5e
  406dd0:	4628      	mov	r0, r5
  406dd2:	47b0      	blx	r6
  406dd4:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::PID_I_CLIP_WR, 250);     // Integral clamp
  406dd6:	22fa      	movs	r2, #250	; 0xfa
  406dd8:	215d      	movs	r1, #93	; 0x5d
  406dda:	4628      	mov	r0, r5
  406ddc:	47b0      	blx	r6
  406dde:	4004      	ands	r4, r0
    enc_in_conf_word |= (m_cl_s.enable_pid << 22); // regulation_modus (!Do not use at high RPM)
  406de0:	7bea      	ldrb	r2, [r5, #15]
    succeed &= writeRegister(TMC4361A_Reg::ENC_IN_CONF, enc_in_conf_word);
  406de2:	4b06      	ldr	r3, [pc, #24]	; (406dfc <_ZN8TMC4361A13setClosedLoopEv+0x9c>)
  406de4:	ea43 5282 	orr.w	r2, r3, r2, lsl #22
  406de8:	2107      	movs	r1, #7
  406dea:	4628      	mov	r0, r5
  406dec:	47b0      	blx	r6
  406dee:	4020      	ands	r0, r4
    return succeed;
  406df0:	bd70      	pop	{r4, r5, r6, pc}
        writeRegister(TMC4361A_Reg::CL_TOLERANCE_WR, min(static_cast<uint32_t>(m_cl_s.enc_in_res / 2), 256)); // cl_fit
  406df2:	f44f 7280 	mov.w	r2, #256	; 0x100
  406df6:	e7c3      	b.n	406d80 <_ZN8TMC4361A13setClosedLoopEv+0x20>
  406df8:	00406ae9 	.word	0x00406ae9
  406dfc:	2a000c05 	.word	0x2a000c05

00406e00 <_ZN8TMC4361A17setStallDetectionEv>:
bool TMC4361A::setStallDetection() {
  406e00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406e02:	4604      	mov	r4, r0
    if (m_cl_s.enable) m_stall_s.stop_on_stall = false;
  406e04:	7b83      	ldrb	r3, [r0, #14]
  406e06:	b10b      	cbz	r3, 406e0c <_ZN8TMC4361A17setStallDetectionEv+0xc>
  406e08:	2300      	movs	r3, #0
  406e0a:	7283      	strb	r3, [r0, #10]
    reference_conf_word |= (m_stall_s.stop_on_stall << 26); // stop_on_stall
  406e0c:	7aa5      	ldrb	r5, [r4, #10]
  406e0e:	06ad      	lsls	r5, r5, #26
    reference_conf_word |= (1 << 27);                       // drive_after_stall
  406e10:	f045 6500 	orr.w	r5, r5, #134217728	; 0x8000000
    float stall_thresh_rpm_f = (float)(m_stall_s.stall_thresh_rpm); // 0 dp
  406e14:	89a0      	ldrh	r0, [r4, #12]
  406e16:	4b0b      	ldr	r3, [pc, #44]	; (406e44 <_ZN8TMC4361A17setStallDetectionEv+0x44>)
  406e18:	4798      	blx	r3
  406e1a:	4607      	mov	r7, r0
    succeed &= writeRegister(TMC4361A_Reg::REFERENCE_CONF, reference_conf_word);
  406e1c:	462a      	mov	r2, r5
  406e1e:	2101      	movs	r1, #1
  406e20:	4620      	mov	r0, r4
  406e22:	4e09      	ldr	r6, [pc, #36]	; (406e48 <_ZN8TMC4361A17setStallDetectionEv+0x48>)
  406e24:	47b0      	blx	r6
  406e26:	4605      	mov	r5, r0
    succeed &= writeRegister(TMC4361A_Reg::VSTALL_LIMIT_WR, floatToFixed(rpmToSpd(stall_thresh_rpm_f), 0));
  406e28:	4639      	mov	r1, r7
  406e2a:	4620      	mov	r0, r4
  406e2c:	4b07      	ldr	r3, [pc, #28]	; (406e4c <_ZN8TMC4361A17setStallDetectionEv+0x4c>)
  406e2e:	4798      	blx	r3
  406e30:	2100      	movs	r1, #0
  406e32:	4b07      	ldr	r3, [pc, #28]	; (406e50 <_ZN8TMC4361A17setStallDetectionEv+0x50>)
  406e34:	4798      	blx	r3
  406e36:	4602      	mov	r2, r0
  406e38:	2167      	movs	r1, #103	; 0x67
  406e3a:	4620      	mov	r0, r4
  406e3c:	47b0      	blx	r6
    return succeed;
  406e3e:	4028      	ands	r0, r5
}
  406e40:	b2c0      	uxtb	r0, r0
  406e42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406e44:	0040bd31 	.word	0x0040bd31
  406e48:	00406ae9 	.word	0x00406ae9
  406e4c:	0040676d 	.word	0x0040676d
  406e50:	004067a1 	.word	0x004067a1

00406e54 <_ZN8TMC4361A11clearEventsEv>:
void TMC4361A::clearEvents() { writeRegister(TMC4361A_Reg::EVENTS, UINT32_MAX); }
  406e54:	b508      	push	{r3, lr}
  406e56:	f04f 32ff 	mov.w	r2, #4294967295
  406e5a:	210e      	movs	r1, #14
  406e5c:	4b01      	ldr	r3, [pc, #4]	; (406e64 <_ZN8TMC4361A11clearEventsEv+0x10>)
  406e5e:	4798      	blx	r3
  406e60:	bd08      	pop	{r3, pc}
  406e62:	bf00      	nop
  406e64:	00406ae9 	.word	0x00406ae9

00406e68 <_ZN8TMC4361A9softResetEv>:
bool TMC4361A::softReset() {
  406e68:	b570      	push	{r4, r5, r6, lr}
  406e6a:	b082      	sub	sp, #8
  406e6c:	4604      	mov	r4, r0
    reset &= writeRegister(TMC4361A_Reg::EVENTS, 0xFFFFFFFF);
  406e6e:	f04f 32ff 	mov.w	r2, #4294967295
  406e72:	210e      	movs	r1, #14
  406e74:	4e0d      	ldr	r6, [pc, #52]	; (406eac <_ZN8TMC4361A9softResetEv+0x44>)
  406e76:	47b0      	blx	r6
  406e78:	4605      	mov	r5, r0
    reset &= writeRegister(TMC4361A_Reg::RESET_REG, 0x52535400);
  406e7a:	4a0d      	ldr	r2, [pc, #52]	; (406eb0 <_ZN8TMC4361A9softResetEv+0x48>)
  406e7c:	214f      	movs	r1, #79	; 0x4f
  406e7e:	4620      	mov	r0, r4
  406e80:	47b0      	blx	r6
  406e82:	4005      	ands	r5, r0
  406e84:	b2ed      	uxtb	r5, r5
    m_freeze_event      = FreezeEvent::OK;
  406e86:	2300      	movs	r3, #0
  406e88:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    m_ignore_next_stall = true;
  406e8c:	2201      	movs	r2, #1
  406e8e:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
    m_drv_no_comm       = false;
  406e92:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    clearEvents();
  406e96:	4620      	mov	r0, r4
  406e98:	4b06      	ldr	r3, [pc, #24]	; (406eb4 <_ZN8TMC4361A9softResetEv+0x4c>)
  406e9a:	4798      	blx	r3
    readStatus(&dummy); // clear first reading
  406e9c:	a901      	add	r1, sp, #4
  406e9e:	4620      	mov	r0, r4
  406ea0:	4b05      	ldr	r3, [pc, #20]	; (406eb8 <_ZN8TMC4361A9softResetEv+0x50>)
  406ea2:	4798      	blx	r3
}
  406ea4:	4628      	mov	r0, r5
  406ea6:	b002      	add	sp, #8
  406ea8:	bd70      	pop	{r4, r5, r6, pc}
  406eaa:	bf00      	nop
  406eac:	00406ae9 	.word	0x00406ae9
  406eb0:	52535400 	.word	0x52535400
  406eb4:	00406e55 	.word	0x00406e55
  406eb8:	004069a9 	.word	0x004069a9

00406ebc <_ZN8TMC4361A16writeDrvRegisterEhm>:
bool TMC4361A::writeDrvRegister(uint8_t drv_reg, uint32_t data) {
  406ebc:	b5f0      	push	{r4, r5, r6, r7, lr}
  406ebe:	b083      	sub	sp, #12
  406ec0:	4605      	mov	r5, r0
  406ec2:	4616      	mov	r6, r2
    writeRegister(TMC4361A_Reg::COVER_HIGH_WR, reg_write);
  406ec4:	f101 0280 	add.w	r2, r1, #128	; 0x80
  406ec8:	216d      	movs	r1, #109	; 0x6d
  406eca:	4c17      	ldr	r4, [pc, #92]	; (406f28 <_ZN8TMC4361A16writeDrvRegisterEhm+0x6c>)
  406ecc:	47a0      	blx	r4
    writeRegister(TMC4361A_Reg::COVER_LOW_WR, data);
  406ece:	4632      	mov	r2, r6
  406ed0:	216c      	movs	r1, #108	; 0x6c
  406ed2:	4628      	mov	r0, r5
  406ed4:	47a0      	blx	r4
    waitForCoverDone();
  406ed6:	4628      	mov	r0, r5
  406ed8:	4b14      	ldr	r3, [pc, #80]	; (406f2c <_ZN8TMC4361A16writeDrvRegisterEhm+0x70>)
  406eda:	4798      	blx	r3
    delay_us(100);
  406edc:	f240 20ae 	movw	r0, #686	; 0x2ae
  406ee0:	4b13      	ldr	r3, [pc, #76]	; (406f30 <_ZN8TMC4361A16writeDrvRegisterEhm+0x74>)
  406ee2:	4798      	blx	r3
    read_success &= readRegister(TMC4361A_Reg::COVER_DRV_LOW_RD, &readback_high);
  406ee4:	466a      	mov	r2, sp
  406ee6:	216e      	movs	r1, #110	; 0x6e
  406ee8:	4628      	mov	r0, r5
  406eea:	4f12      	ldr	r7, [pc, #72]	; (406f34 <_ZN8TMC4361A16writeDrvRegisterEhm+0x78>)
  406eec:	47b8      	blx	r7
  406eee:	4604      	mov	r4, r0
    read_success &= readRegister(TMC4361A_Reg::COVER_DRV_HIGH_RD, &readback_low);
  406ef0:	aa01      	add	r2, sp, #4
  406ef2:	216f      	movs	r1, #111	; 0x6f
  406ef4:	4628      	mov	r0, r5
  406ef6:	47b8      	blx	r7
  406ef8:	4020      	ands	r0, r4
    if (data != 0 && data != 0xFFFFFFFF) {
  406efa:	3e01      	subs	r6, #1
  406efc:	f116 0f03 	cmn.w	r6, #3
  406f00:	d806      	bhi.n	406f10 <_ZN8TMC4361A16writeDrvRegisterEhm+0x54>
  406f02:	b2c0      	uxtb	r0, r0
        if (!read_success || (readback_low == 0 || readback_low == 0xFFFFFFFF)) {
  406f04:	b150      	cbz	r0, 406f1c <_ZN8TMC4361A16writeDrvRegisterEhm+0x60>
  406f06:	9b01      	ldr	r3, [sp, #4]
  406f08:	3b01      	subs	r3, #1
  406f0a:	f113 0f03 	cmn.w	r3, #3
  406f0e:	d805      	bhi.n	406f1c <_ZN8TMC4361A16writeDrvRegisterEhm+0x60>
    delay_us(10);
  406f10:	2045      	movs	r0, #69	; 0x45
  406f12:	4b07      	ldr	r3, [pc, #28]	; (406f30 <_ZN8TMC4361A16writeDrvRegisterEhm+0x74>)
  406f14:	4798      	blx	r3
    return true;
  406f16:	2001      	movs	r0, #1
}
  406f18:	b003      	add	sp, #12
  406f1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            m_drv_no_comm = true;
  406f1c:	2301      	movs	r3, #1
  406f1e:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
            return false;
  406f22:	2000      	movs	r0, #0
  406f24:	e7f8      	b.n	406f18 <_ZN8TMC4361A16writeDrvRegisterEhm+0x5c>
  406f26:	bf00      	nop
  406f28:	00406ae9 	.word	0x00406ae9
  406f2c:	00406ac5 	.word	0x00406ac5
  406f30:	20000001 	.word	0x20000001
  406f34:	004068b9 	.word	0x004068b9

00406f38 <_ZN8TMC4361A10setCurrentEv>:
bool TMC4361A::setCurrent() {
  406f38:	b508      	push	{r3, lr}
    ihold_irun_word |= (m_current_s.i_hold << 0);        // IHOLD (0-31)
  406f3a:	7983      	ldrb	r3, [r0, #6]
    ihold_irun_word |= (m_current_s.i_run << 8);         // IRUN  (0-31)
  406f3c:	79c2      	ldrb	r2, [r0, #7]
  406f3e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    ihold_irun_word |= (m_current_s.i_hold_delay << 16); // IHOLDDELAY
  406f42:	7a02      	ldrb	r2, [r0, #8]
    return writeDrvRegister(TMC5160_Reg::IHOLD_IRUN, ihold_irun_word);
  406f44:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  406f48:	2110      	movs	r1, #16
  406f4a:	4b01      	ldr	r3, [pc, #4]	; (406f50 <_ZN8TMC4361A10setCurrentEv+0x18>)
  406f4c:	4798      	blx	r3
}
  406f4e:	bd08      	pop	{r3, pc}
  406f50:	00406ebd 	.word	0x00406ebd

00406f54 <_ZN8TMC4361A8setFixedEv>:
bool TMC4361A::setFixed() {
  406f54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406f56:	4605      	mov	r5, r0
    succeed &= writeRegister(TMC4361A_Reg::CLK_FREQ, m_fclk);    // set clock frequency
  406f58:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  406f5a:	2131      	movs	r1, #49	; 0x31
  406f5c:	4e3c      	ldr	r6, [pc, #240]	; (407050 <_ZN8TMC4361A8setFixedEv+0xfc>)
  406f5e:	47b0      	blx	r6
  406f60:	4604      	mov	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::DFREEZE, 0x00FFFFFF); // free axis, instant stop on freeze
  406f62:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  406f66:	214e      	movs	r1, #78	; 0x4e
  406f68:	4628      	mov	r0, r5
  406f6a:	47b0      	blx	r6
  406f6c:	4004      	ands	r4, r0
  406f6e:	b2e4      	uxtb	r4, r4
    succeed &= writeRegister(TMC4361A_Reg::GENERAL_CONF, general_conf_word);
  406f70:	4a38      	ldr	r2, [pc, #224]	; (407054 <_ZN8TMC4361A8setFixedEv+0x100>)
  406f72:	2100      	movs	r1, #0
  406f74:	4628      	mov	r0, r5
  406f76:	47b0      	blx	r6
  406f78:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::STP_LENGTH_ADD, stp_length_add_word);
  406f7a:	4a37      	ldr	r2, [pc, #220]	; (407058 <_ZN8TMC4361A8setFixedEv+0x104>)
  406f7c:	2110      	movs	r1, #16
  406f7e:	4628      	mov	r0, r5
  406f80:	47b0      	blx	r6
  406f82:	4004      	ands	r4, r0
    succeed &= writeRegister(TMC4361A_Reg::SPIOUT_CONF, 0x4440128D);
  406f84:	4a35      	ldr	r2, [pc, #212]	; (40705c <_ZN8TMC4361A8setFixedEv+0x108>)
  406f86:	2104      	movs	r1, #4
  406f88:	4628      	mov	r0, r5
  406f8a:	47b0      	blx	r6
  406f8c:	4004      	ands	r4, r0
    succeed &= writeDrvRegister(TMC5160_Reg::CHOPCONF, 0x00000000); // TOFF first for driver reenable
  406f8e:	2200      	movs	r2, #0
  406f90:	216c      	movs	r1, #108	; 0x6c
  406f92:	4628      	mov	r0, r5
  406f94:	4e32      	ldr	r6, [pc, #200]	; (407060 <_ZN8TMC4361A8setFixedEv+0x10c>)
  406f96:	47b0      	blx	r6
  406f98:	4004      	ands	r4, r0
    succeed &= writeDrvRegister(TMC5160_Reg::CHOPCONF, 0x002101F4);
  406f9a:	4a32      	ldr	r2, [pc, #200]	; (407064 <_ZN8TMC4361A8setFixedEv+0x110>)
  406f9c:	216c      	movs	r1, #108	; 0x6c
  406f9e:	4628      	mov	r0, r5
  406fa0:	47b0      	blx	r6
  406fa2:	4004      	ands	r4, r0
    succeed &= writeDrvRegister(TMC5160_Reg::TPOWERDOWN, 0x0000000A);
  406fa4:	220a      	movs	r2, #10
  406fa6:	2111      	movs	r1, #17
  406fa8:	4628      	mov	r0, r5
  406faa:	47b0      	blx	r6
  406fac:	4004      	ands	r4, r0
    succeed &= writeDrvRegister(TMC5160_Reg::GCONF, gconf_word);
  406fae:	220c      	movs	r2, #12
  406fb0:	2100      	movs	r1, #0
  406fb2:	4628      	mov	r0, r5
  406fb4:	47b0      	blx	r6
  406fb6:	4004      	ands	r4, r0
    float    stealthchop_thresh_rpm_f   = (float)m_stealthchop_thresh_rpm;
  406fb8:	4f2b      	ldr	r7, [pc, #172]	; (407068 <_ZN8TMC4361A8setFixedEv+0x114>)
  406fba:	8aa8      	ldrh	r0, [r5, #20]
  406fbc:	47b8      	blx	r7
    uint32_t m_stealthchop_thresh_speed = floatToFixed(rpmToSpd(stealthchop_thresh_rpm_f), 0);
  406fbe:	4601      	mov	r1, r0
  406fc0:	4628      	mov	r0, r5
  406fc2:	4b2a      	ldr	r3, [pc, #168]	; (40706c <_ZN8TMC4361A8setFixedEv+0x118>)
  406fc4:	4798      	blx	r3
  406fc6:	2100      	movs	r1, #0
  406fc8:	4b29      	ldr	r3, [pc, #164]	; (407070 <_ZN8TMC4361A8setFixedEv+0x11c>)
  406fca:	4798      	blx	r3
    uint32_t tpwnthrs_word = uint32_t(tmc5160_internal_clock / m_stealthchop_thresh_speed);
  406fcc:	47b8      	blx	r7
  406fce:	4601      	mov	r1, r0
  406fd0:	4828      	ldr	r0, [pc, #160]	; (407074 <_ZN8TMC4361A8setFixedEv+0x120>)
  406fd2:	4b29      	ldr	r3, [pc, #164]	; (407078 <_ZN8TMC4361A8setFixedEv+0x124>)
  406fd4:	4798      	blx	r3
  406fd6:	4b29      	ldr	r3, [pc, #164]	; (40707c <_ZN8TMC4361A8setFixedEv+0x128>)
  406fd8:	4798      	blx	r3
    succeed &= writeDrvRegister(TMC5160_Reg::TPWMTHRS, tpwnthrs_word);
  406fda:	4602      	mov	r2, r0
  406fdc:	2113      	movs	r1, #19
  406fde:	4628      	mov	r0, r5
  406fe0:	47b0      	blx	r6
  406fe2:	4004      	ands	r4, r0
    if (m_cl_s.enable) m_drv_s.mstep_per_fs = 256; // closed loop override
  406fe4:	7bab      	ldrb	r3, [r5, #14]
  406fe6:	b113      	cbz	r3, 406fee <_ZN8TMC4361A8setFixedEv+0x9a>
  406fe8:	f44f 7380 	mov.w	r3, #256	; 0x100
  406fec:	802b      	strh	r3, [r5, #0]
    switch (m_drv_s.mstep_per_fs) {
  406fee:	882b      	ldrh	r3, [r5, #0]
  406ff0:	2b08      	cmp	r3, #8
  406ff2:	d025      	beq.n	407040 <_ZN8TMC4361A8setFixedEv+0xec>
  406ff4:	d908      	bls.n	407008 <_ZN8TMC4361A8setFixedEv+0xb4>
  406ff6:	2b20      	cmp	r3, #32
  406ff8:	d024      	beq.n	407044 <_ZN8TMC4361A8setFixedEv+0xf0>
  406ffa:	d919      	bls.n	407030 <_ZN8TMC4361A8setFixedEv+0xdc>
  406ffc:	2b40      	cmp	r3, #64	; 0x40
  406ffe:	d023      	beq.n	407048 <_ZN8TMC4361A8setFixedEv+0xf4>
  407000:	2b80      	cmp	r3, #128	; 0x80
  407002:	d107      	bne.n	407014 <_ZN8TMC4361A8setFixedEv+0xc0>
    case 128: step_confg_word |= (1 << 0); break;
  407004:	2301      	movs	r3, #1
  407006:	e006      	b.n	407016 <_ZN8TMC4361A8setFixedEv+0xc2>
    switch (m_drv_s.mstep_per_fs) {
  407008:	2b02      	cmp	r3, #2
  40700a:	d015      	beq.n	407038 <_ZN8TMC4361A8setFixedEv+0xe4>
  40700c:	2b04      	cmp	r3, #4
  40700e:	d015      	beq.n	40703c <_ZN8TMC4361A8setFixedEv+0xe8>
  407010:	2b01      	cmp	r3, #1
  407012:	d01b      	beq.n	40704c <_ZN8TMC4361A8setFixedEv+0xf8>
    uint32_t step_confg_word = 0;
  407014:	2300      	movs	r3, #0
    step_confg_word |= (((uint32_t)m_drv_s.fs_per_rev & 0xFFF) << 4); // FS_PER_REV (bits 15:4)
  407016:	886a      	ldrh	r2, [r5, #2]
  407018:	0112      	lsls	r2, r2, #4
  40701a:	b292      	uxth	r2, r2
  40701c:	431a      	orrs	r2, r3
    step_confg_word |= (m_drv_s.mstatus_selection << 16);             // MSTATUS_SELECTION (bits 16:23)
  40701e:	792b      	ldrb	r3, [r5, #4]
    succeed &= writeRegister(TMC4361A_Reg::STEP_CONF, step_confg_word);
  407020:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  407024:	210a      	movs	r1, #10
  407026:	4628      	mov	r0, r5
  407028:	4b09      	ldr	r3, [pc, #36]	; (407050 <_ZN8TMC4361A8setFixedEv+0xfc>)
  40702a:	4798      	blx	r3
}
  40702c:	4020      	ands	r0, r4
  40702e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (m_drv_s.mstep_per_fs) {
  407030:	2b10      	cmp	r3, #16
  407032:	d1ef      	bne.n	407014 <_ZN8TMC4361A8setFixedEv+0xc0>
    case 16 : step_confg_word |= (4 << 0); break;
  407034:	2304      	movs	r3, #4
  407036:	e7ee      	b.n	407016 <_ZN8TMC4361A8setFixedEv+0xc2>
    case 2  : step_confg_word |= (7 << 0); break;
  407038:	2307      	movs	r3, #7
  40703a:	e7ec      	b.n	407016 <_ZN8TMC4361A8setFixedEv+0xc2>
    case 4  : step_confg_word |= (6 << 0); break;
  40703c:	2306      	movs	r3, #6
  40703e:	e7ea      	b.n	407016 <_ZN8TMC4361A8setFixedEv+0xc2>
    case 8  : step_confg_word |= (5 << 0); break;
  407040:	2305      	movs	r3, #5
  407042:	e7e8      	b.n	407016 <_ZN8TMC4361A8setFixedEv+0xc2>
    case 32 : step_confg_word |= (3 << 0); break;
  407044:	2303      	movs	r3, #3
  407046:	e7e6      	b.n	407016 <_ZN8TMC4361A8setFixedEv+0xc2>
    case 64 : step_confg_word |= (2 << 0); break;
  407048:	2302      	movs	r3, #2
  40704a:	e7e4      	b.n	407016 <_ZN8TMC4361A8setFixedEv+0xc2>
    case 1  : step_confg_word |= (8 << 0); break;
  40704c:	2308      	movs	r3, #8
  40704e:	e7e2      	b.n	407016 <_ZN8TMC4361A8setFixedEv+0xc2>
  407050:	00406ae9 	.word	0x00406ae9
  407054:	60000026 	.word	0x60000026
  407058:	00060004 	.word	0x00060004
  40705c:	4440128d 	.word	0x4440128d
  407060:	00406ebd 	.word	0x00406ebd
  407064:	002101f4 	.word	0x002101f4
  407068:	0040bd31 	.word	0x0040bd31
  40706c:	0040676d 	.word	0x0040676d
  407070:	004067a1 	.word	0x004067a1
  407074:	4b435000 	.word	0x4b435000
  407078:	0040bf49 	.word	0x0040bf49
  40707c:	0040c1b9 	.word	0x0040c1b9

00407080 <_ZN8TMC4361A10initializeEv>:
bool TMC4361A::initialize() {
  407080:	b530      	push	{r4, r5, lr}
  407082:	b083      	sub	sp, #12
  407084:	4604      	mov	r4, r0
    if (m_rtos_inited) { vTaskSuspend(drv_monitor_handle); }
  407086:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
  40708a:	2b00      	cmp	r3, #0
  40708c:	d12b      	bne.n	4070e6 <_ZN8TMC4361A10initializeEv+0x66>
    softReset();
  40708e:	4620      	mov	r0, r4
  407090:	4b1d      	ldr	r3, [pc, #116]	; (407108 <_ZN8TMC4361A10initializeEv+0x88>)
  407092:	4798      	blx	r3
    initialized &= setFixed();
  407094:	4620      	mov	r0, r4
  407096:	4b1d      	ldr	r3, [pc, #116]	; (40710c <_ZN8TMC4361A10initializeEv+0x8c>)
  407098:	4798      	blx	r3
  40709a:	4605      	mov	r5, r0
    initialized &= setInterrupt();
  40709c:	4620      	mov	r0, r4
  40709e:	4b1c      	ldr	r3, [pc, #112]	; (407110 <_ZN8TMC4361A10initializeEv+0x90>)
  4070a0:	4798      	blx	r3
  4070a2:	4005      	ands	r5, r0
  4070a4:	b2ed      	uxtb	r5, r5
    initialized &= setCurrent();
  4070a6:	4620      	mov	r0, r4
  4070a8:	4b1a      	ldr	r3, [pc, #104]	; (407114 <_ZN8TMC4361A10initializeEv+0x94>)
  4070aa:	4798      	blx	r3
  4070ac:	4005      	ands	r5, r0
    initialized &= setClosedLoop();
  4070ae:	4620      	mov	r0, r4
  4070b0:	4b19      	ldr	r3, [pc, #100]	; (407118 <_ZN8TMC4361A10initializeEv+0x98>)
  4070b2:	4798      	blx	r3
  4070b4:	4005      	ands	r5, r0
    initialized &= setStallDetection();
  4070b6:	4620      	mov	r0, r4
  4070b8:	4b18      	ldr	r3, [pc, #96]	; (40711c <_ZN8TMC4361A10initializeEv+0x9c>)
  4070ba:	4798      	blx	r3
  4070bc:	4005      	ands	r5, r0
    clearEvents();
  4070be:	4620      	mov	r0, r4
  4070c0:	4b17      	ldr	r3, [pc, #92]	; (407120 <_ZN8TMC4361A10initializeEv+0xa0>)
  4070c2:	4798      	blx	r3
    readStatus(&dummy); // clear first reading
  4070c4:	a901      	add	r1, sp, #4
  4070c6:	4620      	mov	r0, r4
  4070c8:	4b16      	ldr	r3, [pc, #88]	; (407124 <_ZN8TMC4361A10initializeEv+0xa4>)
  4070ca:	4798      	blx	r3
    if (m_write_position_after_reset) {
  4070cc:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
  4070d0:	b96b      	cbnz	r3, 4070ee <_ZN8TMC4361A10initializeEv+0x6e>
    if (m_rtos_inited) { vTaskResume(drv_monitor_handle); }
  4070d2:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
  4070d6:	b993      	cbnz	r3, 4070fe <_ZN8TMC4361A10initializeEv+0x7e>
    delay_ms(1);
  4070d8:	f641 20ca 	movw	r0, #6858	; 0x1aca
  4070dc:	4b12      	ldr	r3, [pc, #72]	; (407128 <_ZN8TMC4361A10initializeEv+0xa8>)
  4070de:	4798      	blx	r3
}
  4070e0:	4628      	mov	r0, r5
  4070e2:	b003      	add	sp, #12
  4070e4:	bd30      	pop	{r4, r5, pc}
    if (m_rtos_inited) { vTaskSuspend(drv_monitor_handle); }
  4070e6:	6980      	ldr	r0, [r0, #24]
  4070e8:	4b10      	ldr	r3, [pc, #64]	; (40712c <_ZN8TMC4361A10initializeEv+0xac>)
  4070ea:	4798      	blx	r3
  4070ec:	e7cf      	b.n	40708e <_ZN8TMC4361A10initializeEv+0xe>
        initialized &= setPosition(m_cached_position);
  4070ee:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  4070f0:	4620      	mov	r0, r4
  4070f2:	4b0f      	ldr	r3, [pc, #60]	; (407130 <_ZN8TMC4361A10initializeEv+0xb0>)
  4070f4:	4798      	blx	r3
  4070f6:	4005      	ands	r5, r0
        m_cached_position = 0;
  4070f8:	2300      	movs	r3, #0
  4070fa:	63a3      	str	r3, [r4, #56]	; 0x38
  4070fc:	e7e9      	b.n	4070d2 <_ZN8TMC4361A10initializeEv+0x52>
    if (m_rtos_inited) { vTaskResume(drv_monitor_handle); }
  4070fe:	69a0      	ldr	r0, [r4, #24]
  407100:	4b0c      	ldr	r3, [pc, #48]	; (407134 <_ZN8TMC4361A10initializeEv+0xb4>)
  407102:	4798      	blx	r3
  407104:	e7e8      	b.n	4070d8 <_ZN8TMC4361A10initializeEv+0x58>
  407106:	bf00      	nop
  407108:	00406e69 	.word	0x00406e69
  40710c:	00406f55 	.word	0x00406f55
  407110:	00406d35 	.word	0x00406d35
  407114:	00406f39 	.word	0x00406f39
  407118:	00406d61 	.word	0x00406d61
  40711c:	00406e01 	.word	0x00406e01
  407120:	00406e55 	.word	0x00406e55
  407124:	004069a9 	.word	0x004069a9
  407128:	20000001 	.word	0x20000001
  40712c:	00409d49 	.word	0x00409d49
  407130:	00406ccd 	.word	0x00406ccd
  407134:	00409889 	.word	0x00409889

00407138 <_ZN11MotionQueueC1Ev>:
 *  Author: Tan
 */

#include "motion_queue.h"

MotionQueue::MotionQueue() {
  407138:	b570      	push	{r4, r5, r6, lr}
  40713a:	b084      	sub	sp, #16
  40713c:	4604      	mov	r4, r0
  40713e:	4606      	mov	r6, r0
  407140:	250e      	movs	r5, #14
  407142:	e002      	b.n	40714a <_ZN11MotionQueueC1Ev+0x12>
  407144:	f506 66e0 	add.w	r6, r6, #1792	; 0x700
  407148:	3d01      	subs	r5, #1
  40714a:	2d00      	cmp	r5, #0
  40714c:	db24      	blt.n	407198 <_ZN11MotionQueueC1Ev+0x60>
        MotionType       motion_type;
        MotionParameters parameters;
        uint8_t          sequence_number = 0xFF; // use for extra check
    };

    struct Queue {
  40714e:	4633      	mov	r3, r6
  407150:	201f      	movs	r0, #31
  407152:	2800      	cmp	r0, #0
  407154:	dbf6      	blt.n	407144 <_ZN11MotionQueueC1Ev+0xc>
    struct MotionParameters {
  407156:	21ff      	movs	r1, #255	; 0xff
  407158:	8059      	strh	r1, [r3, #2]
  40715a:	2200      	movs	r2, #0
  40715c:	809a      	strh	r2, [r3, #4]
  40715e:	80da      	strh	r2, [r3, #6]
  407160:	811a      	strh	r2, [r3, #8]
  407162:	815a      	strh	r2, [r3, #10]
  407164:	8199      	strh	r1, [r3, #12]
  407166:	81da      	strh	r2, [r3, #14]
  407168:	821a      	strh	r2, [r3, #16]
  40716a:	825a      	strh	r2, [r3, #18]
  40716c:	829a      	strh	r2, [r3, #20]
  40716e:	82da      	strh	r2, [r3, #22]
  407170:	831a      	strh	r2, [r3, #24]
  407172:	835a      	strh	r2, [r3, #26]
  407174:	839a      	strh	r2, [r3, #28]
  407176:	83da      	strh	r2, [r3, #30]
  407178:	841a      	strh	r2, [r3, #32]
  40717a:	845a      	strh	r2, [r3, #34]	; 0x22
  40717c:	849a      	strh	r2, [r3, #36]	; 0x24
  40717e:	84da      	strh	r2, [r3, #38]	; 0x26
  407180:	851a      	strh	r2, [r3, #40]	; 0x28
  407182:	855a      	strh	r2, [r3, #42]	; 0x2a
  407184:	859a      	strh	r2, [r3, #44]	; 0x2c
  407186:	85da      	strh	r2, [r3, #46]	; 0x2e
  407188:	861a      	strh	r2, [r3, #48]	; 0x30
  40718a:	865a      	strh	r2, [r3, #50]	; 0x32
  40718c:	869a      	strh	r2, [r3, #52]	; 0x34
    struct QueueItem {
  40718e:	f883 1036 	strb.w	r1, [r3, #54]	; 0x36
    struct Queue {
  407192:	3338      	adds	r3, #56	; 0x38
  407194:	3801      	subs	r0, #1
  407196:	e7dc      	b.n	407152 <_ZN11MotionQueueC1Ev+0x1a>
    struct MotionParameters {
  407198:	f646 1202 	movw	r2, #26882	; 0x6902
  40719c:	18a3      	adds	r3, r4, r2
  40719e:	21ff      	movs	r1, #255	; 0xff
  4071a0:	52a1      	strh	r1, [r4, r2]
  4071a2:	2200      	movs	r2, #0
  4071a4:	805a      	strh	r2, [r3, #2]
  4071a6:	809a      	strh	r2, [r3, #4]
  4071a8:	80da      	strh	r2, [r3, #6]
  4071aa:	811a      	strh	r2, [r3, #8]
  4071ac:	8159      	strh	r1, [r3, #10]
  4071ae:	819a      	strh	r2, [r3, #12]
  4071b0:	81da      	strh	r2, [r3, #14]
  4071b2:	821a      	strh	r2, [r3, #16]
  4071b4:	825a      	strh	r2, [r3, #18]
  4071b6:	829a      	strh	r2, [r3, #20]
  4071b8:	82da      	strh	r2, [r3, #22]
  4071ba:	831a      	strh	r2, [r3, #24]
  4071bc:	835a      	strh	r2, [r3, #26]
  4071be:	839a      	strh	r2, [r3, #28]
  4071c0:	83da      	strh	r2, [r3, #30]
  4071c2:	841a      	strh	r2, [r3, #32]
  4071c4:	845a      	strh	r2, [r3, #34]	; 0x22
  4071c6:	849a      	strh	r2, [r3, #36]	; 0x24
  4071c8:	84da      	strh	r2, [r3, #38]	; 0x26
  4071ca:	851a      	strh	r2, [r3, #40]	; 0x28
  4071cc:	855a      	strh	r2, [r3, #42]	; 0x2a
  4071ce:	859a      	strh	r2, [r3, #44]	; 0x2c
  4071d0:	85da      	strh	r2, [r3, #46]	; 0x2e
  4071d2:	861a      	strh	r2, [r3, #48]	; 0x30
  4071d4:	865a      	strh	r2, [r3, #50]	; 0x32
    struct QueueItem {
  4071d6:	f504 43d2 	add.w	r3, r4, #26880	; 0x6900
  4071da:	f883 1036 	strb.w	r1, [r3, #54]	; 0x36
  4071de:	3338      	adds	r3, #56	; 0x38
  4071e0:	201f      	movs	r0, #31
  4071e2:	2800      	cmp	r0, #0
  4071e4:	db20      	blt.n	407228 <_ZN11MotionQueueC1Ev+0xf0>
    struct MotionParameters {
  4071e6:	21ff      	movs	r1, #255	; 0xff
  4071e8:	8059      	strh	r1, [r3, #2]
  4071ea:	2200      	movs	r2, #0
  4071ec:	809a      	strh	r2, [r3, #4]
  4071ee:	80da      	strh	r2, [r3, #6]
  4071f0:	811a      	strh	r2, [r3, #8]
  4071f2:	815a      	strh	r2, [r3, #10]
  4071f4:	8199      	strh	r1, [r3, #12]
  4071f6:	81da      	strh	r2, [r3, #14]
  4071f8:	821a      	strh	r2, [r3, #16]
  4071fa:	825a      	strh	r2, [r3, #18]
  4071fc:	829a      	strh	r2, [r3, #20]
  4071fe:	82da      	strh	r2, [r3, #22]
  407200:	831a      	strh	r2, [r3, #24]
  407202:	835a      	strh	r2, [r3, #26]
  407204:	839a      	strh	r2, [r3, #28]
  407206:	83da      	strh	r2, [r3, #30]
  407208:	841a      	strh	r2, [r3, #32]
  40720a:	845a      	strh	r2, [r3, #34]	; 0x22
  40720c:	849a      	strh	r2, [r3, #36]	; 0x24
  40720e:	84da      	strh	r2, [r3, #38]	; 0x26
  407210:	851a      	strh	r2, [r3, #40]	; 0x28
  407212:	855a      	strh	r2, [r3, #42]	; 0x2a
  407214:	859a      	strh	r2, [r3, #44]	; 0x2c
  407216:	85da      	strh	r2, [r3, #46]	; 0x2e
  407218:	861a      	strh	r2, [r3, #48]	; 0x30
  40721a:	865a      	strh	r2, [r3, #50]	; 0x32
  40721c:	869a      	strh	r2, [r3, #52]	; 0x34
    struct QueueItem {
  40721e:	f883 1036 	strb.w	r1, [r3, #54]	; 0x36
  407222:	3338      	adds	r3, #56	; 0x38
  407224:	3801      	subs	r0, #1
  407226:	e7dc      	b.n	4071e2 <_ZN11MotionQueueC1Ev+0xaa>
  407228:	2500      	movs	r5, #0
  40722a:	f247 0351 	movw	r3, #28753	; 0x7051
  40722e:	54e5      	strb	r5, [r4, r3]

    // Commands
    bool m_abort_queue = false;

    // Trackers
    struct QueueStatus {
  407230:	f247 0252 	movw	r2, #28754	; 0x7052
  407234:	18a3      	adds	r3, r4, r2
  407236:	52a5      	strh	r5, [r4, r2]
  407238:	805d      	strh	r5, [r3, #2]
  40723a:	809d      	strh	r5, [r3, #4]
     * @return Result
     */
    Result execSuccessful(MotionType motion_type, MotionParameters parameters);

    /* ================================ Motion Queue Task =============================== */
    xQueueHandle m_motion_queue_handle = xQueueCreate(1, sizeof(uint8_t *));
  40723c:	462a      	mov	r2, r5
  40723e:	2104      	movs	r1, #4
  407240:	2001      	movs	r0, #1
  407242:	4e0d      	ldr	r6, [pc, #52]	; (407278 <_ZN11MotionQueueC1Ev+0x140>)
  407244:	47b0      	blx	r6
  407246:	f247 0358 	movw	r3, #28760	; 0x7058
  40724a:	50e0      	str	r0, [r4, r3]
    xQueueHandle m_result_queue_handle = xQueueCreate(1, sizeof(Result));
  40724c:	462a      	mov	r2, r5
  40724e:	2101      	movs	r1, #1
  407250:	4608      	mov	r0, r1
  407252:	47b0      	blx	r6
  407254:	f247 035c 	movw	r3, #28764	; 0x705c
  407258:	50e0      	str	r0, [r4, r3]
                (const signed char *)"motionQueue", // task name
                496,                                // stack size (117)
                this,                               // stack parameters
                2,                                  // stack priority
                NULL                                // stack handle
    );
  40725a:	9503      	str	r5, [sp, #12]
  40725c:	9502      	str	r5, [sp, #8]
  40725e:	9501      	str	r5, [sp, #4]
  407260:	2302      	movs	r3, #2
  407262:	9300      	str	r3, [sp, #0]
  407264:	4623      	mov	r3, r4
  407266:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
  40726a:	4904      	ldr	r1, [pc, #16]	; (40727c <_ZN11MotionQueueC1Ev+0x144>)
  40726c:	4804      	ldr	r0, [pc, #16]	; (407280 <_ZN11MotionQueueC1Ev+0x148>)
  40726e:	4d05      	ldr	r5, [pc, #20]	; (407284 <_ZN11MotionQueueC1Ev+0x14c>)
  407270:	47a8      	blx	r5
}
  407272:	4620      	mov	r0, r4
  407274:	b004      	add	sp, #16
  407276:	bd70      	pop	{r4, r5, r6, pc}
  407278:	004091b5 	.word	0x004091b5
  40727c:	0040e2a4 	.word	0x0040e2a4
  407280:	00407f5d 	.word	0x00407f5d
  407284:	00409659 	.word	0x00409659

00407288 <_ZN11MotionQueue11queueMotionEh>:

/* ---------------------------------------------------------------------------------- */
MotionQueue::PutQueueRes MotionQueue::queueMotion(uint8_t motion_num) {
  407288:	b530      	push	{r4, r5, lr}
  40728a:	b083      	sub	sp, #12
  40728c:	4604      	mov	r4, r0
  40728e:	460d      	mov	r5, r1
    if (uxQueueMessagesWaiting(m_result_queue_handle) != 0) {
  407290:	f247 035c 	movw	r3, #28764	; 0x705c
  407294:	58c0      	ldr	r0, [r0, r3]
  407296:	4b0f      	ldr	r3, [pc, #60]	; (4072d4 <_ZN11MotionQueue11queueMotionEh+0x4c>)
  407298:	4798      	blx	r3
  40729a:	b110      	cbz	r0, 4072a2 <_ZN11MotionQueue11queueMotionEh+0x1a>
        motion_queue_debug("Put queue failed! Results pending\n");
        return PutQueueRes::Q_RESULTS_PENDING;
  40729c:	2003      	movs	r0, #3
        // Queue full, free heap memory
        motion_queue_debug("Put queue failed! Queue is full\n", motion_num);
        delete motion_num_ptr;
        return PutQueueRes::Q_FULL;
    }
}
  40729e:	b003      	add	sp, #12
  4072a0:	bd30      	pop	{r4, r5, pc}
    uint8_t *motion_num_ptr = new uint8_t(motion_num);
  4072a2:	2001      	movs	r0, #1
  4072a4:	4b0c      	ldr	r3, [pc, #48]	; (4072d8 <_ZN11MotionQueue11queueMotionEh+0x50>)
  4072a6:	4798      	blx	r3
  4072a8:	7005      	strb	r5, [r0, #0]
  4072aa:	a902      	add	r1, sp, #8
  4072ac:	f841 0d04 	str.w	r0, [r1, #-4]!
    if (xQueueSend(m_motion_queue_handle, &motion_num_ptr, 0) == pdTRUE) {
  4072b0:	2300      	movs	r3, #0
  4072b2:	461a      	mov	r2, r3
  4072b4:	f247 0058 	movw	r0, #28760	; 0x7058
  4072b8:	5820      	ldr	r0, [r4, r0]
  4072ba:	4c08      	ldr	r4, [pc, #32]	; (4072dc <_ZN11MotionQueue11queueMotionEh+0x54>)
  4072bc:	47a0      	blx	r4
  4072be:	2801      	cmp	r0, #1
  4072c0:	d005      	beq.n	4072ce <_ZN11MotionQueue11queueMotionEh+0x46>
        delete motion_num_ptr;
  4072c2:	2101      	movs	r1, #1
  4072c4:	9801      	ldr	r0, [sp, #4]
  4072c6:	4b06      	ldr	r3, [pc, #24]	; (4072e0 <_ZN11MotionQueue11queueMotionEh+0x58>)
  4072c8:	4798      	blx	r3
        return PutQueueRes::Q_FULL;
  4072ca:	2002      	movs	r0, #2
  4072cc:	e7e7      	b.n	40729e <_ZN11MotionQueue11queueMotionEh+0x16>
        return PutQueueRes::Q_SUCCESS;
  4072ce:	2001      	movs	r0, #1
  4072d0:	e7e5      	b.n	40729e <_ZN11MotionQueue11queueMotionEh+0x16>
  4072d2:	bf00      	nop
  4072d4:	00409589 	.word	0x00409589
  4072d8:	0040b2b9 	.word	0x0040b2b9
  4072dc:	00409209 	.word	0x00409209
  4072e0:	0040b2b5 	.word	0x0040b2b5

004072e4 <_ZN11MotionQueue16registerSteppersEPP7Stepper>:
    return static_cast<PreloadPutQueueRes>(res);
}

/* ---------------------------------------------------------------------------------- */
void MotionQueue::registerSteppers(Stepper *steppers[MAX_STEPPERS]) {
    for (int i = 0; i < MAX_STEPPERS; i++) {
  4072e4:	2300      	movs	r3, #0
  4072e6:	2b04      	cmp	r3, #4
  4072e8:	dc0b      	bgt.n	407302 <_ZN11MotionQueue16registerSteppersEPP7Stepper+0x1e>
void MotionQueue::registerSteppers(Stepper *steppers[MAX_STEPPERS]) {
  4072ea:	b410      	push	{r4}
        m_steppers[i] = steppers[i]; // copy each pointer
  4072ec:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
  4072f0:	f503 52e0 	add.w	r2, r3, #7168	; 0x1c00
  4072f4:	320e      	adds	r2, #14
  4072f6:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
    for (int i = 0; i < MAX_STEPPERS; i++) {
  4072fa:	3301      	adds	r3, #1
  4072fc:	2b04      	cmp	r3, #4
  4072fe:	ddf5      	ble.n	4072ec <_ZN11MotionQueue16registerSteppersEPP7Stepper+0x8>
    }
}
  407300:	bc10      	pop	{r4}
  407302:	4770      	bx	lr

00407304 <_ZN11MotionQueue11getReadbackEPm>:

/* ---------------------------------------------------------------------------------- */
bool MotionQueue::getReadback(uint32_t *readback) {
  407304:	b530      	push	{r4, r5, lr}
  407306:	b083      	sub	sp, #12
  407308:	460d      	mov	r5, r1
    Result res;
    bool   has_readback = xQueueReceive(m_result_queue_handle, &res, 0) == pdTRUE;
  40730a:	2300      	movs	r3, #0
  40730c:	461a      	mov	r2, r3
  40730e:	f10d 0107 	add.w	r1, sp, #7
  407312:	f247 045c 	movw	r4, #28764	; 0x705c
  407316:	5900      	ldr	r0, [r0, r4]
  407318:	4c06      	ldr	r4, [pc, #24]	; (407334 <_ZN11MotionQueue11getReadbackEPm+0x30>)
  40731a:	47a0      	blx	r4
  40731c:	2801      	cmp	r0, #1
  40731e:	bf0c      	ite	eq
  407320:	2001      	moveq	r0, #1
  407322:	2000      	movne	r0, #0

    if (has_readback) {
  407324:	d001      	beq.n	40732a <_ZN11MotionQueue11getReadbackEPm+0x26>
        motion_queue_debug("Readback -> %d\n", res);
        *readback = static_cast<uint32_t>(res);
    }

    return has_readback;
}
  407326:	b003      	add	sp, #12
  407328:	bd30      	pop	{r4, r5, pc}
        *readback = static_cast<uint32_t>(res);
  40732a:	f89d 3007 	ldrb.w	r3, [sp, #7]
  40732e:	602b      	str	r3, [r5, #0]
  407330:	e7f9      	b.n	407326 <_ZN11MotionQueue11getReadbackEPm+0x22>
  407332:	bf00      	nop
  407334:	00409421 	.word	0x00409421

00407338 <_ZN11MotionQueue14getQueueStatusEv>:

/* ---------------------------------------------------------------------------------- */
uint16_t MotionQueue::getQueueStatus() {
    uint16_t word = 0;

    word |= ((m_queue_status.is_executing & 0x1) << 15);
  407338:	f247 0352 	movw	r3, #28754	; 0x7052
  40733c:	5ac3      	ldrh	r3, [r0, r3]
  40733e:	03db      	lsls	r3, r3, #15
  407340:	b21b      	sxth	r3, r3
    word |= ((m_queue_status.motion_num & 0xF) << 11);
  407342:	f247 0254 	movw	r2, #28756	; 0x7054
  407346:	5a82      	ldrh	r2, [r0, r2]
  407348:	02d2      	lsls	r2, r2, #11
  40734a:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
  40734e:	4313      	orrs	r3, r2
    word |= ((m_queue_status.sequence_num & 0x7FF) << 0);
  407350:	f247 0256 	movw	r2, #28758	; 0x7056
  407354:	5e80      	ldrsh	r0, [r0, r2]
  407356:	f3c0 000a 	ubfx	r0, r0, #0, #11
  40735a:	4318      	orrs	r0, r3

    return word;
}
  40735c:	b280      	uxth	r0, r0
  40735e:	4770      	bx	lr

00407360 <_ZN11MotionQueue20isStepperUsedInQueueEh>:

/* ---------------------------------------------------------------------------------- */
bool MotionQueue::isStepperUsedInQueue(uint8_t driver_num) {
    if (driver_num >= MAX_STEPPERS) { return false; }
  407360:	2904      	cmp	r1, #4
  407362:	dc04      	bgt.n	40736e <_ZN11MotionQueue20isStepperUsedInQueueEh+0xe>
    return stepper_used_in_queue[driver_num];
  407364:	4408      	add	r0, r1
  407366:	f247 034c 	movw	r3, #28748	; 0x704c
  40736a:	5cc0      	ldrb	r0, [r0, r3]
  40736c:	4770      	bx	lr
    if (driver_num >= MAX_STEPPERS) { return false; }
  40736e:	2000      	movs	r0, #0
}
  407370:	4770      	bx	lr

00407372 <_ZN11MotionQueue10abortQueueEv>:

/* ---------------------------------------------------------------------------------- */
bool MotionQueue::abortQueue() {
    if (m_queue_status.is_executing == 1) {
  407372:	f247 0352 	movw	r3, #28754	; 0x7052
  407376:	5ac3      	ldrh	r3, [r0, r3]
  407378:	2b01      	cmp	r3, #1
  40737a:	d001      	beq.n	407380 <_ZN11MotionQueue10abortQueueEv+0xe>
        m_abort_queue = true;
        return true;
    }
    return false;
  40737c:	2000      	movs	r0, #0
}
  40737e:	4770      	bx	lr
        m_abort_queue = true;
  407380:	f247 0251 	movw	r2, #28753	; 0x7051
  407384:	5483      	strb	r3, [r0, r2]
        return true;
  407386:	4618      	mov	r0, r3
  407388:	4770      	bx	lr

0040738a <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht>:

/* ---------------------------------------------------------------------------------- */
void MotionQueue::writeMotionItem(QueueItemKey q_key, uint8_t motion_num, uint8_t item_num, uint16_t val) {
  40738a:	b430      	push	{r4, r5}
  40738c:	f8bd 5008 	ldrh.w	r5, [sp, #8]
    QueueItem &q_item = (motion_num == TEST_MOTION_NUM) ? test_item : motion_list[motion_num].items[item_num];
  407390:	2aff      	cmp	r2, #255	; 0xff
  407392:	d019      	beq.n	4073c8 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x3e>
  407394:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  407398:	00dc      	lsls	r4, r3, #3
  40739a:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
  40739e:	0213      	lsls	r3, r2, #8
  4073a0:	441c      	add	r4, r3
  4073a2:	4420      	add	r0, r4

    motion_queue_debug("(M%d%d) Write Key %d -> %d\n", motion_num, item_num, q_key, val);
    switch (q_key) {
  4073a4:	291b      	cmp	r1, #27
  4073a6:	d813      	bhi.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
  4073a8:	e8df f001 	tbb	[pc, r1]
  4073ac:	19171411 	.word	0x19171411
  4073b0:	211f1d1b 	.word	0x211f1d1b
  4073b4:	29272523 	.word	0x29272523
  4073b8:	312f2d2b 	.word	0x312f2d2b
  4073bc:	39373533 	.word	0x39373533
  4073c0:	413f3d3b 	.word	0x413f3d3b
  4073c4:	49474543 	.word	0x49474543
    QueueItem &q_item = (motion_num == TEST_MOTION_NUM) ? test_item : motion_list[motion_num].items[item_num];
  4073c8:	f500 40d2 	add.w	r0, r0, #26880	; 0x6900
  4073cc:	e7ea      	b.n	4073a4 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x1a>
    case QueueItemKey::MOTION_TYPE: {
        q_item.motion_type = static_cast<MotionType>(val);
  4073ce:	7005      	strb	r5, [r0, #0]
    }
    default: {
        break;
    }
    }
}
  4073d0:	bc30      	pop	{r4, r5}
  4073d2:	4770      	bx	lr
        q_item.sequence_number = val;
  4073d4:	f880 5036 	strb.w	r5, [r0, #54]	; 0x36
        break;
  4073d8:	e7fa      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.driver_num = val;
  4073da:	8045      	strh	r5, [r0, #2]
        break;
  4073dc:	e7f8      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.position_h = val;
  4073de:	8085      	strh	r5, [r0, #4]
        break;
  4073e0:	e7f6      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.position_l = val;
  4073e2:	80c5      	strh	r5, [r0, #6]
        break;
  4073e4:	e7f4      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.offset_h = val;
  4073e6:	8105      	strh	r5, [r0, #8]
        break;
  4073e8:	e7f2      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.offset_l = val;
  4073ea:	8145      	strh	r5, [r0, #10]
        break;
  4073ec:	e7f0      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.homing_mode = val;
  4073ee:	8185      	strh	r5, [r0, #12]
        break;
  4073f0:	e7ee      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.homing_sensor = val;
  4073f2:	81c5      	strh	r5, [r0, #14]
        break;
  4073f4:	e7ec      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.sensor_home_value = val;
  4073f6:	8205      	strh	r5, [r0, #16]
        break;
  4073f8:	e7ea      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.ramp_type = val;
  4073fa:	8245      	strh	r5, [r0, #18]
        break;
  4073fc:	e7e8      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.max_speed_h = val;
  4073fe:	8285      	strh	r5, [r0, #20]
        break;
  407400:	e7e6      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.max_speed_l = val;
  407402:	82c5      	strh	r5, [r0, #22]
        break;
  407404:	e7e4      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.max_accel_h = val;
  407406:	8305      	strh	r5, [r0, #24]
        break;
  407408:	e7e2      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.max_accel_l = val;
  40740a:	8345      	strh	r5, [r0, #26]
        break;
  40740c:	e7e0      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.max_decel_h = val;
  40740e:	8385      	strh	r5, [r0, #28]
        break;
  407410:	e7de      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.max_decel_l = val;
  407412:	83c5      	strh	r5, [r0, #30]
        break;
  407414:	e7dc      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.bow1_h = val;
  407416:	8405      	strh	r5, [r0, #32]
        break;
  407418:	e7da      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.bow1_l = val;
  40741a:	8445      	strh	r5, [r0, #34]	; 0x22
        break;
  40741c:	e7d8      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.bow2_h = val;
  40741e:	8485      	strh	r5, [r0, #36]	; 0x24
        break;
  407420:	e7d6      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.bow2_l = val;
  407422:	84c5      	strh	r5, [r0, #38]	; 0x26
        break;
  407424:	e7d4      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.bow3_h = val;
  407426:	8505      	strh	r5, [r0, #40]	; 0x28
        break;
  407428:	e7d2      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.bow3_l = val;
  40742a:	8545      	strh	r5, [r0, #42]	; 0x2a
        break;
  40742c:	e7d0      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.bow4_h = val;
  40742e:	8585      	strh	r5, [r0, #44]	; 0x2c
        break;
  407430:	e7ce      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.bow4_l = val;
  407432:	85c5      	strh	r5, [r0, #46]	; 0x2e
        break;
  407434:	e7cc      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.use_inverse_time = val;
  407436:	8605      	strh	r5, [r0, #48]	; 0x30
        break;
  407438:	e7ca      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.time_h = val;
  40743a:	8645      	strh	r5, [r0, #50]	; 0x32
        break;
  40743c:	e7c8      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
        q_item.parameters.time_l = val;
  40743e:	8685      	strh	r5, [r0, #52]	; 0x34
}
  407440:	e7c6      	b.n	4073d0 <_ZN11MotionQueue15writeMotionItemENS_12QueueItemKeyEhht+0x46>
	...

00407444 <_ZN11MotionQueue25stepperIsReadyForMovementEh>:
    motion_queue_debug("FAILED\n\n");
    return Result::FAILED_MIDWAY;
}

/* ---------------------------------------------------------------------------------- */
bool MotionQueue::stepperIsReadyForMovement(uint8_t driver_num) {
  407444:	b508      	push	{r3, lr}
    Stepper::Status sts = m_steppers[driver_num]->getStatus();
  407446:	f501 51e0 	add.w	r1, r1, #7168	; 0x1c00
  40744a:	310e      	adds	r1, #14
  40744c:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
  407450:	4b05      	ldr	r3, [pc, #20]	; (407468 <_ZN11MotionQueue25stepperIsReadyForMovementEh+0x24>)
  407452:	4798      	blx	r3

    return (sts == Stepper::Status::READY || sts == Stepper::Status::MOTION_NOT_INIT);
  407454:	2801      	cmp	r0, #1
  407456:	d005      	beq.n	407464 <_ZN11MotionQueue25stepperIsReadyForMovementEh+0x20>
  407458:	2806      	cmp	r0, #6
  40745a:	d001      	beq.n	407460 <_ZN11MotionQueue25stepperIsReadyForMovementEh+0x1c>
  40745c:	2000      	movs	r0, #0
}
  40745e:	bd08      	pop	{r3, pc}
    return (sts == Stepper::Status::READY || sts == Stepper::Status::MOTION_NOT_INIT);
  407460:	2001      	movs	r0, #1
  407462:	bd08      	pop	{r3, pc}
  407464:	2001      	movs	r0, #1
  407466:	bd08      	pop	{r3, pc}
  407468:	004052f5 	.word	0x004052f5

0040746c <_ZN11MotionQueue22flagStepperUsedInQueueEh>:

/* ---------------------------------------------------------------------------------- */
void MotionQueue::flagStepperUsedInQueue(uint8_t driver_num) {
    if (driver_num >= MAX_STEPPERS) { return; }
  40746c:	2904      	cmp	r1, #4
  40746e:	dc04      	bgt.n	40747a <_ZN11MotionQueue22flagStepperUsedInQueueEh+0xe>
    stepper_used_in_queue[driver_num] = true;
  407470:	4408      	add	r0, r1
  407472:	2201      	movs	r2, #1
  407474:	f247 034c 	movw	r3, #28748	; 0x704c
  407478:	54c2      	strb	r2, [r0, r3]
  40747a:	4770      	bx	lr

0040747c <_ZN11MotionQueue17unflagAllSteppersEv>:
}

/* ---------------------------------------------------------------------------------- */
void MotionQueue::unflagAllSteppers() {
    for (int i = 0; i < MAX_STEPPERS; i++) {
  40747c:	2300      	movs	r3, #0
  40747e:	2b04      	cmp	r3, #4
  407480:	dc09      	bgt.n	407496 <_ZN11MotionQueue17unflagAllSteppersEv+0x1a>
void MotionQueue::unflagAllSteppers() {
  407482:	b410      	push	{r4}
        stepper_used_in_queue[i] = false;
  407484:	18c1      	adds	r1, r0, r3
  407486:	2400      	movs	r4, #0
  407488:	f247 024c 	movw	r2, #28748	; 0x704c
  40748c:	548c      	strb	r4, [r1, r2]
    for (int i = 0; i < MAX_STEPPERS; i++) {
  40748e:	3301      	adds	r3, #1
  407490:	2b04      	cmp	r3, #4
  407492:	ddf7      	ble.n	407484 <_ZN11MotionQueue17unflagAllSteppersEv+0x8>
    }
}
  407494:	bc10      	pop	{r4}
  407496:	4770      	bx	lr

00407498 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE>:

/* ---------------------------------------------------------------------------------- */
bool MotionQueue::setMotionParameters(MotionType motion_type, MotionParameters parameters) {
  407498:	b082      	sub	sp, #8
  40749a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40749e:	b09c      	sub	sp, #112	; 0x70
  4074a0:	ac24      	add	r4, sp, #144	; 0x90
  4074a2:	e884 000c 	stmia.w	r4, {r2, r3}
    uint8_t driver_num = parameters.driver_num;
  4074a6:	f89d 5090 	ldrb.w	r5, [sp, #144]	; 0x90

    if (motion_type == MotionType::WAIT_SENSOR || motion_type == MotionType::WAIT_TIME) {
  4074aa:	1ecb      	subs	r3, r1, #3
  4074ac:	b2db      	uxtb	r3, r3
  4074ae:	2b01      	cmp	r3, #1
  4074b0:	f240 8106 	bls.w	4076c0 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x228>
  4074b4:	460e      	mov	r6, r1
  4074b6:	4604      	mov	r4, r0
        motion_queue_debug(" [Set motion skipped] ");
        return true;
    }

    // Homing
    if (motion_type == MotionType::MOVE_HOMING) {
  4074b8:	2902      	cmp	r1, #2
  4074ba:	f000 80a2 	beq.w	407602 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x16a>

        return true;
    }

    // Relative / Absolute
    Stepper::MoveSettings move_s;
  4074be:	ab18      	add	r3, sp, #96	; 0x60
  4074c0:	2700      	movs	r7, #0
  4074c2:	971a      	str	r7, [sp, #104]	; 0x68
  4074c4:	971b      	str	r7, [sp, #108]	; 0x6c
  4074c6:	2202      	movs	r2, #2
  4074c8:	f88d 206c 	strb.w	r2, [sp, #108]	; 0x6c
    move_s.unit_high    = parameters.position_h;
  4074cc:	f8bd 2092 	ldrh.w	r2, [sp, #146]	; 0x92
  4074d0:	f8ad 2060 	strh.w	r2, [sp, #96]	; 0x60
    move_s.unit_low     = parameters.position_l;
  4074d4:	f8bd 2094 	ldrh.w	r2, [sp, #148]	; 0x94
  4074d8:	f8ad 2062 	strh.w	r2, [sp, #98]	; 0x62
    move_s.time_ms_high = parameters.time_h;
  4074dc:	f8bd 20c0 	ldrh.w	r2, [sp, #192]	; 0xc0
  4074e0:	f8ad 2064 	strh.w	r2, [sp, #100]	; 0x64
    move_s.time_ms_low  = parameters.time_l;
  4074e4:	f8bd 20c2 	ldrh.w	r2, [sp, #194]	; 0xc2
  4074e8:	f8ad 2066 	strh.w	r2, [sp, #102]	; 0x66

    m_steppers[driver_num]->confMove(move_s);
  4074ec:	f505 58e0 	add.w	r8, r5, #7168	; 0x1c00
  4074f0:	f108 080e 	add.w	r8, r8, #14
  4074f4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
  4074f6:	9200      	str	r2, [sp, #0]
  4074f8:	cb0e      	ldmia	r3, {r1, r2, r3}
  4074fa:	f850 0028 	ldr.w	r0, [r0, r8, lsl #2]
  4074fe:	f8df 91e0 	ldr.w	r9, [pc, #480]	; 4076e0 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x248>
  407502:	47c8      	blx	r9

    Stepper::RampSettings ramp_s;
  407504:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4076e4 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x24c>
  407508:	46ca      	mov	sl, r9
  40750a:	f83a 3b04 	ldrh.w	r3, [sl], #4
  40750e:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
    ramp_s.ramp_mode = Stepper::RampMode::POSITIONING_MODE;
    ramp_s.ramp_type = static_cast<Stepper::RampType>(parameters.ramp_type);
  407512:	f89d 30a0 	ldrb.w	r3, [sp, #160]	; 0xa0
  407516:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d

    m_steppers[driver_num]->confRamp(ramp_s);
  40751a:	9917      	ldr	r1, [sp, #92]	; 0x5c
  40751c:	f854 0028 	ldr.w	r0, [r4, r8, lsl #2]
  407520:	4b68      	ldr	r3, [pc, #416]	; (4076c4 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x22c>)
  407522:	4798      	blx	r3

    Stepper::SpeedSettings m_spd_s;
  407524:	ab13      	add	r3, sp, #76	; 0x4c
  407526:	9714      	str	r7, [sp, #80]	; 0x50
  407528:	9715      	str	r7, [sp, #84]	; 0x54
    m_spd_s.max_h = parameters.max_speed_h;
  40752a:	f8bd 20a2 	ldrh.w	r2, [sp, #162]	; 0xa2
  40752e:	f8ad 204c 	strh.w	r2, [sp, #76]	; 0x4c
    m_spd_s.max_l = parameters.max_speed_l;
  407532:	f8bd 20a4 	ldrh.w	r2, [sp, #164]	; 0xa4
  407536:	f8ad 204e 	strh.w	r2, [sp, #78]	; 0x4e

    m_steppers[driver_num]->confSpeed(m_spd_s);
  40753a:	9700      	str	r7, [sp, #0]
  40753c:	cb0e      	ldmia	r3, {r1, r2, r3}
  40753e:	f854 0028 	ldr.w	r0, [r4, r8, lsl #2]
  407542:	4f61      	ldr	r7, [pc, #388]	; (4076c8 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x230>)
  407544:	47b8      	blx	r7

    Stepper::AccelerationSettings m_accel_s;
  407546:	af0f      	add	r7, sp, #60	; 0x3c
  407548:	e89a 000f 	ldmia.w	sl, {r0, r1, r2, r3}
  40754c:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    m_accel_s.max_accel_h = parameters.max_accel_h;
  407550:	f8bd 30a6 	ldrh.w	r3, [sp, #166]	; 0xa6
  407554:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
    m_accel_s.max_accel_l = parameters.max_accel_l;
  407558:	f8bd 30a8 	ldrh.w	r3, [sp, #168]	; 0xa8
  40755c:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
    m_accel_s.max_decel_h = parameters.max_decel_h;
  407560:	f8bd 30aa 	ldrh.w	r3, [sp, #170]	; 0xaa
  407564:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
    m_accel_s.max_decel_l = parameters.max_decel_l;
  407568:	f8bd 30ac 	ldrh.w	r3, [sp, #172]	; 0xac
  40756c:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42

    m_steppers[driver_num]->confAccel(m_accel_s);
  407570:	9b12      	ldr	r3, [sp, #72]	; 0x48
  407572:	9300      	str	r3, [sp, #0]
  407574:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
  407578:	f854 0028 	ldr.w	r0, [r4, r8, lsl #2]
  40757c:	4f53      	ldr	r7, [pc, #332]	; (4076cc <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x234>)
  40757e:	47b8      	blx	r7

    Stepper::BowSettings m_bow_s;
  407580:	af0b      	add	r7, sp, #44	; 0x2c
  407582:	f109 0314 	add.w	r3, r9, #20
  407586:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  407588:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    m_bow_s.bow1_h = parameters.bow1_h;
  40758c:	f8bd 30ae 	ldrh.w	r3, [sp, #174]	; 0xae
  407590:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    m_bow_s.bow1_l = parameters.bow1_l;
  407594:	f8bd 30b0 	ldrh.w	r3, [sp, #176]	; 0xb0
  407598:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
    m_bow_s.bow2_h = parameters.bow2_h;
  40759c:	f8bd 30b2 	ldrh.w	r3, [sp, #178]	; 0xb2
  4075a0:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
    m_bow_s.bow2_l = parameters.bow2_l;
  4075a4:	f8bd 30b4 	ldrh.w	r3, [sp, #180]	; 0xb4
  4075a8:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
    m_bow_s.bow3_h = parameters.bow3_h;
  4075ac:	f8bd 30b6 	ldrh.w	r3, [sp, #182]	; 0xb6
  4075b0:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
    m_bow_s.bow3_l = parameters.bow3_l;
  4075b4:	f8bd 30b8 	ldrh.w	r3, [sp, #184]	; 0xb8
  4075b8:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
    m_bow_s.bow4_h = parameters.bow4_h;
  4075bc:	f8bd 30ba 	ldrh.w	r3, [sp, #186]	; 0xba
  4075c0:	f8ad 3038 	strh.w	r3, [sp, #56]	; 0x38
    m_bow_s.bow4_l = parameters.bow4_l;
  4075c4:	f8bd 30bc 	ldrh.w	r3, [sp, #188]	; 0xbc
  4075c8:	f8ad 303a 	strh.w	r3, [sp, #58]	; 0x3a

    m_steppers[driver_num]->confBow(m_bow_s);
  4075cc:	f854 0028 	ldr.w	r0, [r4, r8, lsl #2]
  4075d0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4075d2:	9300      	str	r3, [sp, #0]
  4075d4:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
  4075d8:	4f3d      	ldr	r7, [pc, #244]	; (4076d0 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x238>)
  4075da:	47b8      	blx	r7

    if (motion_type == MotionType::MOVE_RELATIVE) {
  4075dc:	2e00      	cmp	r6, #0
  4075de:	d166      	bne.n	4076ae <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x216>
        m_steppers[driver_num]->confPositioning_posMode(Stepper::PositioningMode::PM_RELATIVE);
  4075e0:	2100      	movs	r1, #0
  4075e2:	f854 0028 	ldr.w	r0, [r4, r8, lsl #2]
  4075e6:	4b3b      	ldr	r3, [pc, #236]	; (4076d4 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x23c>)
  4075e8:	4798      	blx	r3
    } else {
        m_steppers[driver_num]->confPositioning_posMode(Stepper::PositioningMode::PM_ABSOLUTE);
    }

    return m_steppers[driver_num]->execSetMotion();
  4075ea:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
  4075ee:	350e      	adds	r5, #14
  4075f0:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
  4075f4:	4b38      	ldr	r3, [pc, #224]	; (4076d8 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x240>)
  4075f6:	4798      	blx	r3
}
  4075f8:	b01c      	add	sp, #112	; 0x70
  4075fa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4075fe:	b002      	add	sp, #8
  407600:	4770      	bx	lr
        if (parameters.homing_mode == 0xFF) {
  407602:	f8bd 309a 	ldrh.w	r3, [sp, #154]	; 0x9a
  407606:	2bff      	cmp	r3, #255	; 0xff
  407608:	d04f      	beq.n	4076aa <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x212>
        Stepper::HomeSettings home_s;
  40760a:	ae04      	add	r6, sp, #16
  40760c:	2200      	movs	r2, #0
  40760e:	9204      	str	r2, [sp, #16]
        home_s.homing_mode       = static_cast<Stepper::HomingMode>(parameters.homing_mode);
  407610:	f88d 3010 	strb.w	r3, [sp, #16]
        home_s.homing_sensor     = static_cast<Stepper::HomingSensor>(parameters.homing_sensor);
  407614:	f89d 309c 	ldrb.w	r3, [sp, #156]	; 0x9c
  407618:	f88d 3011 	strb.w	r3, [sp, #17]
        home_s.sensor_home_value = static_cast<bool>(parameters.sensor_home_value);
  40761c:	f8bd 309e 	ldrh.w	r3, [sp, #158]	; 0x9e
  407620:	1a9b      	subs	r3, r3, r2
  407622:	bf18      	it	ne
  407624:	2301      	movne	r3, #1
  407626:	f88d 3012 	strb.w	r3, [sp, #18]
        home_s.max_find_h        = parameters.position_h;
  40762a:	f8bd 3092 	ldrh.w	r3, [sp, #146]	; 0x92
  40762e:	f8ad 3014 	strh.w	r3, [sp, #20]
        home_s.max_find_l        = parameters.position_l;
  407632:	f8bd 3094 	ldrh.w	r3, [sp, #148]	; 0x94
  407636:	f8ad 3016 	strh.w	r3, [sp, #22]
        home_s.max_speed_h       = parameters.max_speed_h;
  40763a:	f8bd 30a2 	ldrh.w	r3, [sp, #162]	; 0xa2
  40763e:	f8ad 3018 	strh.w	r3, [sp, #24]
        home_s.max_speed_l       = parameters.max_speed_l;
  407642:	f8bd 30a4 	ldrh.w	r3, [sp, #164]	; 0xa4
  407646:	f8ad 301a 	strh.w	r3, [sp, #26]
        home_s.max_accel_h       = parameters.max_accel_h;
  40764a:	f8bd 30a6 	ldrh.w	r3, [sp, #166]	; 0xa6
  40764e:	f8ad 301c 	strh.w	r3, [sp, #28]
        home_s.max_accel_l       = parameters.max_accel_l;
  407652:	f8bd 30a8 	ldrh.w	r3, [sp, #168]	; 0xa8
  407656:	f8ad 301e 	strh.w	r3, [sp, #30]
        home_s.max_decel_h       = parameters.max_decel_h;
  40765a:	f8bd 30aa 	ldrh.w	r3, [sp, #170]	; 0xaa
  40765e:	f8ad 3020 	strh.w	r3, [sp, #32]
        home_s.max_decel_l       = parameters.max_decel_l;
  407662:	f8bd 30ac 	ldrh.w	r3, [sp, #172]	; 0xac
  407666:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
        home_s.offset_h          = parameters.offset_h;
  40766a:	f8bd 3096 	ldrh.w	r3, [sp, #150]	; 0x96
  40766e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        home_s.offset_l          = parameters.offset_l;
  407672:	f8bd 3098 	ldrh.w	r3, [sp, #152]	; 0x98
  407676:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
        home_s.timeout_ms_h      = parameters.time_h;
  40767a:	f8bd 30c0 	ldrh.w	r3, [sp, #192]	; 0xc0
  40767e:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
        home_s.timeout_ms_l      = parameters.time_l;
  407682:	f8bd 30c2 	ldrh.w	r3, [sp, #194]	; 0xc2
  407686:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
        m_steppers[driver_num]->confHome(home_s);
  40768a:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
  40768e:	350e      	adds	r5, #14
  407690:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
  407694:	ab07      	add	r3, sp, #28
  407696:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  407698:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
  40769c:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
  4076a0:	4620      	mov	r0, r4
  4076a2:	4c0e      	ldr	r4, [pc, #56]	; (4076dc <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x244>)
  4076a4:	47a0      	blx	r4
        return true;
  4076a6:	2001      	movs	r0, #1
  4076a8:	e7a6      	b.n	4075f8 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x160>
            return false;
  4076aa:	2000      	movs	r0, #0
  4076ac:	e7a4      	b.n	4075f8 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x160>
        m_steppers[driver_num]->confPositioning_posMode(Stepper::PositioningMode::PM_ABSOLUTE);
  4076ae:	f505 53e0 	add.w	r3, r5, #7168	; 0x1c00
  4076b2:	330e      	adds	r3, #14
  4076b4:	2101      	movs	r1, #1
  4076b6:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
  4076ba:	4b06      	ldr	r3, [pc, #24]	; (4076d4 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x23c>)
  4076bc:	4798      	blx	r3
  4076be:	e794      	b.n	4075ea <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x152>
        return true;
  4076c0:	2001      	movs	r0, #1
  4076c2:	e799      	b.n	4075f8 <_ZN11MotionQueue19setMotionParametersENS_10MotionTypeENS_16MotionParametersE+0x160>
  4076c4:	00405165 	.word	0x00405165
  4076c8:	0040517b 	.word	0x0040517b
  4076cc:	004051c7 	.word	0x004051c7
  4076d0:	00405213 	.word	0x00405213
  4076d4:	00405153 	.word	0x00405153
  4076d8:	00405811 	.word	0x00405811
  4076dc:	004050c1 	.word	0x004050c1
  4076e0:	00405085 	.word	0x00405085
  4076e4:	0040e2b8 	.word	0x0040e2b8

004076e8 <_ZN11MotionQueue21queuePreloadedMotionsEhPh>:
    if (motion_num >= MAX_MOTIONS) {
  4076e8:	290e      	cmp	r1, #14
  4076ea:	dd01      	ble.n	4076f0 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x8>
        return PreloadPutQueueRes::P_INVALID_MOTION;
  4076ec:	2004      	movs	r0, #4
  4076ee:	4770      	bx	lr
MotionQueue::PreloadPutQueueRes MotionQueue::queuePreloadedMotions(uint8_t motion_num, uint8_t *driver_num) {
  4076f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4076f4:	b08d      	sub	sp, #52	; 0x34
    QueueItem &item = preloaded_motions[motion_num];
  4076f6:	00cb      	lsls	r3, r1, #3
  4076f8:	1a5d      	subs	r5, r3, r1
  4076fa:	00ec      	lsls	r4, r5, #3
  4076fc:	4625      	mov	r5, r4
  4076fe:	f646 1638 	movw	r6, #26936	; 0x6938
  407702:	4434      	add	r4, r6
  407704:	4404      	add	r4, r0
    if (item.motion_type == MotionType::WAIT_SENSOR || item.motion_type == MotionType::WAIT_TIME) {
  407706:	4405      	add	r5, r0
  407708:	5dab      	ldrb	r3, [r5, r6]
  40770a:	3b03      	subs	r3, #3
  40770c:	b2db      	uxtb	r3, r3
  40770e:	2b01      	cmp	r3, #1
  407710:	d976      	bls.n	407800 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x118>
    if (item.parameters.driver_num >= MAX_STEPPERS) {
  407712:	ebc1 05c1 	rsb	r5, r1, r1, lsl #3
  407716:	00eb      	lsls	r3, r5, #3
  407718:	4403      	add	r3, r0
  40771a:	f646 153a 	movw	r5, #26938	; 0x693a
  40771e:	5b5b      	ldrh	r3, [r3, r5]
  407720:	2b04      	cmp	r3, #4
  407722:	dd03      	ble.n	40772c <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x44>
        return PreloadPutQueueRes::P_INVALID_MOTION;
  407724:	2004      	movs	r0, #4
}
  407726:	b00d      	add	sp, #52	; 0x34
  407728:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40772c:	460e      	mov	r6, r1
  40772e:	4605      	mov	r5, r0
    Stepper &stepper = *(m_steppers[item.parameters.driver_num]); // Stepper, dereferenced
  407730:	f503 51e0 	add.w	r1, r3, #7168	; 0x1c00
  407734:	310e      	adds	r1, #14
  407736:	f850 7021 	ldr.w	r7, [r0, r1, lsl #2]
    *driver_num      = item.parameters.driver_num;                // Assign driver_num
  40773a:	7013      	strb	r3, [r2, #0]
    Stepper::Status sts = stepper.getStatus();
  40773c:	4638      	mov	r0, r7
  40773e:	4b31      	ldr	r3, [pc, #196]	; (407804 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x11c>)
  407740:	4798      	blx	r3
    if (sts != Stepper::Status::READY && sts != Stepper::Status::MOTION_NOT_INIT) {
  407742:	2801      	cmp	r0, #1
  407744:	d003      	beq.n	40774e <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x66>
  407746:	2806      	cmp	r0, #6
  407748:	d001      	beq.n	40774e <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x66>
        return PreloadPutQueueRes::P_STEPPER_NOT_READY;
  40774a:	2005      	movs	r0, #5
  40774c:	e7eb      	b.n	407726 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x3e>
    if (isStepperUsedInQueue(item.parameters.driver_num)) {
  40774e:	ebc6 02c6 	rsb	r2, r6, r6, lsl #3
  407752:	00d3      	lsls	r3, r2, #3
  407754:	442b      	add	r3, r5
  407756:	f646 123a 	movw	r2, #26938	; 0x693a
  40775a:	5c99      	ldrb	r1, [r3, r2]
  40775c:	4628      	mov	r0, r5
  40775e:	4b2a      	ldr	r3, [pc, #168]	; (407808 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x120>)
  407760:	4798      	blx	r3
  407762:	b108      	cbz	r0, 407768 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x80>
        return PreloadPutQueueRes::P_STEPPER_NOT_READY;
  407764:	2005      	movs	r0, #5
  407766:	e7de      	b.n	407726 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x3e>
    setMotionParameters(item.motion_type, item.parameters);
  407768:	ebc6 02c6 	rsb	r2, r6, r6, lsl #3
  40776c:	00d3      	lsls	r3, r2, #3
  40776e:	442b      	add	r3, r5
  407770:	f646 1238 	movw	r2, #26936	; 0x6938
  407774:	f813 8002 	ldrb.w	r8, [r3, r2]
  407778:	f8d4 a002 	ldr.w	sl, [r4, #2]
  40777c:	f8d4 9006 	ldr.w	r9, [r4, #6]
  407780:	f104 0e0a 	add.w	lr, r4, #10
  407784:	46ec      	mov	ip, sp
  407786:	342a      	adds	r4, #42	; 0x2a
  407788:	46e3      	mov	fp, ip
  40778a:	f8de 0000 	ldr.w	r0, [lr]
  40778e:	f8de 1004 	ldr.w	r1, [lr, #4]
  407792:	f8de 2008 	ldr.w	r2, [lr, #8]
  407796:	f8de 300c 	ldr.w	r3, [lr, #12]
  40779a:	e8ab 000f 	stmia.w	fp!, {r0, r1, r2, r3}
  40779e:	f10e 0e10 	add.w	lr, lr, #16
  4077a2:	46dc      	mov	ip, fp
  4077a4:	45a6      	cmp	lr, r4
  4077a6:	d1ef      	bne.n	407788 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0xa0>
  4077a8:	f8de 0000 	ldr.w	r0, [lr]
  4077ac:	f8de 1004 	ldr.w	r1, [lr, #4]
  4077b0:	f8de 2008 	ldr.w	r2, [lr, #8]
  4077b4:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
  4077b8:	4652      	mov	r2, sl
  4077ba:	464b      	mov	r3, r9
  4077bc:	4641      	mov	r1, r8
  4077be:	4628      	mov	r0, r5
  4077c0:	4c12      	ldr	r4, [pc, #72]	; (40780c <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x124>)
  4077c2:	47a0      	blx	r4
    if (item.motion_type == MotionType::MOVE_HOMING) {
  4077c4:	ebc6 02c6 	rsb	r2, r6, r6, lsl #3
  4077c8:	00d3      	lsls	r3, r2, #3
  4077ca:	442b      	add	r3, r5
  4077cc:	f646 1238 	movw	r2, #26936	; 0x6938
  4077d0:	5c9b      	ldrb	r3, [r3, r2]
  4077d2:	2b02      	cmp	r3, #2
  4077d4:	d00c      	beq.n	4077f0 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x108>
    } else if (item.parameters.use_inverse_time == 1) {
  4077d6:	ebc6 01c6 	rsb	r1, r6, r6, lsl #3
  4077da:	00c8      	lsls	r0, r1, #3
  4077dc:	4428      	add	r0, r5
  4077de:	f646 1368 	movw	r3, #26984	; 0x6968
  4077e2:	5ac3      	ldrh	r3, [r0, r3]
  4077e4:	2b01      	cmp	r3, #1
  4077e6:	d007      	beq.n	4077f8 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x110>
        res = stepper.move();
  4077e8:	4638      	mov	r0, r7
  4077ea:	4b09      	ldr	r3, [pc, #36]	; (407810 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x128>)
  4077ec:	4798      	blx	r3
  4077ee:	e79a      	b.n	407726 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x3e>
        res = stepper.moveHoming();
  4077f0:	4638      	mov	r0, r7
  4077f2:	4b08      	ldr	r3, [pc, #32]	; (407814 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x12c>)
  4077f4:	4798      	blx	r3
  4077f6:	e796      	b.n	407726 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x3e>
        res = stepper.moveInverseTime();
  4077f8:	4638      	mov	r0, r7
  4077fa:	4b07      	ldr	r3, [pc, #28]	; (407818 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x130>)
  4077fc:	4798      	blx	r3
  4077fe:	e792      	b.n	407726 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x3e>
        return PreloadPutQueueRes::P_INVALID_MOTION;
  407800:	2004      	movs	r0, #4
  407802:	e790      	b.n	407726 <_ZN11MotionQueue21queuePreloadedMotionsEhPh+0x3e>
  407804:	004052f5 	.word	0x004052f5
  407808:	00407361 	.word	0x00407361
  40780c:	00407499 	.word	0x00407499
  407810:	00405635 	.word	0x00405635
  407814:	004053e5 	.word	0x004053e5
  407818:	004056b9 	.word	0x004056b9

0040781c <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE>:

/* ---------------------------------------------------------------------------------- */
bool MotionQueue::startMotion(MotionType motion_type, MotionParameters parameters) {
  40781c:	b082      	sub	sp, #8
  40781e:	b508      	push	{r3, lr}
  407820:	f10d 0e08 	add.w	lr, sp, #8
  407824:	e88e 000c 	stmia.w	lr, {r2, r3}
    if (motion_type == MotionType::WAIT_SENSOR || motion_type == MotionType::WAIT_TIME) {
  407828:	1ecb      	subs	r3, r1, #3
  40782a:	b2db      	uxtb	r3, r3
  40782c:	2b01      	cmp	r3, #1
  40782e:	d926      	bls.n	40787e <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x62>
        motion_queue_debug(" [Start motion skipped] ");
        return true;
    }

    uint8_t              driver_num = parameters.driver_num;
  407830:	f89d 3008 	ldrb.w	r3, [sp, #8]
    Stepper::PutQueueRes res;

    if (motion_type == MotionType::MOVE_HOMING) {
  407834:	2902      	cmp	r1, #2
  407836:	d012      	beq.n	40785e <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x42>
        res = m_steppers[driver_num]->moveHoming();

    } else if (parameters.use_inverse_time == 1) {
  407838:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
  40783c:	2a01      	cmp	r2, #1
  40783e:	d016      	beq.n	40786e <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x52>
        res = m_steppers[driver_num]->moveInverseTime();
    } else {

        res = m_steppers[driver_num]->move();
  407840:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
  407844:	330e      	adds	r3, #14
  407846:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
  40784a:	4b0e      	ldr	r3, [pc, #56]	; (407884 <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x68>)
  40784c:	4798      	blx	r3
    }

    return res == Stepper::PutQueueRes::Q_SUCCESS;
  40784e:	2801      	cmp	r0, #1
  407850:	bf14      	ite	ne
  407852:	2000      	movne	r0, #0
  407854:	2001      	moveq	r0, #1
}
  407856:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  40785a:	b002      	add	sp, #8
  40785c:	4770      	bx	lr
        res = m_steppers[driver_num]->moveHoming();
  40785e:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
  407862:	330e      	adds	r3, #14
  407864:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
  407868:	4b07      	ldr	r3, [pc, #28]	; (407888 <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x6c>)
  40786a:	4798      	blx	r3
  40786c:	e7ef      	b.n	40784e <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x32>
        res = m_steppers[driver_num]->moveInverseTime();
  40786e:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
  407872:	330e      	adds	r3, #14
  407874:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
  407878:	4b04      	ldr	r3, [pc, #16]	; (40788c <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x70>)
  40787a:	4798      	blx	r3
  40787c:	e7e7      	b.n	40784e <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x32>
        return true;
  40787e:	2001      	movs	r0, #1
  407880:	e7e9      	b.n	407856 <_ZN11MotionQueue11startMotionENS_10MotionTypeENS_16MotionParametersE+0x3a>
  407882:	bf00      	nop
  407884:	00405635 	.word	0x00405635
  407888:	004053e5 	.word	0x004053e5
  40788c:	004056b9 	.word	0x004056b9

00407890 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm>:

/* ---------------------------------------------------------------------------------- */
MotionQueue::MotionStatus MotionQueue::getMotionStatus(MotionType motion_type, MotionParameters parameters,
                                                       portTickType start_tick) {
  407890:	b082      	sub	sp, #8
  407892:	b570      	push	{r4, r5, r6, lr}
  407894:	ac04      	add	r4, sp, #16
  407896:	e884 000c 	stmia.w	r4, {r2, r3}
    // Sensor wait
    if (motion_type == MotionType::WAIT_SENSOR) {
  40789a:	2904      	cmp	r1, #4
  40789c:	d014      	beq.n	4078c8 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0x38>

        return (condition_met || timeout) ? MotionStatus::COMPLETE : MotionStatus::M_RUNNING;
    }

    // Blind wait
    if (motion_type == MotionType::WAIT_TIME) {
  40789e:	2903      	cmp	r1, #3
  4078a0:	d039      	beq.n	407916 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0x86>
        motion_queue_debug(condition_met ? "Wait complete" : ".");
        return condition_met ? MotionStatus::COMPLETE : MotionStatus::M_RUNNING;
    }

    // Motor block
    Stepper::Status sts = m_steppers[parameters.driver_num]->getStatus();
  4078a2:	f8bd 3010 	ldrh.w	r3, [sp, #16]
  4078a6:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
  4078aa:	330e      	adds	r3, #14
  4078ac:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
  4078b0:	4b27      	ldr	r3, [pc, #156]	; (407950 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xc0>)
  4078b2:	4798      	blx	r3
    if (sts == Stepper::Status::BUSY || sts == Stepper::Status::HOMING) { return MotionStatus::M_RUNNING; }
  4078b4:	1e83      	subs	r3, r0, #2
  4078b6:	b2db      	uxtb	r3, r3
  4078b8:	2b01      	cmp	r3, #1
  4078ba:	d942      	bls.n	407942 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb2>
    if (sts == Stepper::Status::READY || sts == Stepper::Status::MOTION_NOT_INIT) { return MotionStatus::COMPLETE; }
  4078bc:	2801      	cmp	r0, #1
  4078be:	d042      	beq.n	407946 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb6>
  4078c0:	2806      	cmp	r0, #6
  4078c2:	d036      	beq.n	407932 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xa2>
    return MotionStatus::M_ERR;
  4078c4:	2002      	movs	r0, #2
  4078c6:	e03f      	b.n	407948 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb8>
        sensor_sts    = m_steppers[parameters.driver_num]->getSensorReading();
  4078c8:	f8bd 3010 	ldrh.w	r3, [sp, #16]
  4078cc:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
  4078d0:	330e      	adds	r3, #14
  4078d2:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
  4078d6:	4b1f      	ldr	r3, [pc, #124]	; (407954 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xc4>)
  4078d8:	4798      	blx	r3
        sensor_value  = static_cast<uint16_t>((sensor_sts >> parameters.homing_sensor) & 1);
  4078da:	f8bd 401c 	ldrh.w	r4, [sp, #28]
  4078de:	fa40 f404 	asr.w	r4, r0, r4
  4078e2:	f004 0401 	and.w	r4, r4, #1
        timeout_ms    = (static_cast<uint32_t>(parameters.time_h) << 16) | static_cast<uint32_t>(parameters.time_l);
  4078e6:	f8bd 5040 	ldrh.w	r5, [sp, #64]	; 0x40
  4078ea:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
        bool condition_met = (sensor_value == parameters.sensor_home_value);
  4078ee:	f8bd 601e 	ldrh.w	r6, [sp, #30]
        if (timeout_ticks != 0) { timeout = (xTaskGetTickCount() - start_tick) >= timeout_ticks; }
  4078f2:	ea53 4505 	orrs.w	r5, r3, r5, lsl #16
  4078f6:	d105      	bne.n	407904 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0x74>
        bool         timeout = false;
  4078f8:	2300      	movs	r3, #0
        return (condition_met || timeout) ? MotionStatus::COMPLETE : MotionStatus::M_RUNNING;
  4078fa:	42b4      	cmp	r4, r6
  4078fc:	d01b      	beq.n	407936 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xa6>
  4078fe:	b1e3      	cbz	r3, 40793a <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xaa>
  407900:	2003      	movs	r0, #3
  407902:	e021      	b.n	407948 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb8>
        if (timeout_ticks != 0) { timeout = (xTaskGetTickCount() - start_tick) >= timeout_ticks; }
  407904:	4b14      	ldr	r3, [pc, #80]	; (407958 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xc8>)
  407906:	4798      	blx	r3
  407908:	9b11      	ldr	r3, [sp, #68]	; 0x44
  40790a:	1ac3      	subs	r3, r0, r3
  40790c:	429d      	cmp	r5, r3
  40790e:	bf8c      	ite	hi
  407910:	2300      	movhi	r3, #0
  407912:	2301      	movls	r3, #1
  407914:	e7f1      	b.n	4078fa <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0x6a>
        target_wait_ms    = (static_cast<uint32_t>(parameters.time_h) << 16) | static_cast<uint32_t>(parameters.time_l);
  407916:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
  40791a:	f8bd 4042 	ldrh.w	r4, [sp, #66]	; 0x42
  40791e:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
        bool condition_met = (xTaskGetTickCount() - start_tick) >= target_wait_ticks;
  407922:	4b0d      	ldr	r3, [pc, #52]	; (407958 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xc8>)
  407924:	4798      	blx	r3
  407926:	9b11      	ldr	r3, [sp, #68]	; 0x44
  407928:	1ac0      	subs	r0, r0, r3
        return condition_met ? MotionStatus::COMPLETE : MotionStatus::M_RUNNING;
  40792a:	4284      	cmp	r4, r0
  40792c:	d807      	bhi.n	40793e <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xae>
  40792e:	2003      	movs	r0, #3
  407930:	e00a      	b.n	407948 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb8>
    if (sts == Stepper::Status::READY || sts == Stepper::Status::MOTION_NOT_INIT) { return MotionStatus::COMPLETE; }
  407932:	2003      	movs	r0, #3
  407934:	e008      	b.n	407948 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb8>
        return (condition_met || timeout) ? MotionStatus::COMPLETE : MotionStatus::M_RUNNING;
  407936:	2003      	movs	r0, #3
  407938:	e006      	b.n	407948 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb8>
  40793a:	2001      	movs	r0, #1
  40793c:	e004      	b.n	407948 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb8>
        return condition_met ? MotionStatus::COMPLETE : MotionStatus::M_RUNNING;
  40793e:	2001      	movs	r0, #1
  407940:	e002      	b.n	407948 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb8>
    if (sts == Stepper::Status::BUSY || sts == Stepper::Status::HOMING) { return MotionStatus::M_RUNNING; }
  407942:	2001      	movs	r0, #1
  407944:	e000      	b.n	407948 <_ZN11MotionQueue15getMotionStatusENS_10MotionTypeENS_16MotionParametersEm+0xb8>
    if (sts == Stepper::Status::READY || sts == Stepper::Status::MOTION_NOT_INIT) { return MotionStatus::COMPLETE; }
  407946:	2003      	movs	r0, #3
}
  407948:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  40794c:	b002      	add	sp, #8
  40794e:	4770      	bx	lr
  407950:	004052f5 	.word	0x004052f5
  407954:	004063f1 	.word	0x004063f1
  407958:	0040998d 	.word	0x0040998d

0040795c <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE>:

/* ---------------------------------------------------------------------------------- */
MotionQueue::Result MotionQueue::execSuccessful(MotionType motion_type, MotionParameters parameters) {
  40795c:	b082      	sub	sp, #8
  40795e:	b570      	push	{r4, r5, r6, lr}
  407960:	b082      	sub	sp, #8
  407962:	4605      	mov	r5, r0
  407964:	460e      	mov	r6, r1
  407966:	a906      	add	r1, sp, #24
  407968:	e881 000c 	stmia.w	r1, {r2, r3}
    if (motion_type == MotionType::WAIT_SENSOR) {
  40796c:	2e04      	cmp	r6, #4
  40796e:	d013      	beq.n	407998 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x3c>
        bool condition_met = ((sensor_sts >> parameters.homing_sensor) & 1) == parameters.sensor_home_value;

        return condition_met ? Result::SUCCESS : Result::FAILED_MIDWAY;
    }

    if (motion_type == MotionType::WAIT_TIME) { return Result::SUCCESS; }
  407970:	2e03      	cmp	r6, #3
  407972:	d042      	beq.n	4079fa <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x9e>

    uint32_t readback_value    = 0;
  407974:	2400      	movs	r4, #0
  407976:	9401      	str	r4, [sp, #4]
    bool     readback_acquired = false;

    while (!readback_acquired) {
  407978:	bb2c      	cbnz	r4, 4079c6 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x6a>
        readback_acquired = m_steppers[parameters.driver_num]->getReadback(&readback_value);
  40797a:	f8bd 3018 	ldrh.w	r3, [sp, #24]
  40797e:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
  407982:	330e      	adds	r3, #14
  407984:	a901      	add	r1, sp, #4
  407986:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
  40798a:	4b1e      	ldr	r3, [pc, #120]	; (407a04 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0xa8>)
  40798c:	4798      	blx	r3
  40798e:	4604      	mov	r4, r0
        vTaskDelay(5 / portTICK_RATE_MS);
  407990:	2005      	movs	r0, #5
  407992:	4b1d      	ldr	r3, [pc, #116]	; (407a08 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0xac>)
  407994:	4798      	blx	r3
    while (!readback_acquired) {
  407996:	e7ef      	b.n	407978 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x1c>
        uint8_t sensor_sts = m_steppers[parameters.driver_num]->getSensorReading();
  407998:	f8bd 3018 	ldrh.w	r3, [sp, #24]
  40799c:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
  4079a0:	330e      	adds	r3, #14
  4079a2:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
  4079a6:	4b19      	ldr	r3, [pc, #100]	; (407a0c <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0xb0>)
  4079a8:	4798      	blx	r3
        bool condition_met = ((sensor_sts >> parameters.homing_sensor) & 1) == parameters.sensor_home_value;
  4079aa:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
  4079ae:	fa40 f303 	asr.w	r3, r0, r3
  4079b2:	f003 0301 	and.w	r3, r3, #1
  4079b6:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
        return condition_met ? Result::SUCCESS : Result::FAILED_MIDWAY;
  4079ba:	4293      	cmp	r3, r2
  4079bc:	d001      	beq.n	4079c2 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x66>
  4079be:	2003      	movs	r0, #3
  4079c0:	e008      	b.n	4079d4 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x78>
  4079c2:	2001      	movs	r0, #1
  4079c4:	e006      	b.n	4079d4 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x78>
    }

    // Homing
    if (motion_type == MotionType::MOVE_HOMING) {
  4079c6:	2e02      	cmp	r6, #2
  4079c8:	d009      	beq.n	4079de <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x82>
            return Result::CONDITIONAL_SUCCESS;
        }
        return Result::FAILED_MIDWAY;
    }

    Stepper::ExecCode exec_code = static_cast<Stepper::ExecCode>(readback_value);
  4079ca:	f89d 3004 	ldrb.w	r3, [sp, #4]

    return (exec_code == Stepper::ExecCode::E_SUCCESS) ? Result::SUCCESS : Result::FAILED_MIDWAY;
  4079ce:	2b01      	cmp	r3, #1
  4079d0:	d011      	beq.n	4079f6 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x9a>
  4079d2:	2003      	movs	r0, #3
}
  4079d4:	b002      	add	sp, #8
  4079d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  4079da:	b002      	add	sp, #8
  4079dc:	4770      	bx	lr
        Stepper::HomingCode homing_code = static_cast<Stepper::HomingCode>(readback_value);
  4079de:	f89d 3004 	ldrb.w	r3, [sp, #4]
        if (homing_code == Stepper::HomingCode::H_SUCCESS) { return Result::SUCCESS; }
  4079e2:	2b01      	cmp	r3, #1
  4079e4:	d00b      	beq.n	4079fe <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0xa2>
        if (homing_code == Stepper::HomingCode::H_MAX_PULSE_REACHED || homing_code == Stepper::HomingCode::H_TIMEOUT) {
  4079e6:	3b07      	subs	r3, #7
  4079e8:	b2db      	uxtb	r3, r3
  4079ea:	2b01      	cmp	r3, #1
  4079ec:	d901      	bls.n	4079f2 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x96>
        return Result::FAILED_MIDWAY;
  4079ee:	2003      	movs	r0, #3
  4079f0:	e7f0      	b.n	4079d4 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x78>
            return Result::CONDITIONAL_SUCCESS;
  4079f2:	2002      	movs	r0, #2
  4079f4:	e7ee      	b.n	4079d4 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x78>
    return (exec_code == Stepper::ExecCode::E_SUCCESS) ? Result::SUCCESS : Result::FAILED_MIDWAY;
  4079f6:	2001      	movs	r0, #1
  4079f8:	e7ec      	b.n	4079d4 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x78>
    if (motion_type == MotionType::WAIT_TIME) { return Result::SUCCESS; }
  4079fa:	2001      	movs	r0, #1
  4079fc:	e7ea      	b.n	4079d4 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x78>
        if (homing_code == Stepper::HomingCode::H_SUCCESS) { return Result::SUCCESS; }
  4079fe:	2001      	movs	r0, #1
  407a00:	e7e8      	b.n	4079d4 <_ZN11MotionQueue14execSuccessfulENS_10MotionTypeENS_16MotionParametersE+0x78>
  407a02:	bf00      	nop
  407a04:	00405501 	.word	0x00405501
  407a08:	00409bd5 	.word	0x00409bd5
  407a0c:	004063f1 	.word	0x004063f1

00407a10 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh>:
MotionQueue::Result MotionQueue::executeItemInMotionQueue(QueueItem items[], const uint8_t num_items) {
  407a10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  407a14:	b093      	sub	sp, #76	; 0x4c
  407a16:	af0c      	add	r7, sp, #48	; 0x30
    for (i = 0; i < num_items; i++) {
  407a18:	2300      	movs	r3, #0
  407a1a:	e001      	b.n	407a20 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x10>
  407a1c:	3301      	adds	r3, #1
  407a1e:	b2db      	uxtb	r3, r3
  407a20:	4614      	mov	r4, r2
  407a22:	4293      	cmp	r3, r2
  407a24:	da0b      	bge.n	407a3e <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x2e>
        if ((items[i].parameters.driver_num >= MAX_STEPPERS) && (items[i].motion_type != MotionType::WAIT_TIME)) {
  407a26:	ebc3 05c3 	rsb	r5, r3, r3, lsl #3
  407a2a:	00ec      	lsls	r4, r5, #3
  407a2c:	190d      	adds	r5, r1, r4
  407a2e:	886d      	ldrh	r5, [r5, #2]
  407a30:	2d04      	cmp	r5, #4
  407a32:	ddf3      	ble.n	407a1c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0xc>
  407a34:	5d0c      	ldrb	r4, [r1, r4]
  407a36:	2c03      	cmp	r4, #3
  407a38:	d0f0      	beq.n	407a1c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0xc>
            return Result::BAD_PARAMETERS;
  407a3a:	2008      	movs	r0, #8
  407a3c:	e016      	b.n	407a6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x5c>
  407a3e:	f04f 0e00 	mov.w	lr, #0
  407a42:	e01b      	b.n	407a7c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x6c>
        for (j = 0; j < num_items; j++) {
  407a44:	3301      	adds	r3, #1
  407a46:	b2db      	uxtb	r3, r3
  407a48:	429c      	cmp	r4, r3
  407a4a:	dd13      	ble.n	407a74 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x64>
            if ((i != j) && (items[i].parameters.driver_num == items[j].parameters.driver_num)) {
  407a4c:	459e      	cmp	lr, r3
  407a4e:	d0f9      	beq.n	407a44 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x34>
  407a50:	ebce 06ce 	rsb	r6, lr, lr, lsl #3
  407a54:	00f5      	lsls	r5, r6, #3
  407a56:	440d      	add	r5, r1
  407a58:	f8b5 c002 	ldrh.w	ip, [r5, #2]
  407a5c:	ebc3 06c3 	rsb	r6, r3, r3, lsl #3
  407a60:	00f5      	lsls	r5, r6, #3
  407a62:	440d      	add	r5, r1
  407a64:	886d      	ldrh	r5, [r5, #2]
  407a66:	45ac      	cmp	ip, r5
  407a68:	d1ec      	bne.n	407a44 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x34>
                return Result::REPEATED_ASSIGNMENT;
  407a6a:	2007      	movs	r0, #7
}
  407a6c:	371c      	adds	r7, #28
  407a6e:	46bd      	mov	sp, r7
  407a70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (i = 0; i < num_items; i++) {
  407a74:	f10e 0e01 	add.w	lr, lr, #1
  407a78:	fa5f fe8e 	uxtb.w	lr, lr
  407a7c:	4574      	cmp	r4, lr
  407a7e:	dd01      	ble.n	407a84 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x74>
  407a80:	2300      	movs	r3, #0
  407a82:	e7e1      	b.n	407a48 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x38>
  407a84:	60ba      	str	r2, [r7, #8]
  407a86:	468a      	mov	sl, r1
  407a88:	6178      	str	r0, [r7, #20]
  407a8a:	2500      	movs	r5, #0
  407a8c:	e007      	b.n	407a9e <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x8e>
        if ((items[i].motion_type != MotionType::WAIT_TIME) && (!stepperIsReadyForMovement(driver_num))) {
  407a8e:	2301      	movs	r3, #1
  407a90:	e000      	b.n	407a94 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x84>
  407a92:	2300      	movs	r3, #0
  407a94:	2b00      	cmp	r3, #0
  407a96:	f040 815f 	bne.w	407d58 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x348>
    for (i = 0; i < num_items; i++) {
  407a9a:	3501      	adds	r5, #1
  407a9c:	b2ed      	uxtb	r5, r5
  407a9e:	42ac      	cmp	r4, r5
  407aa0:	dd10      	ble.n	407ac4 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0xb4>
        driver_num = items[i].parameters.driver_num;
  407aa2:	ebc5 02c5 	rsb	r2, r5, r5, lsl #3
  407aa6:	00d3      	lsls	r3, r2, #3
  407aa8:	eb0a 0203 	add.w	r2, sl, r3
  407aac:	7891      	ldrb	r1, [r2, #2]
        if ((items[i].motion_type != MotionType::WAIT_TIME) && (!stepperIsReadyForMovement(driver_num))) {
  407aae:	f81a 3003 	ldrb.w	r3, [sl, r3]
  407ab2:	2b03      	cmp	r3, #3
  407ab4:	d0ed      	beq.n	407a92 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x82>
  407ab6:	6978      	ldr	r0, [r7, #20]
  407ab8:	4baa      	ldr	r3, [pc, #680]	; (407d64 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x354>)
  407aba:	4798      	blx	r3
  407abc:	2800      	cmp	r0, #0
  407abe:	d0e6      	beq.n	407a8e <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x7e>
  407ac0:	2300      	movs	r3, #0
  407ac2:	e7e7      	b.n	407a94 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x84>
  407ac4:	2301      	movs	r3, #1
  407ac6:	60fb      	str	r3, [r7, #12]
  407ac8:	f04f 0800 	mov.w	r8, #0
    for (i = 0; i < num_items; i++) {
  407acc:	4544      	cmp	r4, r8
  407ace:	dd2d      	ble.n	407b2c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x11c>
        success &= setMotionParameters(items[i].motion_type, items[i].parameters);
  407ad0:	ebc8 02c8 	rsb	r2, r8, r8, lsl #3
  407ad4:	00d3      	lsls	r3, r2, #3
  407ad6:	eb0a 0603 	add.w	r6, sl, r3
  407ada:	f81a 3003 	ldrb.w	r3, [sl, r3]
  407ade:	613b      	str	r3, [r7, #16]
  407ae0:	f8d6 b002 	ldr.w	fp, [r6, #2]
  407ae4:	f8d6 9006 	ldr.w	r9, [r6, #6]
  407ae8:	f106 050a 	add.w	r5, r6, #10
  407aec:	46ec      	mov	ip, sp
  407aee:	362a      	adds	r6, #42	; 0x2a
  407af0:	46e6      	mov	lr, ip
  407af2:	6828      	ldr	r0, [r5, #0]
  407af4:	6869      	ldr	r1, [r5, #4]
  407af6:	68aa      	ldr	r2, [r5, #8]
  407af8:	68eb      	ldr	r3, [r5, #12]
  407afa:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
  407afe:	3510      	adds	r5, #16
  407b00:	46f4      	mov	ip, lr
  407b02:	42b5      	cmp	r5, r6
  407b04:	d1f4      	bne.n	407af0 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0xe0>
  407b06:	6828      	ldr	r0, [r5, #0]
  407b08:	6869      	ldr	r1, [r5, #4]
  407b0a:	68aa      	ldr	r2, [r5, #8]
  407b0c:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
  407b10:	465a      	mov	r2, fp
  407b12:	464b      	mov	r3, r9
  407b14:	6939      	ldr	r1, [r7, #16]
  407b16:	6978      	ldr	r0, [r7, #20]
  407b18:	4d93      	ldr	r5, [pc, #588]	; (407d68 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x358>)
  407b1a:	47a8      	blx	r5
  407b1c:	68fb      	ldr	r3, [r7, #12]
  407b1e:	4003      	ands	r3, r0
  407b20:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < num_items; i++) {
  407b22:	f108 0801 	add.w	r8, r8, #1
  407b26:	fa5f f888 	uxtb.w	r8, r8
  407b2a:	e7cf      	b.n	407acc <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0xbc>
    if (!success) {
  407b2c:	68fb      	ldr	r3, [r7, #12]
  407b2e:	b90b      	cbnz	r3, 407b34 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x124>
        return Result::FAILED_MIDWAY;
  407b30:	2003      	movs	r0, #3
  407b32:	e79b      	b.n	407a6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x5c>
  407b34:	f04f 0b00 	mov.w	fp, #0
    for (i = 0; i < num_items; i++) {
  407b38:	455c      	cmp	r4, fp
  407b3a:	dd2d      	ble.n	407b98 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x188>
        success &= startMotion(items[i].motion_type, items[i].parameters);
  407b3c:	ebcb 02cb 	rsb	r2, fp, fp, lsl #3
  407b40:	00d3      	lsls	r3, r2, #3
  407b42:	eb0a 0603 	add.w	r6, sl, r3
  407b46:	f81a 3003 	ldrb.w	r3, [sl, r3]
  407b4a:	613b      	str	r3, [r7, #16]
  407b4c:	f8d6 9002 	ldr.w	r9, [r6, #2]
  407b50:	f8d6 8006 	ldr.w	r8, [r6, #6]
  407b54:	f106 050a 	add.w	r5, r6, #10
  407b58:	46ec      	mov	ip, sp
  407b5a:	362a      	adds	r6, #42	; 0x2a
  407b5c:	46e6      	mov	lr, ip
  407b5e:	6828      	ldr	r0, [r5, #0]
  407b60:	6869      	ldr	r1, [r5, #4]
  407b62:	68aa      	ldr	r2, [r5, #8]
  407b64:	68eb      	ldr	r3, [r5, #12]
  407b66:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
  407b6a:	3510      	adds	r5, #16
  407b6c:	46f4      	mov	ip, lr
  407b6e:	42b5      	cmp	r5, r6
  407b70:	d1f4      	bne.n	407b5c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x14c>
  407b72:	6828      	ldr	r0, [r5, #0]
  407b74:	6869      	ldr	r1, [r5, #4]
  407b76:	68aa      	ldr	r2, [r5, #8]
  407b78:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
  407b7c:	464a      	mov	r2, r9
  407b7e:	4643      	mov	r3, r8
  407b80:	6939      	ldr	r1, [r7, #16]
  407b82:	6978      	ldr	r0, [r7, #20]
  407b84:	4d79      	ldr	r5, [pc, #484]	; (407d6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x35c>)
  407b86:	47a8      	blx	r5
  407b88:	68fb      	ldr	r3, [r7, #12]
  407b8a:	4003      	ands	r3, r0
  407b8c:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < num_items; i++) {
  407b8e:	f10b 0b01 	add.w	fp, fp, #1
  407b92:	fa5f fb8b 	uxtb.w	fp, fp
  407b96:	e7cf      	b.n	407b38 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x128>
    if (!success) {
  407b98:	68fb      	ldr	r3, [r7, #12]
  407b9a:	b90b      	cbnz	r3, 407ba0 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x190>
        return Result::FAILED_MIDWAY;
  407b9c:	2003      	movs	r0, #3
  407b9e:	e765      	b.n	407a6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x5c>
    vTaskDelay(100 / portTICK_RATE_MS);
  407ba0:	2064      	movs	r0, #100	; 0x64
  407ba2:	4b73      	ldr	r3, [pc, #460]	; (407d70 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x360>)
  407ba4:	4798      	blx	r3
    MotionStatus motion_status[num_items] = {MotionStatus::M_RUNNING};
  407ba6:	68bb      	ldr	r3, [r7, #8]
  407ba8:	3307      	adds	r3, #7
  407baa:	f023 0307 	bic.w	r3, r3, #7
  407bae:	ebad 0d03 	sub.w	sp, sp, r3
  407bb2:	f10d 0930 	add.w	r9, sp, #48	; 0x30
  407bb6:	2301      	movs	r3, #1
  407bb8:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
  407bbc:	f10d 0231 	add.w	r2, sp, #49	; 0x31
  407bc0:	1ea3      	subs	r3, r4, #2
  407bc2:	2b00      	cmp	r3, #0
  407bc4:	db04      	blt.n	407bd0 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x1c0>
  407bc6:	2100      	movs	r1, #0
  407bc8:	f802 1b01 	strb.w	r1, [r2], #1
  407bcc:	3b01      	subs	r3, #1
  407bce:	e7f8      	b.n	407bc2 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x1b2>
    portTickType start_tick = xTaskGetTickCount();
  407bd0:	4b68      	ldr	r3, [pc, #416]	; (407d74 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x364>)
  407bd2:	4798      	blx	r3
  407bd4:	6138      	str	r0, [r7, #16]
  407bd6:	46a0      	mov	r8, r4
        vTaskDelay((10 * MAX_STEPPERS) / portTICK_RATE_MS);
  407bd8:	2032      	movs	r0, #50	; 0x32
  407bda:	4b65      	ldr	r3, [pc, #404]	; (407d70 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x360>)
  407bdc:	4798      	blx	r3
        for (i = 0; i < num_items; i++) {
  407bde:	f04f 0b00 	mov.w	fp, #0
  407be2:	f8c7 b008 	str.w	fp, [r7, #8]
  407be6:	45d8      	cmp	r8, fp
  407be8:	dd2f      	ble.n	407c4a <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x23a>
            motion_status[i] = getMotionStatus(items[i].motion_type, items[i].parameters, start_tick);
  407bea:	ebcb 02cb 	rsb	r2, fp, fp, lsl #3
  407bee:	00d3      	lsls	r3, r2, #3
  407bf0:	eb0a 0603 	add.w	r6, sl, r3
  407bf4:	f81a 3003 	ldrb.w	r3, [sl, r3]
  407bf8:	607b      	str	r3, [r7, #4]
  407bfa:	693b      	ldr	r3, [r7, #16]
  407bfc:	930b      	str	r3, [sp, #44]	; 0x2c
  407bfe:	f8d6 c002 	ldr.w	ip, [r6, #2]
  407c02:	f8d6 3006 	ldr.w	r3, [r6, #6]
  407c06:	603b      	str	r3, [r7, #0]
  407c08:	f106 050a 	add.w	r5, r6, #10
  407c0c:	466c      	mov	r4, sp
  407c0e:	362a      	adds	r6, #42	; 0x2a
  407c10:	46a6      	mov	lr, r4
  407c12:	6828      	ldr	r0, [r5, #0]
  407c14:	6869      	ldr	r1, [r5, #4]
  407c16:	68aa      	ldr	r2, [r5, #8]
  407c18:	68eb      	ldr	r3, [r5, #12]
  407c1a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
  407c1e:	3510      	adds	r5, #16
  407c20:	4674      	mov	r4, lr
  407c22:	42b5      	cmp	r5, r6
  407c24:	d1f4      	bne.n	407c10 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x200>
  407c26:	6828      	ldr	r0, [r5, #0]
  407c28:	6869      	ldr	r1, [r5, #4]
  407c2a:	68aa      	ldr	r2, [r5, #8]
  407c2c:	c407      	stmia	r4!, {r0, r1, r2}
  407c2e:	4662      	mov	r2, ip
  407c30:	683b      	ldr	r3, [r7, #0]
  407c32:	6879      	ldr	r1, [r7, #4]
  407c34:	6978      	ldr	r0, [r7, #20]
  407c36:	4c50      	ldr	r4, [pc, #320]	; (407d78 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x368>)
  407c38:	47a0      	blx	r4
  407c3a:	68bb      	ldr	r3, [r7, #8]
  407c3c:	f809 0003 	strb.w	r0, [r9, r3]
        for (i = 0; i < num_items; i++) {
  407c40:	f10b 0b01 	add.w	fp, fp, #1
  407c44:	fa5f fb8b 	uxtb.w	fp, fp
  407c48:	e7cb      	b.n	407be2 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x1d2>
  407c4a:	2300      	movs	r3, #0
        for (i = 0; i < num_items; i++) {
  407c4c:	4598      	cmp	r8, r3
  407c4e:	dd29      	ble.n	407ca4 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x294>
            if ((motion_status[i] == MotionStatus::M_ERR) || m_abort_queue) {
  407c50:	f819 2003 	ldrb.w	r2, [r9, r3]
  407c54:	2a02      	cmp	r2, #2
  407c56:	d00a      	beq.n	407c6e <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x25e>
  407c58:	f247 0251 	movw	r2, #28753	; 0x7051
  407c5c:	6979      	ldr	r1, [r7, #20]
  407c5e:	5c8a      	ldrb	r2, [r1, r2]
  407c60:	b912      	cbnz	r2, 407c68 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x258>
        for (i = 0; i < num_items; i++) {
  407c62:	3301      	adds	r3, #1
  407c64:	b2db      	uxtb	r3, r3
  407c66:	e7f1      	b.n	407c4c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x23c>
  407c68:	4644      	mov	r4, r8
  407c6a:	2500      	movs	r5, #0
  407c6c:	e001      	b.n	407c72 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x262>
  407c6e:	4644      	mov	r4, r8
  407c70:	2500      	movs	r5, #0
                for (j = 0; j < num_items; j++) {
  407c72:	42ac      	cmp	r4, r5
  407c74:	dd0f      	ble.n	407c96 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x286>
                    driver_num = items[j].parameters.driver_num;
  407c76:	ebc5 02c5 	rsb	r2, r5, r5, lsl #3
  407c7a:	00d3      	lsls	r3, r2, #3
  407c7c:	4453      	add	r3, sl
  407c7e:	789b      	ldrb	r3, [r3, #2]
                    m_steppers[driver_num]->d_emStop();
  407c80:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
  407c84:	330e      	adds	r3, #14
  407c86:	697a      	ldr	r2, [r7, #20]
  407c88:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
  407c8c:	4b3b      	ldr	r3, [pc, #236]	; (407d7c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x36c>)
  407c8e:	4798      	blx	r3
                for (j = 0; j < num_items; j++) {
  407c90:	3501      	adds	r5, #1
  407c92:	b2ed      	uxtb	r5, r5
  407c94:	e7ed      	b.n	407c72 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x262>
                m_abort_queue = false; // reset
  407c96:	2200      	movs	r2, #0
  407c98:	f247 0351 	movw	r3, #28753	; 0x7051
  407c9c:	6979      	ldr	r1, [r7, #20]
  407c9e:	54ca      	strb	r2, [r1, r3]
                return Result::FAILED_MIDWAY;
  407ca0:	2003      	movs	r0, #3
  407ca2:	e6e3      	b.n	407a6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x5c>
  407ca4:	68f9      	ldr	r1, [r7, #12]
  407ca6:	2300      	movs	r3, #0
        for (i = 0; i < num_items; i++) {
  407ca8:	4598      	cmp	r8, r3
  407caa:	dd09      	ble.n	407cc0 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x2b0>
            complete &= (motion_status[i] == MotionStatus::COMPLETE);
  407cac:	f819 2003 	ldrb.w	r2, [r9, r3]
  407cb0:	2a03      	cmp	r2, #3
  407cb2:	bf14      	ite	ne
  407cb4:	2100      	movne	r1, #0
  407cb6:	f001 0101 	andeq.w	r1, r1, #1
        for (i = 0; i < num_items; i++) {
  407cba:	3301      	adds	r3, #1
  407cbc:	b2db      	uxtb	r3, r3
  407cbe:	e7f3      	b.n	407ca8 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x298>
        if (complete) { break; }
  407cc0:	2900      	cmp	r1, #0
  407cc2:	d089      	beq.n	407bd8 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x1c8>
  407cc4:	468b      	mov	fp, r1
  407cc6:	4644      	mov	r4, r8
  407cc8:	4688      	mov	r8, r1
  407cca:	f04f 0900 	mov.w	r9, #0
    for (i = 0; i < num_items; i++) {
  407cce:	454c      	cmp	r4, r9
  407cd0:	dd3a      	ble.n	407d48 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x338>
        Result res = execSuccessful(items[i].motion_type, items[i].parameters);
  407cd2:	ebc9 02c9 	rsb	r2, r9, r9, lsl #3
  407cd6:	00d3      	lsls	r3, r2, #3
  407cd8:	eb0a 0e03 	add.w	lr, sl, r3
  407cdc:	f81a 3003 	ldrb.w	r3, [sl, r3]
  407ce0:	613b      	str	r3, [r7, #16]
  407ce2:	f8de 3002 	ldr.w	r3, [lr, #2]
  407ce6:	60fb      	str	r3, [r7, #12]
  407ce8:	f8de 3006 	ldr.w	r3, [lr, #6]
  407cec:	60bb      	str	r3, [r7, #8]
  407cee:	f10e 060a 	add.w	r6, lr, #10
  407cf2:	466d      	mov	r5, sp
  407cf4:	f10e 0e2a 	add.w	lr, lr, #42	; 0x2a
  407cf8:	46ac      	mov	ip, r5
  407cfa:	6830      	ldr	r0, [r6, #0]
  407cfc:	6871      	ldr	r1, [r6, #4]
  407cfe:	68b2      	ldr	r2, [r6, #8]
  407d00:	68f3      	ldr	r3, [r6, #12]
  407d02:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
  407d06:	3610      	adds	r6, #16
  407d08:	4665      	mov	r5, ip
  407d0a:	4576      	cmp	r6, lr
  407d0c:	d1f4      	bne.n	407cf8 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x2e8>
  407d0e:	6830      	ldr	r0, [r6, #0]
  407d10:	6871      	ldr	r1, [r6, #4]
  407d12:	68b2      	ldr	r2, [r6, #8]
  407d14:	c507      	stmia	r5!, {r0, r1, r2}
  407d16:	68fa      	ldr	r2, [r7, #12]
  407d18:	68bb      	ldr	r3, [r7, #8]
  407d1a:	6939      	ldr	r1, [r7, #16]
  407d1c:	6978      	ldr	r0, [r7, #20]
  407d1e:	4d18      	ldr	r5, [pc, #96]	; (407d80 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x370>)
  407d20:	47a8      	blx	r5
  407d22:	2801      	cmp	r0, #1
  407d24:	bf14      	ite	ne
  407d26:	f04f 0b00 	movne.w	fp, #0
  407d2a:	f00b 0b01 	andeq.w	fp, fp, #1
        conditional_complete &= (res == Result::SUCCESS || res == Result::CONDITIONAL_SUCCESS);
  407d2e:	1e43      	subs	r3, r0, #1
  407d30:	b2db      	uxtb	r3, r3
  407d32:	2b01      	cmp	r3, #1
  407d34:	bf8c      	ite	hi
  407d36:	f04f 0800 	movhi.w	r8, #0
  407d3a:	f008 0801 	andls.w	r8, r8, #1
    for (i = 0; i < num_items; i++) {
  407d3e:	f109 0901 	add.w	r9, r9, #1
  407d42:	fa5f f989 	uxtb.w	r9, r9
  407d46:	e7c2      	b.n	407cce <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x2be>
    if (all_complete) {
  407d48:	f1bb 0f00 	cmp.w	fp, #0
  407d4c:	d106      	bne.n	407d5c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x34c>
    if (conditional_complete) {
  407d4e:	f1b8 0f00 	cmp.w	r8, #0
  407d52:	d005      	beq.n	407d60 <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x350>
        return Result::CONDITIONAL_SUCCESS;
  407d54:	2002      	movs	r0, #2
  407d56:	e689      	b.n	407a6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x5c>
            return Result::STEPPERS_NOT_READY;
  407d58:	2009      	movs	r0, #9
  407d5a:	e687      	b.n	407a6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x5c>
        return Result::SUCCESS;
  407d5c:	2001      	movs	r0, #1
  407d5e:	e685      	b.n	407a6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x5c>
    return Result::FAILED_MIDWAY;
  407d60:	2003      	movs	r0, #3
  407d62:	e683      	b.n	407a6c <_ZN11MotionQueue24executeItemInMotionQueueEPNS_9QueueItemEh+0x5c>
  407d64:	00407445 	.word	0x00407445
  407d68:	00407499 	.word	0x00407499
  407d6c:	0040781d 	.word	0x0040781d
  407d70:	00409bd5 	.word	0x00409bd5
  407d74:	0040998d 	.word	0x0040998d
  407d78:	00407891 	.word	0x00407891
  407d7c:	00405261 	.word	0x00405261
  407d80:	0040795d 	.word	0x0040795d

00407d84 <_ZN11MotionQueue18executeMotionQueueEPh>:
MotionQueue::Result MotionQueue::executeMotionQueue(uint8_t *motion_num_ptr) {
  407d84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  407d88:	b0c7      	sub	sp, #284	; 0x11c
  407d8a:	4606      	mov	r6, r0
  407d8c:	4608      	mov	r0, r1
    uint8_t motion_num = *motion_num_ptr;
  407d8e:	780d      	ldrb	r5, [r1, #0]
    delete motion_num_ptr;
  407d90:	2101      	movs	r1, #1
  407d92:	4b6e      	ldr	r3, [pc, #440]	; (407f4c <_ZN11MotionQueue18executeMotionQueueEPh+0x1c8>)
  407d94:	4798      	blx	r3
    if ((motion_num >= MAX_MOTIONS) && (motion_num != TEST_MOTION_NUM)) {
  407d96:	f1a5 030f 	sub.w	r3, r5, #15
  407d9a:	b2db      	uxtb	r3, r3
  407d9c:	2bef      	cmp	r3, #239	; 0xef
  407d9e:	d804      	bhi.n	407daa <_ZN11MotionQueue18executeMotionQueueEPh+0x26>
        return Result::INVALID_MOTION;
  407da0:	2404      	movs	r4, #4
}
  407da2:	4620      	mov	r0, r4
  407da4:	b047      	add	sp, #284	; 0x11c
  407da6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    m_queue_status.is_executing = 1;
  407daa:	2201      	movs	r2, #1
  407dac:	f247 0352 	movw	r3, #28754	; 0x7052
  407db0:	52f2      	strh	r2, [r6, r3]
    m_queue_status.motion_num   = motion_num;
  407db2:	f247 0354 	movw	r3, #28756	; 0x7054
  407db6:	52f5      	strh	r5, [r6, r3]
    m_queue_status.sequence_num = 0;
  407db8:	2200      	movs	r2, #0
  407dba:	f247 0356 	movw	r3, #28758	; 0x7056
  407dbe:	52f2      	strh	r2, [r6, r3]
    if (motion_num == TEST_MOTION_NUM) {
  407dc0:	2dff      	cmp	r5, #255	; 0xff
  407dc2:	d003      	beq.n	407dcc <_ZN11MotionQueue18executeMotionQueueEPh+0x48>
    for (int i = 0; i < MAX_ITEMS_PER_MOTION; i++) {
  407dc4:	2400      	movs	r4, #0
    bool    has_queue_item = false;
  407dc6:	4620      	mov	r0, r4
    uint8_t max_seq        = 0;
  407dc8:	4627      	mov	r7, r4
  407dca:	e02b      	b.n	407e24 <_ZN11MotionQueue18executeMotionQueueEPh+0xa0>
        flagStepperUsedInQueue(test_item.parameters.driver_num);
  407dcc:	f646 1302 	movw	r3, #26882	; 0x6902
  407dd0:	5cf1      	ldrb	r1, [r6, r3]
  407dd2:	4630      	mov	r0, r6
  407dd4:	4b5e      	ldr	r3, [pc, #376]	; (407f50 <_ZN11MotionQueue18executeMotionQueueEPh+0x1cc>)
  407dd6:	4798      	blx	r3
        QueueItem test_items[] = {test_item};
  407dd8:	466c      	mov	r4, sp
  407dda:	f506 45d2 	add.w	r5, r6, #26880	; 0x6900
  407dde:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  407de0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  407de2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  407de4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  407de6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  407de8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  407dea:	e895 0003 	ldmia.w	r5, {r0, r1}
  407dee:	e884 0003 	stmia.w	r4, {r0, r1}
        Result    res          = executeItemInMotionQueue(test_items, 1);
  407df2:	2201      	movs	r2, #1
  407df4:	4669      	mov	r1, sp
  407df6:	4630      	mov	r0, r6
  407df8:	4b56      	ldr	r3, [pc, #344]	; (407f54 <_ZN11MotionQueue18executeMotionQueueEPh+0x1d0>)
  407dfa:	4798      	blx	r3
  407dfc:	4604      	mov	r4, r0
        unflagAllSteppers();
  407dfe:	4630      	mov	r0, r6
  407e00:	4b55      	ldr	r3, [pc, #340]	; (407f58 <_ZN11MotionQueue18executeMotionQueueEPh+0x1d4>)
  407e02:	4798      	blx	r3
  407e04:	e7cd      	b.n	407da2 <_ZN11MotionQueue18executeMotionQueueEPh+0x1e>
            flagStepperUsedInQueue(q.items[i].parameters.driver_num);
  407e06:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
  407e0a:	00d3      	lsls	r3, r2, #3
  407e0c:	ebc5 01c5 	rsb	r1, r5, r5, lsl #3
  407e10:	020a      	lsls	r2, r1, #8
  407e12:	4413      	add	r3, r2
  407e14:	4433      	add	r3, r6
  407e16:	7899      	ldrb	r1, [r3, #2]
  407e18:	4630      	mov	r0, r6
  407e1a:	4b4d      	ldr	r3, [pc, #308]	; (407f50 <_ZN11MotionQueue18executeMotionQueueEPh+0x1cc>)
  407e1c:	4798      	blx	r3
  407e1e:	4647      	mov	r7, r8
            has_queue_item = true;
  407e20:	2001      	movs	r0, #1
    for (int i = 0; i < MAX_ITEMS_PER_MOTION; i++) {
  407e22:	3401      	adds	r4, #1
  407e24:	2c1f      	cmp	r4, #31
  407e26:	dc10      	bgt.n	407e4a <_ZN11MotionQueue18executeMotionQueueEPh+0xc6>
        if (q.items[i].sequence_number != 0xFF) {
  407e28:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
  407e2c:	00d3      	lsls	r3, r2, #3
  407e2e:	ebc5 01c5 	rsb	r1, r5, r5, lsl #3
  407e32:	020a      	lsls	r2, r1, #8
  407e34:	4413      	add	r3, r2
  407e36:	4433      	add	r3, r6
  407e38:	f893 8036 	ldrb.w	r8, [r3, #54]	; 0x36
  407e3c:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
  407e40:	d0ef      	beq.n	407e22 <_ZN11MotionQueue18executeMotionQueueEPh+0x9e>
            if (q.items[i].sequence_number > max_seq) { max_seq = q.items[i].sequence_number; }
  407e42:	45b8      	cmp	r8, r7
  407e44:	dcdf      	bgt.n	407e06 <_ZN11MotionQueue18executeMotionQueueEPh+0x82>
  407e46:	46b8      	mov	r8, r7
  407e48:	e7dd      	b.n	407e06 <_ZN11MotionQueue18executeMotionQueueEPh+0x82>
    if (!has_queue_item) {
  407e4a:	b908      	cbnz	r0, 407e50 <_ZN11MotionQueue18executeMotionQueueEPh+0xcc>
        return Result::EMPTY_QUEUE;
  407e4c:	2405      	movs	r4, #5
  407e4e:	e7a8      	b.n	407da2 <_ZN11MotionQueue18executeMotionQueueEPh+0x1e>
  407e50:	f04f 0800 	mov.w	r8, #0
  407e54:	e03b      	b.n	407ece <_ZN11MotionQueue18executeMotionQueueEPh+0x14a>
  407e56:	f04f 0e00 	mov.w	lr, #0
  407e5a:	46f4      	mov	ip, lr
  407e5c:	e001      	b.n	407e62 <_ZN11MotionQueue18executeMotionQueueEPh+0xde>
        for (int q_item = 0; q_item < MAX_ITEMS_PER_MOTION; q_item++) {
  407e5e:	f10e 0e01 	add.w	lr, lr, #1
  407e62:	f1be 0f1f 	cmp.w	lr, #31
  407e66:	dc2d      	bgt.n	407ec4 <_ZN11MotionQueue18executeMotionQueueEPh+0x140>
            if (q.items[q_item].sequence_number == sq_num) {
  407e68:	ebce 02ce 	rsb	r2, lr, lr, lsl #3
  407e6c:	00d3      	lsls	r3, r2, #3
  407e6e:	ebc5 01c5 	rsb	r1, r5, r5, lsl #3
  407e72:	020a      	lsls	r2, r1, #8
  407e74:	4611      	mov	r1, r2
  407e76:	4413      	add	r3, r2
  407e78:	4433      	add	r3, r6
  407e7a:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
  407e7e:	4598      	cmp	r8, r3
  407e80:	d1ed      	bne.n	407e5e <_ZN11MotionQueue18executeMotionQueueEPh+0xda>
                num_items++;
  407e82:	f10c 0c01 	add.w	ip, ip, #1
  407e86:	fa5f fc8c 	uxtb.w	ip, ip
                if (num_items > MAX_CONCURRENT_SEQUENCES) { return Result::EXCEED_MAX_CONCURRENT; }
  407e8a:	f1bc 0f05 	cmp.w	ip, #5
  407e8e:	dc55      	bgt.n	407f3c <_ZN11MotionQueue18executeMotionQueueEPh+0x1b8>
                items_this_sequence[num_items - 1] = q.items[q_item];
  407e90:	f10c 33ff 	add.w	r3, ip, #4294967295
  407e94:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  407e98:	ea4f 09c3 	mov.w	r9, r3, lsl #3
  407e9c:	ebce 03ce 	rsb	r3, lr, lr, lsl #3
  407ea0:	00dc      	lsls	r4, r3, #3
  407ea2:	440c      	add	r4, r1
  407ea4:	44e9      	add	r9, sp
  407ea6:	4434      	add	r4, r6
  407ea8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  407eaa:	e8a9 000f 	stmia.w	r9!, {r0, r1, r2, r3}
  407eae:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  407eb0:	e8a9 000f 	stmia.w	r9!, {r0, r1, r2, r3}
  407eb4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  407eb6:	e8a9 000f 	stmia.w	r9!, {r0, r1, r2, r3}
  407eba:	e894 0003 	ldmia.w	r4, {r0, r1}
  407ebe:	e889 0003 	stmia.w	r9, {r0, r1}
  407ec2:	e7cc      	b.n	407e5e <_ZN11MotionQueue18executeMotionQueueEPh+0xda>
        if (num_items == 0) continue;
  407ec4:	f1bc 0f00 	cmp.w	ip, #0
  407ec8:	d128      	bne.n	407f1c <_ZN11MotionQueue18executeMotionQueueEPh+0x198>
    for (int sq_num = 0; sq_num <= max_seq; sq_num++) {
  407eca:	f108 0801 	add.w	r8, r8, #1
  407ece:	45b8      	cmp	r8, r7
  407ed0:	dc36      	bgt.n	407f40 <_ZN11MotionQueue18executeMotionQueueEPh+0x1bc>
  407ed2:	2004      	movs	r0, #4
  407ed4:	466b      	mov	r3, sp
        QueueItem items_this_sequence[MAX_CONCURRENT_SEQUENCES];
  407ed6:	2800      	cmp	r0, #0
  407ed8:	dbbd      	blt.n	407e56 <_ZN11MotionQueue18executeMotionQueueEPh+0xd2>
    struct MotionParameters {
  407eda:	21ff      	movs	r1, #255	; 0xff
  407edc:	8059      	strh	r1, [r3, #2]
  407ede:	2200      	movs	r2, #0
  407ee0:	809a      	strh	r2, [r3, #4]
  407ee2:	80da      	strh	r2, [r3, #6]
  407ee4:	811a      	strh	r2, [r3, #8]
  407ee6:	815a      	strh	r2, [r3, #10]
  407ee8:	8199      	strh	r1, [r3, #12]
  407eea:	81da      	strh	r2, [r3, #14]
  407eec:	821a      	strh	r2, [r3, #16]
  407eee:	825a      	strh	r2, [r3, #18]
  407ef0:	829a      	strh	r2, [r3, #20]
  407ef2:	82da      	strh	r2, [r3, #22]
  407ef4:	831a      	strh	r2, [r3, #24]
  407ef6:	835a      	strh	r2, [r3, #26]
  407ef8:	839a      	strh	r2, [r3, #28]
  407efa:	83da      	strh	r2, [r3, #30]
  407efc:	841a      	strh	r2, [r3, #32]
  407efe:	845a      	strh	r2, [r3, #34]	; 0x22
  407f00:	849a      	strh	r2, [r3, #36]	; 0x24
  407f02:	84da      	strh	r2, [r3, #38]	; 0x26
  407f04:	851a      	strh	r2, [r3, #40]	; 0x28
  407f06:	855a      	strh	r2, [r3, #42]	; 0x2a
  407f08:	859a      	strh	r2, [r3, #44]	; 0x2c
  407f0a:	85da      	strh	r2, [r3, #46]	; 0x2e
  407f0c:	861a      	strh	r2, [r3, #48]	; 0x30
  407f0e:	865a      	strh	r2, [r3, #50]	; 0x32
  407f10:	869a      	strh	r2, [r3, #52]	; 0x34
    struct QueueItem {
  407f12:	f883 1036 	strb.w	r1, [r3, #54]	; 0x36
  407f16:	3338      	adds	r3, #56	; 0x38
  407f18:	3801      	subs	r0, #1
  407f1a:	e7dc      	b.n	407ed6 <_ZN11MotionQueue18executeMotionQueueEPh+0x152>
        m_queue_status.sequence_num = sq_num; // update sequence number
  407f1c:	f247 0356 	movw	r3, #28758	; 0x7056
  407f20:	f826 8003 	strh.w	r8, [r6, r3]
        res = executeItemInMotionQueue(items_this_sequence, num_items);
  407f24:	4662      	mov	r2, ip
  407f26:	4669      	mov	r1, sp
  407f28:	4630      	mov	r0, r6
  407f2a:	4b0a      	ldr	r3, [pc, #40]	; (407f54 <_ZN11MotionQueue18executeMotionQueueEPh+0x1d0>)
  407f2c:	4798      	blx	r3
  407f2e:	4604      	mov	r4, r0
        if (res != Result::SUCCESS) {
  407f30:	2801      	cmp	r0, #1
  407f32:	d0ca      	beq.n	407eca <_ZN11MotionQueue18executeMotionQueueEPh+0x146>
            unflagAllSteppers();
  407f34:	4630      	mov	r0, r6
  407f36:	4b08      	ldr	r3, [pc, #32]	; (407f58 <_ZN11MotionQueue18executeMotionQueueEPh+0x1d4>)
  407f38:	4798      	blx	r3
            return res;
  407f3a:	e732      	b.n	407da2 <_ZN11MotionQueue18executeMotionQueueEPh+0x1e>
                if (num_items > MAX_CONCURRENT_SEQUENCES) { return Result::EXCEED_MAX_CONCURRENT; }
  407f3c:	2406      	movs	r4, #6
  407f3e:	e730      	b.n	407da2 <_ZN11MotionQueue18executeMotionQueueEPh+0x1e>
    unflagAllSteppers();
  407f40:	4630      	mov	r0, r6
  407f42:	4b05      	ldr	r3, [pc, #20]	; (407f58 <_ZN11MotionQueue18executeMotionQueueEPh+0x1d4>)
  407f44:	4798      	blx	r3
    return Result::SUCCESS;
  407f46:	2401      	movs	r4, #1
  407f48:	e72b      	b.n	407da2 <_ZN11MotionQueue18executeMotionQueueEPh+0x1e>
  407f4a:	bf00      	nop
  407f4c:	0040b2b5 	.word	0x0040b2b5
  407f50:	0040746d 	.word	0x0040746d
  407f54:	00407a11 	.word	0x00407a11
  407f58:	0040747d 	.word	0x0040747d

00407f5c <_ZN11MotionQueue16task_motionQueueEPv>:

/* ---------------------------------------------------------------------------------- */
void MotionQueue::task_motionQueue(void *parameters) {
  407f5c:	b570      	push	{r4, r5, r6, lr}
  407f5e:	b082      	sub	sp, #8
  407f60:	4604      	mov	r4, r0
  407f62:	e019      	b.n	407f98 <_ZN11MotionQueue16task_motionQueueEPv+0x3c>
    for (;;) {
        if (xQueuePeek(self->m_motion_queue_handle, &motion_number_ptr, 0) == pdTRUE) {
            // motion_queue_debug("Received command to run motion %d\n", *motion_number_ptr);

            // Execute and free heap memory inside executeMotionQueue
            result = self->executeMotionQueue(motion_number_ptr);
  407f64:	9901      	ldr	r1, [sp, #4]
  407f66:	4620      	mov	r0, r4
  407f68:	4b12      	ldr	r3, [pc, #72]	; (407fb4 <_ZN11MotionQueue16task_motionQueueEPv+0x58>)
  407f6a:	4798      	blx	r3
  407f6c:	a902      	add	r1, sp, #8
  407f6e:	f801 0d05 	strb.w	r0, [r1, #-5]!

            self->m_queue_status.is_executing = 0; // reset status
  407f72:	2500      	movs	r5, #0
  407f74:	f247 0352 	movw	r3, #28754	; 0x7052
  407f78:	52e5      	strh	r5, [r4, r3]

            // Send result
            xQueueSend(self->m_result_queue_handle, &result, 0);
  407f7a:	462b      	mov	r3, r5
  407f7c:	462a      	mov	r2, r5
  407f7e:	f247 005c 	movw	r0, #28764	; 0x705c
  407f82:	5820      	ldr	r0, [r4, r0]
  407f84:	4e0c      	ldr	r6, [pc, #48]	; (407fb8 <_ZN11MotionQueue16task_motionQueueEPv+0x5c>)
  407f86:	47b0      	blx	r6

            // Remove from queue
            xQueueReceive(self->m_motion_queue_handle, &motion_number_ptr, 0);
  407f88:	462b      	mov	r3, r5
  407f8a:	462a      	mov	r2, r5
  407f8c:	a901      	add	r1, sp, #4
  407f8e:	f247 0058 	movw	r0, #28760	; 0x7058
  407f92:	5820      	ldr	r0, [r4, r0]
  407f94:	4d09      	ldr	r5, [pc, #36]	; (407fbc <_ZN11MotionQueue16task_motionQueueEPv+0x60>)
  407f96:	47a8      	blx	r5
        if (xQueuePeek(self->m_motion_queue_handle, &motion_number_ptr, 0) == pdTRUE) {
  407f98:	2301      	movs	r3, #1
  407f9a:	2200      	movs	r2, #0
  407f9c:	a901      	add	r1, sp, #4
  407f9e:	f247 0058 	movw	r0, #28760	; 0x7058
  407fa2:	5820      	ldr	r0, [r4, r0]
  407fa4:	4d05      	ldr	r5, [pc, #20]	; (407fbc <_ZN11MotionQueue16task_motionQueueEPv+0x60>)
  407fa6:	47a8      	blx	r5
  407fa8:	2801      	cmp	r0, #1
  407faa:	d0db      	beq.n	407f64 <_ZN11MotionQueue16task_motionQueueEPv+0x8>
        } else {
            vTaskDelay(10 / portTICK_RATE_MS);
  407fac:	200a      	movs	r0, #10
  407fae:	4b04      	ldr	r3, [pc, #16]	; (407fc0 <_ZN11MotionQueue16task_motionQueueEPv+0x64>)
  407fb0:	4798      	blx	r3
  407fb2:	e7f1      	b.n	407f98 <_ZN11MotionQueue16task_motionQueueEPv+0x3c>
  407fb4:	00407d85 	.word	0x00407d85
  407fb8:	00409209 	.word	0x00409209
  407fbc:	00409421 	.word	0x00409421
  407fc0:	00409bd5 	.word	0x00409bd5

00407fc4 <_ZN6SDCard5mountEv>:
#include "sd_card.h"

bool SDCard::mount() {
  407fc4:	b510      	push	{r4, lr}
  407fc6:	b082      	sub	sp, #8
  407fc8:	4604      	mov	r4, r0
    Ctrl_status status;

    sd_card_debug("Waiting for card...");
    do {
        status = sd_mmc_test_unit_ready(0);
  407fca:	2000      	movs	r0, #0
  407fcc:	4b13      	ldr	r3, [pc, #76]	; (40801c <_ZN6SDCard5mountEv+0x58>)
  407fce:	4798      	blx	r3
        if (CTRL_FAIL == status) {
  407fd0:	2801      	cmp	r0, #1
  407fd2:	d01e      	beq.n	408012 <_ZN6SDCard5mountEv+0x4e>
            sd_card_debug("[FAIL] Please unplug and re-plug the card.\r\n");
            return false;
        }
    } while (CTRL_GOOD != status);
  407fd4:	2800      	cmp	r0, #0
  407fd6:	d1f8      	bne.n	407fca <_ZN6SDCard5mountEv+0x6>

    sd_card_debug("[OK]\r\n");

    sd_card_debug("Mounting card...");
    memset(&fs, 0, sizeof(FATFS));
  407fd8:	f44f 720c 	mov.w	r2, #560	; 0x230
  407fdc:	2100      	movs	r1, #0
  407fde:	4620      	mov	r0, r4
  407fe0:	4b0f      	ldr	r3, [pc, #60]	; (408020 <_ZN6SDCard5mountEv+0x5c>)
  407fe2:	4798      	blx	r3
    FRESULT res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  407fe4:	4621      	mov	r1, r4
  407fe6:	2000      	movs	r0, #0
  407fe8:	4b0e      	ldr	r3, [pc, #56]	; (408024 <_ZN6SDCard5mountEv+0x60>)
  407fea:	4798      	blx	r3

    if (res != FR_OK) {
  407fec:	b108      	cbz	r0, 407ff2 <_ZN6SDCard5mountEv+0x2e>
        sd_card_debug("[FAIL] f_mount res=%d\r\n", res);
        return false;
  407fee:	2000      	movs	r0, #0
  407ff0:	e010      	b.n	408014 <_ZN6SDCard5mountEv+0x50>

    DWORD  free_clusters;
    FATFS *fsp;

    sd_card_debug("Checking SD card type...");
    res = f_getfree("0:", &free_clusters, &fsp);
  407ff2:	466a      	mov	r2, sp
  407ff4:	a901      	add	r1, sp, #4
  407ff6:	480c      	ldr	r0, [pc, #48]	; (408028 <_ZN6SDCard5mountEv+0x64>)
  407ff8:	4b0c      	ldr	r3, [pc, #48]	; (40802c <_ZN6SDCard5mountEv+0x68>)
  407ffa:	4798      	blx	r3

    if (res != FR_OK) {
  407ffc:	b960      	cbnz	r0, 408018 <_ZN6SDCard5mountEv+0x54>
        sd_card_debug("[FAIL] Not valid FAT filesystem (res=%d)\r\n", res);
        return false;
    }

    if (fsp->fs_type != FS_FAT32) {
  407ffe:	9b00      	ldr	r3, [sp, #0]
  408000:	781b      	ldrb	r3, [r3, #0]
  408002:	2b03      	cmp	r3, #3
  408004:	d001      	beq.n	40800a <_ZN6SDCard5mountEv+0x46>
        sd_card_debug("[FAIL] Not FAT32 (detected type %d)\r\n", fsp->fs_type);
        return false;
  408006:	2000      	movs	r0, #0
  408008:	e004      	b.n	408014 <_ZN6SDCard5mountEv+0x50>
    }

    sd_card_debug("[OK]\r\n");

    m_card_mounted = true;
  40800a:	2001      	movs	r0, #1
  40800c:	f884 0254 	strb.w	r0, [r4, #596]	; 0x254
    return true;
  408010:	e000      	b.n	408014 <_ZN6SDCard5mountEv+0x50>
            return false;
  408012:	2000      	movs	r0, #0
}
  408014:	b002      	add	sp, #8
  408016:	bd10      	pop	{r4, pc}
        return false;
  408018:	2000      	movs	r0, #0
  40801a:	e7fb      	b.n	408014 <_ZN6SDCard5mountEv+0x50>
  40801c:	00401239 	.word	0x00401239
  408020:	0040c287 	.word	0x0040c287
  408024:	00403025 	.word	0x00403025
  408028:	0040e2dc 	.word	0x0040e2dc
  40802c:	00403631 	.word	0x00403631

00408030 <_ZN6SDCard7unmountEv>:

/* ---------------------------------------------------------------------------------- */
void SDCard::unmount() {
    sd_card_debug("Unmounting card...");
    if (!m_card_mounted) {
  408030:	f890 3254 	ldrb.w	r3, [r0, #596]	; 0x254
  408034:	b903      	cbnz	r3, 408038 <_ZN6SDCard7unmountEv+0x8>
  408036:	4770      	bx	lr
void SDCard::unmount() {
  408038:	b510      	push	{r4, lr}
  40803a:	4604      	mov	r4, r0
        sd_card_debug("[FAILED] Card not mounted\r\n");
        return;
    }
    f_mount(LUN_ID_SD_MMC_0_MEM, NULL);
  40803c:	2100      	movs	r1, #0
  40803e:	4608      	mov	r0, r1
  408040:	4b02      	ldr	r3, [pc, #8]	; (40804c <_ZN6SDCard7unmountEv+0x1c>)
  408042:	4798      	blx	r3
    sd_card_debug("[OK]\r\n");

    m_card_mounted = false;
  408044:	2300      	movs	r3, #0
  408046:	f884 3254 	strb.w	r3, [r4, #596]	; 0x254
  40804a:	bd10      	pop	{r4, pc}
  40804c:	00403025 	.word	0x00403025

00408050 <_ZN6SDCard9writeFileEPKcS1_>:
}

/* ---------------------------------------------------------------------------------- */
bool SDCard::writeFile(const char *file_name, const char *data) {
  408050:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  408054:	b08a      	sub	sp, #40	; 0x28
    sd_card_debug("Create/open file (f_open)...");

    // Sanity check
    if (!m_card_mounted) {
  408056:	f890 4254 	ldrb.w	r4, [r0, #596]	; 0x254
  40805a:	b91c      	cbnz	r4, 408064 <_ZN6SDCard9writeFileEPKcS1_+0x14>
    if (res != FR_OK) { sd_card_debug("[FAIL] f_sync res=%d\r\n", res); }

    f_close(&file_object);
    sd_card_debug("[OK]\r\n");
    return true;
}
  40805c:	4620      	mov	r0, r4
  40805e:	b00a      	add	sp, #40	; 0x28
  408060:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408064:	4616      	mov	r6, r2
  408066:	460d      	mov	r5, r1
    size_t path_len = strlen(file_name) + 3; // 2 for "0:" + 1 for null
  408068:	4608      	mov	r0, r1
  40806a:	4b1c      	ldr	r3, [pc, #112]	; (4080dc <_ZN6SDCard9writeFileEPKcS1_+0x8c>)
  40806c:	4798      	blx	r3
  40806e:	f100 0803 	add.w	r8, r0, #3
    char  *path     = (char *)malloc(path_len);
  408072:	4640      	mov	r0, r8
  408074:	4b1a      	ldr	r3, [pc, #104]	; (4080e0 <_ZN6SDCard9writeFileEPKcS1_+0x90>)
  408076:	4798      	blx	r3
    if (!path) {
  408078:	4607      	mov	r7, r0
  40807a:	2800      	cmp	r0, #0
  40807c:	d02c      	beq.n	4080d8 <_ZN6SDCard9writeFileEPKcS1_+0x88>
    snprintf(path, path_len, "0:%s", file_name);
  40807e:	462b      	mov	r3, r5
  408080:	4a18      	ldr	r2, [pc, #96]	; (4080e4 <_ZN6SDCard9writeFileEPKcS1_+0x94>)
  408082:	4641      	mov	r1, r8
  408084:	4d18      	ldr	r5, [pc, #96]	; (4080e8 <_ZN6SDCard9writeFileEPKcS1_+0x98>)
  408086:	47a8      	blx	r5
    res = f_open(&file_object, path, FA_WRITE | FA_CREATE_ALWAYS | FA_READ);
  408088:	220b      	movs	r2, #11
  40808a:	4639      	mov	r1, r7
  40808c:	a801      	add	r0, sp, #4
  40808e:	4b17      	ldr	r3, [pc, #92]	; (4080ec <_ZN6SDCard9writeFileEPKcS1_+0x9c>)
  408090:	4798      	blx	r3
  408092:	4605      	mov	r5, r0
    free(path);
  408094:	4638      	mov	r0, r7
  408096:	4b16      	ldr	r3, [pc, #88]	; (4080f0 <_ZN6SDCard9writeFileEPKcS1_+0xa0>)
  408098:	4798      	blx	r3
    if (res != FR_OK) {
  40809a:	b10d      	cbz	r5, 4080a0 <_ZN6SDCard9writeFileEPKcS1_+0x50>
        return false;
  40809c:	2400      	movs	r4, #0
  40809e:	e7dd      	b.n	40805c <_ZN6SDCard9writeFileEPKcS1_+0xc>
    res = f_write(&file_object, data, strlen(data), &bytes_written);
  4080a0:	4630      	mov	r0, r6
  4080a2:	4b0e      	ldr	r3, [pc, #56]	; (4080dc <_ZN6SDCard9writeFileEPKcS1_+0x8c>)
  4080a4:	4798      	blx	r3
  4080a6:	466b      	mov	r3, sp
  4080a8:	4602      	mov	r2, r0
  4080aa:	4631      	mov	r1, r6
  4080ac:	a801      	add	r0, sp, #4
  4080ae:	4d11      	ldr	r5, [pc, #68]	; (4080f4 <_ZN6SDCard9writeFileEPKcS1_+0xa4>)
  4080b0:	47a8      	blx	r5
    if (res != FR_OK || bytes_written != strlen(data)) {
  4080b2:	b928      	cbnz	r0, 4080c0 <_ZN6SDCard9writeFileEPKcS1_+0x70>
  4080b4:	4630      	mov	r0, r6
  4080b6:	4b09      	ldr	r3, [pc, #36]	; (4080dc <_ZN6SDCard9writeFileEPKcS1_+0x8c>)
  4080b8:	4798      	blx	r3
  4080ba:	9b00      	ldr	r3, [sp, #0]
  4080bc:	4298      	cmp	r0, r3
  4080be:	d004      	beq.n	4080ca <_ZN6SDCard9writeFileEPKcS1_+0x7a>
        f_close(&file_object);
  4080c0:	a801      	add	r0, sp, #4
  4080c2:	4b0d      	ldr	r3, [pc, #52]	; (4080f8 <_ZN6SDCard9writeFileEPKcS1_+0xa8>)
  4080c4:	4798      	blx	r3
        return false;
  4080c6:	2400      	movs	r4, #0
  4080c8:	e7c8      	b.n	40805c <_ZN6SDCard9writeFileEPKcS1_+0xc>
    res = f_sync(&file_object);
  4080ca:	a801      	add	r0, sp, #4
  4080cc:	4b0b      	ldr	r3, [pc, #44]	; (4080fc <_ZN6SDCard9writeFileEPKcS1_+0xac>)
  4080ce:	4798      	blx	r3
    f_close(&file_object);
  4080d0:	a801      	add	r0, sp, #4
  4080d2:	4b09      	ldr	r3, [pc, #36]	; (4080f8 <_ZN6SDCard9writeFileEPKcS1_+0xa8>)
  4080d4:	4798      	blx	r3
    return true;
  4080d6:	e7c1      	b.n	40805c <_ZN6SDCard9writeFileEPKcS1_+0xc>
        return false;
  4080d8:	2400      	movs	r4, #0
  4080da:	e7bf      	b.n	40805c <_ZN6SDCard9writeFileEPKcS1_+0xc>
  4080dc:	0040c78b 	.word	0x0040c78b
  4080e0:	0040c251 	.word	0x0040c251
  4080e4:	0040e2e0 	.word	0x0040e2e0
  4080e8:	0040c605 	.word	0x0040c605
  4080ec:	0040304d 	.word	0x0040304d
  4080f0:	0040c261 	.word	0x0040c261
  4080f4:	00403379 	.word	0x00403379
  4080f8:	00403619 	.word	0x00403619
  4080fc:	00403581 	.word	0x00403581

00408100 <_ZN6SDCard8readFileEPKcPPc>:

/* ---------------------------------------------------------------------------------- */
bool SDCard::readFile(const char *file_name, char **out_buffer) {
  408100:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  408104:	b08a      	sub	sp, #40	; 0x28
    sd_card_debug("Reading file (%s)...", file_name);

    // Sanity check
    if (!m_card_mounted) {
  408106:	f890 4254 	ldrb.w	r4, [r0, #596]	; 0x254
  40810a:	b91c      	cbnz	r4, 408114 <_ZN6SDCard8readFileEPKcPPc+0x14>
    //   if (buffer[i] == '\r') buffer[i] = '\n';
    // }

    *out_buffer = buffer;
    return true;
}
  40810c:	4620      	mov	r0, r4
  40810e:	b00a      	add	sp, #40	; 0x28
  408110:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408114:	4616      	mov	r6, r2
  408116:	460d      	mov	r5, r1
    *out_buffer = NULL;
  408118:	2300      	movs	r3, #0
  40811a:	6013      	str	r3, [r2, #0]
    size_t path_len = strlen(file_name) + 3; // 2 for "0:" + 1 for null
  40811c:	4608      	mov	r0, r1
  40811e:	4b24      	ldr	r3, [pc, #144]	; (4081b0 <_ZN6SDCard8readFileEPKcPPc+0xb0>)
  408120:	4798      	blx	r3
  408122:	f100 0803 	add.w	r8, r0, #3
    char  *path     = (char *)malloc(path_len);
  408126:	4640      	mov	r0, r8
  408128:	4b22      	ldr	r3, [pc, #136]	; (4081b4 <_ZN6SDCard8readFileEPKcPPc+0xb4>)
  40812a:	4798      	blx	r3
    if (!path) {
  40812c:	4607      	mov	r7, r0
  40812e:	2800      	cmp	r0, #0
  408130:	d03a      	beq.n	4081a8 <_ZN6SDCard8readFileEPKcPPc+0xa8>
    snprintf(path, path_len, "0:%s", file_name);
  408132:	462b      	mov	r3, r5
  408134:	4a20      	ldr	r2, [pc, #128]	; (4081b8 <_ZN6SDCard8readFileEPKcPPc+0xb8>)
  408136:	4641      	mov	r1, r8
  408138:	4d20      	ldr	r5, [pc, #128]	; (4081bc <_ZN6SDCard8readFileEPKcPPc+0xbc>)
  40813a:	47a8      	blx	r5
    res = f_open(&file, path, FA_READ);
  40813c:	2201      	movs	r2, #1
  40813e:	4639      	mov	r1, r7
  408140:	a801      	add	r0, sp, #4
  408142:	4b1f      	ldr	r3, [pc, #124]	; (4081c0 <_ZN6SDCard8readFileEPKcPPc+0xc0>)
  408144:	4798      	blx	r3
  408146:	4605      	mov	r5, r0
    free(path);
  408148:	4638      	mov	r0, r7
  40814a:	4b1e      	ldr	r3, [pc, #120]	; (4081c4 <_ZN6SDCard8readFileEPKcPPc+0xc4>)
  40814c:	4798      	blx	r3
    if (res != FR_OK) {
  40814e:	2d00      	cmp	r5, #0
  408150:	d12c      	bne.n	4081ac <_ZN6SDCard8readFileEPKcPPc+0xac>
    DWORD size = f_size(&file);
  408152:	9d04      	ldr	r5, [sp, #16]
    if (size == 0) {
  408154:	b1bd      	cbz	r5, 408186 <_ZN6SDCard8readFileEPKcPPc+0x86>
    char *buffer = (char *)malloc(size + 1);
  408156:	1c68      	adds	r0, r5, #1
  408158:	4b16      	ldr	r3, [pc, #88]	; (4081b4 <_ZN6SDCard8readFileEPKcPPc+0xb4>)
  40815a:	4798      	blx	r3
    if (!buffer) {
  40815c:	4607      	mov	r7, r0
  40815e:	b1b8      	cbz	r0, 408190 <_ZN6SDCard8readFileEPKcPPc+0x90>
    res = f_read(&file, buffer, size, &bytes_read);
  408160:	466b      	mov	r3, sp
  408162:	462a      	mov	r2, r5
  408164:	4601      	mov	r1, r0
  408166:	a801      	add	r0, sp, #4
  408168:	f8df 8060 	ldr.w	r8, [pc, #96]	; 4081cc <_ZN6SDCard8readFileEPKcPPc+0xcc>
  40816c:	47c0      	blx	r8
    if (res != FR_OK || bytes_read != size) {
  40816e:	b910      	cbnz	r0, 408176 <_ZN6SDCard8readFileEPKcPPc+0x76>
  408170:	9b00      	ldr	r3, [sp, #0]
  408172:	429d      	cmp	r5, r3
  408174:	d011      	beq.n	40819a <_ZN6SDCard8readFileEPKcPPc+0x9a>
        free(buffer);
  408176:	4638      	mov	r0, r7
  408178:	4b12      	ldr	r3, [pc, #72]	; (4081c4 <_ZN6SDCard8readFileEPKcPPc+0xc4>)
  40817a:	4798      	blx	r3
        f_close(&file);
  40817c:	a801      	add	r0, sp, #4
  40817e:	4b12      	ldr	r3, [pc, #72]	; (4081c8 <_ZN6SDCard8readFileEPKcPPc+0xc8>)
  408180:	4798      	blx	r3
        return false;
  408182:	2400      	movs	r4, #0
  408184:	e7c2      	b.n	40810c <_ZN6SDCard8readFileEPKcPPc+0xc>
        f_close(&file);
  408186:	a801      	add	r0, sp, #4
  408188:	4b0f      	ldr	r3, [pc, #60]	; (4081c8 <_ZN6SDCard8readFileEPKcPPc+0xc8>)
  40818a:	4798      	blx	r3
        return false;
  40818c:	2400      	movs	r4, #0
  40818e:	e7bd      	b.n	40810c <_ZN6SDCard8readFileEPKcPPc+0xc>
        f_close(&file);
  408190:	a801      	add	r0, sp, #4
  408192:	4b0d      	ldr	r3, [pc, #52]	; (4081c8 <_ZN6SDCard8readFileEPKcPPc+0xc8>)
  408194:	4798      	blx	r3
        return false;
  408196:	2400      	movs	r4, #0
  408198:	e7b8      	b.n	40810c <_ZN6SDCard8readFileEPKcPPc+0xc>
    buffer[size] = '\0'; // null terminate
  40819a:	2300      	movs	r3, #0
  40819c:	557b      	strb	r3, [r7, r5]
    f_close(&file);
  40819e:	a801      	add	r0, sp, #4
  4081a0:	4b09      	ldr	r3, [pc, #36]	; (4081c8 <_ZN6SDCard8readFileEPKcPPc+0xc8>)
  4081a2:	4798      	blx	r3
    *out_buffer = buffer;
  4081a4:	6037      	str	r7, [r6, #0]
    return true;
  4081a6:	e7b1      	b.n	40810c <_ZN6SDCard8readFileEPKcPPc+0xc>
        return false;
  4081a8:	2400      	movs	r4, #0
  4081aa:	e7af      	b.n	40810c <_ZN6SDCard8readFileEPKcPPc+0xc>
        return false;
  4081ac:	2400      	movs	r4, #0
  4081ae:	e7ad      	b.n	40810c <_ZN6SDCard8readFileEPKcPPc+0xc>
  4081b0:	0040c78b 	.word	0x0040c78b
  4081b4:	0040c251 	.word	0x0040c251
  4081b8:	0040e2e0 	.word	0x0040e2e0
  4081bc:	0040c605 	.word	0x0040c605
  4081c0:	0040304d 	.word	0x0040304d
  4081c4:	0040c261 	.word	0x0040c261
  4081c8:	00403619 	.word	0x00403619
  4081cc:	004031e5 	.word	0x004031e5

004081d0 <_ZN6SDCard10deleteFileEPKc>:

/* ---------------------------------------------------------------------------------- */
bool SDCard::deleteFile(const char *file_name) {
  4081d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    sd_card_debug("Delete file (f_unlink)...");

    // Sanity check
    if (!m_card_mounted) {
  4081d2:	f890 4254 	ldrb.w	r4, [r0, #596]	; 0x254
  4081d6:	b90c      	cbnz	r4, 4081dc <_ZN6SDCard10deleteFileEPKc+0xc>
        return false;
    }

    sd_card_debug("[OK]\r\n");
    return true;
}
  4081d8:	4620      	mov	r0, r4
  4081da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4081dc:	460d      	mov	r5, r1
    size_t path_len = strlen(file_name) + 3; // "0:" + null
  4081de:	4608      	mov	r0, r1
  4081e0:	4b0c      	ldr	r3, [pc, #48]	; (408214 <_ZN6SDCard10deleteFileEPKc+0x44>)
  4081e2:	4798      	blx	r3
  4081e4:	1cc7      	adds	r7, r0, #3
    char  *path     = (char *)malloc(path_len);
  4081e6:	4638      	mov	r0, r7
  4081e8:	4b0b      	ldr	r3, [pc, #44]	; (408218 <_ZN6SDCard10deleteFileEPKc+0x48>)
  4081ea:	4798      	blx	r3
    if (!path) {
  4081ec:	4606      	mov	r6, r0
  4081ee:	b178      	cbz	r0, 408210 <_ZN6SDCard10deleteFileEPKc+0x40>
    snprintf(path, path_len, "0:%s", file_name);
  4081f0:	462b      	mov	r3, r5
  4081f2:	4a0a      	ldr	r2, [pc, #40]	; (40821c <_ZN6SDCard10deleteFileEPKc+0x4c>)
  4081f4:	4639      	mov	r1, r7
  4081f6:	4d0a      	ldr	r5, [pc, #40]	; (408220 <_ZN6SDCard10deleteFileEPKc+0x50>)
  4081f8:	47a8      	blx	r5
    FRESULT res = f_unlink(path);
  4081fa:	4630      	mov	r0, r6
  4081fc:	4b09      	ldr	r3, [pc, #36]	; (408224 <_ZN6SDCard10deleteFileEPKc+0x54>)
  4081fe:	4798      	blx	r3
  408200:	4605      	mov	r5, r0
    free(path);
  408202:	4630      	mov	r0, r6
  408204:	4b08      	ldr	r3, [pc, #32]	; (408228 <_ZN6SDCard10deleteFileEPKc+0x58>)
  408206:	4798      	blx	r3
    if (res != FR_OK) {
  408208:	2d00      	cmp	r5, #0
  40820a:	d0e5      	beq.n	4081d8 <_ZN6SDCard10deleteFileEPKc+0x8>
        return false;
  40820c:	2400      	movs	r4, #0
  40820e:	e7e3      	b.n	4081d8 <_ZN6SDCard10deleteFileEPKc+0x8>
        return false;
  408210:	2400      	movs	r4, #0
  408212:	e7e1      	b.n	4081d8 <_ZN6SDCard10deleteFileEPKc+0x8>
  408214:	0040c78b 	.word	0x0040c78b
  408218:	0040c251 	.word	0x0040c251
  40821c:	0040e2e0 	.word	0x0040e2e0
  408220:	0040c605 	.word	0x0040c605
  408224:	00403739 	.word	0x00403739
  408228:	0040c261 	.word	0x0040c261

0040822c <_ZL22floatToHighAndLowWordsf>:
struct UInt32Parts {
    uint16_t high;
    uint16_t low;
};

static UInt32Parts floatToHighAndLowWords(float value) {
  40822c:	b500      	push	{lr}
  40822e:	b083      	sub	sp, #12
    UInt32Parts res;

    uint32_t int_value = static_cast<uint32_t>(value * 1000.0f);
  408230:	490a      	ldr	r1, [pc, #40]	; (40825c <_ZL22floatToHighAndLowWordsf+0x30>)
  408232:	4b0b      	ldr	r3, [pc, #44]	; (408260 <_ZL22floatToHighAndLowWordsf+0x34>)
  408234:	4798      	blx	r3
  408236:	4b0b      	ldr	r3, [pc, #44]	; (408264 <_ZL22floatToHighAndLowWordsf+0x38>)
  408238:	4798      	blx	r3

    res.high = (int_value >> 16) & 0xFFFF;
  40823a:	0c03      	lsrs	r3, r0, #16
  40823c:	f8ad 3000 	strh.w	r3, [sp]
    res.low  = int_value & 0xFFFF;
  408240:	f8ad 0002 	strh.w	r0, [sp, #2]

    return res;
  408244:	9b00      	ldr	r3, [sp, #0]
  408246:	2000      	movs	r0, #0
  408248:	b29a      	uxth	r2, r3
  40824a:	f362 000f 	bfi	r0, r2, #0, #16
  40824e:	0c1b      	lsrs	r3, r3, #16
  408250:	f363 401f 	bfi	r0, r3, #16, #16
}
  408254:	b003      	add	sp, #12
  408256:	f85d fb04 	ldr.w	pc, [sp], #4
  40825a:	bf00      	nop
  40825c:	447a0000 	.word	0x447a0000
  408260:	0040bde1 	.word	0x0040bde1
  408264:	0040c1b9 	.word	0x0040c1b9

00408268 <_ZL22int32ToHighAndLowWordsl>:

static UInt32Parts int32ToHighAndLowWords(int32_t value) {
  408268:	b082      	sub	sp, #8
    UInt32Parts res;

    uint32_t int_value = static_cast<uint32_t>(value);

    res.high = (int_value >> 16) & 0xFFFF;
  40826a:	0c03      	lsrs	r3, r0, #16
  40826c:	f8ad 3000 	strh.w	r3, [sp]
    res.low  = int_value & 0xFFFF;
  408270:	f8ad 0002 	strh.w	r0, [sp, #2]

    return res;
  408274:	9b00      	ldr	r3, [sp, #0]
  408276:	2000      	movs	r0, #0
  408278:	b29a      	uxth	r2, r3
  40827a:	f362 000f 	bfi	r0, r2, #0, #16
  40827e:	0c1b      	lsrs	r3, r3, #16
  408280:	f363 401f 	bfi	r0, r3, #16, #16
}
  408284:	b002      	add	sp, #8
  408286:	4770      	bx	lr

00408288 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch>:

    return true;
}

static bool parsePreloadedItems(SDCard *sd_card, MotionQueue *motion_queue, uint8_t index_list[MAX_ITEMS_PER_MOTION],
                                char file_name_list[MAX_ITEMS_PER_MOTION][32], uint8_t num_items) {
  408288:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40828c:	b09f      	sub	sp, #124	; 0x7c
  40828e:	9001      	str	r0, [sp, #4]
  408290:	4688      	mov	r8, r1
  408292:	4693      	mov	fp, r2
  408294:	469a      	mov	sl, r3
  408296:	f89d 90a0 	ldrb.w	r9, [sp, #160]	; 0xa0

    uint8_t current_item = 0;

    for (int i = 0; i < num_items; i++) {
  40829a:	2600      	movs	r6, #0
  40829c:	e1b2      	b.n	408604 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x37c>
            size_t len = strlen(line);
            if (len > 0 && line[len - 1] == '\r') line[len - 1] = '\0';

            char cmd[32];
            int  val;
            if (sscanf(line, "%31[^=]=%d", cmd, &val) == 2) {
  40829e:	ab04      	add	r3, sp, #16
  4082a0:	aa06      	add	r2, sp, #24
  4082a2:	4994      	ldr	r1, [pc, #592]	; (4084f4 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26c>)
  4082a4:	4620      	mov	r0, r4
  4082a6:	4c94      	ldr	r4, [pc, #592]	; (4084f8 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x270>)
  4082a8:	47a0      	blx	r4
  4082aa:	2802      	cmp	r0, #2
  4082ac:	d01b      	beq.n	4082e6 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x5e>
                    motion_queue->preloaded_motions[current_item].parameters.time_h = time_ms.high;
                    motion_queue->preloaded_motions[current_item].parameters.time_l = time_ms.low;
                }
            }

            if (!end) break;
  4082ae:	2d00      	cmp	r5, #0
  4082b0:	f000 81a4 	beq.w	4085fc <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x374>
            line = end + 1;
  4082b4:	1c6c      	adds	r4, r5, #1
        while (*line) {
  4082b6:	7823      	ldrb	r3, [r4, #0]
  4082b8:	2b00      	cmp	r3, #0
  4082ba:	f000 819f 	beq.w	4085fc <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x374>
            char *end = strchr(line, '\n');
  4082be:	210a      	movs	r1, #10
  4082c0:	4620      	mov	r0, r4
  4082c2:	4b8e      	ldr	r3, [pc, #568]	; (4084fc <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x274>)
  4082c4:	4798      	blx	r3
            if (end) *end = '\0';
  4082c6:	4605      	mov	r5, r0
  4082c8:	b108      	cbz	r0, 4082ce <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x46>
  4082ca:	2300      	movs	r3, #0
  4082cc:	7003      	strb	r3, [r0, #0]
            size_t len = strlen(line);
  4082ce:	4620      	mov	r0, r4
  4082d0:	4b8b      	ldr	r3, [pc, #556]	; (408500 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x278>)
  4082d2:	4798      	blx	r3
            if (len > 0 && line[len - 1] == '\r') line[len - 1] = '\0';
  4082d4:	2800      	cmp	r0, #0
  4082d6:	d0e2      	beq.n	40829e <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x16>
  4082d8:	1e43      	subs	r3, r0, #1
  4082da:	5ce2      	ldrb	r2, [r4, r3]
  4082dc:	2a0d      	cmp	r2, #13
  4082de:	d1de      	bne.n	40829e <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x16>
  4082e0:	2200      	movs	r2, #0
  4082e2:	54e2      	strb	r2, [r4, r3]
  4082e4:	e7db      	b.n	40829e <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x16>
                if (strcmp(cmd, "MOTION_TYPE") == 0) {
  4082e6:	4987      	ldr	r1, [pc, #540]	; (408504 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x27c>)
  4082e8:	a806      	add	r0, sp, #24
  4082ea:	4b87      	ldr	r3, [pc, #540]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  4082ec:	4798      	blx	r3
  4082ee:	b948      	cbnz	r0, 408304 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x7c>
                        static_cast<MotionQueue::MotionType>(val);
  4082f0:	f89d 1010 	ldrb.w	r1, [sp, #16]
                    motion_queue->preloaded_motions[current_item].motion_type =
  4082f4:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
  4082f8:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
  4082fc:	f646 1238 	movw	r2, #26936	; 0x6938
  408300:	5499      	strb	r1, [r3, r2]
  408302:	e7d4      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "DRIVER_NUMBER") == 0) {
  408304:	4981      	ldr	r1, [pc, #516]	; (40850c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x284>)
  408306:	a806      	add	r0, sp, #24
  408308:	4b7f      	ldr	r3, [pc, #508]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  40830a:	4798      	blx	r3
  40830c:	b948      	cbnz	r0, 408322 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x9a>
                    motion_queue->preloaded_motions[current_item].parameters.driver_num = val;
  40830e:	f8bd 1010 	ldrh.w	r1, [sp, #16]
  408312:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
  408316:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
  40831a:	f646 123a 	movw	r2, #26938	; 0x693a
  40831e:	5299      	strh	r1, [r3, r2]
  408320:	e7c5      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "POSITION") == 0) {
  408322:	497b      	ldr	r1, [pc, #492]	; (408510 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x288>)
  408324:	a806      	add	r0, sp, #24
  408326:	4b78      	ldr	r3, [pc, #480]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  408328:	4798      	blx	r3
  40832a:	b988      	cbnz	r0, 408350 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0xc8>
                    UInt32Parts position = int32ToHighAndLowWords(static_cast<int32_t>(val));
  40832c:	9804      	ldr	r0, [sp, #16]
  40832e:	4b79      	ldr	r3, [pc, #484]	; (408514 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x28c>)
  408330:	4798      	blx	r3
  408332:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.position_h = position.high;
  408334:	00fb      	lsls	r3, r7, #3
  408336:	1bda      	subs	r2, r3, r7
  408338:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  40833c:	f646 113c 	movw	r1, #26940	; 0x693c
  408340:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.position_l = position.low;
  408342:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  408346:	4613      	mov	r3, r2
  408348:	f646 123e 	movw	r2, #26942	; 0x693e
  40834c:	5299      	strh	r1, [r3, r2]
  40834e:	e7ae      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "OFFSET") == 0) {
  408350:	4971      	ldr	r1, [pc, #452]	; (408518 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x290>)
  408352:	a806      	add	r0, sp, #24
  408354:	4b6c      	ldr	r3, [pc, #432]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  408356:	4798      	blx	r3
  408358:	b988      	cbnz	r0, 40837e <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0xf6>
                    UInt32Parts offset = int32ToHighAndLowWords(static_cast<int32_t>(val));
  40835a:	9804      	ldr	r0, [sp, #16]
  40835c:	4b6d      	ldr	r3, [pc, #436]	; (408514 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x28c>)
  40835e:	4798      	blx	r3
  408360:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.offset_h = offset.high;
  408362:	00fb      	lsls	r3, r7, #3
  408364:	1bda      	subs	r2, r3, r7
  408366:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  40836a:	f646 1140 	movw	r1, #26944	; 0x6940
  40836e:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.offset_l = offset.low;
  408370:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  408374:	4613      	mov	r3, r2
  408376:	f646 1242 	movw	r2, #26946	; 0x6942
  40837a:	5299      	strh	r1, [r3, r2]
  40837c:	e797      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "HOMING_MODE") == 0) {
  40837e:	4967      	ldr	r1, [pc, #412]	; (40851c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x294>)
  408380:	a806      	add	r0, sp, #24
  408382:	4b61      	ldr	r3, [pc, #388]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  408384:	4798      	blx	r3
  408386:	b948      	cbnz	r0, 40839c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x114>
                    motion_queue->preloaded_motions[current_item].parameters.homing_mode = val;
  408388:	f8bd 1010 	ldrh.w	r1, [sp, #16]
  40838c:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
  408390:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
  408394:	f646 1244 	movw	r2, #26948	; 0x6944
  408398:	5299      	strh	r1, [r3, r2]
  40839a:	e788      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "HOMING_SENSOR") == 0) {
  40839c:	4960      	ldr	r1, [pc, #384]	; (408520 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x298>)
  40839e:	a806      	add	r0, sp, #24
  4083a0:	4b59      	ldr	r3, [pc, #356]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  4083a2:	4798      	blx	r3
  4083a4:	b948      	cbnz	r0, 4083ba <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x132>
                    motion_queue->preloaded_motions[current_item].parameters.homing_sensor = val;
  4083a6:	f8bd 1010 	ldrh.w	r1, [sp, #16]
  4083aa:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
  4083ae:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
  4083b2:	f646 1246 	movw	r2, #26950	; 0x6946
  4083b6:	5299      	strh	r1, [r3, r2]
  4083b8:	e779      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "SENSOR_HOME_VALUE") == 0) {
  4083ba:	495a      	ldr	r1, [pc, #360]	; (408524 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x29c>)
  4083bc:	a806      	add	r0, sp, #24
  4083be:	4b52      	ldr	r3, [pc, #328]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  4083c0:	4798      	blx	r3
  4083c2:	b948      	cbnz	r0, 4083d8 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x150>
                    motion_queue->preloaded_motions[current_item].parameters.sensor_home_value = val;
  4083c4:	f8bd 1010 	ldrh.w	r1, [sp, #16]
  4083c8:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
  4083cc:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
  4083d0:	f646 1248 	movw	r2, #26952	; 0x6948
  4083d4:	5299      	strh	r1, [r3, r2]
  4083d6:	e76a      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "RAMP_TYPE") == 0) {
  4083d8:	4953      	ldr	r1, [pc, #332]	; (408528 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2a0>)
  4083da:	a806      	add	r0, sp, #24
  4083dc:	4b4a      	ldr	r3, [pc, #296]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  4083de:	4798      	blx	r3
  4083e0:	b948      	cbnz	r0, 4083f6 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x16e>
                    motion_queue->preloaded_motions[current_item].parameters.ramp_type = val;
  4083e2:	f8bd 1010 	ldrh.w	r1, [sp, #16]
  4083e6:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
  4083ea:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
  4083ee:	f646 124a 	movw	r2, #26954	; 0x694a
  4083f2:	5299      	strh	r1, [r3, r2]
  4083f4:	e75b      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "MAX_SPEED") == 0) {
  4083f6:	494d      	ldr	r1, [pc, #308]	; (40852c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2a4>)
  4083f8:	a806      	add	r0, sp, #24
  4083fa:	4b43      	ldr	r3, [pc, #268]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  4083fc:	4798      	blx	r3
  4083fe:	b998      	cbnz	r0, 408428 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x1a0>
                    UInt32Parts max_speed = floatToHighAndLowWords(static_cast<float>(val));
  408400:	9804      	ldr	r0, [sp, #16]
  408402:	4b4b      	ldr	r3, [pc, #300]	; (408530 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2a8>)
  408404:	4798      	blx	r3
  408406:	4b4b      	ldr	r3, [pc, #300]	; (408534 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2ac>)
  408408:	4798      	blx	r3
  40840a:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.max_speed_h = max_speed.high;
  40840c:	00fb      	lsls	r3, r7, #3
  40840e:	1bda      	subs	r2, r3, r7
  408410:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  408414:	f646 114c 	movw	r1, #26956	; 0x694c
  408418:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.max_speed_l = max_speed.low;
  40841a:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  40841e:	4613      	mov	r3, r2
  408420:	f646 124e 	movw	r2, #26958	; 0x694e
  408424:	5299      	strh	r1, [r3, r2]
  408426:	e742      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "MAX_ACCELERATION") == 0) {
  408428:	4943      	ldr	r1, [pc, #268]	; (408538 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2b0>)
  40842a:	a806      	add	r0, sp, #24
  40842c:	4b36      	ldr	r3, [pc, #216]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  40842e:	4798      	blx	r3
  408430:	b998      	cbnz	r0, 40845a <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x1d2>
                    UInt32Parts max_acceleration = floatToHighAndLowWords(static_cast<float>(val));
  408432:	9804      	ldr	r0, [sp, #16]
  408434:	4b3e      	ldr	r3, [pc, #248]	; (408530 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2a8>)
  408436:	4798      	blx	r3
  408438:	4b3e      	ldr	r3, [pc, #248]	; (408534 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2ac>)
  40843a:	4798      	blx	r3
  40843c:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.max_accel_h = max_acceleration.high;
  40843e:	00fb      	lsls	r3, r7, #3
  408440:	1bda      	subs	r2, r3, r7
  408442:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  408446:	f646 1150 	movw	r1, #26960	; 0x6950
  40844a:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.max_accel_l = max_acceleration.low;
  40844c:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  408450:	4613      	mov	r3, r2
  408452:	f646 1252 	movw	r2, #26962	; 0x6952
  408456:	5299      	strh	r1, [r3, r2]
  408458:	e729      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "MAX_DECELERATION") == 0) {
  40845a:	4938      	ldr	r1, [pc, #224]	; (40853c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2b4>)
  40845c:	a806      	add	r0, sp, #24
  40845e:	4b2a      	ldr	r3, [pc, #168]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  408460:	4798      	blx	r3
  408462:	b998      	cbnz	r0, 40848c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x204>
                    UInt32Parts max_deceleration = floatToHighAndLowWords(static_cast<float>(val));
  408464:	9804      	ldr	r0, [sp, #16]
  408466:	4b32      	ldr	r3, [pc, #200]	; (408530 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2a8>)
  408468:	4798      	blx	r3
  40846a:	4b32      	ldr	r3, [pc, #200]	; (408534 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2ac>)
  40846c:	4798      	blx	r3
  40846e:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.max_decel_h = max_deceleration.high;
  408470:	00fb      	lsls	r3, r7, #3
  408472:	1bda      	subs	r2, r3, r7
  408474:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  408478:	f646 1154 	movw	r1, #26964	; 0x6954
  40847c:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.max_decel_l = max_deceleration.low;
  40847e:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  408482:	4613      	mov	r3, r2
  408484:	f646 1256 	movw	r2, #26966	; 0x6956
  408488:	5299      	strh	r1, [r3, r2]
  40848a:	e710      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "BOW1") == 0) {
  40848c:	492c      	ldr	r1, [pc, #176]	; (408540 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2b8>)
  40848e:	a806      	add	r0, sp, #24
  408490:	4b1d      	ldr	r3, [pc, #116]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  408492:	4798      	blx	r3
  408494:	b998      	cbnz	r0, 4084be <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x236>
                    UInt32Parts bow1 = floatToHighAndLowWords(static_cast<float>(val));
  408496:	9804      	ldr	r0, [sp, #16]
  408498:	4b25      	ldr	r3, [pc, #148]	; (408530 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2a8>)
  40849a:	4798      	blx	r3
  40849c:	4b25      	ldr	r3, [pc, #148]	; (408534 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2ac>)
  40849e:	4798      	blx	r3
  4084a0:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.bow1_h = bow1.high;
  4084a2:	00fb      	lsls	r3, r7, #3
  4084a4:	1bda      	subs	r2, r3, r7
  4084a6:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  4084aa:	f646 1158 	movw	r1, #26968	; 0x6958
  4084ae:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.bow1_l = bow1.low;
  4084b0:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  4084b4:	4613      	mov	r3, r2
  4084b6:	f646 125a 	movw	r2, #26970	; 0x695a
  4084ba:	5299      	strh	r1, [r3, r2]
  4084bc:	e6f7      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "BOW2") == 0) {
  4084be:	4921      	ldr	r1, [pc, #132]	; (408544 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2bc>)
  4084c0:	a806      	add	r0, sp, #24
  4084c2:	4b11      	ldr	r3, [pc, #68]	; (408508 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x280>)
  4084c4:	4798      	blx	r3
  4084c6:	2800      	cmp	r0, #0
  4084c8:	d13e      	bne.n	408548 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2c0>
                    UInt32Parts bow2 = floatToHighAndLowWords(static_cast<float>(val));
  4084ca:	9804      	ldr	r0, [sp, #16]
  4084cc:	4b18      	ldr	r3, [pc, #96]	; (408530 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2a8>)
  4084ce:	4798      	blx	r3
  4084d0:	4b18      	ldr	r3, [pc, #96]	; (408534 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2ac>)
  4084d2:	4798      	blx	r3
  4084d4:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.bow2_h = bow2.high;
  4084d6:	00fb      	lsls	r3, r7, #3
  4084d8:	1bda      	subs	r2, r3, r7
  4084da:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  4084de:	f646 115c 	movw	r1, #26972	; 0x695c
  4084e2:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.bow2_l = bow2.low;
  4084e4:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  4084e8:	4613      	mov	r3, r2
  4084ea:	f646 125e 	movw	r2, #26974	; 0x695e
  4084ee:	5299      	strh	r1, [r3, r2]
  4084f0:	e6dd      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
  4084f2:	bf00      	nop
  4084f4:	0040e2f0 	.word	0x0040e2f0
  4084f8:	0040c66d 	.word	0x0040c66d
  4084fc:	0040c74b 	.word	0x0040c74b
  408500:	0040c78b 	.word	0x0040c78b
  408504:	0040e2fc 	.word	0x0040e2fc
  408508:	0040c767 	.word	0x0040c767
  40850c:	0040e308 	.word	0x0040e308
  408510:	0040e318 	.word	0x0040e318
  408514:	00408269 	.word	0x00408269
  408518:	0040e324 	.word	0x0040e324
  40851c:	0040e32c 	.word	0x0040e32c
  408520:	0040e338 	.word	0x0040e338
  408524:	0040e348 	.word	0x0040e348
  408528:	0040e35c 	.word	0x0040e35c
  40852c:	0040e368 	.word	0x0040e368
  408530:	0040bd39 	.word	0x0040bd39
  408534:	0040822d 	.word	0x0040822d
  408538:	0040e374 	.word	0x0040e374
  40853c:	0040e388 	.word	0x0040e388
  408540:	0040e39c 	.word	0x0040e39c
  408544:	0040e3a4 	.word	0x0040e3a4
                } else if (strcmp(cmd, "BOW3") == 0) {
  408548:	493b      	ldr	r1, [pc, #236]	; (408638 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3b0>)
  40854a:	a806      	add	r0, sp, #24
  40854c:	4b3b      	ldr	r3, [pc, #236]	; (40863c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3b4>)
  40854e:	4798      	blx	r3
  408550:	b998      	cbnz	r0, 40857a <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2f2>
                    UInt32Parts bow3 = floatToHighAndLowWords(static_cast<float>(val));
  408552:	9804      	ldr	r0, [sp, #16]
  408554:	4b3a      	ldr	r3, [pc, #232]	; (408640 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3b8>)
  408556:	4798      	blx	r3
  408558:	4b3a      	ldr	r3, [pc, #232]	; (408644 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3bc>)
  40855a:	4798      	blx	r3
  40855c:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.bow3_h = bow3.high;
  40855e:	00fb      	lsls	r3, r7, #3
  408560:	1bda      	subs	r2, r3, r7
  408562:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  408566:	f646 1160 	movw	r1, #26976	; 0x6960
  40856a:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.bow3_l = bow3.low;
  40856c:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  408570:	4613      	mov	r3, r2
  408572:	f646 1262 	movw	r2, #26978	; 0x6962
  408576:	5299      	strh	r1, [r3, r2]
  408578:	e699      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "BOW4") == 0) {
  40857a:	4933      	ldr	r1, [pc, #204]	; (408648 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3c0>)
  40857c:	a806      	add	r0, sp, #24
  40857e:	4b2f      	ldr	r3, [pc, #188]	; (40863c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3b4>)
  408580:	4798      	blx	r3
  408582:	b998      	cbnz	r0, 4085ac <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x324>
                    UInt32Parts bow4 = floatToHighAndLowWords(static_cast<float>(val));
  408584:	9804      	ldr	r0, [sp, #16]
  408586:	4b2e      	ldr	r3, [pc, #184]	; (408640 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3b8>)
  408588:	4798      	blx	r3
  40858a:	4b2e      	ldr	r3, [pc, #184]	; (408644 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3bc>)
  40858c:	4798      	blx	r3
  40858e:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.bow4_h = bow4.high;
  408590:	00fb      	lsls	r3, r7, #3
  408592:	1bda      	subs	r2, r3, r7
  408594:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  408598:	f646 1164 	movw	r1, #26980	; 0x6964
  40859c:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.bow4_l = bow4.low;
  40859e:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  4085a2:	4613      	mov	r3, r2
  4085a4:	f646 1266 	movw	r2, #26982	; 0x6966
  4085a8:	5299      	strh	r1, [r3, r2]
  4085aa:	e680      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "USE_INVERSE_TIME") == 0) {
  4085ac:	4927      	ldr	r1, [pc, #156]	; (40864c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3c4>)
  4085ae:	a806      	add	r0, sp, #24
  4085b0:	4b22      	ldr	r3, [pc, #136]	; (40863c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3b4>)
  4085b2:	4798      	blx	r3
  4085b4:	b948      	cbnz	r0, 4085ca <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x342>
                        static_cast<uint16_t>(val);
  4085b6:	f8bd 1010 	ldrh.w	r1, [sp, #16]
                    motion_queue->preloaded_motions[current_item].parameters.use_inverse_time =
  4085ba:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
  4085be:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
  4085c2:	f646 1268 	movw	r2, #26984	; 0x6968
  4085c6:	5299      	strh	r1, [r3, r2]
  4085c8:	e671      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                } else if (strcmp(cmd, "TIME_MS") == 0) {
  4085ca:	4921      	ldr	r1, [pc, #132]	; (408650 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3c8>)
  4085cc:	a806      	add	r0, sp, #24
  4085ce:	4b1b      	ldr	r3, [pc, #108]	; (40863c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3b4>)
  4085d0:	4798      	blx	r3
  4085d2:	2800      	cmp	r0, #0
  4085d4:	f47f ae6b 	bne.w	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
                    UInt32Parts time_ms = int32ToHighAndLowWords(static_cast<int32_t>(val));
  4085d8:	9804      	ldr	r0, [sp, #16]
  4085da:	4b1e      	ldr	r3, [pc, #120]	; (408654 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3cc>)
  4085dc:	4798      	blx	r3
  4085de:	9005      	str	r0, [sp, #20]
                    motion_queue->preloaded_motions[current_item].parameters.time_h = time_ms.high;
  4085e0:	00fb      	lsls	r3, r7, #3
  4085e2:	1bda      	subs	r2, r3, r7
  4085e4:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  4085e8:	f646 116a 	movw	r1, #26986	; 0x696a
  4085ec:	5250      	strh	r0, [r2, r1]
                    motion_queue->preloaded_motions[current_item].parameters.time_l = time_ms.low;
  4085ee:	f8bd 1016 	ldrh.w	r1, [sp, #22]
  4085f2:	4613      	mov	r3, r2
  4085f4:	f646 126c 	movw	r2, #26988	; 0x696c
  4085f8:	5299      	strh	r1, [r3, r2]
  4085fa:	e658      	b.n	4082ae <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x26>
        }

        free(file_contents);
  4085fc:	9803      	ldr	r0, [sp, #12]
  4085fe:	4b16      	ldr	r3, [pc, #88]	; (408658 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3d0>)
  408600:	4798      	blx	r3
    for (int i = 0; i < num_items; i++) {
  408602:	3601      	adds	r6, #1
  408604:	454e      	cmp	r6, r9
  408606:	da13      	bge.n	408630 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3a8>
        char *file_contents = NULL;
  408608:	2300      	movs	r3, #0
  40860a:	9303      	str	r3, [sp, #12]
        snprintf(filename, sizeof(filename), "motion/%s", file_name_list[i]);
  40860c:	eb0a 1346 	add.w	r3, sl, r6, lsl #5
  408610:	4a12      	ldr	r2, [pc, #72]	; (40865c <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3d4>)
  408612:	2140      	movs	r1, #64	; 0x40
  408614:	a80e      	add	r0, sp, #56	; 0x38
  408616:	4c12      	ldr	r4, [pc, #72]	; (408660 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3d8>)
  408618:	47a0      	blx	r4
        if (!sd_card->readFile(filename, &file_contents)) {
  40861a:	aa03      	add	r2, sp, #12
  40861c:	a90e      	add	r1, sp, #56	; 0x38
  40861e:	9801      	ldr	r0, [sp, #4]
  408620:	4b10      	ldr	r3, [pc, #64]	; (408664 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x3dc>)
  408622:	4798      	blx	r3
  408624:	2800      	cmp	r0, #0
  408626:	d0ec      	beq.n	408602 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x37a>
        current_item = index_list[i];
  408628:	f81b 7006 	ldrb.w	r7, [fp, r6]
        char *line = file_contents;
  40862c:	9c03      	ldr	r4, [sp, #12]
  40862e:	e642      	b.n	4082b6 <_ZL19parsePreloadedItemsP6SDCardP11MotionQueuePhPA32_ch+0x2e>
    }

    return true;
}
  408630:	2001      	movs	r0, #1
  408632:	b01f      	add	sp, #124	; 0x7c
  408634:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  408638:	0040e3ac 	.word	0x0040e3ac
  40863c:	0040c767 	.word	0x0040c767
  408640:	0040bd39 	.word	0x0040bd39
  408644:	0040822d 	.word	0x0040822d
  408648:	0040e3b4 	.word	0x0040e3b4
  40864c:	0040e3bc 	.word	0x0040e3bc
  408650:	0040e3d0 	.word	0x0040e3d0
  408654:	00408269 	.word	0x00408269
  408658:	0040c261 	.word	0x0040c261
  40865c:	0040e274 	.word	0x0040e274
  408660:	0040c605 	.word	0x0040c605
  408664:	00408101 	.word	0x00408101

00408668 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue>:

static bool parseItemsIntoSequence(SDCard *sd_card, MotionQueue *motion_queue) {
  408668:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40866c:	b08c      	sub	sp, #48	; 0x30
  40866e:	4681      	mov	r9, r0
  408670:	4688      	mov	r8, r1
    for (int sq_idx = 0; sq_idx <= MAX_MOTIONS; sq_idx++) {
  408672:	2700      	movs	r7, #0
  408674:	e058      	b.n	408728 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xc0>
            if (len > 0 && ptr[len - 1] == '\r') ptr[len - 1] = '\0';

            int sq_num;
            int item_index;

            if (sscanf(ptr, "%d=%d", &sq_num, &item_index) == 2) {
  408676:	ab03      	add	r3, sp, #12
  408678:	aa02      	add	r2, sp, #8
  40867a:	4937      	ldr	r1, [pc, #220]	; (408758 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xf0>)
  40867c:	4620      	mov	r0, r4
  40867e:	4c37      	ldr	r4, [pc, #220]	; (40875c <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xf4>)
  408680:	47a0      	blx	r4
  408682:	2802      	cmp	r0, #2
  408684:	d019      	beq.n	4086ba <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0x52>
                motion_queue->motion_list[sq_idx].items[sq_item_idx].sequence_number = sq_num;

                sq_item_idx++;
            }

            if (!end) break;
  408686:	2d00      	cmp	r5, #0
  408688:	d04a      	beq.n	408720 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xb8>
            ptr = end + 1;
  40868a:	1c6c      	adds	r4, r5, #1
        while (*ptr) {
  40868c:	7823      	ldrb	r3, [r4, #0]
  40868e:	2b00      	cmp	r3, #0
  408690:	d046      	beq.n	408720 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xb8>
            char *end = strchr(ptr, '\n');
  408692:	210a      	movs	r1, #10
  408694:	4620      	mov	r0, r4
  408696:	4b32      	ldr	r3, [pc, #200]	; (408760 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xf8>)
  408698:	4798      	blx	r3
            if (end) *end = '\0';
  40869a:	4605      	mov	r5, r0
  40869c:	b108      	cbz	r0, 4086a2 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0x3a>
  40869e:	2300      	movs	r3, #0
  4086a0:	7003      	strb	r3, [r0, #0]
            size_t len = strlen(ptr);
  4086a2:	4620      	mov	r0, r4
  4086a4:	4b2f      	ldr	r3, [pc, #188]	; (408764 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xfc>)
  4086a6:	4798      	blx	r3
            if (len > 0 && ptr[len - 1] == '\r') ptr[len - 1] = '\0';
  4086a8:	2800      	cmp	r0, #0
  4086aa:	d0e4      	beq.n	408676 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xe>
  4086ac:	1e43      	subs	r3, r0, #1
  4086ae:	5ce2      	ldrb	r2, [r4, r3]
  4086b0:	2a0d      	cmp	r2, #13
  4086b2:	d1e0      	bne.n	408676 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xe>
  4086b4:	2200      	movs	r2, #0
  4086b6:	54e2      	strb	r2, [r4, r3]
  4086b8:	e7dd      	b.n	408676 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xe>
                motion_queue->motion_list[sq_idx].items[sq_item_idx] = motion_queue->preloaded_motions[item_index];
  4086ba:	9b03      	ldr	r3, [sp, #12]
  4086bc:	ea4f 0cc6 	mov.w	ip, r6, lsl #3
  4086c0:	ebac 0206 	sub.w	r2, ip, r6
  4086c4:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
  4086c8:	ea4f 0ec7 	mov.w	lr, r7, lsl #3
  4086cc:	ebae 0107 	sub.w	r1, lr, r7
  4086d0:	020a      	lsls	r2, r1, #8
  4086d2:	4492      	add	sl, r2
  4086d4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  4086d8:	00dc      	lsls	r4, r3, #3
  4086da:	4444      	add	r4, r8
  4086dc:	44c2      	add	sl, r8
  4086de:	f504 44d2 	add.w	r4, r4, #26880	; 0x6900
  4086e2:	3438      	adds	r4, #56	; 0x38
  4086e4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  4086e6:	e8aa 000f 	stmia.w	sl!, {r0, r1, r2, r3}
  4086ea:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  4086ec:	e8aa 000f 	stmia.w	sl!, {r0, r1, r2, r3}
  4086f0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  4086f2:	e8aa 000f 	stmia.w	sl!, {r0, r1, r2, r3}
  4086f6:	e894 0003 	ldmia.w	r4, {r0, r1}
  4086fa:	e88a 0003 	stmia.w	sl, {r0, r1}
                motion_queue->motion_list[sq_idx].items[sq_item_idx].sequence_number = sq_num;
  4086fe:	f89d 1008 	ldrb.w	r1, [sp, #8]
  408702:	ebac 0c06 	sub.w	ip, ip, r6
  408706:	ea4f 03cc 	mov.w	r3, ip, lsl #3
  40870a:	ebae 0e07 	sub.w	lr, lr, r7
  40870e:	ea4f 220e 	mov.w	r2, lr, lsl #8
  408712:	4413      	add	r3, r2
  408714:	4443      	add	r3, r8
  408716:	f883 1036 	strb.w	r1, [r3, #54]	; 0x36
                sq_item_idx++;
  40871a:	3601      	adds	r6, #1
  40871c:	b2f6      	uxtb	r6, r6
  40871e:	e7b2      	b.n	408686 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0x1e>
        }

        free(file_contents);
  408720:	9801      	ldr	r0, [sp, #4]
  408722:	4b11      	ldr	r3, [pc, #68]	; (408768 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0x100>)
  408724:	4798      	blx	r3
    for (int sq_idx = 0; sq_idx <= MAX_MOTIONS; sq_idx++) {
  408726:	3701      	adds	r7, #1
  408728:	2f0f      	cmp	r7, #15
  40872a:	dc11      	bgt.n	408750 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xe8>
        char *file_contents = NULL;
  40872c:	2300      	movs	r3, #0
  40872e:	9301      	str	r3, [sp, #4]
        snprintf(filename, sizeof(filename), "sequence/%d", sq_idx);
  408730:	463b      	mov	r3, r7
  408732:	4a0e      	ldr	r2, [pc, #56]	; (40876c <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0x104>)
  408734:	2120      	movs	r1, #32
  408736:	a804      	add	r0, sp, #16
  408738:	4c0d      	ldr	r4, [pc, #52]	; (408770 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0x108>)
  40873a:	47a0      	blx	r4
        if (!sd_card->readFile(filename, &file_contents)) {
  40873c:	aa01      	add	r2, sp, #4
  40873e:	a904      	add	r1, sp, #16
  408740:	4648      	mov	r0, r9
  408742:	4b0c      	ldr	r3, [pc, #48]	; (408774 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0x10c>)
  408744:	4798      	blx	r3
  408746:	2800      	cmp	r0, #0
  408748:	d0ed      	beq.n	408726 <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0xbe>
        char   *ptr         = file_contents;
  40874a:	9c01      	ldr	r4, [sp, #4]
        uint8_t sq_item_idx = 0;
  40874c:	2600      	movs	r6, #0
  40874e:	e79d      	b.n	40868c <_ZL22parseItemsIntoSequenceP6SDCardP11MotionQueue+0x24>
    }
    return true;
}
  408750:	2001      	movs	r0, #1
  408752:	b00c      	add	sp, #48	; 0x30
  408754:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  408758:	0040e3d8 	.word	0x0040e3d8
  40875c:	0040c66d 	.word	0x0040c66d
  408760:	0040c74b 	.word	0x0040c74b
  408764:	0040c78b 	.word	0x0040c78b
  408768:	0040c261 	.word	0x0040c261
  40876c:	0040e290 	.word	0x0040e290
  408770:	0040c605 	.word	0x0040c605
  408774:	00408101 	.word	0x00408101

00408778 <_ZL16getCurrentScalert>:
    if (current_ma <= MIN_CURRENT) return 1;
  408778:	2898      	cmp	r0, #152	; 0x98
  40877a:	dd1e      	ble.n	4087ba <_ZL16getCurrentScalert+0x42>
static uint16_t getCurrentScaler(uint16_t current_ma) {
  40877c:	b510      	push	{r4, lr}
    if (current_ma > MAX_CURRENT_NEMA17) current_ma = MAX_CURRENT_NEMA17;
  40877e:	f640 33b8 	movw	r3, #3000	; 0xbb8
  408782:	4298      	cmp	r0, r3
  408784:	dd00      	ble.n	408788 <_ZL16getCurrentScalert+0x10>
  408786:	4618      	mov	r0, r3
    float scale = (static_cast<float>(current_ma) / DRIVER_RMS_MAX) * MAX_STEP;
  408788:	4b0f      	ldr	r3, [pc, #60]	; (4087c8 <_ZL16getCurrentScalert+0x50>)
  40878a:	4798      	blx	r3
  40878c:	4b0f      	ldr	r3, [pc, #60]	; (4087cc <_ZL16getCurrentScalert+0x54>)
  40878e:	4798      	blx	r3
  408790:	a30b      	add	r3, pc, #44	; (adr r3, 4087c0 <_ZL16getCurrentScalert+0x48>)
  408792:	e9d3 2300 	ldrd	r2, r3, [r3]
  408796:	4c0e      	ldr	r4, [pc, #56]	; (4087d0 <_ZL16getCurrentScalert+0x58>)
  408798:	47a0      	blx	r4
  40879a:	2200      	movs	r2, #0
  40879c:	4b0d      	ldr	r3, [pc, #52]	; (4087d4 <_ZL16getCurrentScalert+0x5c>)
  40879e:	4c0e      	ldr	r4, [pc, #56]	; (4087d8 <_ZL16getCurrentScalert+0x60>)
  4087a0:	47a0      	blx	r4
  4087a2:	4b0e      	ldr	r3, [pc, #56]	; (4087dc <_ZL16getCurrentScalert+0x64>)
  4087a4:	4798      	blx	r3
    uint16_t scaler = static_cast<uint16_t>(roundf(scale));
  4087a6:	4b0e      	ldr	r3, [pc, #56]	; (4087e0 <_ZL16getCurrentScalert+0x68>)
  4087a8:	4798      	blx	r3
  4087aa:	4b0e      	ldr	r3, [pc, #56]	; (4087e4 <_ZL16getCurrentScalert+0x6c>)
  4087ac:	4798      	blx	r3
  4087ae:	b280      	uxth	r0, r0
    if (scaler > MAX_STEP) scaler = MAX_STEP;
  4087b0:	281f      	cmp	r0, #31
  4087b2:	dd01      	ble.n	4087b8 <_ZL16getCurrentScalert+0x40>
  4087b4:	201f      	movs	r0, #31
};
  4087b6:	bd10      	pop	{r4, pc}
  4087b8:	bd10      	pop	{r4, pc}
    if (current_ma <= MIN_CURRENT) return 1;
  4087ba:	2001      	movs	r0, #1
  4087bc:	4770      	bx	lr
  4087be:	bf00      	nop
  4087c0:	00000000 	.word	0x00000000
  4087c4:	40b25c00 	.word	0x40b25c00
  4087c8:	0040bd31 	.word	0x0040bd31
  4087cc:	0040b609 	.word	0x0040b609
  4087d0:	0040b905 	.word	0x0040b905
  4087d4:	403f0000 	.word	0x403f0000
  4087d8:	0040b6b1 	.word	0x0040b6b1
  4087dc:	0040bb25 	.word	0x0040bb25
  4087e0:	0040b2f5 	.word	0x0040b2f5
  4087e4:	0040c1b9 	.word	0x0040c1b9

004087e8 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_>:
                          char out_file_name_list[MAX_ITEMS_PER_MOTION][32], uint8_t *out_num_items) {
  4087e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4087ec:	b08a      	sub	sp, #40	; 0x28
  4087ee:	4688      	mov	r8, r1
  4087f0:	4691      	mov	r9, r2
  4087f2:	469a      	mov	sl, r3
    char *file_contents = NULL;
  4087f4:	aa0a      	add	r2, sp, #40	; 0x28
  4087f6:	2300      	movs	r3, #0
  4087f8:	f842 3d04 	str.w	r3, [r2, #-4]!
    if (!sd_card->readFile("motion/_indexMap", &file_contents)) {
  4087fc:	491e      	ldr	r1, [pc, #120]	; (408878 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x90>)
  4087fe:	4b1f      	ldr	r3, [pc, #124]	; (40887c <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x94>)
  408800:	4798      	blx	r3
  408802:	4607      	mov	r7, r0
  408804:	2800      	cmp	r0, #0
  408806:	d033      	beq.n	408870 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x88>
    char   *ptr       = file_contents;
  408808:	9c09      	ldr	r4, [sp, #36]	; 0x24
    uint8_t num_items = 0;
  40880a:	2600      	movs	r6, #0
  40880c:	e009      	b.n	408822 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x3a>
        if (sscanf(ptr, "%d=%31s", &motion_num, motion_file_name) == 2) {
  40880e:	ab01      	add	r3, sp, #4
  408810:	466a      	mov	r2, sp
  408812:	491b      	ldr	r1, [pc, #108]	; (408880 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x98>)
  408814:	4620      	mov	r0, r4
  408816:	4c1b      	ldr	r4, [pc, #108]	; (408884 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x9c>)
  408818:	47a0      	blx	r4
  40881a:	2802      	cmp	r0, #2
  40881c:	d017      	beq.n	40884e <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x66>
        if (!end) break;
  40881e:	b315      	cbz	r5, 408866 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x7e>
        ptr = end + 1;
  408820:	1c6c      	adds	r4, r5, #1
    while (*ptr) {
  408822:	7823      	ldrb	r3, [r4, #0]
  408824:	b1fb      	cbz	r3, 408866 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x7e>
        char *end = strchr(ptr, '\n');
  408826:	210a      	movs	r1, #10
  408828:	4620      	mov	r0, r4
  40882a:	4b17      	ldr	r3, [pc, #92]	; (408888 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0xa0>)
  40882c:	4798      	blx	r3
        if (end) *end = '\0';
  40882e:	4605      	mov	r5, r0
  408830:	b108      	cbz	r0, 408836 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x4e>
  408832:	2300      	movs	r3, #0
  408834:	7003      	strb	r3, [r0, #0]
        size_t len = strlen(ptr);
  408836:	4620      	mov	r0, r4
  408838:	4b14      	ldr	r3, [pc, #80]	; (40888c <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0xa4>)
  40883a:	4798      	blx	r3
        if (len > 0 && ptr[len - 1] == '\r') ptr[len - 1] = '\0';
  40883c:	2800      	cmp	r0, #0
  40883e:	d0e6      	beq.n	40880e <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x26>
  408840:	1e43      	subs	r3, r0, #1
  408842:	5ce2      	ldrb	r2, [r4, r3]
  408844:	2a0d      	cmp	r2, #13
  408846:	d1e2      	bne.n	40880e <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x26>
  408848:	2200      	movs	r2, #0
  40884a:	54e2      	strb	r2, [r4, r3]
  40884c:	e7df      	b.n	40880e <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x26>
            out_index_list[num_items] = motion_num;
  40884e:	f89d 3000 	ldrb.w	r3, [sp]
  408852:	f808 3006 	strb.w	r3, [r8, r6]
            strcpy(out_file_name_list[num_items], motion_file_name);
  408856:	a901      	add	r1, sp, #4
  408858:	eb09 1046 	add.w	r0, r9, r6, lsl #5
  40885c:	4b0c      	ldr	r3, [pc, #48]	; (408890 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0xa8>)
  40885e:	4798      	blx	r3
            num_items++;
  408860:	3601      	adds	r6, #1
  408862:	b2f6      	uxtb	r6, r6
  408864:	e7db      	b.n	40881e <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0x36>
    free(file_contents);
  408866:	9809      	ldr	r0, [sp, #36]	; 0x24
  408868:	4b0a      	ldr	r3, [pc, #40]	; (408894 <_ZL13parseIndexMapP6SDCardPhPA32_cS1_+0xac>)
  40886a:	4798      	blx	r3
    *out_num_items = num_items;
  40886c:	f88a 6000 	strb.w	r6, [sl]
}
  408870:	4638      	mov	r0, r7
  408872:	b00a      	add	sp, #40	; 0x28
  408874:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  408878:	0040e3e0 	.word	0x0040e3e0
  40887c:	00408101 	.word	0x00408101
  408880:	0040e3f4 	.word	0x0040e3f4
  408884:	0040c66d 	.word	0x0040c66d
  408888:	0040c74b 	.word	0x0040c74b
  40888c:	0040c78b 	.word	0x0040c78b
  408890:	0040c77b 	.word	0x0040c77b
  408894:	0040c261 	.word	0x0040c261

00408898 <_Z18parse_driverConfigP6SDCardPP7Stepper>:
uint8_t parse_driverConfig(SDCard *sd_card, Stepper *steppers[MAX_STEPPERS]) {
  408898:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40889c:	b093      	sub	sp, #76	; 0x4c
  40889e:	4681      	mov	r9, r0
  4088a0:	4688      	mov	r8, r1
    char   *file_contents = NULL;
  4088a2:	2700      	movs	r7, #0
  4088a4:	9711      	str	r7, [sp, #68]	; 0x44
    for (int i = 0; i < MAX_STEPPERS; i++) {
  4088a6:	463e      	mov	r6, r7
  4088a8:	e0cf      	b.n	408a4a <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1b2>
            if (sscanf(ptr, "%31[^=]=%d", cmd, &val) == 2) {
  4088aa:	466b      	mov	r3, sp
  4088ac:	aa01      	add	r2, sp, #4
  4088ae:	4974      	ldr	r1, [pc, #464]	; (408a80 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1e8>)
  4088b0:	4620      	mov	r0, r4
  4088b2:	4c74      	ldr	r4, [pc, #464]	; (408a84 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1ec>)
  4088b4:	47a0      	blx	r4
  4088b6:	2802      	cmp	r0, #2
  4088b8:	d01b      	beq.n	4088f2 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x5a>
            if (!end) break;
  4088ba:	2d00      	cmp	r5, #0
  4088bc:	f000 80bd 	beq.w	408a3a <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1a2>
            ptr = end + 1;
  4088c0:	1c6c      	adds	r4, r5, #1
        while (*ptr) {
  4088c2:	7823      	ldrb	r3, [r4, #0]
  4088c4:	2b00      	cmp	r3, #0
  4088c6:	f000 80b8 	beq.w	408a3a <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1a2>
            char *end = strchr(ptr, '\n');
  4088ca:	210a      	movs	r1, #10
  4088cc:	4620      	mov	r0, r4
  4088ce:	4b6e      	ldr	r3, [pc, #440]	; (408a88 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1f0>)
  4088d0:	4798      	blx	r3
            if (end) *end = '\0';
  4088d2:	4605      	mov	r5, r0
  4088d4:	b108      	cbz	r0, 4088da <_Z18parse_driverConfigP6SDCardPP7Stepper+0x42>
  4088d6:	2300      	movs	r3, #0
  4088d8:	7003      	strb	r3, [r0, #0]
            size_t len = strlen(ptr);
  4088da:	4620      	mov	r0, r4
  4088dc:	4b6b      	ldr	r3, [pc, #428]	; (408a8c <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1f4>)
  4088de:	4798      	blx	r3
            if (len > 0 && ptr[len - 1] == '\r') ptr[len - 1] = '\0';
  4088e0:	2800      	cmp	r0, #0
  4088e2:	d0e2      	beq.n	4088aa <_Z18parse_driverConfigP6SDCardPP7Stepper+0x12>
  4088e4:	1e43      	subs	r3, r0, #1
  4088e6:	5ce2      	ldrb	r2, [r4, r3]
  4088e8:	2a0d      	cmp	r2, #13
  4088ea:	d1de      	bne.n	4088aa <_Z18parse_driverConfigP6SDCardPP7Stepper+0x12>
  4088ec:	2200      	movs	r2, #0
  4088ee:	54e2      	strb	r2, [r4, r3]
  4088f0:	e7db      	b.n	4088aa <_Z18parse_driverConfigP6SDCardPP7Stepper+0x12>
                if (strcmp(cmd, "MICROSTEP_PER_FULLSTEP") == 0) {
  4088f2:	4967      	ldr	r1, [pc, #412]	; (408a90 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1f8>)
  4088f4:	a801      	add	r0, sp, #4
  4088f6:	4b67      	ldr	r3, [pc, #412]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  4088f8:	4798      	blx	r3
  4088fa:	2800      	cmp	r0, #0
  4088fc:	d048      	beq.n	408990 <_Z18parse_driverConfigP6SDCardPP7Stepper+0xf8>
                } else if (strcmp(cmd, "FULLSTEP_PER_REVOLUTION") == 0) {
  4088fe:	4966      	ldr	r1, [pc, #408]	; (408a98 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x200>)
  408900:	a801      	add	r0, sp, #4
  408902:	4b64      	ldr	r3, [pc, #400]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  408904:	4798      	blx	r3
  408906:	2800      	cmp	r0, #0
  408908:	d049      	beq.n	40899e <_Z18parse_driverConfigP6SDCardPP7Stepper+0x106>
                } else if (strcmp(cmd, "UNIT_PER_REVOLUTION") == 0) {
  40890a:	4964      	ldr	r1, [pc, #400]	; (408a9c <_Z18parse_driverConfigP6SDCardPP7Stepper+0x204>)
  40890c:	a801      	add	r0, sp, #4
  40890e:	4b61      	ldr	r3, [pc, #388]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  408910:	4798      	blx	r3
  408912:	2800      	cmp	r0, #0
  408914:	d04a      	beq.n	4089ac <_Z18parse_driverConfigP6SDCardPP7Stepper+0x114>
                } else if (strcmp(cmd, "PEAK_CURRENT") == 0) {
  408916:	4962      	ldr	r1, [pc, #392]	; (408aa0 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x208>)
  408918:	a801      	add	r0, sp, #4
  40891a:	4b5e      	ldr	r3, [pc, #376]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  40891c:	4798      	blx	r3
  40891e:	2800      	cmp	r0, #0
  408920:	d04b      	beq.n	4089ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x122>
                } else if (strcmp(cmd, "HOLDING_CURRENT") == 0) {
  408922:	4960      	ldr	r1, [pc, #384]	; (408aa4 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x20c>)
  408924:	a801      	add	r0, sp, #4
  408926:	4b5b      	ldr	r3, [pc, #364]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  408928:	4798      	blx	r3
  40892a:	2800      	cmp	r0, #0
  40892c:	d050      	beq.n	4089d0 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x138>
                } else if (strcmp(cmd, "STOP_ON_STALL_ENABLE") == 0) {
  40892e:	495e      	ldr	r1, [pc, #376]	; (408aa8 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x210>)
  408930:	a801      	add	r0, sp, #4
  408932:	4b58      	ldr	r3, [pc, #352]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  408934:	4798      	blx	r3
  408936:	2800      	cmp	r0, #0
  408938:	d055      	beq.n	4089e6 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x14e>
                } else if (strcmp(cmd, "STOP_ON_STALL_THRESHOLD") == 0) {
  40893a:	495c      	ldr	r1, [pc, #368]	; (408aac <_Z18parse_driverConfigP6SDCardPP7Stepper+0x214>)
  40893c:	a801      	add	r0, sp, #4
  40893e:	4b55      	ldr	r3, [pc, #340]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  408940:	4798      	blx	r3
  408942:	2800      	cmp	r0, #0
  408944:	d056      	beq.n	4089f4 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x15c>
                } else if (strcmp(cmd, "CLOSED_LOOP_ENABLE") == 0) {
  408946:	495a      	ldr	r1, [pc, #360]	; (408ab0 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x218>)
  408948:	a801      	add	r0, sp, #4
  40894a:	4b52      	ldr	r3, [pc, #328]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  40894c:	4798      	blx	r3
  40894e:	2800      	cmp	r0, #0
  408950:	d057      	beq.n	408a02 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x16a>
                } else if (strcmp(cmd, "CLOSED_LOOP_USE_PID") == 0) {
  408952:	4958      	ldr	r1, [pc, #352]	; (408ab4 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x21c>)
  408954:	a801      	add	r0, sp, #4
  408956:	4b4f      	ldr	r3, [pc, #316]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  408958:	4798      	blx	r3
  40895a:	2800      	cmp	r0, #0
  40895c:	d058      	beq.n	408a10 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x178>
                } else if (strcmp(cmd, "ENCODER_PULSE_PER_REVOLUTION") == 0) {
  40895e:	4956      	ldr	r1, [pc, #344]	; (408ab8 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x220>)
  408960:	a801      	add	r0, sp, #4
  408962:	4b4c      	ldr	r3, [pc, #304]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  408964:	4798      	blx	r3
  408966:	2800      	cmp	r0, #0
  408968:	d059      	beq.n	408a1e <_Z18parse_driverConfigP6SDCardPP7Stepper+0x186>
                } else if (strcmp(cmd, "MAX_DELTA_PULSE") == 0) {
  40896a:	4954      	ldr	r1, [pc, #336]	; (408abc <_Z18parse_driverConfigP6SDCardPP7Stepper+0x224>)
  40896c:	a801      	add	r0, sp, #4
  40896e:	4b49      	ldr	r3, [pc, #292]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  408970:	4798      	blx	r3
  408972:	2800      	cmp	r0, #0
  408974:	d05a      	beq.n	408a2c <_Z18parse_driverConfigP6SDCardPP7Stepper+0x194>
                } else if (strcmp(cmd, "STEALTH_CHOP_THRESHOLD") == 0) {
  408976:	4952      	ldr	r1, [pc, #328]	; (408ac0 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x228>)
  408978:	a801      	add	r0, sp, #4
  40897a:	4b46      	ldr	r3, [pc, #280]	; (408a94 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1fc>)
  40897c:	4798      	blx	r3
  40897e:	2800      	cmp	r0, #0
  408980:	d19b      	bne.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setStealthChopThreshold(val);
  408982:	f8bd 1000 	ldrh.w	r1, [sp]
  408986:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  40898a:	4b4e      	ldr	r3, [pc, #312]	; (408ac4 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22c>)
  40898c:	4798      	blx	r3
  40898e:	e794      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setDrv_mstepPerFs(val);
  408990:	f8bd 1000 	ldrh.w	r1, [sp]
  408994:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  408998:	4b4b      	ldr	r3, [pc, #300]	; (408ac8 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x230>)
  40899a:	4798      	blx	r3
  40899c:	e78d      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setDrv_fsPerRev(val);
  40899e:	f8bd 1000 	ldrh.w	r1, [sp]
  4089a2:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  4089a6:	4b49      	ldr	r3, [pc, #292]	; (408acc <_Z18parse_driverConfigP6SDCardPP7Stepper+0x234>)
  4089a8:	4798      	blx	r3
  4089aa:	e786      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->confPositioning_unitPerRev(val);
  4089ac:	f8bd 1000 	ldrh.w	r1, [sp]
  4089b0:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  4089b4:	4b46      	ldr	r3, [pc, #280]	; (408ad0 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x238>)
  4089b6:	4798      	blx	r3
  4089b8:	e77f      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setCurrent_iRun(getCurrentScaler(val));
  4089ba:	f858 4026 	ldr.w	r4, [r8, r6, lsl #2]
  4089be:	f8bd 0000 	ldrh.w	r0, [sp]
  4089c2:	4b44      	ldr	r3, [pc, #272]	; (408ad4 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x23c>)
  4089c4:	4798      	blx	r3
  4089c6:	4601      	mov	r1, r0
  4089c8:	4620      	mov	r0, r4
  4089ca:	4b43      	ldr	r3, [pc, #268]	; (408ad8 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x240>)
  4089cc:	4798      	blx	r3
  4089ce:	e774      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setCurrent_iHold(getCurrentScaler(val));
  4089d0:	f858 4026 	ldr.w	r4, [r8, r6, lsl #2]
  4089d4:	f8bd 0000 	ldrh.w	r0, [sp]
  4089d8:	4b3e      	ldr	r3, [pc, #248]	; (408ad4 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x23c>)
  4089da:	4798      	blx	r3
  4089dc:	4601      	mov	r1, r0
  4089de:	4620      	mov	r0, r4
  4089e0:	4b3e      	ldr	r3, [pc, #248]	; (408adc <_Z18parse_driverConfigP6SDCardPP7Stepper+0x244>)
  4089e2:	4798      	blx	r3
  4089e4:	e769      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setStopOnStall_enable(val);
  4089e6:	f8bd 1000 	ldrh.w	r1, [sp]
  4089ea:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  4089ee:	4b3c      	ldr	r3, [pc, #240]	; (408ae0 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x248>)
  4089f0:	4798      	blx	r3
  4089f2:	e762      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setStopOnStall_thresh(val);
  4089f4:	f8bd 1000 	ldrh.w	r1, [sp]
  4089f8:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  4089fc:	4b39      	ldr	r3, [pc, #228]	; (408ae4 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x24c>)
  4089fe:	4798      	blx	r3
  408a00:	e75b      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setClosedLoop_enable(val);
  408a02:	f8bd 1000 	ldrh.w	r1, [sp]
  408a06:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  408a0a:	4b37      	ldr	r3, [pc, #220]	; (408ae8 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x250>)
  408a0c:	4798      	blx	r3
  408a0e:	e754      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setClosedLoop_usePID(val);
  408a10:	f8bd 1000 	ldrh.w	r1, [sp]
  408a14:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  408a18:	4b34      	ldr	r3, [pc, #208]	; (408aec <_Z18parse_driverConfigP6SDCardPP7Stepper+0x254>)
  408a1a:	4798      	blx	r3
  408a1c:	e74d      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setClosedLoop_encInRes(val);
  408a1e:	f8bd 1000 	ldrh.w	r1, [sp]
  408a22:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  408a26:	4b32      	ldr	r3, [pc, #200]	; (408af0 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x258>)
  408a28:	4798      	blx	r3
  408a2a:	e746      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
                    steppers[i]->setClosedLoop_tolerance(val);
  408a2c:	f8bd 1000 	ldrh.w	r1, [sp]
  408a30:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
  408a34:	4b2f      	ldr	r3, [pc, #188]	; (408af4 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x25c>)
  408a36:	4798      	blx	r3
  408a38:	e73f      	b.n	4088ba <_Z18parse_driverConfigP6SDCardPP7Stepper+0x22>
        free(file_contents);
  408a3a:	9811      	ldr	r0, [sp, #68]	; 0x44
  408a3c:	4b2e      	ldr	r3, [pc, #184]	; (408af8 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x260>)
  408a3e:	4798      	blx	r3
        rslt |= 1 << i;
  408a40:	2301      	movs	r3, #1
  408a42:	40b3      	lsls	r3, r6
  408a44:	431f      	orrs	r7, r3
  408a46:	b2ff      	uxtb	r7, r7
    for (int i = 0; i < MAX_STEPPERS; i++) {
  408a48:	3601      	adds	r6, #1
  408a4a:	2e04      	cmp	r6, #4
  408a4c:	dc0e      	bgt.n	408a6c <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1d4>
        snprintf(filename, sizeof(filename), "config/%d", i);
  408a4e:	4633      	mov	r3, r6
  408a50:	4a2a      	ldr	r2, [pc, #168]	; (408afc <_Z18parse_driverConfigP6SDCardPP7Stepper+0x264>)
  408a52:	2120      	movs	r1, #32
  408a54:	a809      	add	r0, sp, #36	; 0x24
  408a56:	4c2a      	ldr	r4, [pc, #168]	; (408b00 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x268>)
  408a58:	47a0      	blx	r4
        if (!sd_card->readFile(filename, &file_contents)) {
  408a5a:	aa11      	add	r2, sp, #68	; 0x44
  408a5c:	a909      	add	r1, sp, #36	; 0x24
  408a5e:	4648      	mov	r0, r9
  408a60:	4b28      	ldr	r3, [pc, #160]	; (408b04 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x26c>)
  408a62:	4798      	blx	r3
  408a64:	2800      	cmp	r0, #0
  408a66:	d0ef      	beq.n	408a48 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1b0>
        char *ptr = file_contents;
  408a68:	9c11      	ldr	r4, [sp, #68]	; 0x44
  408a6a:	e72a      	b.n	4088c2 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x2a>
  408a6c:	2300      	movs	r3, #0
  408a6e:	e000      	b.n	408a72 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1da>
    for (int j = 0; j < MAX_STEPPERS; j++) {
  408a70:	3301      	adds	r3, #1
  408a72:	2b04      	cmp	r3, #4
  408a74:	ddfc      	ble.n	408a70 <_Z18parse_driverConfigP6SDCardPP7Stepper+0x1d8>
}
  408a76:	4638      	mov	r0, r7
  408a78:	b013      	add	sp, #76	; 0x4c
  408a7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  408a7e:	bf00      	nop
  408a80:	0040e2f0 	.word	0x0040e2f0
  408a84:	0040c66d 	.word	0x0040c66d
  408a88:	0040c74b 	.word	0x0040c74b
  408a8c:	0040c78b 	.word	0x0040c78b
  408a90:	0040e3fc 	.word	0x0040e3fc
  408a94:	0040c767 	.word	0x0040c767
  408a98:	0040e414 	.word	0x0040e414
  408a9c:	0040e42c 	.word	0x0040e42c
  408aa0:	0040e440 	.word	0x0040e440
  408aa4:	0040e450 	.word	0x0040e450
  408aa8:	0040e460 	.word	0x0040e460
  408aac:	0040e478 	.word	0x0040e478
  408ab0:	0040e490 	.word	0x0040e490
  408ab4:	0040e4a4 	.word	0x0040e4a4
  408ab8:	0040e4b8 	.word	0x0040e4b8
  408abc:	0040e4d8 	.word	0x0040e4d8
  408ac0:	0040e4e8 	.word	0x0040e4e8
  408ac4:	004064b3 	.word	0x004064b3
  408ac8:	00406479 	.word	0x00406479
  408acc:	0040647d 	.word	0x0040647d
  408ad0:	0040515f 	.word	0x0040515f
  408ad4:	00408779 	.word	0x00408779
  408ad8:	00406485 	.word	0x00406485
  408adc:	00406481 	.word	0x00406481
  408ae0:	00406489 	.word	0x00406489
  408ae4:	00406493 	.word	0x00406493
  408ae8:	00406497 	.word	0x00406497
  408aec:	004064a1 	.word	0x004064a1
  408af0:	004064ab 	.word	0x004064ab
  408af4:	004064af 	.word	0x004064af
  408af8:	0040c261 	.word	0x0040c261
  408afc:	0040e268 	.word	0x0040e268
  408b00:	0040c605 	.word	0x0040c605
  408b04:	00408101 	.word	0x00408101

00408b08 <_Z20parse_motionSequenceP6SDCardP11MotionQueue>:

/* ---------------------------------------------------------------------------------- */

bool parse_motionSequence(SDCard *sd_card, MotionQueue *motion_queue) {
  408b08:	b570      	push	{r4, r5, r6, lr}
  408b0a:	f5ad 6d86 	sub.w	sp, sp, #1072	; 0x430
  408b0e:	4605      	mov	r5, r0
  408b10:	460e      	mov	r6, r1
    parser_debug("\n=====================================\n");
    parser_debug("|     PARSING MOTION & SEQUENCE     |");
    parser_debug("\n=====================================\n");

    uint8_t num_items = 0;
  408b12:	f50d 6386 	add.w	r3, sp, #1072	; 0x430
  408b16:	2200      	movs	r2, #0
  408b18:	f803 2d01 	strb.w	r2, [r3, #-1]!
    uint8_t index_list[MAX_ITEMS_PER_MOTION];
    char    file_name_list[MAX_ITEMS_PER_MOTION][32];

    // Read _indexMap
    if (!parseIndexMap(sd_card, index_list, file_name_list, &num_items)) { return false; }
  408b1c:	aa03      	add	r2, sp, #12
  408b1e:	f20d 410c 	addw	r1, sp, #1036	; 0x40c
  408b22:	4c0d      	ldr	r4, [pc, #52]	; (408b58 <_Z20parse_motionSequenceP6SDCardP11MotionQueue+0x50>)
  408b24:	47a0      	blx	r4
  408b26:	4603      	mov	r3, r0
  408b28:	b918      	cbnz	r0, 408b32 <_Z20parse_motionSequenceP6SDCardP11MotionQueue+0x2a>

    // Read Sequence
    if (!parseItemsIntoSequence(sd_card, motion_queue)) { return false; }

    return true;
}
  408b2a:	4618      	mov	r0, r3
  408b2c:	f50d 6d86 	add.w	sp, sp, #1072	; 0x430
  408b30:	bd70      	pop	{r4, r5, r6, pc}
    if (!parsePreloadedItems(sd_card, motion_queue, index_list, file_name_list, num_items)) { return false; }
  408b32:	f89d 342f 	ldrb.w	r3, [sp, #1071]	; 0x42f
  408b36:	9300      	str	r3, [sp, #0]
  408b38:	ab03      	add	r3, sp, #12
  408b3a:	f20d 420c 	addw	r2, sp, #1036	; 0x40c
  408b3e:	4631      	mov	r1, r6
  408b40:	4628      	mov	r0, r5
  408b42:	4c06      	ldr	r4, [pc, #24]	; (408b5c <_Z20parse_motionSequenceP6SDCardP11MotionQueue+0x54>)
  408b44:	47a0      	blx	r4
  408b46:	4603      	mov	r3, r0
  408b48:	2800      	cmp	r0, #0
  408b4a:	d0ee      	beq.n	408b2a <_Z20parse_motionSequenceP6SDCardP11MotionQueue+0x22>
    if (!parseItemsIntoSequence(sd_card, motion_queue)) { return false; }
  408b4c:	4631      	mov	r1, r6
  408b4e:	4628      	mov	r0, r5
  408b50:	4b03      	ldr	r3, [pc, #12]	; (408b60 <_Z20parse_motionSequenceP6SDCardP11MotionQueue+0x58>)
  408b52:	4798      	blx	r3
  408b54:	4603      	mov	r3, r0
  408b56:	e7e8      	b.n	408b2a <_Z20parse_motionSequenceP6SDCardP11MotionQueue+0x22>
  408b58:	004087e9 	.word	0x004087e9
  408b5c:	00408289 	.word	0x00408289
  408b60:	00408669 	.word	0x00408669

00408b64 <_Z20parse_motionFileNameP6SDCardhPc>:

bool parse_motionFileName(SDCard *sd_card, const uint8_t motion_index, char *out_file_name) {
  408b64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  408b68:	b09a      	sub	sp, #104	; 0x68
  408b6a:	4607      	mov	r7, r0
  408b6c:	460e      	mov	r6, r1
  408b6e:	4690      	mov	r8, r2
    // Read "_indexMap" file
    const char file_name[64] = "motion/_indexMap";
  408b70:	ac0a      	add	r4, sp, #40	; 0x28
  408b72:	4d25      	ldr	r5, [pc, #148]	; (408c08 <_Z20parse_motionFileNameP6SDCardhPc+0xa4>)
  408b74:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  408b76:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  408b78:	682b      	ldr	r3, [r5, #0]
  408b7a:	7023      	strb	r3, [r4, #0]
  408b7c:	222f      	movs	r2, #47	; 0x2f
  408b7e:	2100      	movs	r1, #0
  408b80:	f10d 0039 	add.w	r0, sp, #57	; 0x39
  408b84:	4b21      	ldr	r3, [pc, #132]	; (408c0c <_Z20parse_motionFileNameP6SDCardhPc+0xa8>)
  408b86:	4798      	blx	r3
    char      *file_contents = NULL;
  408b88:	aa1a      	add	r2, sp, #104	; 0x68
  408b8a:	2300      	movs	r3, #0
  408b8c:	f842 3d44 	str.w	r3, [r2, #-68]!

    bool file_read = sd_card->readFile(file_name, &file_contents);
  408b90:	a90a      	add	r1, sp, #40	; 0x28
  408b92:	4638      	mov	r0, r7
  408b94:	4b1e      	ldr	r3, [pc, #120]	; (408c10 <_Z20parse_motionFileNameP6SDCardhPc+0xac>)
  408b96:	4798      	blx	r3

    if (!file_read) {
  408b98:	4607      	mov	r7, r0
  408b9a:	2800      	cmp	r0, #0
  408b9c:	d02f      	beq.n	408bfe <_Z20parse_motionFileNameP6SDCardhPc+0x9a>
        parser_debug("Failed to read _indexMap file.\n");
        return false;
    }

    parser_debug("\nReading _indexMap file...\n");
    char *ptr         = file_contents;
  408b9e:	9c09      	ldr	r4, [sp, #36]	; 0x24
  408ba0:	e009      	b.n	408bb6 <_Z20parse_motionFileNameP6SDCardhPc+0x52>
        if (len > 0 && ptr[len - 1] == '\r') ptr[len - 1] = '\0';

        int  motion_num;
        char motion_file_name[32];

        if (sscanf(ptr, "%d=%31s", &motion_num, motion_file_name) == 2) {
  408ba2:	ab01      	add	r3, sp, #4
  408ba4:	466a      	mov	r2, sp
  408ba6:	491b      	ldr	r1, [pc, #108]	; (408c14 <_Z20parse_motionFileNameP6SDCardhPc+0xb0>)
  408ba8:	4620      	mov	r0, r4
  408baa:	4c1b      	ldr	r4, [pc, #108]	; (408c18 <_Z20parse_motionFileNameP6SDCardhPc+0xb4>)
  408bac:	47a0      	blx	r4
  408bae:	2802      	cmp	r0, #2
  408bb0:	d017      	beq.n	408be2 <_Z20parse_motionFileNameP6SDCardhPc+0x7e>
                match_found = true;
                break;
            }
        }

        if (!end) break;
  408bb2:	b1f5      	cbz	r5, 408bf2 <_Z20parse_motionFileNameP6SDCardhPc+0x8e>
        ptr = end + 1;
  408bb4:	1c6c      	adds	r4, r5, #1
    while (*ptr) {
  408bb6:	7823      	ldrb	r3, [r4, #0]
  408bb8:	b1eb      	cbz	r3, 408bf6 <_Z20parse_motionFileNameP6SDCardhPc+0x92>
        char *end = strchr(ptr, '\n');
  408bba:	210a      	movs	r1, #10
  408bbc:	4620      	mov	r0, r4
  408bbe:	4b17      	ldr	r3, [pc, #92]	; (408c1c <_Z20parse_motionFileNameP6SDCardhPc+0xb8>)
  408bc0:	4798      	blx	r3
        if (end) *end = '\0';
  408bc2:	4605      	mov	r5, r0
  408bc4:	b108      	cbz	r0, 408bca <_Z20parse_motionFileNameP6SDCardhPc+0x66>
  408bc6:	2300      	movs	r3, #0
  408bc8:	7003      	strb	r3, [r0, #0]
        size_t len = strlen(ptr);
  408bca:	4620      	mov	r0, r4
  408bcc:	4b14      	ldr	r3, [pc, #80]	; (408c20 <_Z20parse_motionFileNameP6SDCardhPc+0xbc>)
  408bce:	4798      	blx	r3
        if (len > 0 && ptr[len - 1] == '\r') ptr[len - 1] = '\0';
  408bd0:	2800      	cmp	r0, #0
  408bd2:	d0e6      	beq.n	408ba2 <_Z20parse_motionFileNameP6SDCardhPc+0x3e>
  408bd4:	1e43      	subs	r3, r0, #1
  408bd6:	5ce2      	ldrb	r2, [r4, r3]
  408bd8:	2a0d      	cmp	r2, #13
  408bda:	d1e2      	bne.n	408ba2 <_Z20parse_motionFileNameP6SDCardhPc+0x3e>
  408bdc:	2200      	movs	r2, #0
  408bde:	54e2      	strb	r2, [r4, r3]
  408be0:	e7df      	b.n	408ba2 <_Z20parse_motionFileNameP6SDCardhPc+0x3e>
            if (motion_num == motion_index) {
  408be2:	9b00      	ldr	r3, [sp, #0]
  408be4:	429e      	cmp	r6, r3
  408be6:	d1e4      	bne.n	408bb2 <_Z20parse_motionFileNameP6SDCardhPc+0x4e>
                strcpy(out_file_name, motion_file_name);
  408be8:	a901      	add	r1, sp, #4
  408bea:	4640      	mov	r0, r8
  408bec:	4b0d      	ldr	r3, [pc, #52]	; (408c24 <_Z20parse_motionFileNameP6SDCardhPc+0xc0>)
  408bee:	4798      	blx	r3
                break;
  408bf0:	e002      	b.n	408bf8 <_Z20parse_motionFileNameP6SDCardhPc+0x94>
    bool  match_found = false;
  408bf2:	2700      	movs	r7, #0
  408bf4:	e000      	b.n	408bf8 <_Z20parse_motionFileNameP6SDCardhPc+0x94>
  408bf6:	2700      	movs	r7, #0
    }

    free(file_contents);
  408bf8:	9809      	ldr	r0, [sp, #36]	; 0x24
  408bfa:	4b0b      	ldr	r3, [pc, #44]	; (408c28 <_Z20parse_motionFileNameP6SDCardhPc+0xc4>)
  408bfc:	4798      	blx	r3

    if (!match_found) parser_debug("No matching filename for %d\n", motion_index);

    return match_found;
  408bfe:	4638      	mov	r0, r7
  408c00:	b01a      	add	sp, #104	; 0x68
  408c02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408c06:	bf00      	nop
  408c08:	0040e3e0 	.word	0x0040e3e0
  408c0c:	0040c287 	.word	0x0040c287
  408c10:	00408101 	.word	0x00408101
  408c14:	0040e3f4 	.word	0x0040e3f4
  408c18:	0040c66d 	.word	0x0040c66d
  408c1c:	0040c74b 	.word	0x0040c74b
  408c20:	0040c78b 	.word	0x0040c78b
  408c24:	0040c77b 	.word	0x0040c77b
  408c28:	0040c261 	.word	0x0040c261

00408c2c <_Z41__static_initialization_and_destruction_0ii>:
            vTaskDelay(25 / portTICK_RATE_MS);
        }

        vTaskDelay(DELAY_MS / portTICK_RATE_MS);
    }
  408c2c:	2801      	cmp	r0, #1
  408c2e:	d000      	beq.n	408c32 <_Z41__static_initialization_and_destruction_0ii+0x6>
  408c30:	4770      	bx	lr
  408c32:	b508      	push	{r3, lr}
  408c34:	f64f 73ff 	movw	r3, #65535	; 0xffff
  408c38:	4299      	cmp	r1, r3
  408c3a:	d000      	beq.n	408c3e <_Z41__static_initialization_and_destruction_0ii+0x12>
  408c3c:	bd08      	pop	{r3, pc}
xQueueHandle PRINT_MUTEX = xSemaphoreCreateMutex();
  408c3e:	4b02      	ldr	r3, [pc, #8]	; (408c48 <_Z41__static_initialization_and_destruction_0ii+0x1c>)
  408c40:	4798      	blx	r3
  408c42:	4b02      	ldr	r3, [pc, #8]	; (408c4c <_Z41__static_initialization_and_destruction_0ii+0x20>)
  408c44:	6018      	str	r0, [r3, #0]
  408c46:	e7f9      	b.n	408c3c <_Z41__static_initialization_and_destruction_0ii+0x10>
  408c48:	00409331 	.word	0x00409331
  408c4c:	20007620 	.word	0x20007620

00408c50 <_GLOBAL__sub_I_PRINT_MUTEX>:
  408c50:	b508      	push	{r3, lr}
  408c52:	f64f 71ff 	movw	r1, #65535	; 0xffff
  408c56:	2001      	movs	r0, #1
  408c58:	4b01      	ldr	r3, [pc, #4]	; (408c60 <_GLOBAL__sub_I_PRINT_MUTEX+0x10>)
  408c5a:	4798      	blx	r3
  408c5c:	bd08      	pop	{r3, pc}
  408c5e:	bf00      	nop
  408c60:	00408c2d 	.word	0x00408c2d

00408c64 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
  408c64:	f100 0308 	add.w	r3, r0, #8
  408c68:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  408c6a:	f04f 32ff 	mov.w	r2, #4294967295
  408c6e:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  408c70:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  408c72:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  408c74:	2300      	movs	r3, #0
  408c76:	6003      	str	r3, [r0, #0]
  408c78:	4770      	bx	lr

00408c7a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  408c7a:	2300      	movs	r3, #0
  408c7c:	6103      	str	r3, [r0, #16]
  408c7e:	4770      	bx	lr

00408c80 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  408c80:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  408c82:	685a      	ldr	r2, [r3, #4]
  408c84:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  408c86:	6842      	ldr	r2, [r0, #4]
  408c88:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  408c8a:	685a      	ldr	r2, [r3, #4]
  408c8c:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  408c8e:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  408c90:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  408c92:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  408c94:	6803      	ldr	r3, [r0, #0]
  408c96:	3301      	adds	r3, #1
  408c98:	6003      	str	r3, [r0, #0]
  408c9a:	4770      	bx	lr

00408c9c <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
  408c9c:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  408c9e:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  408ca0:	f1b4 3fff 	cmp.w	r4, #4294967295
  408ca4:	d016      	beq.n	408cd4 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
  408ca6:	f100 0308 	add.w	r3, r0, #8
  408caa:	68c2      	ldr	r2, [r0, #12]
  408cac:	6812      	ldr	r2, [r2, #0]
  408cae:	4294      	cmp	r4, r2
  408cb0:	d304      	bcc.n	408cbc <vListInsert+0x20>
  408cb2:	685b      	ldr	r3, [r3, #4]
  408cb4:	685a      	ldr	r2, [r3, #4]
  408cb6:	6812      	ldr	r2, [r2, #0]
  408cb8:	4294      	cmp	r4, r2
  408cba:	d2fa      	bcs.n	408cb2 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  408cbc:	685a      	ldr	r2, [r3, #4]
  408cbe:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  408cc0:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
  408cc2:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
  408cc4:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  408cc6:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  408cc8:	6803      	ldr	r3, [r0, #0]
  408cca:	3301      	adds	r3, #1
  408ccc:	6003      	str	r3, [r0, #0]
}
  408cce:	f85d 4b04 	ldr.w	r4, [sp], #4
  408cd2:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
  408cd4:	6903      	ldr	r3, [r0, #16]
  408cd6:	e7f1      	b.n	408cbc <vListInsert+0x20>

00408cd8 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  408cd8:	6843      	ldr	r3, [r0, #4]
  408cda:	6882      	ldr	r2, [r0, #8]
  408cdc:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  408cde:	6883      	ldr	r3, [r0, #8]
  408ce0:	6842      	ldr	r2, [r0, #4]
  408ce2:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  408ce4:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  408ce6:	685a      	ldr	r2, [r3, #4]
  408ce8:	4290      	cmp	r0, r2
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  408cea:	bf04      	itt	eq
  408cec:	6882      	ldreq	r2, [r0, #8]
  408cee:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  408cf0:	2200      	movs	r2, #0
  408cf2:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  408cf4:	681a      	ldr	r2, [r3, #0]
  408cf6:	3a01      	subs	r2, #1
  408cf8:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  408cfa:	6818      	ldr	r0, [r3, #0]
}
  408cfc:	4770      	bx	lr
	...

00408d00 <prvPortStartFirstTask>:

/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile (
  408d00:	4803      	ldr	r0, [pc, #12]	; (408d10 <prvPortStartFirstTask+0x10>)
  408d02:	6800      	ldr	r0, [r0, #0]
  408d04:	6800      	ldr	r0, [r0, #0]
  408d06:	f380 8808 	msr	MSP, r0
  408d0a:	b662      	cpsie	i
  408d0c:	df00      	svc	0
  408d0e:	bf00      	nop
  408d10:	e000ed08 	.word	0xe000ed08

00408d14 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
  408d14:	f8df 000c 	ldr.w	r0, [pc, #12]	; 408d24 <vPortEnableVFP+0x10>
  408d18:	6801      	ldr	r1, [r0, #0]
  408d1a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  408d1e:	6001      	str	r1, [r0, #0]
  408d20:	4770      	bx	lr
  408d22:	0000      	.short	0x0000
  408d24:	e000ed88 	.word	0xe000ed88

00408d28 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;    /* xPSR */
  408d28:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  408d2c:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (portSTACK_TYPE)pxCode;       /* PC */
  408d30:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = 0;    /* LR */
  408d34:	2300      	movs	r3, #0
  408d36:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = (portSTACK_TYPE)pvParameters;       /* R0 */
  408d3a:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
  408d3e:	f06f 0302 	mvn.w	r3, #2
  408d42:	f840 3c24 	str.w	r3, [r0, #-36]
}
  408d46:	3844      	subs	r0, #68	; 0x44
  408d48:	4770      	bx	lr
	...

00408d4c <SVC_Handler>:
	__asm volatile (
  408d4c:	4b05      	ldr	r3, [pc, #20]	; (408d64 <pxCurrentTCBConst2>)
  408d4e:	6819      	ldr	r1, [r3, #0]
  408d50:	6808      	ldr	r0, [r1, #0]
  408d52:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  408d56:	f380 8809 	msr	PSP, r0
  408d5a:	f04f 0000 	mov.w	r0, #0
  408d5e:	f380 8811 	msr	BASEPRI, r0
  408d62:	4770      	bx	lr

00408d64 <pxCurrentTCBConst2>:
  408d64:	20011638 	.word	0x20011638

00408d68 <vPortYieldFromISR>:
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  408d68:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  408d6c:	4b01      	ldr	r3, [pc, #4]	; (408d74 <vPortYieldFromISR+0xc>)
  408d6e:	601a      	str	r2, [r3, #0]
  408d70:	4770      	bx	lr
  408d72:	bf00      	nop
  408d74:	e000ed04 	.word	0xe000ed04

00408d78 <ulPortSetInterruptMask>:
	__asm volatile \
  408d78:	f3ef 8011 	mrs	r0, BASEPRI
  408d7c:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  408d80:	f381 8811 	msr	BASEPRI, r1
  408d84:	4770      	bx	lr
}
  408d86:	2000      	movs	r0, #0

00408d88 <vPortEnterCritical>:
{
  408d88:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
  408d8a:	4b03      	ldr	r3, [pc, #12]	; (408d98 <vPortEnterCritical+0x10>)
  408d8c:	4798      	blx	r3
	uxCriticalNesting++;
  408d8e:	4a03      	ldr	r2, [pc, #12]	; (408d9c <vPortEnterCritical+0x14>)
  408d90:	6813      	ldr	r3, [r2, #0]
  408d92:	3301      	adds	r3, #1
  408d94:	6013      	str	r3, [r2, #0]
  408d96:	bd08      	pop	{r3, pc}
  408d98:	00408d79 	.word	0x00408d79
  408d9c:	2000000c 	.word	0x2000000c

00408da0 <vPortClearInterruptMask>:
	__asm volatile \
  408da0:	f380 8811 	msr	BASEPRI, r0
  408da4:	4770      	bx	lr
	...

00408da8 <vPortExitCritical>:
{
  408da8:	b508      	push	{r3, lr}
	uxCriticalNesting--;
  408daa:	4a05      	ldr	r2, [pc, #20]	; (408dc0 <vPortExitCritical+0x18>)
  408dac:	6813      	ldr	r3, [r2, #0]
  408dae:	3b01      	subs	r3, #1
  408db0:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  408db2:	b103      	cbz	r3, 408db6 <vPortExitCritical+0xe>
  408db4:	bd08      	pop	{r3, pc}
		portENABLE_INTERRUPTS();
  408db6:	2000      	movs	r0, #0
  408db8:	4b02      	ldr	r3, [pc, #8]	; (408dc4 <vPortExitCritical+0x1c>)
  408dba:	4798      	blx	r3
}
  408dbc:	e7fa      	b.n	408db4 <vPortExitCritical+0xc>
  408dbe:	bf00      	nop
  408dc0:	2000000c 	.word	0x2000000c
  408dc4:	00408da1 	.word	0x00408da1

00408dc8 <PendSV_Handler>:
	__asm volatile
  408dc8:	f3ef 8009 	mrs	r0, PSP
  408dcc:	4b11      	ldr	r3, [pc, #68]	; (408e14 <pxCurrentTCBConst>)
  408dce:	681a      	ldr	r2, [r3, #0]
  408dd0:	f01e 0f10 	tst.w	lr, #16
  408dd4:	bf08      	it	eq
  408dd6:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  408dda:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  408dde:	6010      	str	r0, [r2, #0]
  408de0:	e92d 4008 	stmdb	sp!, {r3, lr}
  408de4:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  408de8:	f380 8811 	msr	BASEPRI, r0
  408dec:	f000 ff5c 	bl	409ca8 <vTaskSwitchContext>
  408df0:	f04f 0000 	mov.w	r0, #0
  408df4:	f380 8811 	msr	BASEPRI, r0
  408df8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  408dfc:	6819      	ldr	r1, [r3, #0]
  408dfe:	6808      	ldr	r0, [r1, #0]
  408e00:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  408e04:	f01e 0f10 	tst.w	lr, #16
  408e08:	bf08      	it	eq
  408e0a:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  408e0e:	f380 8809 	msr	PSP, r0
  408e12:	4770      	bx	lr

00408e14 <pxCurrentTCBConst>:
  408e14:	20011638 	.word	0x20011638

00408e18 <SysTick_Handler>:
{
  408e18:	b508      	push	{r3, lr}
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  408e1a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  408e1e:	4b05      	ldr	r3, [pc, #20]	; (408e34 <SysTick_Handler+0x1c>)
  408e20:	601a      	str	r2, [r3, #0]
	(void)portSET_INTERRUPT_MASK_FROM_ISR();
  408e22:	4b05      	ldr	r3, [pc, #20]	; (408e38 <SysTick_Handler+0x20>)
  408e24:	4798      	blx	r3
		vTaskIncrementTick();
  408e26:	4b05      	ldr	r3, [pc, #20]	; (408e3c <SysTick_Handler+0x24>)
  408e28:	4798      	blx	r3
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  408e2a:	2000      	movs	r0, #0
  408e2c:	4b04      	ldr	r3, [pc, #16]	; (408e40 <SysTick_Handler+0x28>)
  408e2e:	4798      	blx	r3
  408e30:	bd08      	pop	{r3, pc}
  408e32:	bf00      	nop
  408e34:	e000ed04 	.word	0xe000ed04
  408e38:	00408d79 	.word	0x00408d79
  408e3c:	004099ad 	.word	0x004099ad
  408e40:	00408da1 	.word	0x00408da1

00408e44 <vPortSetupTimerInterrupt>:
		= (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
  408e44:	4a03      	ldr	r2, [pc, #12]	; (408e54 <vPortSetupTimerInterrupt+0x10>)
  408e46:	4b04      	ldr	r3, [pc, #16]	; (408e58 <vPortSetupTimerInterrupt+0x14>)
  408e48:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT |
  408e4a:	2207      	movs	r2, #7
  408e4c:	3b04      	subs	r3, #4
  408e4e:	601a      	str	r2, [r3, #0]
  408e50:	4770      	bx	lr
  408e52:	bf00      	nop
  408e54:	000176ff 	.word	0x000176ff
  408e58:	e000e014 	.word	0xe000e014

00408e5c <xPortStartScheduler>:
{
  408e5c:	b510      	push	{r4, lr}
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  408e5e:	4b0c      	ldr	r3, [pc, #48]	; (408e90 <xPortStartScheduler+0x34>)
  408e60:	681a      	ldr	r2, [r3, #0]
  408e62:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  408e66:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  408e68:	681a      	ldr	r2, [r3, #0]
  408e6a:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  408e6e:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
  408e70:	4b08      	ldr	r3, [pc, #32]	; (408e94 <xPortStartScheduler+0x38>)
  408e72:	4798      	blx	r3
	uxCriticalNesting = 0;
  408e74:	2400      	movs	r4, #0
  408e76:	4b08      	ldr	r3, [pc, #32]	; (408e98 <xPortStartScheduler+0x3c>)
  408e78:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
  408e7a:	4b08      	ldr	r3, [pc, #32]	; (408e9c <xPortStartScheduler+0x40>)
  408e7c:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
  408e7e:	4a08      	ldr	r2, [pc, #32]	; (408ea0 <xPortStartScheduler+0x44>)
  408e80:	6813      	ldr	r3, [r2, #0]
  408e82:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  408e86:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
  408e88:	4b06      	ldr	r3, [pc, #24]	; (408ea4 <xPortStartScheduler+0x48>)
  408e8a:	4798      	blx	r3
}
  408e8c:	4620      	mov	r0, r4
  408e8e:	bd10      	pop	{r4, pc}
  408e90:	e000ed20 	.word	0xe000ed20
  408e94:	00408e45 	.word	0x00408e45
  408e98:	2000000c 	.word	0x2000000c
  408e9c:	00408d15 	.word	0x00408d15
  408ea0:	e000ef34 	.word	0xe000ef34
  408ea4:	00408d01 	.word	0x00408d01

00408ea8 <prvInsertBlockIntoFreeList>:
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  408ea8:	b410      	push	{r4}
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  408eaa:	4a13      	ldr	r2, [pc, #76]	; (408ef8 <prvInsertBlockIntoFreeList+0x50>)
  408eac:	e000      	b.n	408eb0 <prvInsertBlockIntoFreeList+0x8>
  408eae:	461a      	mov	r2, r3
  408eb0:	6813      	ldr	r3, [r2, #0]
  408eb2:	4283      	cmp	r3, r0
  408eb4:	d3fb      	bcc.n	408eae <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  408eb6:	6851      	ldr	r1, [r2, #4]
  408eb8:	1854      	adds	r4, r2, r1
  408eba:	42a0      	cmp	r0, r4
  408ebc:	d00a      	beq.n	408ed4 <prvInsertBlockIntoFreeList+0x2c>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  408ebe:	6841      	ldr	r1, [r0, #4]
  408ec0:	1844      	adds	r4, r0, r1
  408ec2:	42a3      	cmp	r3, r4
  408ec4:	d00b      	beq.n	408ede <prvInsertBlockIntoFreeList+0x36>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  408ec6:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  408ec8:	4290      	cmp	r0, r2
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  408eca:	bf18      	it	ne
  408ecc:	6010      	strne	r0, [r2, #0]
	}
}
  408ece:	f85d 4b04 	ldr.w	r4, [sp], #4
  408ed2:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  408ed4:	6840      	ldr	r0, [r0, #4]
  408ed6:	4401      	add	r1, r0
  408ed8:	6051      	str	r1, [r2, #4]
  408eda:	4610      	mov	r0, r2
  408edc:	e7ef      	b.n	408ebe <prvInsertBlockIntoFreeList+0x16>
		if( pxIterator->pxNextFreeBlock != pxEnd )
  408ede:	4c07      	ldr	r4, [pc, #28]	; (408efc <prvInsertBlockIntoFreeList+0x54>)
  408ee0:	6824      	ldr	r4, [r4, #0]
  408ee2:	42a3      	cmp	r3, r4
  408ee4:	d006      	beq.n	408ef4 <prvInsertBlockIntoFreeList+0x4c>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  408ee6:	685b      	ldr	r3, [r3, #4]
  408ee8:	4419      	add	r1, r3
  408eea:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  408eec:	6813      	ldr	r3, [r2, #0]
  408eee:	681b      	ldr	r3, [r3, #0]
  408ef0:	6003      	str	r3, [r0, #0]
  408ef2:	e7e9      	b.n	408ec8 <prvInsertBlockIntoFreeList+0x20>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  408ef4:	6003      	str	r3, [r0, #0]
  408ef6:	e7e7      	b.n	408ec8 <prvInsertBlockIntoFreeList+0x20>
  408ef8:	20011630 	.word	0x20011630
  408efc:	2000762c 	.word	0x2000762c

00408f00 <pvPortMalloc>:
{
  408f00:	b538      	push	{r3, r4, r5, lr}
  408f02:	4604      	mov	r4, r0
	vTaskSuspendAll();
  408f04:	4b2c      	ldr	r3, [pc, #176]	; (408fb8 <pvPortMalloc+0xb8>)
  408f06:	4798      	blx	r3
		if( pxEnd == NULL )
  408f08:	4b2c      	ldr	r3, [pc, #176]	; (408fbc <pvPortMalloc+0xbc>)
  408f0a:	681b      	ldr	r3, [r3, #0]
  408f0c:	b18b      	cbz	r3, 408f32 <pvPortMalloc+0x32>
		if( xWantedSize > 0 )
  408f0e:	2c00      	cmp	r4, #0
  408f10:	d04b      	beq.n	408faa <pvPortMalloc+0xaa>
			xWantedSize += heapSTRUCT_SIZE;
  408f12:	f104 0210 	add.w	r2, r4, #16
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  408f16:	f012 0f07 	tst.w	r2, #7
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  408f1a:	bf1c      	itt	ne
  408f1c:	f022 0207 	bicne.w	r2, r2, #7
  408f20:	3208      	addne	r2, #8
		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
  408f22:	1e51      	subs	r1, r2, #1
  408f24:	f649 73fe 	movw	r3, #40958	; 0x9ffe
  408f28:	4299      	cmp	r1, r3
  408f2a:	d83b      	bhi.n	408fa4 <pvPortMalloc+0xa4>
			pxBlock = xStart.pxNextFreeBlock;
  408f2c:	4924      	ldr	r1, [pc, #144]	; (408fc0 <pvPortMalloc+0xc0>)
  408f2e:	680c      	ldr	r4, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  408f30:	e016      	b.n	408f60 <pvPortMalloc+0x60>
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
  408f32:	4a23      	ldr	r2, [pc, #140]	; (408fc0 <pvPortMalloc+0xc0>)
  408f34:	4b23      	ldr	r3, [pc, #140]	; (408fc4 <pvPortMalloc+0xc4>)
  408f36:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
  408f38:	2100      	movs	r1, #0
  408f3a:	6051      	str	r1, [r2, #4]
	pxEnd = ( void * ) pucHeapEnd;
  408f3c:	f649 72f0 	movw	r2, #40944	; 0x9ff0
  408f40:	1898      	adds	r0, r3, r2
  408f42:	4d1e      	ldr	r5, [pc, #120]	; (408fbc <pvPortMalloc+0xbc>)
  408f44:	6028      	str	r0, [r5, #0]
	pxEnd->xBlockSize = 0;
  408f46:	f649 75f4 	movw	r5, #40948	; 0x9ff4
  408f4a:	5159      	str	r1, [r3, r5]
	pxEnd->pxNextFreeBlock = NULL;
  408f4c:	5099      	str	r1, [r3, r2]
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  408f4e:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  408f50:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  408f52:	4a1d      	ldr	r2, [pc, #116]	; (408fc8 <pvPortMalloc+0xc8>)
  408f54:	6813      	ldr	r3, [r2, #0]
  408f56:	3b10      	subs	r3, #16
  408f58:	6013      	str	r3, [r2, #0]
  408f5a:	e7d8      	b.n	408f0e <pvPortMalloc+0xe>
  408f5c:	4621      	mov	r1, r4
				pxBlock = pxBlock->pxNextFreeBlock;
  408f5e:	461c      	mov	r4, r3
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  408f60:	6863      	ldr	r3, [r4, #4]
  408f62:	429a      	cmp	r2, r3
  408f64:	d902      	bls.n	408f6c <pvPortMalloc+0x6c>
  408f66:	6823      	ldr	r3, [r4, #0]
  408f68:	2b00      	cmp	r3, #0
  408f6a:	d1f7      	bne.n	408f5c <pvPortMalloc+0x5c>
			if( pxBlock != pxEnd )
  408f6c:	4b13      	ldr	r3, [pc, #76]	; (408fbc <pvPortMalloc+0xbc>)
  408f6e:	681b      	ldr	r3, [r3, #0]
  408f70:	429c      	cmp	r4, r3
  408f72:	d017      	beq.n	408fa4 <pvPortMalloc+0xa4>
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  408f74:	680d      	ldr	r5, [r1, #0]
  408f76:	3510      	adds	r5, #16
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  408f78:	6823      	ldr	r3, [r4, #0]
  408f7a:	600b      	str	r3, [r1, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  408f7c:	6863      	ldr	r3, [r4, #4]
  408f7e:	1a9b      	subs	r3, r3, r2
  408f80:	2b20      	cmp	r3, #32
  408f82:	d809      	bhi.n	408f98 <pvPortMalloc+0x98>
				xFreeBytesRemaining -= pxBlock->xBlockSize;
  408f84:	4a10      	ldr	r2, [pc, #64]	; (408fc8 <pvPortMalloc+0xc8>)
  408f86:	6813      	ldr	r3, [r2, #0]
  408f88:	6861      	ldr	r1, [r4, #4]
  408f8a:	1a5b      	subs	r3, r3, r1
  408f8c:	6013      	str	r3, [r2, #0]
	xTaskResumeAll();
  408f8e:	4b0f      	ldr	r3, [pc, #60]	; (408fcc <pvPortMalloc+0xcc>)
  408f90:	4798      	blx	r3
		if( pvReturn == NULL )
  408f92:	b165      	cbz	r5, 408fae <pvPortMalloc+0xae>
}
  408f94:	4628      	mov	r0, r5
  408f96:	bd38      	pop	{r3, r4, r5, pc}
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  408f98:	18a0      	adds	r0, r4, r2
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  408f9a:	6043      	str	r3, [r0, #4]
					pxBlock->xBlockSize = xWantedSize;
  408f9c:	6062      	str	r2, [r4, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  408f9e:	4b0c      	ldr	r3, [pc, #48]	; (408fd0 <pvPortMalloc+0xd0>)
  408fa0:	4798      	blx	r3
  408fa2:	e7ef      	b.n	408f84 <pvPortMalloc+0x84>
	xTaskResumeAll();
  408fa4:	4b09      	ldr	r3, [pc, #36]	; (408fcc <pvPortMalloc+0xcc>)
  408fa6:	4798      	blx	r3
  408fa8:	e001      	b.n	408fae <pvPortMalloc+0xae>
  408faa:	4b08      	ldr	r3, [pc, #32]	; (408fcc <pvPortMalloc+0xcc>)
  408fac:	4798      	blx	r3
			vApplicationMallocFailedHook();
  408fae:	4b09      	ldr	r3, [pc, #36]	; (408fd4 <pvPortMalloc+0xd4>)
  408fb0:	4798      	blx	r3
  408fb2:	2500      	movs	r5, #0
	return pvReturn;
  408fb4:	e7ee      	b.n	408f94 <pvPortMalloc+0x94>
  408fb6:	bf00      	nop
  408fb8:	0040997d 	.word	0x0040997d
  408fbc:	2000762c 	.word	0x2000762c
  408fc0:	20011630 	.word	0x20011630
  408fc4:	20007630 	.word	0x20007630
  408fc8:	20000010 	.word	0x20000010
  408fcc:	00409ad5 	.word	0x00409ad5
  408fd0:	00408ea9 	.word	0x00408ea9
  408fd4:	00400539 	.word	0x00400539

00408fd8 <vPortFree>:
	if( pv != NULL )
  408fd8:	b180      	cbz	r0, 408ffc <vPortFree+0x24>
{
  408fda:	b510      	push	{r4, lr}
  408fdc:	4604      	mov	r4, r0
		vTaskSuspendAll();
  408fde:	4b08      	ldr	r3, [pc, #32]	; (409000 <vPortFree+0x28>)
  408fe0:	4798      	blx	r3
			xFreeBytesRemaining += pxLink->xBlockSize;
  408fe2:	4a08      	ldr	r2, [pc, #32]	; (409004 <vPortFree+0x2c>)
  408fe4:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  408fe8:	6811      	ldr	r1, [r2, #0]
  408fea:	440b      	add	r3, r1
  408fec:	6013      	str	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
  408fee:	f1a4 0010 	sub.w	r0, r4, #16
  408ff2:	4b05      	ldr	r3, [pc, #20]	; (409008 <vPortFree+0x30>)
  408ff4:	4798      	blx	r3
		xTaskResumeAll();
  408ff6:	4b05      	ldr	r3, [pc, #20]	; (40900c <vPortFree+0x34>)
  408ff8:	4798      	blx	r3
  408ffa:	bd10      	pop	{r4, pc}
  408ffc:	4770      	bx	lr
  408ffe:	bf00      	nop
  409000:	0040997d 	.word	0x0040997d
  409004:	20000010 	.word	0x20000010
  409008:	00408ea9 	.word	0x00408ea9
  40900c:	00409ad5 	.word	0x00409ad5

00409010 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  409010:	b510      	push	{r4, lr}
  409012:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  409014:	6c03      	ldr	r3, [r0, #64]	; 0x40
  409016:	b95b      	cbnz	r3, 409030 <prvCopyDataToQueue+0x20>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  409018:	6803      	ldr	r3, [r0, #0]
  40901a:	b11b      	cbz	r3, 409024 <prvCopyDataToQueue+0x14>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  40901c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  40901e:	3301      	adds	r3, #1
  409020:	63a3      	str	r3, [r4, #56]	; 0x38
  409022:	bd10      	pop	{r4, pc}
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  409024:	6840      	ldr	r0, [r0, #4]
  409026:	4b12      	ldr	r3, [pc, #72]	; (409070 <prvCopyDataToQueue+0x60>)
  409028:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  40902a:	2300      	movs	r3, #0
  40902c:	6063      	str	r3, [r4, #4]
  40902e:	e7f5      	b.n	40901c <prvCopyDataToQueue+0xc>
	else if( xPosition == queueSEND_TO_BACK )
  409030:	b96a      	cbnz	r2, 40904e <prvCopyDataToQueue+0x3e>
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  409032:	461a      	mov	r2, r3
  409034:	6880      	ldr	r0, [r0, #8]
  409036:	4b0f      	ldr	r3, [pc, #60]	; (409074 <prvCopyDataToQueue+0x64>)
  409038:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  40903a:	68a3      	ldr	r3, [r4, #8]
  40903c:	6c22      	ldr	r2, [r4, #64]	; 0x40
  40903e:	4413      	add	r3, r2
  409040:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  409042:	6862      	ldr	r2, [r4, #4]
  409044:	4293      	cmp	r3, r2
  409046:	d3e9      	bcc.n	40901c <prvCopyDataToQueue+0xc>
			pxQueue->pcWriteTo = pxQueue->pcHead;
  409048:	6823      	ldr	r3, [r4, #0]
  40904a:	60a3      	str	r3, [r4, #8]
  40904c:	e7e6      	b.n	40901c <prvCopyDataToQueue+0xc>
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  40904e:	461a      	mov	r2, r3
  409050:	68c0      	ldr	r0, [r0, #12]
  409052:	4b08      	ldr	r3, [pc, #32]	; (409074 <prvCopyDataToQueue+0x64>)
  409054:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  409056:	6c22      	ldr	r2, [r4, #64]	; 0x40
  409058:	4252      	negs	r2, r2
  40905a:	68e3      	ldr	r3, [r4, #12]
  40905c:	4413      	add	r3, r2
  40905e:	60e3      	str	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  409060:	6821      	ldr	r1, [r4, #0]
  409062:	428b      	cmp	r3, r1
  409064:	d2da      	bcs.n	40901c <prvCopyDataToQueue+0xc>
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  409066:	6863      	ldr	r3, [r4, #4]
  409068:	441a      	add	r2, r3
  40906a:	60e2      	str	r2, [r4, #12]
  40906c:	e7d6      	b.n	40901c <prvCopyDataToQueue+0xc>
  40906e:	bf00      	nop
  409070:	0040a099 	.word	0x0040a099
  409074:	0040c271 	.word	0x0040c271

00409078 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
  409078:	b538      	push	{r3, r4, r5, lr}
  40907a:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  40907c:	6800      	ldr	r0, [r0, #0]
  40907e:	b158      	cbz	r0, 409098 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  409080:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  409082:	68dc      	ldr	r4, [r3, #12]
  409084:	4414      	add	r4, r2
  409086:	60dc      	str	r4, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  409088:	685d      	ldr	r5, [r3, #4]
  40908a:	42ac      	cmp	r4, r5
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
  40908c:	bf28      	it	cs
  40908e:	60d8      	strcs	r0, [r3, #12]
  409090:	4608      	mov	r0, r1
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
  409092:	68d9      	ldr	r1, [r3, #12]
  409094:	4b01      	ldr	r3, [pc, #4]	; (40909c <prvCopyDataFromQueue+0x24>)
  409096:	4798      	blx	r3
  409098:	bd38      	pop	{r3, r4, r5, pc}
  40909a:	bf00      	nop
  40909c:	0040c271 	.word	0x0040c271

004090a0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
  4090a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4090a2:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  4090a4:	4b1f      	ldr	r3, [pc, #124]	; (409124 <prvUnlockQueue+0x84>)
  4090a6:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  4090a8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4090aa:	2b00      	cmp	r3, #0
  4090ac:	dd14      	ble.n	4090d8 <prvUnlockQueue+0x38>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4090ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4090b0:	b193      	cbz	r3, 4090d8 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4090b2:	f104 0624 	add.w	r6, r4, #36	; 0x24
  4090b6:	4d1c      	ldr	r5, [pc, #112]	; (409128 <prvUnlockQueue+0x88>)
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  4090b8:	4f1c      	ldr	r7, [pc, #112]	; (40912c <prvUnlockQueue+0x8c>)
  4090ba:	e007      	b.n	4090cc <prvUnlockQueue+0x2c>
				}

				--( pxQueue->xTxLock );
  4090bc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4090be:	3b01      	subs	r3, #1
  4090c0:	64a3      	str	r3, [r4, #72]	; 0x48
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  4090c2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4090c4:	2b00      	cmp	r3, #0
  4090c6:	dd07      	ble.n	4090d8 <prvUnlockQueue+0x38>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4090c8:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4090ca:	b12b      	cbz	r3, 4090d8 <prvUnlockQueue+0x38>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4090cc:	4630      	mov	r0, r6
  4090ce:	47a8      	blx	r5
  4090d0:	2800      	cmp	r0, #0
  4090d2:	d0f3      	beq.n	4090bc <prvUnlockQueue+0x1c>
					vTaskMissedYield();
  4090d4:	47b8      	blx	r7
  4090d6:	e7f1      	b.n	4090bc <prvUnlockQueue+0x1c>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
  4090d8:	f04f 33ff 	mov.w	r3, #4294967295
  4090dc:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  4090de:	4b14      	ldr	r3, [pc, #80]	; (409130 <prvUnlockQueue+0x90>)
  4090e0:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  4090e2:	4b10      	ldr	r3, [pc, #64]	; (409124 <prvUnlockQueue+0x84>)
  4090e4:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4090e6:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4090e8:	2b00      	cmp	r3, #0
  4090ea:	dd14      	ble.n	409116 <prvUnlockQueue+0x76>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4090ec:	6923      	ldr	r3, [r4, #16]
  4090ee:	b193      	cbz	r3, 409116 <prvUnlockQueue+0x76>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4090f0:	f104 0610 	add.w	r6, r4, #16
  4090f4:	4d0c      	ldr	r5, [pc, #48]	; (409128 <prvUnlockQueue+0x88>)
				{
					vTaskMissedYield();
  4090f6:	4f0d      	ldr	r7, [pc, #52]	; (40912c <prvUnlockQueue+0x8c>)
  4090f8:	e007      	b.n	40910a <prvUnlockQueue+0x6a>
				}

				--( pxQueue->xRxLock );
  4090fa:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4090fc:	3b01      	subs	r3, #1
  4090fe:	6463      	str	r3, [r4, #68]	; 0x44
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  409100:	6c63      	ldr	r3, [r4, #68]	; 0x44
  409102:	2b00      	cmp	r3, #0
  409104:	dd07      	ble.n	409116 <prvUnlockQueue+0x76>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  409106:	6923      	ldr	r3, [r4, #16]
  409108:	b12b      	cbz	r3, 409116 <prvUnlockQueue+0x76>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  40910a:	4630      	mov	r0, r6
  40910c:	47a8      	blx	r5
  40910e:	2800      	cmp	r0, #0
  409110:	d0f3      	beq.n	4090fa <prvUnlockQueue+0x5a>
					vTaskMissedYield();
  409112:	47b8      	blx	r7
  409114:	e7f1      	b.n	4090fa <prvUnlockQueue+0x5a>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  409116:	f04f 33ff 	mov.w	r3, #4294967295
  40911a:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  40911c:	4b04      	ldr	r3, [pc, #16]	; (409130 <prvUnlockQueue+0x90>)
  40911e:	4798      	blx	r3
  409120:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  409122:	bf00      	nop
  409124:	00408d89 	.word	0x00408d89
  409128:	00409eb1 	.word	0x00409eb1
  40912c:	00409fe1 	.word	0x00409fe1
  409130:	00408da9 	.word	0x00408da9

00409134 <xQueueGenericReset>:
{
  409134:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
  409136:	b308      	cbz	r0, 40917c <xQueueGenericReset+0x48>
  409138:	460d      	mov	r5, r1
  40913a:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
  40913c:	4b17      	ldr	r3, [pc, #92]	; (40919c <xQueueGenericReset+0x68>)
  40913e:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  409140:	6822      	ldr	r2, [r4, #0]
  409142:	6c21      	ldr	r1, [r4, #64]	; 0x40
  409144:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  409146:	fb03 f301 	mul.w	r3, r3, r1
  40914a:	18d0      	adds	r0, r2, r3
  40914c:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  40914e:	2000      	movs	r0, #0
  409150:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  409152:	60a2      	str	r2, [r4, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  409154:	1a5b      	subs	r3, r3, r1
  409156:	4413      	add	r3, r2
  409158:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  40915a:	f04f 33ff 	mov.w	r3, #4294967295
  40915e:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  409160:	64a3      	str	r3, [r4, #72]	; 0x48
		if( xNewQueue == pdFALSE )
  409162:	b995      	cbnz	r5, 40918a <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  409164:	6923      	ldr	r3, [r4, #16]
  409166:	b12b      	cbz	r3, 409174 <xQueueGenericReset+0x40>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  409168:	f104 0010 	add.w	r0, r4, #16
  40916c:	4b0c      	ldr	r3, [pc, #48]	; (4091a0 <xQueueGenericReset+0x6c>)
  40916e:	4798      	blx	r3
  409170:	2801      	cmp	r0, #1
  409172:	d007      	beq.n	409184 <xQueueGenericReset+0x50>
	taskEXIT_CRITICAL();
  409174:	4b0b      	ldr	r3, [pc, #44]	; (4091a4 <xQueueGenericReset+0x70>)
  409176:	4798      	blx	r3
}
  409178:	2001      	movs	r0, #1
  40917a:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxQueue );
  40917c:	4b0a      	ldr	r3, [pc, #40]	; (4091a8 <xQueueGenericReset+0x74>)
  40917e:	4798      	blx	r3
  409180:	bf00      	nop
  409182:	e7fd      	b.n	409180 <xQueueGenericReset+0x4c>
					portYIELD_WITHIN_API();
  409184:	4b09      	ldr	r3, [pc, #36]	; (4091ac <xQueueGenericReset+0x78>)
  409186:	4798      	blx	r3
  409188:	e7f4      	b.n	409174 <xQueueGenericReset+0x40>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  40918a:	f104 0010 	add.w	r0, r4, #16
  40918e:	4d08      	ldr	r5, [pc, #32]	; (4091b0 <xQueueGenericReset+0x7c>)
  409190:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  409192:	f104 0024 	add.w	r0, r4, #36	; 0x24
  409196:	47a8      	blx	r5
  409198:	e7ec      	b.n	409174 <xQueueGenericReset+0x40>
  40919a:	bf00      	nop
  40919c:	00408d89 	.word	0x00408d89
  4091a0:	00409eb1 	.word	0x00409eb1
  4091a4:	00408da9 	.word	0x00408da9
  4091a8:	00408d79 	.word	0x00408d79
  4091ac:	00408d69 	.word	0x00408d69
  4091b0:	00408c65 	.word	0x00408c65

004091b4 <xQueueGenericCreate>:
{
  4091b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  4091b6:	b1d8      	cbz	r0, 4091f0 <xQueueGenericCreate+0x3c>
  4091b8:	460d      	mov	r5, r1
  4091ba:	4617      	mov	r7, r2
  4091bc:	4606      	mov	r6, r0
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  4091be:	2050      	movs	r0, #80	; 0x50
  4091c0:	4b0d      	ldr	r3, [pc, #52]	; (4091f8 <xQueueGenericCreate+0x44>)
  4091c2:	4798      	blx	r3
		if( pxNewQueue != NULL )
  4091c4:	4604      	mov	r4, r0
  4091c6:	b198      	cbz	r0, 4091f0 <xQueueGenericCreate+0x3c>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  4091c8:	fb05 f006 	mul.w	r0, r5, r6
			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  4091cc:	3001      	adds	r0, #1
  4091ce:	4b0a      	ldr	r3, [pc, #40]	; (4091f8 <xQueueGenericCreate+0x44>)
  4091d0:	4798      	blx	r3
  4091d2:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
  4091d4:	b148      	cbz	r0, 4091ea <xQueueGenericCreate+0x36>
				pxNewQueue->uxLength = uxQueueLength;
  4091d6:	63e6      	str	r6, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  4091d8:	6425      	str	r5, [r4, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
  4091da:	2101      	movs	r1, #1
  4091dc:	4620      	mov	r0, r4
  4091de:	4b07      	ldr	r3, [pc, #28]	; (4091fc <xQueueGenericCreate+0x48>)
  4091e0:	4798      	blx	r3
					pxNewQueue->ucQueueType = ucQueueType;
  4091e2:	f884 704d 	strb.w	r7, [r4, #77]	; 0x4d
}
  4091e6:	4620      	mov	r0, r4
  4091e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vPortFree( pxNewQueue );
  4091ea:	4620      	mov	r0, r4
  4091ec:	4b04      	ldr	r3, [pc, #16]	; (409200 <xQueueGenericCreate+0x4c>)
  4091ee:	4798      	blx	r3
	configASSERT( xReturn );
  4091f0:	4b04      	ldr	r3, [pc, #16]	; (409204 <xQueueGenericCreate+0x50>)
  4091f2:	4798      	blx	r3
  4091f4:	bf00      	nop
  4091f6:	e7fd      	b.n	4091f4 <xQueueGenericCreate+0x40>
  4091f8:	00408f01 	.word	0x00408f01
  4091fc:	00409135 	.word	0x00409135
  409200:	00408fd9 	.word	0x00408fd9
  409204:	00408d79 	.word	0x00408d79

00409208 <xQueueGenericSend>:
{
  409208:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40920c:	b085      	sub	sp, #20
  40920e:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
  409210:	b148      	cbz	r0, 409226 <xQueueGenericSend+0x1e>
  409212:	4688      	mov	r8, r1
  409214:	4699      	mov	r9, r3
  409216:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  409218:	b149      	cbz	r1, 40922e <xQueueGenericSend+0x26>
  40921a:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
  40921c:	4e38      	ldr	r6, [pc, #224]	; (409300 <xQueueGenericSend+0xf8>)
					vTaskSetTimeOutState( &xTimeOut );
  40921e:	f8df a10c 	ldr.w	sl, [pc, #268]	; 40932c <xQueueGenericSend+0x124>
		taskEXIT_CRITICAL();
  409222:	4d38      	ldr	r5, [pc, #224]	; (409304 <xQueueGenericSend+0xfc>)
  409224:	e02e      	b.n	409284 <xQueueGenericSend+0x7c>
	configASSERT( pxQueue );
  409226:	4b38      	ldr	r3, [pc, #224]	; (409308 <xQueueGenericSend+0x100>)
  409228:	4798      	blx	r3
  40922a:	bf00      	nop
  40922c:	e7fd      	b.n	40922a <xQueueGenericSend+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  40922e:	6c03      	ldr	r3, [r0, #64]	; 0x40
  409230:	b11b      	cbz	r3, 40923a <xQueueGenericSend+0x32>
  409232:	4b35      	ldr	r3, [pc, #212]	; (409308 <xQueueGenericSend+0x100>)
  409234:	4798      	blx	r3
  409236:	bf00      	nop
  409238:	e7fd      	b.n	409236 <xQueueGenericSend+0x2e>
  40923a:	2700      	movs	r7, #0
  40923c:	e7ee      	b.n	40921c <xQueueGenericSend+0x14>
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  40923e:	464a      	mov	r2, r9
  409240:	4641      	mov	r1, r8
  409242:	4620      	mov	r0, r4
  409244:	4b31      	ldr	r3, [pc, #196]	; (40930c <xQueueGenericSend+0x104>)
  409246:	4798      	blx	r3
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  409248:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40924a:	b92b      	cbnz	r3, 409258 <xQueueGenericSend+0x50>
				taskEXIT_CRITICAL();
  40924c:	4b2d      	ldr	r3, [pc, #180]	; (409304 <xQueueGenericSend+0xfc>)
  40924e:	4798      	blx	r3
				return pdPASS;
  409250:	2001      	movs	r0, #1
}
  409252:	b005      	add	sp, #20
  409254:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  409258:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40925c:	4b2c      	ldr	r3, [pc, #176]	; (409310 <xQueueGenericSend+0x108>)
  40925e:	4798      	blx	r3
  409260:	2801      	cmp	r0, #1
  409262:	d1f3      	bne.n	40924c <xQueueGenericSend+0x44>
						portYIELD_WITHIN_API();
  409264:	4b2b      	ldr	r3, [pc, #172]	; (409314 <xQueueGenericSend+0x10c>)
  409266:	4798      	blx	r3
  409268:	e7f0      	b.n	40924c <xQueueGenericSend+0x44>
					taskEXIT_CRITICAL();
  40926a:	4b26      	ldr	r3, [pc, #152]	; (409304 <xQueueGenericSend+0xfc>)
  40926c:	4798      	blx	r3
					return errQUEUE_FULL;
  40926e:	2000      	movs	r0, #0
  409270:	e7ef      	b.n	409252 <xQueueGenericSend+0x4a>
					vTaskSetTimeOutState( &xTimeOut );
  409272:	a802      	add	r0, sp, #8
  409274:	47d0      	blx	sl
  409276:	e00f      	b.n	409298 <xQueueGenericSend+0x90>
				prvUnlockQueue( pxQueue );
  409278:	4620      	mov	r0, r4
  40927a:	4b27      	ldr	r3, [pc, #156]	; (409318 <xQueueGenericSend+0x110>)
  40927c:	4798      	blx	r3
				( void ) xTaskResumeAll();
  40927e:	4b27      	ldr	r3, [pc, #156]	; (40931c <xQueueGenericSend+0x114>)
  409280:	4798      	blx	r3
  409282:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
  409284:	47b0      	blx	r6
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  409286:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  409288:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40928a:	429a      	cmp	r2, r3
  40928c:	d3d7      	bcc.n	40923e <xQueueGenericSend+0x36>
				if( xTicksToWait == ( portTickType ) 0 )
  40928e:	9b01      	ldr	r3, [sp, #4]
  409290:	2b00      	cmp	r3, #0
  409292:	d0ea      	beq.n	40926a <xQueueGenericSend+0x62>
				else if( xEntryTimeSet == pdFALSE )
  409294:	2f00      	cmp	r7, #0
  409296:	d0ec      	beq.n	409272 <xQueueGenericSend+0x6a>
		taskEXIT_CRITICAL();
  409298:	47a8      	blx	r5
		vTaskSuspendAll();
  40929a:	4b21      	ldr	r3, [pc, #132]	; (409320 <xQueueGenericSend+0x118>)
  40929c:	4798      	blx	r3
		prvLockQueue( pxQueue );
  40929e:	47b0      	blx	r6
  4092a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4092a2:	f1b3 3fff 	cmp.w	r3, #4294967295
  4092a6:	bf04      	itt	eq
  4092a8:	2300      	moveq	r3, #0
  4092aa:	6463      	streq	r3, [r4, #68]	; 0x44
  4092ac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4092ae:	f1b3 3fff 	cmp.w	r3, #4294967295
  4092b2:	bf04      	itt	eq
  4092b4:	2300      	moveq	r3, #0
  4092b6:	64a3      	streq	r3, [r4, #72]	; 0x48
  4092b8:	47a8      	blx	r5
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  4092ba:	a901      	add	r1, sp, #4
  4092bc:	a802      	add	r0, sp, #8
  4092be:	4b19      	ldr	r3, [pc, #100]	; (409324 <xQueueGenericSend+0x11c>)
  4092c0:	4798      	blx	r3
  4092c2:	b9a8      	cbnz	r0, 4092f0 <xQueueGenericSend+0xe8>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  4092c4:	47b0      	blx	r6
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  4092c6:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
  4092ca:	6be7      	ldr	r7, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  4092cc:	47a8      	blx	r5
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  4092ce:	45bb      	cmp	fp, r7
  4092d0:	d1d2      	bne.n	409278 <xQueueGenericSend+0x70>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  4092d2:	9901      	ldr	r1, [sp, #4]
  4092d4:	f104 0010 	add.w	r0, r4, #16
  4092d8:	4b13      	ldr	r3, [pc, #76]	; (409328 <xQueueGenericSend+0x120>)
  4092da:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  4092dc:	4620      	mov	r0, r4
  4092de:	4b0e      	ldr	r3, [pc, #56]	; (409318 <xQueueGenericSend+0x110>)
  4092e0:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  4092e2:	4b0e      	ldr	r3, [pc, #56]	; (40931c <xQueueGenericSend+0x114>)
  4092e4:	4798      	blx	r3
  4092e6:	2800      	cmp	r0, #0
  4092e8:	d1cb      	bne.n	409282 <xQueueGenericSend+0x7a>
					portYIELD_WITHIN_API();
  4092ea:	4b0a      	ldr	r3, [pc, #40]	; (409314 <xQueueGenericSend+0x10c>)
  4092ec:	4798      	blx	r3
  4092ee:	e7c8      	b.n	409282 <xQueueGenericSend+0x7a>
			prvUnlockQueue( pxQueue );
  4092f0:	4620      	mov	r0, r4
  4092f2:	4b09      	ldr	r3, [pc, #36]	; (409318 <xQueueGenericSend+0x110>)
  4092f4:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4092f6:	4b09      	ldr	r3, [pc, #36]	; (40931c <xQueueGenericSend+0x114>)
  4092f8:	4798      	blx	r3
			return errQUEUE_FULL;
  4092fa:	2000      	movs	r0, #0
  4092fc:	e7a9      	b.n	409252 <xQueueGenericSend+0x4a>
  4092fe:	bf00      	nop
  409300:	00408d89 	.word	0x00408d89
  409304:	00408da9 	.word	0x00408da9
  409308:	00408d79 	.word	0x00408d79
  40930c:	00409011 	.word	0x00409011
  409310:	00409eb1 	.word	0x00409eb1
  409314:	00408d69 	.word	0x00408d69
  409318:	004090a1 	.word	0x004090a1
  40931c:	00409ad5 	.word	0x00409ad5
  409320:	0040997d 	.word	0x0040997d
  409324:	00409f5d 	.word	0x00409f5d
  409328:	00409e0d 	.word	0x00409e0d
  40932c:	00409f35 	.word	0x00409f35

00409330 <xQueueCreateMutex>:
	{
  409330:	b570      	push	{r4, r5, r6, lr}
  409332:	4606      	mov	r6, r0
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  409334:	2050      	movs	r0, #80	; 0x50
  409336:	4b12      	ldr	r3, [pc, #72]	; (409380 <xQueueCreateMutex+0x50>)
  409338:	4798      	blx	r3
		if( pxNewQueue != NULL )
  40933a:	b1e8      	cbz	r0, 409378 <xQueueCreateMutex+0x48>
  40933c:	4604      	mov	r4, r0
			pxNewQueue->pxMutexHolder = NULL;
  40933e:	2500      	movs	r5, #0
  409340:	6045      	str	r5, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  409342:	6005      	str	r5, [r0, #0]
			pxNewQueue->pcWriteTo = NULL;
  409344:	6085      	str	r5, [r0, #8]
			pxNewQueue->pcReadFrom = NULL;
  409346:	60c5      	str	r5, [r0, #12]
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  409348:	6385      	str	r5, [r0, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
  40934a:	2301      	movs	r3, #1
  40934c:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
  40934e:	6405      	str	r5, [r0, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
  409350:	f04f 33ff 	mov.w	r3, #4294967295
  409354:	6443      	str	r3, [r0, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
  409356:	6483      	str	r3, [r0, #72]	; 0x48
				pxNewQueue->ucQueueType = ucQueueType;
  409358:	f880 604d 	strb.w	r6, [r0, #77]	; 0x4d
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
  40935c:	3010      	adds	r0, #16
  40935e:	4e09      	ldr	r6, [pc, #36]	; (409384 <xQueueCreateMutex+0x54>)
  409360:	47b0      	blx	r6
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
  409362:	f104 0024 	add.w	r0, r4, #36	; 0x24
  409366:	47b0      	blx	r6
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
  409368:	462b      	mov	r3, r5
  40936a:	462a      	mov	r2, r5
  40936c:	4629      	mov	r1, r5
  40936e:	4620      	mov	r0, r4
  409370:	4d05      	ldr	r5, [pc, #20]	; (409388 <xQueueCreateMutex+0x58>)
  409372:	47a8      	blx	r5
	}
  409374:	4620      	mov	r0, r4
  409376:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxNewQueue );
  409378:	4b04      	ldr	r3, [pc, #16]	; (40938c <xQueueCreateMutex+0x5c>)
  40937a:	4798      	blx	r3
  40937c:	bf00      	nop
  40937e:	e7fd      	b.n	40937c <xQueueCreateMutex+0x4c>
  409380:	00408f01 	.word	0x00408f01
  409384:	00408c65 	.word	0x00408c65
  409388:	00409209 	.word	0x00409209
  40938c:	00408d79 	.word	0x00408d79

00409390 <xQueueGenericSendFromISR>:
{
  409390:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( pxQueue );
  409394:	b190      	cbz	r0, 4093bc <xQueueGenericSendFromISR+0x2c>
  409396:	460e      	mov	r6, r1
  409398:	4615      	mov	r5, r2
  40939a:	4698      	mov	r8, r3
  40939c:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  40939e:	b189      	cbz	r1, 4093c4 <xQueueGenericSendFromISR+0x34>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  4093a0:	4b1b      	ldr	r3, [pc, #108]	; (409410 <xQueueGenericSendFromISR+0x80>)
  4093a2:	4798      	blx	r3
  4093a4:	4607      	mov	r7, r0
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  4093a6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4093a8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  4093aa:	429a      	cmp	r2, r3
  4093ac:	d311      	bcc.n	4093d2 <xQueueGenericSendFromISR+0x42>
			xReturn = errQUEUE_FULL;
  4093ae:	2400      	movs	r4, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  4093b0:	4638      	mov	r0, r7
  4093b2:	4b18      	ldr	r3, [pc, #96]	; (409414 <xQueueGenericSendFromISR+0x84>)
  4093b4:	4798      	blx	r3
}
  4093b6:	4620      	mov	r0, r4
  4093b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	configASSERT( pxQueue );
  4093bc:	4b14      	ldr	r3, [pc, #80]	; (409410 <xQueueGenericSendFromISR+0x80>)
  4093be:	4798      	blx	r3
  4093c0:	bf00      	nop
  4093c2:	e7fd      	b.n	4093c0 <xQueueGenericSendFromISR+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  4093c4:	6c03      	ldr	r3, [r0, #64]	; 0x40
  4093c6:	2b00      	cmp	r3, #0
  4093c8:	d0ea      	beq.n	4093a0 <xQueueGenericSendFromISR+0x10>
  4093ca:	4b11      	ldr	r3, [pc, #68]	; (409410 <xQueueGenericSendFromISR+0x80>)
  4093cc:	4798      	blx	r3
  4093ce:	bf00      	nop
  4093d0:	e7fd      	b.n	4093ce <xQueueGenericSendFromISR+0x3e>
			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4093d2:	4642      	mov	r2, r8
  4093d4:	4631      	mov	r1, r6
  4093d6:	4620      	mov	r0, r4
  4093d8:	4b0f      	ldr	r3, [pc, #60]	; (409418 <xQueueGenericSendFromISR+0x88>)
  4093da:	4798      	blx	r3
			if( pxQueue->xTxLock == queueUNLOCKED )
  4093dc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4093de:	f1b3 3fff 	cmp.w	r3, #4294967295
  4093e2:	d10a      	bne.n	4093fa <xQueueGenericSendFromISR+0x6a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4093e4:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4093e6:	b16b      	cbz	r3, 409404 <xQueueGenericSendFromISR+0x74>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4093e8:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4093ec:	4b0b      	ldr	r3, [pc, #44]	; (40941c <xQueueGenericSendFromISR+0x8c>)
  4093ee:	4798      	blx	r3
  4093f0:	b150      	cbz	r0, 409408 <xQueueGenericSendFromISR+0x78>
						if( pxHigherPriorityTaskWoken != NULL )
  4093f2:	b15d      	cbz	r5, 40940c <xQueueGenericSendFromISR+0x7c>
							*pxHigherPriorityTaskWoken = pdTRUE;
  4093f4:	2401      	movs	r4, #1
  4093f6:	602c      	str	r4, [r5, #0]
  4093f8:	e7da      	b.n	4093b0 <xQueueGenericSendFromISR+0x20>
				++( pxQueue->xTxLock );
  4093fa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4093fc:	3301      	adds	r3, #1
  4093fe:	64a3      	str	r3, [r4, #72]	; 0x48
			xReturn = pdPASS;
  409400:	2401      	movs	r4, #1
  409402:	e7d5      	b.n	4093b0 <xQueueGenericSendFromISR+0x20>
  409404:	2401      	movs	r4, #1
  409406:	e7d3      	b.n	4093b0 <xQueueGenericSendFromISR+0x20>
  409408:	2401      	movs	r4, #1
  40940a:	e7d1      	b.n	4093b0 <xQueueGenericSendFromISR+0x20>
  40940c:	2401      	movs	r4, #1
  40940e:	e7cf      	b.n	4093b0 <xQueueGenericSendFromISR+0x20>
  409410:	00408d79 	.word	0x00408d79
  409414:	00408da1 	.word	0x00408da1
  409418:	00409011 	.word	0x00409011
  40941c:	00409eb1 	.word	0x00409eb1

00409420 <xQueueGenericReceive>:
{
  409420:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  409424:	b084      	sub	sp, #16
  409426:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
  409428:	b148      	cbz	r0, 40943e <xQueueGenericReceive+0x1e>
  40942a:	4688      	mov	r8, r1
  40942c:	4699      	mov	r9, r3
  40942e:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  409430:	b149      	cbz	r1, 409446 <xQueueGenericReceive+0x26>
  409432:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
  409434:	4e46      	ldr	r6, [pc, #280]	; (409550 <xQueueGenericReceive+0x130>)
					vTaskSetTimeOutState( &xTimeOut );
  409436:	f8df a14c 	ldr.w	sl, [pc, #332]	; 409584 <xQueueGenericReceive+0x164>
		taskEXIT_CRITICAL();
  40943a:	4d46      	ldr	r5, [pc, #280]	; (409554 <xQueueGenericReceive+0x134>)
  40943c:	e04b      	b.n	4094d6 <xQueueGenericReceive+0xb6>
	configASSERT( pxQueue );
  40943e:	4b46      	ldr	r3, [pc, #280]	; (409558 <xQueueGenericReceive+0x138>)
  409440:	4798      	blx	r3
  409442:	bf00      	nop
  409444:	e7fd      	b.n	409442 <xQueueGenericReceive+0x22>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  409446:	6c03      	ldr	r3, [r0, #64]	; 0x40
  409448:	b11b      	cbz	r3, 409452 <xQueueGenericReceive+0x32>
  40944a:	4b43      	ldr	r3, [pc, #268]	; (409558 <xQueueGenericReceive+0x138>)
  40944c:	4798      	blx	r3
  40944e:	bf00      	nop
  409450:	e7fd      	b.n	40944e <xQueueGenericReceive+0x2e>
  409452:	2700      	movs	r7, #0
  409454:	e7ee      	b.n	409434 <xQueueGenericReceive+0x14>
				pcOriginalReadPosition = pxQueue->pcReadFrom;
  409456:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  409458:	4641      	mov	r1, r8
  40945a:	4620      	mov	r0, r4
  40945c:	4b3f      	ldr	r3, [pc, #252]	; (40955c <xQueueGenericReceive+0x13c>)
  40945e:	4798      	blx	r3
				if( xJustPeeking == pdFALSE )
  409460:	f1b9 0f00 	cmp.w	r9, #0
  409464:	d117      	bne.n	409496 <xQueueGenericReceive+0x76>
					--( pxQueue->uxMessagesWaiting );
  409466:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  409468:	3b01      	subs	r3, #1
  40946a:	63a3      	str	r3, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40946c:	6823      	ldr	r3, [r4, #0]
  40946e:	b913      	cbnz	r3, 409476 <xQueueGenericReceive+0x56>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
  409470:	4b3b      	ldr	r3, [pc, #236]	; (409560 <xQueueGenericReceive+0x140>)
  409472:	4798      	blx	r3
  409474:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  409476:	6923      	ldr	r3, [r4, #16]
  409478:	b13b      	cbz	r3, 40948a <xQueueGenericReceive+0x6a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  40947a:	f104 0010 	add.w	r0, r4, #16
  40947e:	4b39      	ldr	r3, [pc, #228]	; (409564 <xQueueGenericReceive+0x144>)
  409480:	4798      	blx	r3
  409482:	2801      	cmp	r0, #1
  409484:	d101      	bne.n	40948a <xQueueGenericReceive+0x6a>
							portYIELD_WITHIN_API();
  409486:	4b38      	ldr	r3, [pc, #224]	; (409568 <xQueueGenericReceive+0x148>)
  409488:	4798      	blx	r3
				taskEXIT_CRITICAL();
  40948a:	4b32      	ldr	r3, [pc, #200]	; (409554 <xQueueGenericReceive+0x134>)
  40948c:	4798      	blx	r3
				return pdPASS;
  40948e:	2001      	movs	r0, #1
}
  409490:	b004      	add	sp, #16
  409492:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					pxQueue->pcReadFrom = pcOriginalReadPosition;
  409496:	60e5      	str	r5, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  409498:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40949a:	2b00      	cmp	r3, #0
  40949c:	d0f5      	beq.n	40948a <xQueueGenericReceive+0x6a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40949e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4094a2:	4b30      	ldr	r3, [pc, #192]	; (409564 <xQueueGenericReceive+0x144>)
  4094a4:	4798      	blx	r3
  4094a6:	2800      	cmp	r0, #0
  4094a8:	d0ef      	beq.n	40948a <xQueueGenericReceive+0x6a>
							portYIELD_WITHIN_API();
  4094aa:	4b2f      	ldr	r3, [pc, #188]	; (409568 <xQueueGenericReceive+0x148>)
  4094ac:	4798      	blx	r3
  4094ae:	e7ec      	b.n	40948a <xQueueGenericReceive+0x6a>
					taskEXIT_CRITICAL();
  4094b0:	4b28      	ldr	r3, [pc, #160]	; (409554 <xQueueGenericReceive+0x134>)
  4094b2:	4798      	blx	r3
					return errQUEUE_EMPTY;
  4094b4:	2000      	movs	r0, #0
  4094b6:	e7eb      	b.n	409490 <xQueueGenericReceive+0x70>
					vTaskSetTimeOutState( &xTimeOut );
  4094b8:	a802      	add	r0, sp, #8
  4094ba:	47d0      	blx	sl
  4094bc:	e014      	b.n	4094e8 <xQueueGenericReceive+0xc8>
						portENTER_CRITICAL();
  4094be:	47b0      	blx	r6
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  4094c0:	6860      	ldr	r0, [r4, #4]
  4094c2:	4b2a      	ldr	r3, [pc, #168]	; (40956c <xQueueGenericReceive+0x14c>)
  4094c4:	4798      	blx	r3
						portEXIT_CRITICAL();
  4094c6:	47a8      	blx	r5
  4094c8:	e02c      	b.n	409524 <xQueueGenericReceive+0x104>
				prvUnlockQueue( pxQueue );
  4094ca:	4620      	mov	r0, r4
  4094cc:	4b28      	ldr	r3, [pc, #160]	; (409570 <xQueueGenericReceive+0x150>)
  4094ce:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4094d0:	4b28      	ldr	r3, [pc, #160]	; (409574 <xQueueGenericReceive+0x154>)
  4094d2:	4798      	blx	r3
  4094d4:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
  4094d6:	47b0      	blx	r6
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  4094d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4094da:	2b00      	cmp	r3, #0
  4094dc:	d1bb      	bne.n	409456 <xQueueGenericReceive+0x36>
				if( xTicksToWait == ( portTickType ) 0 )
  4094de:	9b01      	ldr	r3, [sp, #4]
  4094e0:	2b00      	cmp	r3, #0
  4094e2:	d0e5      	beq.n	4094b0 <xQueueGenericReceive+0x90>
				else if( xEntryTimeSet == pdFALSE )
  4094e4:	2f00      	cmp	r7, #0
  4094e6:	d0e7      	beq.n	4094b8 <xQueueGenericReceive+0x98>
		taskEXIT_CRITICAL();
  4094e8:	47a8      	blx	r5
		vTaskSuspendAll();
  4094ea:	4b23      	ldr	r3, [pc, #140]	; (409578 <xQueueGenericReceive+0x158>)
  4094ec:	4798      	blx	r3
		prvLockQueue( pxQueue );
  4094ee:	47b0      	blx	r6
  4094f0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4094f2:	f1b3 3fff 	cmp.w	r3, #4294967295
  4094f6:	bf04      	itt	eq
  4094f8:	2300      	moveq	r3, #0
  4094fa:	6463      	streq	r3, [r4, #68]	; 0x44
  4094fc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4094fe:	f1b3 3fff 	cmp.w	r3, #4294967295
  409502:	bf04      	itt	eq
  409504:	2300      	moveq	r3, #0
  409506:	64a3      	streq	r3, [r4, #72]	; 0x48
  409508:	47a8      	blx	r5
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40950a:	a901      	add	r1, sp, #4
  40950c:	a802      	add	r0, sp, #8
  40950e:	4b1b      	ldr	r3, [pc, #108]	; (40957c <xQueueGenericReceive+0x15c>)
  409510:	4798      	blx	r3
  409512:	b9b0      	cbnz	r0, 409542 <xQueueGenericReceive+0x122>
	taskENTER_CRITICAL();
  409514:	47b0      	blx	r6
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
  409516:	6ba7      	ldr	r7, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  409518:	47a8      	blx	r5
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  40951a:	2f00      	cmp	r7, #0
  40951c:	d1d5      	bne.n	4094ca <xQueueGenericReceive+0xaa>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40951e:	6823      	ldr	r3, [r4, #0]
  409520:	2b00      	cmp	r3, #0
  409522:	d0cc      	beq.n	4094be <xQueueGenericReceive+0x9e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  409524:	9901      	ldr	r1, [sp, #4]
  409526:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40952a:	4b15      	ldr	r3, [pc, #84]	; (409580 <xQueueGenericReceive+0x160>)
  40952c:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  40952e:	4620      	mov	r0, r4
  409530:	4b0f      	ldr	r3, [pc, #60]	; (409570 <xQueueGenericReceive+0x150>)
  409532:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  409534:	4b0f      	ldr	r3, [pc, #60]	; (409574 <xQueueGenericReceive+0x154>)
  409536:	4798      	blx	r3
  409538:	2800      	cmp	r0, #0
  40953a:	d1cb      	bne.n	4094d4 <xQueueGenericReceive+0xb4>
					portYIELD_WITHIN_API();
  40953c:	4b0a      	ldr	r3, [pc, #40]	; (409568 <xQueueGenericReceive+0x148>)
  40953e:	4798      	blx	r3
  409540:	e7c8      	b.n	4094d4 <xQueueGenericReceive+0xb4>
			prvUnlockQueue( pxQueue );
  409542:	4620      	mov	r0, r4
  409544:	4b0a      	ldr	r3, [pc, #40]	; (409570 <xQueueGenericReceive+0x150>)
  409546:	4798      	blx	r3
			( void ) xTaskResumeAll();
  409548:	4b0a      	ldr	r3, [pc, #40]	; (409574 <xQueueGenericReceive+0x154>)
  40954a:	4798      	blx	r3
			return errQUEUE_EMPTY;
  40954c:	2000      	movs	r0, #0
  40954e:	e79f      	b.n	409490 <xQueueGenericReceive+0x70>
  409550:	00408d89 	.word	0x00408d89
  409554:	00408da9 	.word	0x00408da9
  409558:	00408d79 	.word	0x00408d79
  40955c:	00409079 	.word	0x00409079
  409560:	00409fed 	.word	0x00409fed
  409564:	00409eb1 	.word	0x00409eb1
  409568:	00408d69 	.word	0x00408d69
  40956c:	0040a019 	.word	0x0040a019
  409570:	004090a1 	.word	0x004090a1
  409574:	00409ad5 	.word	0x00409ad5
  409578:	0040997d 	.word	0x0040997d
  40957c:	00409f5d 	.word	0x00409f5d
  409580:	00409e0d 	.word	0x00409e0d
  409584:	00409f35 	.word	0x00409f35

00409588 <uxQueueMessagesWaiting>:
{
  409588:	b510      	push	{r4, lr}
	configASSERT( pxQueue );
  40958a:	b138      	cbz	r0, 40959c <uxQueueMessagesWaiting+0x14>
  40958c:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
  40958e:	4b05      	ldr	r3, [pc, #20]	; (4095a4 <uxQueueMessagesWaiting+0x1c>)
  409590:	4798      	blx	r3
		uxReturn = pxQueue->uxMessagesWaiting;
  409592:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  409594:	4b04      	ldr	r3, [pc, #16]	; (4095a8 <uxQueueMessagesWaiting+0x20>)
  409596:	4798      	blx	r3
}
  409598:	4620      	mov	r0, r4
  40959a:	bd10      	pop	{r4, pc}
	configASSERT( pxQueue );
  40959c:	4b03      	ldr	r3, [pc, #12]	; (4095ac <uxQueueMessagesWaiting+0x24>)
  40959e:	4798      	blx	r3
  4095a0:	bf00      	nop
  4095a2:	e7fd      	b.n	4095a0 <uxQueueMessagesWaiting+0x18>
  4095a4:	00408d89 	.word	0x00408d89
  4095a8:	00408da9 	.word	0x00408da9
  4095ac:	00408d79 	.word	0x00408d79

004095b0 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
  4095b0:	b538      	push	{r3, r4, r5, lr}
  4095b2:	4604      	mov	r4, r0
  4095b4:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  4095b6:	4b0e      	ldr	r3, [pc, #56]	; (4095f0 <vQueueWaitForMessageRestricted+0x40>)
  4095b8:	4798      	blx	r3
  4095ba:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4095bc:	f1b3 3fff 	cmp.w	r3, #4294967295
  4095c0:	bf04      	itt	eq
  4095c2:	2300      	moveq	r3, #0
  4095c4:	6463      	streq	r3, [r4, #68]	; 0x44
  4095c6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4095c8:	f1b3 3fff 	cmp.w	r3, #4294967295
  4095cc:	bf04      	itt	eq
  4095ce:	2300      	moveq	r3, #0
  4095d0:	64a3      	streq	r3, [r4, #72]	; 0x48
  4095d2:	4b08      	ldr	r3, [pc, #32]	; (4095f4 <vQueueWaitForMessageRestricted+0x44>)
  4095d4:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
  4095d6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4095d8:	b11b      	cbz	r3, 4095e2 <vQueueWaitForMessageRestricted+0x32>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
		}
		prvUnlockQueue( pxQueue );
  4095da:	4620      	mov	r0, r4
  4095dc:	4b06      	ldr	r3, [pc, #24]	; (4095f8 <vQueueWaitForMessageRestricted+0x48>)
  4095de:	4798      	blx	r3
  4095e0:	bd38      	pop	{r3, r4, r5, pc}
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  4095e2:	4629      	mov	r1, r5
  4095e4:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4095e8:	4b04      	ldr	r3, [pc, #16]	; (4095fc <vQueueWaitForMessageRestricted+0x4c>)
  4095ea:	4798      	blx	r3
  4095ec:	e7f5      	b.n	4095da <vQueueWaitForMessageRestricted+0x2a>
  4095ee:	bf00      	nop
  4095f0:	00408d89 	.word	0x00408d89
  4095f4:	00408da9 	.word	0x00408da9
  4095f8:	004090a1 	.word	0x004090a1
  4095fc:	00409e6d 	.word	0x00409e6d

00409600 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  409600:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  409602:	4b0f      	ldr	r3, [pc, #60]	; (409640 <prvAddCurrentTaskToDelayedList+0x40>)
  409604:	681b      	ldr	r3, [r3, #0]
  409606:	6058      	str	r0, [r3, #4]

	if( xTimeToWake < xTickCount )
  409608:	4b0e      	ldr	r3, [pc, #56]	; (409644 <prvAddCurrentTaskToDelayedList+0x44>)
  40960a:	681b      	ldr	r3, [r3, #0]
  40960c:	4298      	cmp	r0, r3
  40960e:	d30e      	bcc.n	40962e <prvAddCurrentTaskToDelayedList+0x2e>
  409610:	4604      	mov	r4, r0
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  409612:	4b0d      	ldr	r3, [pc, #52]	; (409648 <prvAddCurrentTaskToDelayedList+0x48>)
  409614:	6818      	ldr	r0, [r3, #0]
  409616:	4b0a      	ldr	r3, [pc, #40]	; (409640 <prvAddCurrentTaskToDelayedList+0x40>)
  409618:	6819      	ldr	r1, [r3, #0]
  40961a:	3104      	adds	r1, #4
  40961c:	4b0b      	ldr	r3, [pc, #44]	; (40964c <prvAddCurrentTaskToDelayedList+0x4c>)
  40961e:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  409620:	4b0b      	ldr	r3, [pc, #44]	; (409650 <prvAddCurrentTaskToDelayedList+0x50>)
  409622:	681b      	ldr	r3, [r3, #0]
  409624:	429c      	cmp	r4, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
  409626:	bf3c      	itt	cc
  409628:	4b09      	ldrcc	r3, [pc, #36]	; (409650 <prvAddCurrentTaskToDelayedList+0x50>)
  40962a:	601c      	strcc	r4, [r3, #0]
  40962c:	bd10      	pop	{r4, pc}
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40962e:	4b09      	ldr	r3, [pc, #36]	; (409654 <prvAddCurrentTaskToDelayedList+0x54>)
  409630:	6818      	ldr	r0, [r3, #0]
  409632:	4b03      	ldr	r3, [pc, #12]	; (409640 <prvAddCurrentTaskToDelayedList+0x40>)
  409634:	6819      	ldr	r1, [r3, #0]
  409636:	3104      	adds	r1, #4
  409638:	4b04      	ldr	r3, [pc, #16]	; (40964c <prvAddCurrentTaskToDelayedList+0x4c>)
  40963a:	4798      	blx	r3
  40963c:	bd10      	pop	{r4, pc}
  40963e:	bf00      	nop
  409640:	20011638 	.word	0x20011638
  409644:	20011734 	.word	0x20011734
  409648:	2001163c 	.word	0x2001163c
  40964c:	00408c9d 	.word	0x00408c9d
  409650:	20000014 	.word	0x20000014
  409654:	20011640 	.word	0x20011640

00409658 <xTaskGenericCreate>:
{
  409658:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40965c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  40965e:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
  409662:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	configASSERT( pxTaskCode );
  409664:	b148      	cbz	r0, 40967a <xTaskGenericCreate+0x22>
  409666:	4688      	mov	r8, r1
  409668:	4615      	mov	r5, r2
  40966a:	469b      	mov	fp, r3
  40966c:	4682      	mov	sl, r0
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
  40966e:	2f04      	cmp	r7, #4
  409670:	d907      	bls.n	409682 <xTaskGenericCreate+0x2a>
  409672:	4b5d      	ldr	r3, [pc, #372]	; (4097e8 <xTaskGenericCreate+0x190>)
  409674:	4798      	blx	r3
  409676:	bf00      	nop
  409678:	e7fd      	b.n	409676 <xTaskGenericCreate+0x1e>
	configASSERT( pxTaskCode );
  40967a:	4b5b      	ldr	r3, [pc, #364]	; (4097e8 <xTaskGenericCreate+0x190>)
  40967c:	4798      	blx	r3
  40967e:	bf00      	nop
  409680:	e7fd      	b.n	40967e <xTaskGenericCreate+0x26>
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  409682:	204c      	movs	r0, #76	; 0x4c
  409684:	4b59      	ldr	r3, [pc, #356]	; (4097ec <xTaskGenericCreate+0x194>)
  409686:	4798      	blx	r3

	if( pxNewTCB != NULL )
  409688:	4604      	mov	r4, r0
  40968a:	2800      	cmp	r0, #0
  40968c:	d051      	beq.n	409732 <xTaskGenericCreate+0xda>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  40968e:	2e00      	cmp	r6, #0
  409690:	d045      	beq.n	40971e <xTaskGenericCreate+0xc6>
  409692:	6306      	str	r6, [r0, #48]	; 0x30
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
  409694:	00aa      	lsls	r2, r5, #2
  409696:	21a5      	movs	r1, #165	; 0xa5
  409698:	4630      	mov	r0, r6
  40969a:	4b55      	ldr	r3, [pc, #340]	; (4097f0 <xTaskGenericCreate+0x198>)
  40969c:	4798      	blx	r3
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
  40969e:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
  4096a2:	3d01      	subs	r5, #1
  4096a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
  4096a6:	eb03 0385 	add.w	r3, r3, r5, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
  4096aa:	f023 0507 	bic.w	r5, r3, #7
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
  4096ae:	220a      	movs	r2, #10
  4096b0:	4641      	mov	r1, r8
  4096b2:	f104 0034 	add.w	r0, r4, #52	; 0x34
  4096b6:	4b4f      	ldr	r3, [pc, #316]	; (4097f4 <xTaskGenericCreate+0x19c>)
  4096b8:	4798      	blx	r3
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
  4096ba:	2300      	movs	r3, #0
  4096bc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	pxTCB->uxPriority = uxPriority;
  4096c0:	62e7      	str	r7, [r4, #44]	; 0x2c
		pxTCB->uxBasePriority = uxPriority;
  4096c2:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  4096c4:	f104 0804 	add.w	r8, r4, #4
  4096c8:	4640      	mov	r0, r8
  4096ca:	4e4b      	ldr	r6, [pc, #300]	; (4097f8 <xTaskGenericCreate+0x1a0>)
  4096cc:	47b0      	blx	r6
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  4096ce:	f104 0018 	add.w	r0, r4, #24
  4096d2:	47b0      	blx	r6
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  4096d4:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  4096d6:	f1c7 0305 	rsb	r3, r7, #5
  4096da:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  4096dc:	6264      	str	r4, [r4, #36]	; 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  4096de:	465a      	mov	r2, fp
  4096e0:	4651      	mov	r1, sl
  4096e2:	4628      	mov	r0, r5
  4096e4:	4b45      	ldr	r3, [pc, #276]	; (4097fc <xTaskGenericCreate+0x1a4>)
  4096e6:	4798      	blx	r3
  4096e8:	6020      	str	r0, [r4, #0]
		if( ( void * ) pxCreatedTask != NULL )
  4096ea:	f1b9 0f00 	cmp.w	r9, #0
  4096ee:	d001      	beq.n	4096f4 <xTaskGenericCreate+0x9c>
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
  4096f0:	f8c9 4000 	str.w	r4, [r9]
		taskENTER_CRITICAL();
  4096f4:	4b42      	ldr	r3, [pc, #264]	; (409800 <xTaskGenericCreate+0x1a8>)
  4096f6:	4798      	blx	r3
			uxCurrentNumberOfTasks++;
  4096f8:	4a42      	ldr	r2, [pc, #264]	; (409804 <xTaskGenericCreate+0x1ac>)
  4096fa:	6813      	ldr	r3, [r2, #0]
  4096fc:	3301      	adds	r3, #1
  4096fe:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
  409700:	4b41      	ldr	r3, [pc, #260]	; (409808 <xTaskGenericCreate+0x1b0>)
  409702:	681b      	ldr	r3, [r3, #0]
  409704:	b1cb      	cbz	r3, 40973a <xTaskGenericCreate+0xe2>
				if( xSchedulerRunning == pdFALSE )
  409706:	4b41      	ldr	r3, [pc, #260]	; (40980c <xTaskGenericCreate+0x1b4>)
  409708:	681b      	ldr	r3, [r3, #0]
  40970a:	2b00      	cmp	r3, #0
  40970c:	d13c      	bne.n	409788 <xTaskGenericCreate+0x130>
					if( pxCurrentTCB->uxPriority <= uxPriority )
  40970e:	4b3e      	ldr	r3, [pc, #248]	; (409808 <xTaskGenericCreate+0x1b0>)
  409710:	681b      	ldr	r3, [r3, #0]
  409712:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  409714:	429f      	cmp	r7, r3
						pxCurrentTCB = pxNewTCB;
  409716:	bf24      	itt	cs
  409718:	4b3b      	ldrcs	r3, [pc, #236]	; (409808 <xTaskGenericCreate+0x1b0>)
  40971a:	601c      	strcs	r4, [r3, #0]
  40971c:	e034      	b.n	409788 <xTaskGenericCreate+0x130>
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  40971e:	00a8      	lsls	r0, r5, #2
  409720:	4b32      	ldr	r3, [pc, #200]	; (4097ec <xTaskGenericCreate+0x194>)
  409722:	4798      	blx	r3
  409724:	4606      	mov	r6, r0
  409726:	6320      	str	r0, [r4, #48]	; 0x30
		if( pxNewTCB->pxStack == NULL )
  409728:	2800      	cmp	r0, #0
  40972a:	d1b3      	bne.n	409694 <xTaskGenericCreate+0x3c>
			vPortFree( pxNewTCB );
  40972c:	4620      	mov	r0, r4
  40972e:	4b38      	ldr	r3, [pc, #224]	; (409810 <xTaskGenericCreate+0x1b8>)
  409730:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  409732:	f04f 30ff 	mov.w	r0, #4294967295
}
  409736:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				pxCurrentTCB =  pxNewTCB;
  40973a:	4b33      	ldr	r3, [pc, #204]	; (409808 <xTaskGenericCreate+0x1b0>)
  40973c:	601c      	str	r4, [r3, #0]
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  40973e:	6813      	ldr	r3, [r2, #0]
  409740:	2b01      	cmp	r3, #1
  409742:	d121      	bne.n	409788 <xTaskGenericCreate+0x130>
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  409744:	4e33      	ldr	r6, [pc, #204]	; (409814 <xTaskGenericCreate+0x1bc>)
  409746:	4630      	mov	r0, r6
  409748:	4d33      	ldr	r5, [pc, #204]	; (409818 <xTaskGenericCreate+0x1c0>)
  40974a:	47a8      	blx	r5
  40974c:	f106 0014 	add.w	r0, r6, #20
  409750:	47a8      	blx	r5
  409752:	f106 0028 	add.w	r0, r6, #40	; 0x28
  409756:	47a8      	blx	r5
  409758:	f106 003c 	add.w	r0, r6, #60	; 0x3c
  40975c:	47a8      	blx	r5
  40975e:	f106 0050 	add.w	r0, r6, #80	; 0x50
  409762:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  409764:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 40984c <xTaskGenericCreate+0x1f4>
  409768:	4648      	mov	r0, r9
  40976a:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  40976c:	4e2b      	ldr	r6, [pc, #172]	; (40981c <xTaskGenericCreate+0x1c4>)
  40976e:	4630      	mov	r0, r6
  409770:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xPendingReadyList );
  409772:	482b      	ldr	r0, [pc, #172]	; (409820 <xTaskGenericCreate+0x1c8>)
  409774:	47a8      	blx	r5
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
  409776:	482b      	ldr	r0, [pc, #172]	; (409824 <xTaskGenericCreate+0x1cc>)
  409778:	47a8      	blx	r5
		vListInitialise( ( xList * ) &xSuspendedTaskList );
  40977a:	482b      	ldr	r0, [pc, #172]	; (409828 <xTaskGenericCreate+0x1d0>)
  40977c:	47a8      	blx	r5
	pxDelayedTaskList = &xDelayedTaskList1;
  40977e:	4b2b      	ldr	r3, [pc, #172]	; (40982c <xTaskGenericCreate+0x1d4>)
  409780:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  409784:	4b2a      	ldr	r3, [pc, #168]	; (409830 <xTaskGenericCreate+0x1d8>)
  409786:	601e      	str	r6, [r3, #0]
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
  409788:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  40978a:	4b2a      	ldr	r3, [pc, #168]	; (409834 <xTaskGenericCreate+0x1dc>)
  40978c:	681b      	ldr	r3, [r3, #0]
  40978e:	4298      	cmp	r0, r3
				uxTopUsedPriority = pxNewTCB->uxPriority;
  409790:	bf84      	itt	hi
  409792:	4b28      	ldrhi	r3, [pc, #160]	; (409834 <xTaskGenericCreate+0x1dc>)
  409794:	6018      	strhi	r0, [r3, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
  409796:	4a28      	ldr	r2, [pc, #160]	; (409838 <xTaskGenericCreate+0x1e0>)
  409798:	6813      	ldr	r3, [r2, #0]
  40979a:	6423      	str	r3, [r4, #64]	; 0x40
			uxTaskNumber++;
  40979c:	3301      	adds	r3, #1
  40979e:	6013      	str	r3, [r2, #0]
			prvAddTaskToReadyQueue( pxNewTCB );
  4097a0:	4b26      	ldr	r3, [pc, #152]	; (40983c <xTaskGenericCreate+0x1e4>)
  4097a2:	681b      	ldr	r3, [r3, #0]
  4097a4:	4298      	cmp	r0, r3
  4097a6:	bf84      	itt	hi
  4097a8:	4b24      	ldrhi	r3, [pc, #144]	; (40983c <xTaskGenericCreate+0x1e4>)
  4097aa:	6018      	strhi	r0, [r3, #0]
  4097ac:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4097b0:	4641      	mov	r1, r8
  4097b2:	4b18      	ldr	r3, [pc, #96]	; (409814 <xTaskGenericCreate+0x1bc>)
  4097b4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4097b8:	4b21      	ldr	r3, [pc, #132]	; (409840 <xTaskGenericCreate+0x1e8>)
  4097ba:	4798      	blx	r3
		taskEXIT_CRITICAL();
  4097bc:	4b21      	ldr	r3, [pc, #132]	; (409844 <xTaskGenericCreate+0x1ec>)
  4097be:	4798      	blx	r3
		if( xSchedulerRunning != pdFALSE )
  4097c0:	4b12      	ldr	r3, [pc, #72]	; (40980c <xTaskGenericCreate+0x1b4>)
  4097c2:	681b      	ldr	r3, [r3, #0]
  4097c4:	b14b      	cbz	r3, 4097da <xTaskGenericCreate+0x182>
			if( pxCurrentTCB->uxPriority < uxPriority )
  4097c6:	4b10      	ldr	r3, [pc, #64]	; (409808 <xTaskGenericCreate+0x1b0>)
  4097c8:	681b      	ldr	r3, [r3, #0]
  4097ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4097cc:	429f      	cmp	r7, r3
  4097ce:	d907      	bls.n	4097e0 <xTaskGenericCreate+0x188>
				portYIELD_WITHIN_API();
  4097d0:	4b1d      	ldr	r3, [pc, #116]	; (409848 <xTaskGenericCreate+0x1f0>)
  4097d2:	4798      	blx	r3
  4097d4:	2001      	movs	r0, #1
  4097d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4097da:	2001      	movs	r0, #1
  4097dc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4097e0:	2001      	movs	r0, #1
	return xReturn;
  4097e2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4097e6:	bf00      	nop
  4097e8:	00408d79 	.word	0x00408d79
  4097ec:	00408f01 	.word	0x00408f01
  4097f0:	0040c287 	.word	0x0040c287
  4097f4:	0040c79b 	.word	0x0040c79b
  4097f8:	00408c7b 	.word	0x00408c7b
  4097fc:	00408d29 	.word	0x00408d29
  409800:	00408d89 	.word	0x00408d89
  409804:	200116a8 	.word	0x200116a8
  409808:	20011638 	.word	0x20011638
  40980c:	20011708 	.word	0x20011708
  409810:	00408fd9 	.word	0x00408fd9
  409814:	20011644 	.word	0x20011644
  409818:	00408c65 	.word	0x00408c65
  40981c:	200116d8 	.word	0x200116d8
  409820:	200116f4 	.word	0x200116f4
  409824:	20011720 	.word	0x20011720
  409828:	2001170c 	.word	0x2001170c
  40982c:	2001163c 	.word	0x2001163c
  409830:	20011640 	.word	0x20011640
  409834:	200116c0 	.word	0x200116c0
  409838:	200116b4 	.word	0x200116b4
  40983c:	200116bc 	.word	0x200116bc
  409840:	00408c81 	.word	0x00408c81
  409844:	00408da9 	.word	0x00408da9
  409848:	00408d69 	.word	0x00408d69
  40984c:	200116c4 	.word	0x200116c4

00409850 <xTaskIsTaskSuspended>:
	{
  409850:	b508      	push	{r3, lr}
		configASSERT( xTask );
  409852:	b128      	cbz	r0, 409860 <xTaskIsTaskSuspended+0x10>
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
  409854:	6941      	ldr	r1, [r0, #20]
  409856:	4a09      	ldr	r2, [pc, #36]	; (40987c <xTaskIsTaskSuspended+0x2c>)
  409858:	4291      	cmp	r1, r2
  40985a:	d005      	beq.n	409868 <xTaskIsTaskSuspended+0x18>
	portBASE_TYPE xReturn = pdFALSE;
  40985c:	2000      	movs	r0, #0
  40985e:	bd08      	pop	{r3, pc}
		configASSERT( xTask );
  409860:	4b07      	ldr	r3, [pc, #28]	; (409880 <xTaskIsTaskSuspended+0x30>)
  409862:	4798      	blx	r3
  409864:	bf00      	nop
  409866:	e7fd      	b.n	409864 <xTaskIsTaskSuspended+0x14>
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
  409868:	6a80      	ldr	r0, [r0, #40]	; 0x28
  40986a:	4b06      	ldr	r3, [pc, #24]	; (409884 <xTaskIsTaskSuspended+0x34>)
  40986c:	4298      	cmp	r0, r3
  40986e:	d003      	beq.n	409878 <xTaskIsTaskSuspended+0x28>
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
  409870:	fab0 f080 	clz	r0, r0
  409874:	0940      	lsrs	r0, r0, #5
  409876:	bd08      	pop	{r3, pc}
	portBASE_TYPE xReturn = pdFALSE;
  409878:	2000      	movs	r0, #0
	}
  40987a:	bd08      	pop	{r3, pc}
  40987c:	2001170c 	.word	0x2001170c
  409880:	00408d79 	.word	0x00408d79
  409884:	200116f4 	.word	0x200116f4

00409888 <vTaskResume>:
	{
  409888:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxTaskToResume );
  40988a:	b170      	cbz	r0, 4098aa <vTaskResume+0x22>
  40988c:	4604      	mov	r4, r0
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
  40988e:	4b17      	ldr	r3, [pc, #92]	; (4098ec <vTaskResume+0x64>)
  409890:	681b      	ldr	r3, [r3, #0]
  409892:	4298      	cmp	r0, r3
  409894:	d008      	beq.n	4098a8 <vTaskResume+0x20>
			taskENTER_CRITICAL();
  409896:	4b16      	ldr	r3, [pc, #88]	; (4098f0 <vTaskResume+0x68>)
  409898:	4798      	blx	r3
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
  40989a:	4620      	mov	r0, r4
  40989c:	4b15      	ldr	r3, [pc, #84]	; (4098f4 <vTaskResume+0x6c>)
  40989e:	4798      	blx	r3
  4098a0:	2801      	cmp	r0, #1
  4098a2:	d006      	beq.n	4098b2 <vTaskResume+0x2a>
			taskEXIT_CRITICAL();
  4098a4:	4b14      	ldr	r3, [pc, #80]	; (4098f8 <vTaskResume+0x70>)
  4098a6:	4798      	blx	r3
  4098a8:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pxTaskToResume );
  4098aa:	4b14      	ldr	r3, [pc, #80]	; (4098fc <vTaskResume+0x74>)
  4098ac:	4798      	blx	r3
  4098ae:	bf00      	nop
  4098b0:	e7fd      	b.n	4098ae <vTaskResume+0x26>
					uxListRemove(  &( pxTCB->xGenericListItem ) );
  4098b2:	1d25      	adds	r5, r4, #4
  4098b4:	4628      	mov	r0, r5
  4098b6:	4b12      	ldr	r3, [pc, #72]	; (409900 <vTaskResume+0x78>)
  4098b8:	4798      	blx	r3
					prvAddTaskToReadyQueue( pxTCB );
  4098ba:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4098bc:	4b11      	ldr	r3, [pc, #68]	; (409904 <vTaskResume+0x7c>)
  4098be:	681b      	ldr	r3, [r3, #0]
  4098c0:	4298      	cmp	r0, r3
  4098c2:	bf84      	itt	hi
  4098c4:	4b0f      	ldrhi	r3, [pc, #60]	; (409904 <vTaskResume+0x7c>)
  4098c6:	6018      	strhi	r0, [r3, #0]
  4098c8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4098cc:	4629      	mov	r1, r5
  4098ce:	4b0e      	ldr	r3, [pc, #56]	; (409908 <vTaskResume+0x80>)
  4098d0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4098d4:	4b0d      	ldr	r3, [pc, #52]	; (40990c <vTaskResume+0x84>)
  4098d6:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4098d8:	4b04      	ldr	r3, [pc, #16]	; (4098ec <vTaskResume+0x64>)
  4098da:	681b      	ldr	r3, [r3, #0]
  4098dc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4098de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4098e0:	429a      	cmp	r2, r3
  4098e2:	d3df      	bcc.n	4098a4 <vTaskResume+0x1c>
						portYIELD_WITHIN_API();
  4098e4:	4b0a      	ldr	r3, [pc, #40]	; (409910 <vTaskResume+0x88>)
  4098e6:	4798      	blx	r3
  4098e8:	e7dc      	b.n	4098a4 <vTaskResume+0x1c>
  4098ea:	bf00      	nop
  4098ec:	20011638 	.word	0x20011638
  4098f0:	00408d89 	.word	0x00408d89
  4098f4:	00409851 	.word	0x00409851
  4098f8:	00408da9 	.word	0x00408da9
  4098fc:	00408d79 	.word	0x00408d79
  409900:	00408cd9 	.word	0x00408cd9
  409904:	200116bc 	.word	0x200116bc
  409908:	20011644 	.word	0x20011644
  40990c:	00408c81 	.word	0x00408c81
  409910:	00408d69 	.word	0x00408d69

00409914 <vTaskStartScheduler>:
{
  409914:	b510      	push	{r4, lr}
  409916:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
  409918:	2300      	movs	r3, #0
  40991a:	9303      	str	r3, [sp, #12]
  40991c:	9302      	str	r3, [sp, #8]
  40991e:	9301      	str	r3, [sp, #4]
  409920:	9300      	str	r3, [sp, #0]
  409922:	2282      	movs	r2, #130	; 0x82
  409924:	490d      	ldr	r1, [pc, #52]	; (40995c <vTaskStartScheduler+0x48>)
  409926:	480e      	ldr	r0, [pc, #56]	; (409960 <vTaskStartScheduler+0x4c>)
  409928:	4c0e      	ldr	r4, [pc, #56]	; (409964 <vTaskStartScheduler+0x50>)
  40992a:	47a0      	blx	r4
		if( xReturn == pdPASS )
  40992c:	2801      	cmp	r0, #1
  40992e:	d002      	beq.n	409936 <vTaskStartScheduler+0x22>
	configASSERT( xReturn );
  409930:	b180      	cbz	r0, 409954 <vTaskStartScheduler+0x40>
}
  409932:	b004      	add	sp, #16
  409934:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
  409936:	4b0c      	ldr	r3, [pc, #48]	; (409968 <vTaskStartScheduler+0x54>)
  409938:	4798      	blx	r3
	if( xReturn == pdPASS )
  40993a:	2801      	cmp	r0, #1
  40993c:	d1f8      	bne.n	409930 <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
  40993e:	4b0b      	ldr	r3, [pc, #44]	; (40996c <vTaskStartScheduler+0x58>)
  409940:	4798      	blx	r3
		xSchedulerRunning = pdTRUE;
  409942:	2201      	movs	r2, #1
  409944:	4b0a      	ldr	r3, [pc, #40]	; (409970 <vTaskStartScheduler+0x5c>)
  409946:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
  409948:	2200      	movs	r2, #0
  40994a:	4b0a      	ldr	r3, [pc, #40]	; (409974 <vTaskStartScheduler+0x60>)
  40994c:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
  40994e:	4b0a      	ldr	r3, [pc, #40]	; (409978 <vTaskStartScheduler+0x64>)
  409950:	4798      	blx	r3
  409952:	e7ee      	b.n	409932 <vTaskStartScheduler+0x1e>
	configASSERT( xReturn );
  409954:	4b05      	ldr	r3, [pc, #20]	; (40996c <vTaskStartScheduler+0x58>)
  409956:	4798      	blx	r3
  409958:	bf00      	nop
  40995a:	e7fd      	b.n	409958 <vTaskStartScheduler+0x44>
  40995c:	0040e500 	.word	0x0040e500
  409960:	00409c21 	.word	0x00409c21
  409964:	00409659 	.word	0x00409659
  409968:	0040a191 	.word	0x0040a191
  40996c:	00408d79 	.word	0x00408d79
  409970:	20011708 	.word	0x20011708
  409974:	20011734 	.word	0x20011734
  409978:	00408e5d 	.word	0x00408e5d

0040997c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
  40997c:	4a02      	ldr	r2, [pc, #8]	; (409988 <vTaskSuspendAll+0xc>)
  40997e:	6813      	ldr	r3, [r2, #0]
  409980:	3301      	adds	r3, #1
  409982:	6013      	str	r3, [r2, #0]
  409984:	4770      	bx	lr
  409986:	bf00      	nop
  409988:	200116b0 	.word	0x200116b0

0040998c <xTaskGetTickCount>:
{
  40998c:	b510      	push	{r4, lr}
	taskENTER_CRITICAL();
  40998e:	4b04      	ldr	r3, [pc, #16]	; (4099a0 <xTaskGetTickCount+0x14>)
  409990:	4798      	blx	r3
		xTicks = xTickCount;
  409992:	4b04      	ldr	r3, [pc, #16]	; (4099a4 <xTaskGetTickCount+0x18>)
  409994:	681c      	ldr	r4, [r3, #0]
	taskEXIT_CRITICAL();
  409996:	4b04      	ldr	r3, [pc, #16]	; (4099a8 <xTaskGetTickCount+0x1c>)
  409998:	4798      	blx	r3
}
  40999a:	4620      	mov	r0, r4
  40999c:	bd10      	pop	{r4, pc}
  40999e:	bf00      	nop
  4099a0:	00408d89 	.word	0x00408d89
  4099a4:	20011734 	.word	0x20011734
  4099a8:	00408da9 	.word	0x00408da9

004099ac <vTaskIncrementTick>:
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4099ac:	4b3d      	ldr	r3, [pc, #244]	; (409aa4 <vTaskIncrementTick+0xf8>)
  4099ae:	681b      	ldr	r3, [r3, #0]
  4099b0:	2b00      	cmp	r3, #0
  4099b2:	d16f      	bne.n	409a94 <vTaskIncrementTick+0xe8>
{
  4099b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		++xTickCount;
  4099b8:	4b3b      	ldr	r3, [pc, #236]	; (409aa8 <vTaskIncrementTick+0xfc>)
  4099ba:	681a      	ldr	r2, [r3, #0]
  4099bc:	3201      	adds	r2, #1
  4099be:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
  4099c0:	681b      	ldr	r3, [r3, #0]
  4099c2:	b9ab      	cbnz	r3, 4099f0 <vTaskIncrementTick+0x44>
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
  4099c4:	4b39      	ldr	r3, [pc, #228]	; (409aac <vTaskIncrementTick+0x100>)
  4099c6:	681b      	ldr	r3, [r3, #0]
  4099c8:	681b      	ldr	r3, [r3, #0]
  4099ca:	2b00      	cmp	r3, #0
  4099cc:	d128      	bne.n	409a20 <vTaskIncrementTick+0x74>
			pxTemp = pxDelayedTaskList;
  4099ce:	4b37      	ldr	r3, [pc, #220]	; (409aac <vTaskIncrementTick+0x100>)
  4099d0:	6819      	ldr	r1, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  4099d2:	4a37      	ldr	r2, [pc, #220]	; (409ab0 <vTaskIncrementTick+0x104>)
  4099d4:	6810      	ldr	r0, [r2, #0]
  4099d6:	6018      	str	r0, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  4099d8:	6011      	str	r1, [r2, #0]
			xNumOfOverflows++;
  4099da:	4936      	ldr	r1, [pc, #216]	; (409ab4 <vTaskIncrementTick+0x108>)
  4099dc:	680a      	ldr	r2, [r1, #0]
  4099de:	3201      	adds	r2, #1
  4099e0:	600a      	str	r2, [r1, #0]
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  4099e2:	681b      	ldr	r3, [r3, #0]
  4099e4:	681b      	ldr	r3, [r3, #0]
  4099e6:	b9fb      	cbnz	r3, 409a28 <vTaskIncrementTick+0x7c>
				xNextTaskUnblockTime = portMAX_DELAY;
  4099e8:	f04f 32ff 	mov.w	r2, #4294967295
  4099ec:	4b32      	ldr	r3, [pc, #200]	; (409ab8 <vTaskIncrementTick+0x10c>)
  4099ee:	601a      	str	r2, [r3, #0]
		prvCheckDelayedTasks();
  4099f0:	4b2d      	ldr	r3, [pc, #180]	; (409aa8 <vTaskIncrementTick+0xfc>)
  4099f2:	681a      	ldr	r2, [r3, #0]
  4099f4:	4b30      	ldr	r3, [pc, #192]	; (409ab8 <vTaskIncrementTick+0x10c>)
  4099f6:	681b      	ldr	r3, [r3, #0]
  4099f8:	429a      	cmp	r2, r3
  4099fa:	d350      	bcc.n	409a9e <vTaskIncrementTick+0xf2>
  4099fc:	4b2b      	ldr	r3, [pc, #172]	; (409aac <vTaskIncrementTick+0x100>)
  4099fe:	681b      	ldr	r3, [r3, #0]
  409a00:	681b      	ldr	r3, [r3, #0]
  409a02:	b1cb      	cbz	r3, 409a38 <vTaskIncrementTick+0x8c>
  409a04:	4b29      	ldr	r3, [pc, #164]	; (409aac <vTaskIncrementTick+0x100>)
  409a06:	681b      	ldr	r3, [r3, #0]
  409a08:	68db      	ldr	r3, [r3, #12]
  409a0a:	68dc      	ldr	r4, [r3, #12]
  409a0c:	6863      	ldr	r3, [r4, #4]
  409a0e:	4a26      	ldr	r2, [pc, #152]	; (409aa8 <vTaskIncrementTick+0xfc>)
  409a10:	6812      	ldr	r2, [r2, #0]
  409a12:	4293      	cmp	r3, r2
  409a14:	d816      	bhi.n	409a44 <vTaskIncrementTick+0x98>
  409a16:	4e29      	ldr	r6, [pc, #164]	; (409abc <vTaskIncrementTick+0x110>)
  409a18:	4f29      	ldr	r7, [pc, #164]	; (409ac0 <vTaskIncrementTick+0x114>)
  409a1a:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 409ad0 <vTaskIncrementTick+0x124>
  409a1e:	e02f      	b.n	409a80 <vTaskIncrementTick+0xd4>
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
  409a20:	4b28      	ldr	r3, [pc, #160]	; (409ac4 <vTaskIncrementTick+0x118>)
  409a22:	4798      	blx	r3
  409a24:	bf00      	nop
  409a26:	e7fd      	b.n	409a24 <vTaskIncrementTick+0x78>
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  409a28:	4b20      	ldr	r3, [pc, #128]	; (409aac <vTaskIncrementTick+0x100>)
  409a2a:	681b      	ldr	r3, [r3, #0]
  409a2c:	68db      	ldr	r3, [r3, #12]
  409a2e:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  409a30:	685a      	ldr	r2, [r3, #4]
  409a32:	4b21      	ldr	r3, [pc, #132]	; (409ab8 <vTaskIncrementTick+0x10c>)
  409a34:	601a      	str	r2, [r3, #0]
  409a36:	e7db      	b.n	4099f0 <vTaskIncrementTick+0x44>
		prvCheckDelayedTasks();
  409a38:	f04f 32ff 	mov.w	r2, #4294967295
  409a3c:	4b1e      	ldr	r3, [pc, #120]	; (409ab8 <vTaskIncrementTick+0x10c>)
  409a3e:	601a      	str	r2, [r3, #0]
  409a40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409a44:	4a1c      	ldr	r2, [pc, #112]	; (409ab8 <vTaskIncrementTick+0x10c>)
  409a46:	6013      	str	r3, [r2, #0]
  409a48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409a4c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  409a4e:	683b      	ldr	r3, [r7, #0]
  409a50:	4298      	cmp	r0, r3
  409a52:	bf88      	it	hi
  409a54:	6038      	strhi	r0, [r7, #0]
  409a56:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  409a5a:	4629      	mov	r1, r5
  409a5c:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  409a60:	4b19      	ldr	r3, [pc, #100]	; (409ac8 <vTaskIncrementTick+0x11c>)
  409a62:	4798      	blx	r3
  409a64:	4b11      	ldr	r3, [pc, #68]	; (409aac <vTaskIncrementTick+0x100>)
  409a66:	681b      	ldr	r3, [r3, #0]
  409a68:	681b      	ldr	r3, [r3, #0]
  409a6a:	2b00      	cmp	r3, #0
  409a6c:	d0e4      	beq.n	409a38 <vTaskIncrementTick+0x8c>
  409a6e:	4b0f      	ldr	r3, [pc, #60]	; (409aac <vTaskIncrementTick+0x100>)
  409a70:	681b      	ldr	r3, [r3, #0]
  409a72:	68db      	ldr	r3, [r3, #12]
  409a74:	68dc      	ldr	r4, [r3, #12]
  409a76:	6863      	ldr	r3, [r4, #4]
  409a78:	4a0b      	ldr	r2, [pc, #44]	; (409aa8 <vTaskIncrementTick+0xfc>)
  409a7a:	6812      	ldr	r2, [r2, #0]
  409a7c:	4293      	cmp	r3, r2
  409a7e:	d8e1      	bhi.n	409a44 <vTaskIncrementTick+0x98>
  409a80:	1d25      	adds	r5, r4, #4
  409a82:	4628      	mov	r0, r5
  409a84:	47b0      	blx	r6
  409a86:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  409a88:	2b00      	cmp	r3, #0
  409a8a:	d0df      	beq.n	409a4c <vTaskIncrementTick+0xa0>
  409a8c:	f104 0018 	add.w	r0, r4, #24
  409a90:	47b0      	blx	r6
  409a92:	e7db      	b.n	409a4c <vTaskIncrementTick+0xa0>
		++uxMissedTicks;
  409a94:	4a0d      	ldr	r2, [pc, #52]	; (409acc <vTaskIncrementTick+0x120>)
  409a96:	6813      	ldr	r3, [r2, #0]
  409a98:	3301      	adds	r3, #1
  409a9a:	6013      	str	r3, [r2, #0]
}
  409a9c:	4770      	bx	lr
  409a9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409aa2:	bf00      	nop
  409aa4:	200116b0 	.word	0x200116b0
  409aa8:	20011734 	.word	0x20011734
  409aac:	2001163c 	.word	0x2001163c
  409ab0:	20011640 	.word	0x20011640
  409ab4:	200116f0 	.word	0x200116f0
  409ab8:	20000014 	.word	0x20000014
  409abc:	00408cd9 	.word	0x00408cd9
  409ac0:	200116bc 	.word	0x200116bc
  409ac4:	00408d79 	.word	0x00408d79
  409ac8:	00408c81 	.word	0x00408c81
  409acc:	200116ac 	.word	0x200116ac
  409ad0:	20011644 	.word	0x20011644

00409ad4 <xTaskResumeAll>:
{
  409ad4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
  409ad8:	4b2f      	ldr	r3, [pc, #188]	; (409b98 <xTaskResumeAll+0xc4>)
  409ada:	681b      	ldr	r3, [r3, #0]
  409adc:	b91b      	cbnz	r3, 409ae6 <xTaskResumeAll+0x12>
  409ade:	4b2f      	ldr	r3, [pc, #188]	; (409b9c <xTaskResumeAll+0xc8>)
  409ae0:	4798      	blx	r3
  409ae2:	bf00      	nop
  409ae4:	e7fd      	b.n	409ae2 <xTaskResumeAll+0xe>
	taskENTER_CRITICAL();
  409ae6:	4b2e      	ldr	r3, [pc, #184]	; (409ba0 <xTaskResumeAll+0xcc>)
  409ae8:	4798      	blx	r3
		--uxSchedulerSuspended;
  409aea:	4b2b      	ldr	r3, [pc, #172]	; (409b98 <xTaskResumeAll+0xc4>)
  409aec:	681a      	ldr	r2, [r3, #0]
  409aee:	3a01      	subs	r2, #1
  409af0:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  409af2:	681b      	ldr	r3, [r3, #0]
  409af4:	2b00      	cmp	r3, #0
  409af6:	d14d      	bne.n	409b94 <xTaskResumeAll+0xc0>
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  409af8:	4b2a      	ldr	r3, [pc, #168]	; (409ba4 <xTaskResumeAll+0xd0>)
  409afa:	681b      	ldr	r3, [r3, #0]
  409afc:	b12b      	cbz	r3, 409b0a <xTaskResumeAll+0x36>
  409afe:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  409b00:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 409bd0 <xTaskResumeAll+0xfc>
					uxListRemove( &( pxTCB->xEventListItem ) );
  409b04:	4f28      	ldr	r7, [pc, #160]	; (409ba8 <xTaskResumeAll+0xd4>)
					prvAddTaskToReadyQueue( pxTCB );
  409b06:	4e29      	ldr	r6, [pc, #164]	; (409bac <xTaskResumeAll+0xd8>)
  409b08:	e023      	b.n	409b52 <xTaskResumeAll+0x7e>
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  409b0a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
  409b0c:	4b28      	ldr	r3, [pc, #160]	; (409bb0 <xTaskResumeAll+0xdc>)
  409b0e:	4798      	blx	r3
}
  409b10:	4620      	mov	r0, r4
  409b12:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  409b16:	f8d8 300c 	ldr.w	r3, [r8, #12]
  409b1a:	68dd      	ldr	r5, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
  409b1c:	f105 0018 	add.w	r0, r5, #24
  409b20:	47b8      	blx	r7
					uxListRemove( &( pxTCB->xGenericListItem ) );
  409b22:	f105 0904 	add.w	r9, r5, #4
  409b26:	4648      	mov	r0, r9
  409b28:	47b8      	blx	r7
					prvAddTaskToReadyQueue( pxTCB );
  409b2a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
  409b2c:	6833      	ldr	r3, [r6, #0]
  409b2e:	4298      	cmp	r0, r3
  409b30:	bf88      	it	hi
  409b32:	6030      	strhi	r0, [r6, #0]
  409b34:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  409b38:	4649      	mov	r1, r9
  409b3a:	4b1e      	ldr	r3, [pc, #120]	; (409bb4 <xTaskResumeAll+0xe0>)
  409b3c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  409b40:	4b1d      	ldr	r3, [pc, #116]	; (409bb8 <xTaskResumeAll+0xe4>)
  409b42:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  409b44:	4b1d      	ldr	r3, [pc, #116]	; (409bbc <xTaskResumeAll+0xe8>)
  409b46:	681b      	ldr	r3, [r3, #0]
  409b48:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  409b4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
						xYieldRequired = pdTRUE;
  409b4c:	429a      	cmp	r2, r3
  409b4e:	bf28      	it	cs
  409b50:	2401      	movcs	r4, #1
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  409b52:	f8d8 3000 	ldr.w	r3, [r8]
  409b56:	2b00      	cmp	r3, #0
  409b58:	d1dd      	bne.n	409b16 <xTaskResumeAll+0x42>
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  409b5a:	4b19      	ldr	r3, [pc, #100]	; (409bc0 <xTaskResumeAll+0xec>)
  409b5c:	681b      	ldr	r3, [r3, #0]
  409b5e:	b193      	cbz	r3, 409b86 <xTaskResumeAll+0xb2>
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  409b60:	4b17      	ldr	r3, [pc, #92]	; (409bc0 <xTaskResumeAll+0xec>)
  409b62:	681b      	ldr	r3, [r3, #0]
  409b64:	b143      	cbz	r3, 409b78 <xTaskResumeAll+0xa4>
						vTaskIncrementTick();
  409b66:	4d17      	ldr	r5, [pc, #92]	; (409bc4 <xTaskResumeAll+0xf0>)
						--uxMissedTicks;
  409b68:	4c15      	ldr	r4, [pc, #84]	; (409bc0 <xTaskResumeAll+0xec>)
						vTaskIncrementTick();
  409b6a:	47a8      	blx	r5
						--uxMissedTicks;
  409b6c:	6823      	ldr	r3, [r4, #0]
  409b6e:	3b01      	subs	r3, #1
  409b70:	6023      	str	r3, [r4, #0]
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  409b72:	6823      	ldr	r3, [r4, #0]
  409b74:	2b00      	cmp	r3, #0
  409b76:	d1f8      	bne.n	409b6a <xTaskResumeAll+0x96>
					xMissedYield = pdFALSE;
  409b78:	2200      	movs	r2, #0
  409b7a:	4b13      	ldr	r3, [pc, #76]	; (409bc8 <xTaskResumeAll+0xf4>)
  409b7c:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
  409b7e:	4b13      	ldr	r3, [pc, #76]	; (409bcc <xTaskResumeAll+0xf8>)
  409b80:	4798      	blx	r3
					xAlreadyYielded = pdTRUE;
  409b82:	2401      	movs	r4, #1
  409b84:	e7c2      	b.n	409b0c <xTaskResumeAll+0x38>
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  409b86:	2c01      	cmp	r4, #1
  409b88:	d0f6      	beq.n	409b78 <xTaskResumeAll+0xa4>
  409b8a:	4b0f      	ldr	r3, [pc, #60]	; (409bc8 <xTaskResumeAll+0xf4>)
  409b8c:	681b      	ldr	r3, [r3, #0]
  409b8e:	2b01      	cmp	r3, #1
  409b90:	d1bc      	bne.n	409b0c <xTaskResumeAll+0x38>
  409b92:	e7f1      	b.n	409b78 <xTaskResumeAll+0xa4>
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  409b94:	2400      	movs	r4, #0
  409b96:	e7b9      	b.n	409b0c <xTaskResumeAll+0x38>
  409b98:	200116b0 	.word	0x200116b0
  409b9c:	00408d79 	.word	0x00408d79
  409ba0:	00408d89 	.word	0x00408d89
  409ba4:	200116a8 	.word	0x200116a8
  409ba8:	00408cd9 	.word	0x00408cd9
  409bac:	200116bc 	.word	0x200116bc
  409bb0:	00408da9 	.word	0x00408da9
  409bb4:	20011644 	.word	0x20011644
  409bb8:	00408c81 	.word	0x00408c81
  409bbc:	20011638 	.word	0x20011638
  409bc0:	200116ac 	.word	0x200116ac
  409bc4:	004099ad 	.word	0x004099ad
  409bc8:	200116ec 	.word	0x200116ec
  409bcc:	00408d69 	.word	0x00408d69
  409bd0:	200116f4 	.word	0x200116f4

00409bd4 <vTaskDelay>:
	{
  409bd4:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( portTickType ) 0U )
  409bd6:	b910      	cbnz	r0, 409bde <vTaskDelay+0xa>
			portYIELD_WITHIN_API();
  409bd8:	4b0a      	ldr	r3, [pc, #40]	; (409c04 <vTaskDelay+0x30>)
  409bda:	4798      	blx	r3
  409bdc:	bd10      	pop	{r4, pc}
  409bde:	4604      	mov	r4, r0
			vTaskSuspendAll();
  409be0:	4b09      	ldr	r3, [pc, #36]	; (409c08 <vTaskDelay+0x34>)
  409be2:	4798      	blx	r3
				xTimeToWake = xTickCount + xTicksToDelay;
  409be4:	4b09      	ldr	r3, [pc, #36]	; (409c0c <vTaskDelay+0x38>)
  409be6:	681b      	ldr	r3, [r3, #0]
  409be8:	441c      	add	r4, r3
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  409bea:	4b09      	ldr	r3, [pc, #36]	; (409c10 <vTaskDelay+0x3c>)
  409bec:	6818      	ldr	r0, [r3, #0]
  409bee:	3004      	adds	r0, #4
  409bf0:	4b08      	ldr	r3, [pc, #32]	; (409c14 <vTaskDelay+0x40>)
  409bf2:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTimeToWake );
  409bf4:	4620      	mov	r0, r4
  409bf6:	4b08      	ldr	r3, [pc, #32]	; (409c18 <vTaskDelay+0x44>)
  409bf8:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
  409bfa:	4b08      	ldr	r3, [pc, #32]	; (409c1c <vTaskDelay+0x48>)
  409bfc:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
  409bfe:	2800      	cmp	r0, #0
  409c00:	d1ec      	bne.n	409bdc <vTaskDelay+0x8>
  409c02:	e7e9      	b.n	409bd8 <vTaskDelay+0x4>
  409c04:	00408d69 	.word	0x00408d69
  409c08:	0040997d 	.word	0x0040997d
  409c0c:	20011734 	.word	0x20011734
  409c10:	20011638 	.word	0x20011638
  409c14:	00408cd9 	.word	0x00408cd9
  409c18:	00409601 	.word	0x00409601
  409c1c:	00409ad5 	.word	0x00409ad5

00409c20 <prvIdleTask>:
{
  409c20:	b580      	push	{r7, lr}
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  409c22:	4d16      	ldr	r5, [pc, #88]	; (409c7c <prvIdleTask+0x5c>)
			vTaskSuspendAll();
  409c24:	f8df 8078 	ldr.w	r8, [pc, #120]	; 409ca0 <prvIdleTask+0x80>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  409c28:	4e15      	ldr	r6, [pc, #84]	; (409c80 <prvIdleTask+0x60>)
  409c2a:	e024      	b.n	409c76 <prvIdleTask+0x56>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  409c2c:	4b15      	ldr	r3, [pc, #84]	; (409c84 <prvIdleTask+0x64>)
  409c2e:	681b      	ldr	r3, [r3, #0]
  409c30:	2b01      	cmp	r3, #1
  409c32:	d81e      	bhi.n	409c72 <prvIdleTask+0x52>
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  409c34:	682b      	ldr	r3, [r5, #0]
  409c36:	2b00      	cmp	r3, #0
  409c38:	d0f8      	beq.n	409c2c <prvIdleTask+0xc>
			vTaskSuspendAll();
  409c3a:	47c0      	blx	r8
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  409c3c:	6834      	ldr	r4, [r6, #0]
			xTaskResumeAll();
  409c3e:	47b8      	blx	r7
			if( xListIsEmpty == pdFALSE )
  409c40:	2c00      	cmp	r4, #0
  409c42:	d0f7      	beq.n	409c34 <prvIdleTask+0x14>
				taskENTER_CRITICAL();
  409c44:	4b10      	ldr	r3, [pc, #64]	; (409c88 <prvIdleTask+0x68>)
  409c46:	4798      	blx	r3
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
  409c48:	68f3      	ldr	r3, [r6, #12]
  409c4a:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xGenericListItem ) );
  409c4c:	1d20      	adds	r0, r4, #4
  409c4e:	4b0f      	ldr	r3, [pc, #60]	; (409c8c <prvIdleTask+0x6c>)
  409c50:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  409c52:	4a0f      	ldr	r2, [pc, #60]	; (409c90 <prvIdleTask+0x70>)
  409c54:	6813      	ldr	r3, [r2, #0]
  409c56:	3b01      	subs	r3, #1
  409c58:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
  409c5a:	682b      	ldr	r3, [r5, #0]
  409c5c:	3b01      	subs	r3, #1
  409c5e:	602b      	str	r3, [r5, #0]
				taskEXIT_CRITICAL();
  409c60:	4b0c      	ldr	r3, [pc, #48]	; (409c94 <prvIdleTask+0x74>)
  409c62:	4798      	blx	r3
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  409c64:	6b20      	ldr	r0, [r4, #48]	; 0x30
  409c66:	f8df 903c 	ldr.w	r9, [pc, #60]	; 409ca4 <prvIdleTask+0x84>
  409c6a:	47c8      	blx	r9
		vPortFree( pxTCB );
  409c6c:	4620      	mov	r0, r4
  409c6e:	47c8      	blx	r9
  409c70:	e7e0      	b.n	409c34 <prvIdleTask+0x14>
				taskYIELD();
  409c72:	4b09      	ldr	r3, [pc, #36]	; (409c98 <prvIdleTask+0x78>)
  409c74:	4798      	blx	r3
			xTaskResumeAll();
  409c76:	4f09      	ldr	r7, [pc, #36]	; (409c9c <prvIdleTask+0x7c>)
  409c78:	e7dc      	b.n	409c34 <prvIdleTask+0x14>
  409c7a:	bf00      	nop
  409c7c:	200116b8 	.word	0x200116b8
  409c80:	20011720 	.word	0x20011720
  409c84:	20011644 	.word	0x20011644
  409c88:	00408d89 	.word	0x00408d89
  409c8c:	00408cd9 	.word	0x00408cd9
  409c90:	200116a8 	.word	0x200116a8
  409c94:	00408da9 	.word	0x00408da9
  409c98:	00408d69 	.word	0x00408d69
  409c9c:	00409ad5 	.word	0x00409ad5
  409ca0:	0040997d 	.word	0x0040997d
  409ca4:	00408fd9 	.word	0x00408fd9

00409ca8 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  409ca8:	4b21      	ldr	r3, [pc, #132]	; (409d30 <vTaskSwitchContext+0x88>)
  409caa:	681b      	ldr	r3, [r3, #0]
  409cac:	b9eb      	cbnz	r3, 409cea <vTaskSwitchContext+0x42>
{
  409cae:	b510      	push	{r4, lr}
		taskSELECT_HIGHEST_PRIORITY_TASK();
  409cb0:	4b20      	ldr	r3, [pc, #128]	; (409d34 <vTaskSwitchContext+0x8c>)
  409cb2:	681b      	ldr	r3, [r3, #0]
  409cb4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  409cb8:	009b      	lsls	r3, r3, #2
  409cba:	4a1f      	ldr	r2, [pc, #124]	; (409d38 <vTaskSwitchContext+0x90>)
  409cbc:	58d3      	ldr	r3, [r2, r3]
  409cbe:	b9c3      	cbnz	r3, 409cf2 <vTaskSwitchContext+0x4a>
  409cc0:	4b1c      	ldr	r3, [pc, #112]	; (409d34 <vTaskSwitchContext+0x8c>)
  409cc2:	681b      	ldr	r3, [r3, #0]
  409cc4:	b16b      	cbz	r3, 409ce2 <vTaskSwitchContext+0x3a>
  409cc6:	4a1b      	ldr	r2, [pc, #108]	; (409d34 <vTaskSwitchContext+0x8c>)
  409cc8:	491b      	ldr	r1, [pc, #108]	; (409d38 <vTaskSwitchContext+0x90>)
  409cca:	6813      	ldr	r3, [r2, #0]
  409ccc:	3b01      	subs	r3, #1
  409cce:	6013      	str	r3, [r2, #0]
  409cd0:	6813      	ldr	r3, [r2, #0]
  409cd2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  409cd6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  409cda:	b953      	cbnz	r3, 409cf2 <vTaskSwitchContext+0x4a>
  409cdc:	6813      	ldr	r3, [r2, #0]
  409cde:	2b00      	cmp	r3, #0
  409ce0:	d1f3      	bne.n	409cca <vTaskSwitchContext+0x22>
  409ce2:	4b16      	ldr	r3, [pc, #88]	; (409d3c <vTaskSwitchContext+0x94>)
  409ce4:	4798      	blx	r3
  409ce6:	bf00      	nop
  409ce8:	e7fd      	b.n	409ce6 <vTaskSwitchContext+0x3e>
		xMissedYield = pdTRUE;
  409cea:	2201      	movs	r2, #1
  409cec:	4b14      	ldr	r3, [pc, #80]	; (409d40 <vTaskSwitchContext+0x98>)
  409cee:	601a      	str	r2, [r3, #0]
  409cf0:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
  409cf2:	4b10      	ldr	r3, [pc, #64]	; (409d34 <vTaskSwitchContext+0x8c>)
  409cf4:	681b      	ldr	r3, [r3, #0]
  409cf6:	4a10      	ldr	r2, [pc, #64]	; (409d38 <vTaskSwitchContext+0x90>)
  409cf8:	0099      	lsls	r1, r3, #2
  409cfa:	18c8      	adds	r0, r1, r3
  409cfc:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  409d00:	6844      	ldr	r4, [r0, #4]
  409d02:	6864      	ldr	r4, [r4, #4]
  409d04:	6044      	str	r4, [r0, #4]
  409d06:	4419      	add	r1, r3
  409d08:	4602      	mov	r2, r0
  409d0a:	3208      	adds	r2, #8
  409d0c:	4294      	cmp	r4, r2
  409d0e:	d009      	beq.n	409d24 <vTaskSwitchContext+0x7c>
  409d10:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  409d14:	4a08      	ldr	r2, [pc, #32]	; (409d38 <vTaskSwitchContext+0x90>)
  409d16:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  409d1a:	685b      	ldr	r3, [r3, #4]
  409d1c:	68da      	ldr	r2, [r3, #12]
  409d1e:	4b09      	ldr	r3, [pc, #36]	; (409d44 <vTaskSwitchContext+0x9c>)
  409d20:	601a      	str	r2, [r3, #0]
  409d22:	bd10      	pop	{r4, pc}
  409d24:	6860      	ldr	r0, [r4, #4]
  409d26:	4a04      	ldr	r2, [pc, #16]	; (409d38 <vTaskSwitchContext+0x90>)
  409d28:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  409d2c:	6050      	str	r0, [r2, #4]
  409d2e:	e7ef      	b.n	409d10 <vTaskSwitchContext+0x68>
  409d30:	200116b0 	.word	0x200116b0
  409d34:	200116bc 	.word	0x200116bc
  409d38:	20011644 	.word	0x20011644
  409d3c:	00408d79 	.word	0x00408d79
  409d40:	200116ec 	.word	0x200116ec
  409d44:	20011638 	.word	0x20011638

00409d48 <vTaskSuspend>:
	{
  409d48:	b538      	push	{r3, r4, r5, lr}
  409d4a:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
  409d4c:	4b25      	ldr	r3, [pc, #148]	; (409de4 <vTaskSuspend+0x9c>)
  409d4e:	4798      	blx	r3
			if( pxTaskToSuspend == pxCurrentTCB )
  409d50:	4b25      	ldr	r3, [pc, #148]	; (409de8 <vTaskSuspend+0xa0>)
  409d52:	681b      	ldr	r3, [r3, #0]
  409d54:	42a3      	cmp	r3, r4
  409d56:	d012      	beq.n	409d7e <vTaskSuspend+0x36>
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
  409d58:	b18c      	cbz	r4, 409d7e <vTaskSuspend+0x36>
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  409d5a:	1d25      	adds	r5, r4, #4
  409d5c:	4628      	mov	r0, r5
  409d5e:	4b23      	ldr	r3, [pc, #140]	; (409dec <vTaskSuspend+0xa4>)
  409d60:	4798      	blx	r3
			if( pxTCB->xEventListItem.pvContainer != NULL )
  409d62:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  409d64:	2b00      	cmp	r3, #0
  409d66:	d02b      	beq.n	409dc0 <vTaskSuspend+0x78>
				uxListRemove( &( pxTCB->xEventListItem ) );
  409d68:	f104 0018 	add.w	r0, r4, #24
  409d6c:	4b1f      	ldr	r3, [pc, #124]	; (409dec <vTaskSuspend+0xa4>)
  409d6e:	4798      	blx	r3
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
  409d70:	4629      	mov	r1, r5
  409d72:	481f      	ldr	r0, [pc, #124]	; (409df0 <vTaskSuspend+0xa8>)
  409d74:	4b1f      	ldr	r3, [pc, #124]	; (409df4 <vTaskSuspend+0xac>)
  409d76:	4798      	blx	r3
		taskEXIT_CRITICAL();
  409d78:	4b1f      	ldr	r3, [pc, #124]	; (409df8 <vTaskSuspend+0xb0>)
  409d7a:	4798      	blx	r3
  409d7c:	bd38      	pop	{r3, r4, r5, pc}
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
  409d7e:	4b1a      	ldr	r3, [pc, #104]	; (409de8 <vTaskSuspend+0xa0>)
  409d80:	681d      	ldr	r5, [r3, #0]
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  409d82:	1d2c      	adds	r4, r5, #4
  409d84:	4620      	mov	r0, r4
  409d86:	4b19      	ldr	r3, [pc, #100]	; (409dec <vTaskSuspend+0xa4>)
  409d88:	4798      	blx	r3
			if( pxTCB->xEventListItem.pvContainer != NULL )
  409d8a:	6aab      	ldr	r3, [r5, #40]	; 0x28
  409d8c:	b9fb      	cbnz	r3, 409dce <vTaskSuspend+0x86>
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
  409d8e:	4621      	mov	r1, r4
  409d90:	4817      	ldr	r0, [pc, #92]	; (409df0 <vTaskSuspend+0xa8>)
  409d92:	4b18      	ldr	r3, [pc, #96]	; (409df4 <vTaskSuspend+0xac>)
  409d94:	4798      	blx	r3
		taskEXIT_CRITICAL();
  409d96:	4b18      	ldr	r3, [pc, #96]	; (409df8 <vTaskSuspend+0xb0>)
  409d98:	4798      	blx	r3
			if( xSchedulerRunning != pdFALSE )
  409d9a:	4b18      	ldr	r3, [pc, #96]	; (409dfc <vTaskSuspend+0xb4>)
  409d9c:	681b      	ldr	r3, [r3, #0]
  409d9e:	b943      	cbnz	r3, 409db2 <vTaskSuspend+0x6a>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
  409da0:	4b13      	ldr	r3, [pc, #76]	; (409df0 <vTaskSuspend+0xa8>)
  409da2:	681a      	ldr	r2, [r3, #0]
  409da4:	4b16      	ldr	r3, [pc, #88]	; (409e00 <vTaskSuspend+0xb8>)
  409da6:	681b      	ldr	r3, [r3, #0]
  409da8:	429a      	cmp	r2, r3
  409daa:	d005      	beq.n	409db8 <vTaskSuspend+0x70>
					vTaskSwitchContext();
  409dac:	4b15      	ldr	r3, [pc, #84]	; (409e04 <vTaskSuspend+0xbc>)
  409dae:	4798      	blx	r3
	}
  409db0:	bd38      	pop	{r3, r4, r5, pc}
				portYIELD_WITHIN_API();
  409db2:	4b15      	ldr	r3, [pc, #84]	; (409e08 <vTaskSuspend+0xc0>)
  409db4:	4798      	blx	r3
  409db6:	bd38      	pop	{r3, r4, r5, pc}
					pxCurrentTCB = NULL;
  409db8:	2200      	movs	r2, #0
  409dba:	4b0b      	ldr	r3, [pc, #44]	; (409de8 <vTaskSuspend+0xa0>)
  409dbc:	601a      	str	r2, [r3, #0]
  409dbe:	bd38      	pop	{r3, r4, r5, pc}
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
  409dc0:	4629      	mov	r1, r5
  409dc2:	480b      	ldr	r0, [pc, #44]	; (409df0 <vTaskSuspend+0xa8>)
  409dc4:	4b0b      	ldr	r3, [pc, #44]	; (409df4 <vTaskSuspend+0xac>)
  409dc6:	4798      	blx	r3
		taskEXIT_CRITICAL();
  409dc8:	4b0b      	ldr	r3, [pc, #44]	; (409df8 <vTaskSuspend+0xb0>)
  409dca:	4798      	blx	r3
  409dcc:	bd38      	pop	{r3, r4, r5, pc}
				uxListRemove( &( pxTCB->xEventListItem ) );
  409dce:	f105 0018 	add.w	r0, r5, #24
  409dd2:	4b06      	ldr	r3, [pc, #24]	; (409dec <vTaskSuspend+0xa4>)
  409dd4:	4798      	blx	r3
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
  409dd6:	4621      	mov	r1, r4
  409dd8:	4805      	ldr	r0, [pc, #20]	; (409df0 <vTaskSuspend+0xa8>)
  409dda:	4b06      	ldr	r3, [pc, #24]	; (409df4 <vTaskSuspend+0xac>)
  409ddc:	4798      	blx	r3
		taskEXIT_CRITICAL();
  409dde:	4b06      	ldr	r3, [pc, #24]	; (409df8 <vTaskSuspend+0xb0>)
  409de0:	4798      	blx	r3
  409de2:	e7da      	b.n	409d9a <vTaskSuspend+0x52>
  409de4:	00408d89 	.word	0x00408d89
  409de8:	20011638 	.word	0x20011638
  409dec:	00408cd9 	.word	0x00408cd9
  409df0:	2001170c 	.word	0x2001170c
  409df4:	00408c81 	.word	0x00408c81
  409df8:	00408da9 	.word	0x00408da9
  409dfc:	20011708 	.word	0x20011708
  409e00:	200116a8 	.word	0x200116a8
  409e04:	00409ca9 	.word	0x00409ca9
  409e08:	00408d69 	.word	0x00408d69

00409e0c <vTaskPlaceOnEventList>:
{
  409e0c:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxEventList );
  409e0e:	b190      	cbz	r0, 409e36 <vTaskPlaceOnEventList+0x2a>
  409e10:	460c      	mov	r4, r1
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  409e12:	4d0e      	ldr	r5, [pc, #56]	; (409e4c <vTaskPlaceOnEventList+0x40>)
  409e14:	6829      	ldr	r1, [r5, #0]
  409e16:	3118      	adds	r1, #24
  409e18:	4b0d      	ldr	r3, [pc, #52]	; (409e50 <vTaskPlaceOnEventList+0x44>)
  409e1a:	4798      	blx	r3
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  409e1c:	6828      	ldr	r0, [r5, #0]
  409e1e:	3004      	adds	r0, #4
  409e20:	4b0c      	ldr	r3, [pc, #48]	; (409e54 <vTaskPlaceOnEventList+0x48>)
  409e22:	4798      	blx	r3
		if( xTicksToWait == portMAX_DELAY )
  409e24:	f1b4 3fff 	cmp.w	r4, #4294967295
  409e28:	d009      	beq.n	409e3e <vTaskPlaceOnEventList+0x32>
			xTimeToWake = xTickCount + xTicksToWait;
  409e2a:	4b0b      	ldr	r3, [pc, #44]	; (409e58 <vTaskPlaceOnEventList+0x4c>)
  409e2c:	6818      	ldr	r0, [r3, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  409e2e:	4420      	add	r0, r4
  409e30:	4b0a      	ldr	r3, [pc, #40]	; (409e5c <vTaskPlaceOnEventList+0x50>)
  409e32:	4798      	blx	r3
  409e34:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxEventList );
  409e36:	4b0a      	ldr	r3, [pc, #40]	; (409e60 <vTaskPlaceOnEventList+0x54>)
  409e38:	4798      	blx	r3
  409e3a:	bf00      	nop
  409e3c:	e7fd      	b.n	409e3a <vTaskPlaceOnEventList+0x2e>
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  409e3e:	6829      	ldr	r1, [r5, #0]
  409e40:	3104      	adds	r1, #4
  409e42:	4808      	ldr	r0, [pc, #32]	; (409e64 <vTaskPlaceOnEventList+0x58>)
  409e44:	4b08      	ldr	r3, [pc, #32]	; (409e68 <vTaskPlaceOnEventList+0x5c>)
  409e46:	4798      	blx	r3
  409e48:	bd38      	pop	{r3, r4, r5, pc}
  409e4a:	bf00      	nop
  409e4c:	20011638 	.word	0x20011638
  409e50:	00408c9d 	.word	0x00408c9d
  409e54:	00408cd9 	.word	0x00408cd9
  409e58:	20011734 	.word	0x20011734
  409e5c:	00409601 	.word	0x00409601
  409e60:	00408d79 	.word	0x00408d79
  409e64:	2001170c 	.word	0x2001170c
  409e68:	00408c81 	.word	0x00408c81

00409e6c <vTaskPlaceOnEventListRestricted>:
	{
  409e6c:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
  409e6e:	b178      	cbz	r0, 409e90 <vTaskPlaceOnEventListRestricted+0x24>
  409e70:	460d      	mov	r5, r1
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  409e72:	4c09      	ldr	r4, [pc, #36]	; (409e98 <vTaskPlaceOnEventListRestricted+0x2c>)
  409e74:	6821      	ldr	r1, [r4, #0]
  409e76:	3118      	adds	r1, #24
  409e78:	4b08      	ldr	r3, [pc, #32]	; (409e9c <vTaskPlaceOnEventListRestricted+0x30>)
  409e7a:	4798      	blx	r3
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  409e7c:	6820      	ldr	r0, [r4, #0]
  409e7e:	3004      	adds	r0, #4
  409e80:	4b07      	ldr	r3, [pc, #28]	; (409ea0 <vTaskPlaceOnEventListRestricted+0x34>)
  409e82:	4798      	blx	r3
		xTimeToWake = xTickCount + xTicksToWait;
  409e84:	4b07      	ldr	r3, [pc, #28]	; (409ea4 <vTaskPlaceOnEventListRestricted+0x38>)
  409e86:	6818      	ldr	r0, [r3, #0]
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  409e88:	4428      	add	r0, r5
  409e8a:	4b07      	ldr	r3, [pc, #28]	; (409ea8 <vTaskPlaceOnEventListRestricted+0x3c>)
  409e8c:	4798      	blx	r3
  409e8e:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pxEventList );
  409e90:	4b06      	ldr	r3, [pc, #24]	; (409eac <vTaskPlaceOnEventListRestricted+0x40>)
  409e92:	4798      	blx	r3
  409e94:	bf00      	nop
  409e96:	e7fd      	b.n	409e94 <vTaskPlaceOnEventListRestricted+0x28>
  409e98:	20011638 	.word	0x20011638
  409e9c:	00408c81 	.word	0x00408c81
  409ea0:	00408cd9 	.word	0x00408cd9
  409ea4:	20011734 	.word	0x20011734
  409ea8:	00409601 	.word	0x00409601
  409eac:	00408d79 	.word	0x00408d79

00409eb0 <xTaskRemoveFromEventList>:
{
  409eb0:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  409eb2:	68c3      	ldr	r3, [r0, #12]
  409eb4:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
  409eb6:	b31c      	cbz	r4, 409f00 <xTaskRemoveFromEventList+0x50>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  409eb8:	f104 0518 	add.w	r5, r4, #24
  409ebc:	4628      	mov	r0, r5
  409ebe:	4b15      	ldr	r3, [pc, #84]	; (409f14 <xTaskRemoveFromEventList+0x64>)
  409ec0:	4798      	blx	r3
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  409ec2:	4b15      	ldr	r3, [pc, #84]	; (409f18 <xTaskRemoveFromEventList+0x68>)
  409ec4:	681b      	ldr	r3, [r3, #0]
  409ec6:	b9fb      	cbnz	r3, 409f08 <xTaskRemoveFromEventList+0x58>
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  409ec8:	1d25      	adds	r5, r4, #4
  409eca:	4628      	mov	r0, r5
  409ecc:	4b11      	ldr	r3, [pc, #68]	; (409f14 <xTaskRemoveFromEventList+0x64>)
  409ece:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  409ed0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  409ed2:	4b12      	ldr	r3, [pc, #72]	; (409f1c <xTaskRemoveFromEventList+0x6c>)
  409ed4:	681b      	ldr	r3, [r3, #0]
  409ed6:	4298      	cmp	r0, r3
  409ed8:	bf84      	itt	hi
  409eda:	4b10      	ldrhi	r3, [pc, #64]	; (409f1c <xTaskRemoveFromEventList+0x6c>)
  409edc:	6018      	strhi	r0, [r3, #0]
  409ede:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  409ee2:	4629      	mov	r1, r5
  409ee4:	4b0e      	ldr	r3, [pc, #56]	; (409f20 <xTaskRemoveFromEventList+0x70>)
  409ee6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  409eea:	4b0e      	ldr	r3, [pc, #56]	; (409f24 <xTaskRemoveFromEventList+0x74>)
  409eec:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  409eee:	4b0e      	ldr	r3, [pc, #56]	; (409f28 <xTaskRemoveFromEventList+0x78>)
  409ef0:	681b      	ldr	r3, [r3, #0]
  409ef2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  409ef4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
  409ef6:	4298      	cmp	r0, r3
  409ef8:	bf34      	ite	cc
  409efa:	2000      	movcc	r0, #0
  409efc:	2001      	movcs	r0, #1
  409efe:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxUnblockedTCB );
  409f00:	4b0a      	ldr	r3, [pc, #40]	; (409f2c <xTaskRemoveFromEventList+0x7c>)
  409f02:	4798      	blx	r3
  409f04:	bf00      	nop
  409f06:	e7fd      	b.n	409f04 <xTaskRemoveFromEventList+0x54>
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  409f08:	4629      	mov	r1, r5
  409f0a:	4809      	ldr	r0, [pc, #36]	; (409f30 <xTaskRemoveFromEventList+0x80>)
  409f0c:	4b05      	ldr	r3, [pc, #20]	; (409f24 <xTaskRemoveFromEventList+0x74>)
  409f0e:	4798      	blx	r3
  409f10:	e7ed      	b.n	409eee <xTaskRemoveFromEventList+0x3e>
  409f12:	bf00      	nop
  409f14:	00408cd9 	.word	0x00408cd9
  409f18:	200116b0 	.word	0x200116b0
  409f1c:	200116bc 	.word	0x200116bc
  409f20:	20011644 	.word	0x20011644
  409f24:	00408c81 	.word	0x00408c81
  409f28:	20011638 	.word	0x20011638
  409f2c:	00408d79 	.word	0x00408d79
  409f30:	200116f4 	.word	0x200116f4

00409f34 <vTaskSetTimeOutState>:
{
  409f34:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
  409f36:	b130      	cbz	r0, 409f46 <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  409f38:	4a05      	ldr	r2, [pc, #20]	; (409f50 <vTaskSetTimeOutState+0x1c>)
  409f3a:	6812      	ldr	r2, [r2, #0]
  409f3c:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  409f3e:	4a05      	ldr	r2, [pc, #20]	; (409f54 <vTaskSetTimeOutState+0x20>)
  409f40:	6812      	ldr	r2, [r2, #0]
  409f42:	6042      	str	r2, [r0, #4]
  409f44:	bd08      	pop	{r3, pc}
	configASSERT( pxTimeOut );
  409f46:	4b04      	ldr	r3, [pc, #16]	; (409f58 <vTaskSetTimeOutState+0x24>)
  409f48:	4798      	blx	r3
  409f4a:	bf00      	nop
  409f4c:	e7fd      	b.n	409f4a <vTaskSetTimeOutState+0x16>
  409f4e:	bf00      	nop
  409f50:	200116f0 	.word	0x200116f0
  409f54:	20011734 	.word	0x20011734
  409f58:	00408d79 	.word	0x00408d79

00409f5c <xTaskCheckForTimeOut>:
{
  409f5c:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxTimeOut );
  409f5e:	b1e8      	cbz	r0, 409f9c <xTaskCheckForTimeOut+0x40>
  409f60:	460d      	mov	r5, r1
  409f62:	4604      	mov	r4, r0
	configASSERT( pxTicksToWait );
  409f64:	b1f1      	cbz	r1, 409fa4 <xTaskCheckForTimeOut+0x48>
	taskENTER_CRITICAL();
  409f66:	4b18      	ldr	r3, [pc, #96]	; (409fc8 <xTaskCheckForTimeOut+0x6c>)
  409f68:	4798      	blx	r3
			if( *pxTicksToWait == portMAX_DELAY )
  409f6a:	682b      	ldr	r3, [r5, #0]
  409f6c:	f1b3 3fff 	cmp.w	r3, #4294967295
  409f70:	d026      	beq.n	409fc0 <xTaskCheckForTimeOut+0x64>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
  409f72:	4a16      	ldr	r2, [pc, #88]	; (409fcc <xTaskCheckForTimeOut+0x70>)
  409f74:	6812      	ldr	r2, [r2, #0]
  409f76:	6821      	ldr	r1, [r4, #0]
  409f78:	4291      	cmp	r1, r2
  409f7a:	d004      	beq.n	409f86 <xTaskCheckForTimeOut+0x2a>
  409f7c:	4a14      	ldr	r2, [pc, #80]	; (409fd0 <xTaskCheckForTimeOut+0x74>)
  409f7e:	6812      	ldr	r2, [r2, #0]
  409f80:	6861      	ldr	r1, [r4, #4]
  409f82:	4291      	cmp	r1, r2
  409f84:	d91e      	bls.n	409fc4 <xTaskCheckForTimeOut+0x68>
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  409f86:	4a12      	ldr	r2, [pc, #72]	; (409fd0 <xTaskCheckForTimeOut+0x74>)
  409f88:	6812      	ldr	r2, [r2, #0]
  409f8a:	6861      	ldr	r1, [r4, #4]
  409f8c:	1a52      	subs	r2, r2, r1
  409f8e:	4293      	cmp	r3, r2
  409f90:	d80c      	bhi.n	409fac <xTaskCheckForTimeOut+0x50>
			xReturn = pdTRUE;
  409f92:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
  409f94:	4b0f      	ldr	r3, [pc, #60]	; (409fd4 <xTaskCheckForTimeOut+0x78>)
  409f96:	4798      	blx	r3
}
  409f98:	4620      	mov	r0, r4
  409f9a:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxTimeOut );
  409f9c:	4b0e      	ldr	r3, [pc, #56]	; (409fd8 <xTaskCheckForTimeOut+0x7c>)
  409f9e:	4798      	blx	r3
  409fa0:	bf00      	nop
  409fa2:	e7fd      	b.n	409fa0 <xTaskCheckForTimeOut+0x44>
	configASSERT( pxTicksToWait );
  409fa4:	4b0c      	ldr	r3, [pc, #48]	; (409fd8 <xTaskCheckForTimeOut+0x7c>)
  409fa6:	4798      	blx	r3
  409fa8:	bf00      	nop
  409faa:	e7fd      	b.n	409fa8 <xTaskCheckForTimeOut+0x4c>
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  409fac:	4a08      	ldr	r2, [pc, #32]	; (409fd0 <xTaskCheckForTimeOut+0x74>)
  409fae:	6812      	ldr	r2, [r2, #0]
  409fb0:	1a52      	subs	r2, r2, r1
  409fb2:	1a9b      	subs	r3, r3, r2
  409fb4:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
  409fb6:	4620      	mov	r0, r4
  409fb8:	4b08      	ldr	r3, [pc, #32]	; (409fdc <xTaskCheckForTimeOut+0x80>)
  409fba:	4798      	blx	r3
			xReturn = pdFALSE;
  409fbc:	2400      	movs	r4, #0
  409fbe:	e7e9      	b.n	409f94 <xTaskCheckForTimeOut+0x38>
				xReturn = pdFALSE;
  409fc0:	2400      	movs	r4, #0
  409fc2:	e7e7      	b.n	409f94 <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
  409fc4:	2401      	movs	r4, #1
  409fc6:	e7e5      	b.n	409f94 <xTaskCheckForTimeOut+0x38>
  409fc8:	00408d89 	.word	0x00408d89
  409fcc:	200116f0 	.word	0x200116f0
  409fd0:	20011734 	.word	0x20011734
  409fd4:	00408da9 	.word	0x00408da9
  409fd8:	00408d79 	.word	0x00408d79
  409fdc:	00409f35 	.word	0x00409f35

00409fe0 <vTaskMissedYield>:
	xMissedYield = pdTRUE;
  409fe0:	2201      	movs	r2, #1
  409fe2:	4b01      	ldr	r3, [pc, #4]	; (409fe8 <vTaskMissedYield+0x8>)
  409fe4:	601a      	str	r2, [r3, #0]
  409fe6:	4770      	bx	lr
  409fe8:	200116ec 	.word	0x200116ec

00409fec <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  409fec:	4b01      	ldr	r3, [pc, #4]	; (409ff4 <xTaskGetCurrentTaskHandle+0x8>)
  409fee:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
  409ff0:	4770      	bx	lr
  409ff2:	bf00      	nop
  409ff4:	20011638 	.word	0x20011638

00409ff8 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
  409ff8:	4b05      	ldr	r3, [pc, #20]	; (40a010 <xTaskGetSchedulerState+0x18>)
  409ffa:	681b      	ldr	r3, [r3, #0]
  409ffc:	b133      	cbz	r3, 40a00c <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  409ffe:	4b05      	ldr	r3, [pc, #20]	; (40a014 <xTaskGetSchedulerState+0x1c>)
  40a000:	681b      	ldr	r3, [r3, #0]
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  40a002:	2b00      	cmp	r3, #0
  40a004:	bf0c      	ite	eq
  40a006:	2001      	moveq	r0, #1
  40a008:	2002      	movne	r0, #2
  40a00a:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
  40a00c:	2000      	movs	r0, #0
			}
		}

		return xReturn;
	}
  40a00e:	4770      	bx	lr
  40a010:	20011708 	.word	0x20011708
  40a014:	200116b0 	.word	0x200116b0

0040a018 <vTaskPriorityInherit>:
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  40a018:	2800      	cmp	r0, #0
  40a01a:	d031      	beq.n	40a080 <vTaskPriorityInherit+0x68>
	{
  40a01c:	b538      	push	{r3, r4, r5, lr}
  40a01e:	4605      	mov	r5, r0
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  40a020:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  40a022:	4918      	ldr	r1, [pc, #96]	; (40a084 <vTaskPriorityInherit+0x6c>)
  40a024:	6809      	ldr	r1, [r1, #0]
  40a026:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  40a028:	428b      	cmp	r3, r1
  40a02a:	d211      	bcs.n	40a050 <vTaskPriorityInherit+0x38>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  40a02c:	4915      	ldr	r1, [pc, #84]	; (40a084 <vTaskPriorityInherit+0x6c>)
  40a02e:	6809      	ldr	r1, [r1, #0]
  40a030:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  40a032:	f1c1 0105 	rsb	r1, r1, #5
  40a036:	6181      	str	r1, [r0, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  40a038:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40a03c:	4912      	ldr	r1, [pc, #72]	; (40a088 <vTaskPriorityInherit+0x70>)
  40a03e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
  40a042:	6941      	ldr	r1, [r0, #20]
  40a044:	4299      	cmp	r1, r3
  40a046:	d004      	beq.n	40a052 <vTaskPriorityInherit+0x3a>
					prvAddTaskToReadyQueue( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  40a048:	4b0e      	ldr	r3, [pc, #56]	; (40a084 <vTaskPriorityInherit+0x6c>)
  40a04a:	681b      	ldr	r3, [r3, #0]
  40a04c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40a04e:	62c3      	str	r3, [r0, #44]	; 0x2c
  40a050:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  40a052:	1d04      	adds	r4, r0, #4
  40a054:	4620      	mov	r0, r4
  40a056:	4b0d      	ldr	r3, [pc, #52]	; (40a08c <vTaskPriorityInherit+0x74>)
  40a058:	4798      	blx	r3
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  40a05a:	4b0a      	ldr	r3, [pc, #40]	; (40a084 <vTaskPriorityInherit+0x6c>)
  40a05c:	681b      	ldr	r3, [r3, #0]
  40a05e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  40a060:	62e8      	str	r0, [r5, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
  40a062:	4b0b      	ldr	r3, [pc, #44]	; (40a090 <vTaskPriorityInherit+0x78>)
  40a064:	681b      	ldr	r3, [r3, #0]
  40a066:	4298      	cmp	r0, r3
  40a068:	bf84      	itt	hi
  40a06a:	4b09      	ldrhi	r3, [pc, #36]	; (40a090 <vTaskPriorityInherit+0x78>)
  40a06c:	6018      	strhi	r0, [r3, #0]
  40a06e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40a072:	4621      	mov	r1, r4
  40a074:	4b04      	ldr	r3, [pc, #16]	; (40a088 <vTaskPriorityInherit+0x70>)
  40a076:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  40a07a:	4b06      	ldr	r3, [pc, #24]	; (40a094 <vTaskPriorityInherit+0x7c>)
  40a07c:	4798      	blx	r3
  40a07e:	bd38      	pop	{r3, r4, r5, pc}
  40a080:	4770      	bx	lr
  40a082:	bf00      	nop
  40a084:	20011638 	.word	0x20011638
  40a088:	20011644 	.word	0x20011644
  40a08c:	00408cd9 	.word	0x00408cd9
  40a090:	200116bc 	.word	0x200116bc
  40a094:	00408c81 	.word	0x00408c81

0040a098 <vTaskPriorityDisinherit>:

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
  40a098:	b1e8      	cbz	r0, 40a0d6 <vTaskPriorityDisinherit+0x3e>
	{
  40a09a:	b538      	push	{r3, r4, r5, lr}
  40a09c:	4604      	mov	r4, r0
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  40a09e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  40a0a0:	6c82      	ldr	r2, [r0, #72]	; 0x48
  40a0a2:	4291      	cmp	r1, r2
  40a0a4:	d016      	beq.n	40a0d4 <vTaskPriorityDisinherit+0x3c>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  40a0a6:	1d05      	adds	r5, r0, #4
  40a0a8:	4628      	mov	r0, r5
  40a0aa:	4b0b      	ldr	r3, [pc, #44]	; (40a0d8 <vTaskPriorityDisinherit+0x40>)
  40a0ac:	4798      	blx	r3
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  40a0ae:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  40a0b0:	62e0      	str	r0, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  40a0b2:	f1c0 0305 	rsb	r3, r0, #5
  40a0b6:	61a3      	str	r3, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
  40a0b8:	4b08      	ldr	r3, [pc, #32]	; (40a0dc <vTaskPriorityDisinherit+0x44>)
  40a0ba:	681b      	ldr	r3, [r3, #0]
  40a0bc:	4298      	cmp	r0, r3
  40a0be:	bf84      	itt	hi
  40a0c0:	4b06      	ldrhi	r3, [pc, #24]	; (40a0dc <vTaskPriorityDisinherit+0x44>)
  40a0c2:	6018      	strhi	r0, [r3, #0]
  40a0c4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40a0c8:	4629      	mov	r1, r5
  40a0ca:	4b05      	ldr	r3, [pc, #20]	; (40a0e0 <vTaskPriorityDisinherit+0x48>)
  40a0cc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  40a0d0:	4b04      	ldr	r3, [pc, #16]	; (40a0e4 <vTaskPriorityDisinherit+0x4c>)
  40a0d2:	4798      	blx	r3
  40a0d4:	bd38      	pop	{r3, r4, r5, pc}
  40a0d6:	4770      	bx	lr
  40a0d8:	00408cd9 	.word	0x00408cd9
  40a0dc:	200116bc 	.word	0x200116bc
  40a0e0:	20011644 	.word	0x20011644
  40a0e4:	00408c81 	.word	0x00408c81

0040a0e8 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
  40a0e8:	b508      	push	{r3, lr}
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  40a0ea:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  40a0ec:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
  40a0ee:	4291      	cmp	r1, r2
  40a0f0:	d80c      	bhi.n	40a10c <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
  40a0f2:	1ad2      	subs	r2, r2, r3
  40a0f4:	6983      	ldr	r3, [r0, #24]
  40a0f6:	429a      	cmp	r2, r3
  40a0f8:	d301      	bcc.n	40a0fe <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  40a0fa:	2001      	movs	r0, #1
  40a0fc:	bd08      	pop	{r3, pc}
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  40a0fe:	1d01      	adds	r1, r0, #4
  40a100:	4b09      	ldr	r3, [pc, #36]	; (40a128 <prvInsertTimerInActiveList+0x40>)
  40a102:	6818      	ldr	r0, [r3, #0]
  40a104:	4b09      	ldr	r3, [pc, #36]	; (40a12c <prvInsertTimerInActiveList+0x44>)
  40a106:	4798      	blx	r3
portBASE_TYPE xProcessTimerNow = pdFALSE;
  40a108:	2000      	movs	r0, #0
  40a10a:	bd08      	pop	{r3, pc}
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  40a10c:	429a      	cmp	r2, r3
  40a10e:	d201      	bcs.n	40a114 <prvInsertTimerInActiveList+0x2c>
  40a110:	4299      	cmp	r1, r3
  40a112:	d206      	bcs.n	40a122 <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  40a114:	1d01      	adds	r1, r0, #4
  40a116:	4b06      	ldr	r3, [pc, #24]	; (40a130 <prvInsertTimerInActiveList+0x48>)
  40a118:	6818      	ldr	r0, [r3, #0]
  40a11a:	4b04      	ldr	r3, [pc, #16]	; (40a12c <prvInsertTimerInActiveList+0x44>)
  40a11c:	4798      	blx	r3
portBASE_TYPE xProcessTimerNow = pdFALSE;
  40a11e:	2000      	movs	r0, #0
  40a120:	bd08      	pop	{r3, pc}
			xProcessTimerNow = pdTRUE;
  40a122:	2001      	movs	r0, #1
		}
	}

	return xProcessTimerNow;
}
  40a124:	bd08      	pop	{r3, pc}
  40a126:	bf00      	nop
  40a128:	2001173c 	.word	0x2001173c
  40a12c:	00408c9d 	.word	0x00408c9d
  40a130:	20011738 	.word	0x20011738

0040a134 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  40a134:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  40a136:	4b0d      	ldr	r3, [pc, #52]	; (40a16c <prvCheckForValidListAndQueue+0x38>)
  40a138:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  40a13a:	4b0d      	ldr	r3, [pc, #52]	; (40a170 <prvCheckForValidListAndQueue+0x3c>)
  40a13c:	681b      	ldr	r3, [r3, #0]
  40a13e:	b113      	cbz	r3, 40a146 <prvCheckForValidListAndQueue+0x12>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
		}
	}
	taskEXIT_CRITICAL();
  40a140:	4b0c      	ldr	r3, [pc, #48]	; (40a174 <prvCheckForValidListAndQueue+0x40>)
  40a142:	4798      	blx	r3
  40a144:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &xActiveTimerList1 );
  40a146:	4d0c      	ldr	r5, [pc, #48]	; (40a178 <prvCheckForValidListAndQueue+0x44>)
  40a148:	4628      	mov	r0, r5
  40a14a:	4e0c      	ldr	r6, [pc, #48]	; (40a17c <prvCheckForValidListAndQueue+0x48>)
  40a14c:	47b0      	blx	r6
			vListInitialise( &xActiveTimerList2 );
  40a14e:	4c0c      	ldr	r4, [pc, #48]	; (40a180 <prvCheckForValidListAndQueue+0x4c>)
  40a150:	4620      	mov	r0, r4
  40a152:	47b0      	blx	r6
			pxCurrentTimerList = &xActiveTimerList1;
  40a154:	4b0b      	ldr	r3, [pc, #44]	; (40a184 <prvCheckForValidListAndQueue+0x50>)
  40a156:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  40a158:	4b0b      	ldr	r3, [pc, #44]	; (40a188 <prvCheckForValidListAndQueue+0x54>)
  40a15a:	601c      	str	r4, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  40a15c:	2200      	movs	r2, #0
  40a15e:	210c      	movs	r1, #12
  40a160:	2005      	movs	r0, #5
  40a162:	4b0a      	ldr	r3, [pc, #40]	; (40a18c <prvCheckForValidListAndQueue+0x58>)
  40a164:	4798      	blx	r3
  40a166:	4b02      	ldr	r3, [pc, #8]	; (40a170 <prvCheckForValidListAndQueue+0x3c>)
  40a168:	6018      	str	r0, [r3, #0]
  40a16a:	e7e9      	b.n	40a140 <prvCheckForValidListAndQueue+0xc>
  40a16c:	00408d89 	.word	0x00408d89
  40a170:	2001176c 	.word	0x2001176c
  40a174:	00408da9 	.word	0x00408da9
  40a178:	20011740 	.word	0x20011740
  40a17c:	00408c65 	.word	0x00408c65
  40a180:	20011754 	.word	0x20011754
  40a184:	20011738 	.word	0x20011738
  40a188:	2001173c 	.word	0x2001173c
  40a18c:	004091b5 	.word	0x004091b5

0040a190 <xTimerCreateTimerTask>:
{
  40a190:	b510      	push	{r4, lr}
  40a192:	b084      	sub	sp, #16
	prvCheckForValidListAndQueue();
  40a194:	4b0b      	ldr	r3, [pc, #44]	; (40a1c4 <xTimerCreateTimerTask+0x34>)
  40a196:	4798      	blx	r3
	if( xTimerQueue != NULL )
  40a198:	4b0b      	ldr	r3, [pc, #44]	; (40a1c8 <xTimerCreateTimerTask+0x38>)
  40a19a:	681b      	ldr	r3, [r3, #0]
  40a19c:	b173      	cbz	r3, 40a1bc <xTimerCreateTimerTask+0x2c>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
  40a19e:	2300      	movs	r3, #0
  40a1a0:	9303      	str	r3, [sp, #12]
  40a1a2:	9302      	str	r3, [sp, #8]
  40a1a4:	9301      	str	r3, [sp, #4]
  40a1a6:	2204      	movs	r2, #4
  40a1a8:	9200      	str	r2, [sp, #0]
  40a1aa:	f44f 7282 	mov.w	r2, #260	; 0x104
  40a1ae:	4907      	ldr	r1, [pc, #28]	; (40a1cc <xTimerCreateTimerTask+0x3c>)
  40a1b0:	4807      	ldr	r0, [pc, #28]	; (40a1d0 <xTimerCreateTimerTask+0x40>)
  40a1b2:	4c08      	ldr	r4, [pc, #32]	; (40a1d4 <xTimerCreateTimerTask+0x44>)
  40a1b4:	47a0      	blx	r4
	configASSERT( xReturn );
  40a1b6:	b108      	cbz	r0, 40a1bc <xTimerCreateTimerTask+0x2c>
}
  40a1b8:	b004      	add	sp, #16
  40a1ba:	bd10      	pop	{r4, pc}
	configASSERT( xReturn );
  40a1bc:	4b06      	ldr	r3, [pc, #24]	; (40a1d8 <xTimerCreateTimerTask+0x48>)
  40a1be:	4798      	blx	r3
  40a1c0:	bf00      	nop
  40a1c2:	e7fd      	b.n	40a1c0 <xTimerCreateTimerTask+0x30>
  40a1c4:	0040a135 	.word	0x0040a135
  40a1c8:	2001176c 	.word	0x2001176c
  40a1cc:	0040e508 	.word	0x0040e508
  40a1d0:	0040a2e1 	.word	0x0040a2e1
  40a1d4:	00409659 	.word	0x00409659
  40a1d8:	00408d79 	.word	0x00408d79

0040a1dc <xTimerGenericCommand>:
{
  40a1dc:	b530      	push	{r4, r5, lr}
  40a1de:	b085      	sub	sp, #20
	if( xTimerQueue != NULL )
  40a1e0:	4c0f      	ldr	r4, [pc, #60]	; (40a220 <xTimerGenericCommand+0x44>)
  40a1e2:	6825      	ldr	r5, [r4, #0]
  40a1e4:	b1d5      	cbz	r5, 40a21c <xTimerGenericCommand+0x40>
  40a1e6:	461c      	mov	r4, r3
		xMessage.xMessageID = xCommandID;
  40a1e8:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
  40a1ea:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
  40a1ec:	9003      	str	r0, [sp, #12]
		if( pxHigherPriorityTaskWoken == NULL )
  40a1ee:	b13b      	cbz	r3, 40a200 <xTimerGenericCommand+0x24>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  40a1f0:	2300      	movs	r3, #0
  40a1f2:	4622      	mov	r2, r4
  40a1f4:	a901      	add	r1, sp, #4
  40a1f6:	4628      	mov	r0, r5
  40a1f8:	4c0a      	ldr	r4, [pc, #40]	; (40a224 <xTimerGenericCommand+0x48>)
  40a1fa:	47a0      	blx	r4
}
  40a1fc:	b005      	add	sp, #20
  40a1fe:	bd30      	pop	{r4, r5, pc}
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  40a200:	4b09      	ldr	r3, [pc, #36]	; (40a228 <xTimerGenericCommand+0x4c>)
  40a202:	4798      	blx	r3
  40a204:	2801      	cmp	r0, #1
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
  40a206:	f04f 0300 	mov.w	r3, #0
  40a20a:	bf0c      	ite	eq
  40a20c:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  40a20e:	461a      	movne	r2, r3
  40a210:	a901      	add	r1, sp, #4
  40a212:	4803      	ldr	r0, [pc, #12]	; (40a220 <xTimerGenericCommand+0x44>)
  40a214:	6800      	ldr	r0, [r0, #0]
  40a216:	4c05      	ldr	r4, [pc, #20]	; (40a22c <xTimerGenericCommand+0x50>)
  40a218:	47a0      	blx	r4
  40a21a:	e7ef      	b.n	40a1fc <xTimerGenericCommand+0x20>
portBASE_TYPE xReturn = pdFAIL;
  40a21c:	2000      	movs	r0, #0
	return xReturn;
  40a21e:	e7ed      	b.n	40a1fc <xTimerGenericCommand+0x20>
  40a220:	2001176c 	.word	0x2001176c
  40a224:	00409391 	.word	0x00409391
  40a228:	00409ff9 	.word	0x00409ff9
  40a22c:	00409209 	.word	0x00409209

0040a230 <prvSampleTimeNow>:
{
  40a230:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40a234:	b082      	sub	sp, #8
  40a236:	4681      	mov	r9, r0
	xTimeNow = xTaskGetTickCount();
  40a238:	4b21      	ldr	r3, [pc, #132]	; (40a2c0 <prvSampleTimeNow+0x90>)
  40a23a:	4798      	blx	r3
  40a23c:	4680      	mov	r8, r0
	if( xTimeNow < xLastTime )
  40a23e:	4b21      	ldr	r3, [pc, #132]	; (40a2c4 <prvSampleTimeNow+0x94>)
  40a240:	681b      	ldr	r3, [r3, #0]
  40a242:	4298      	cmp	r0, r3
  40a244:	d315      	bcc.n	40a272 <prvSampleTimeNow+0x42>
		*pxTimerListsWereSwitched = pdFALSE;
  40a246:	2300      	movs	r3, #0
  40a248:	f8c9 3000 	str.w	r3, [r9]
	xLastTime = xTimeNow;
  40a24c:	4b1d      	ldr	r3, [pc, #116]	; (40a2c4 <prvSampleTimeNow+0x94>)
  40a24e:	f8c3 8000 	str.w	r8, [r3]
}
  40a252:	4640      	mov	r0, r8
  40a254:	b002      	add	sp, #8
  40a256:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  40a25a:	2100      	movs	r1, #0
  40a25c:	9100      	str	r1, [sp, #0]
  40a25e:	460b      	mov	r3, r1
  40a260:	4652      	mov	r2, sl
  40a262:	4620      	mov	r0, r4
  40a264:	4c18      	ldr	r4, [pc, #96]	; (40a2c8 <prvSampleTimeNow+0x98>)
  40a266:	47a0      	blx	r4
				configASSERT( xResult );
  40a268:	b928      	cbnz	r0, 40a276 <prvSampleTimeNow+0x46>
  40a26a:	4b18      	ldr	r3, [pc, #96]	; (40a2cc <prvSampleTimeNow+0x9c>)
  40a26c:	4798      	blx	r3
  40a26e:	bf00      	nop
  40a270:	e7fd      	b.n	40a26e <prvSampleTimeNow+0x3e>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40a272:	4e17      	ldr	r6, [pc, #92]	; (40a2d0 <prvSampleTimeNow+0xa0>)
		uxListRemove( &( pxTimer->xTimerListItem ) );
  40a274:	4f17      	ldr	r7, [pc, #92]	; (40a2d4 <prvSampleTimeNow+0xa4>)
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40a276:	6833      	ldr	r3, [r6, #0]
  40a278:	681a      	ldr	r2, [r3, #0]
  40a27a:	b1c2      	cbz	r2, 40a2ae <prvSampleTimeNow+0x7e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  40a27c:	68da      	ldr	r2, [r3, #12]
  40a27e:	f8d2 a000 	ldr.w	sl, [r2]
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  40a282:	68db      	ldr	r3, [r3, #12]
  40a284:	68dc      	ldr	r4, [r3, #12]
		uxListRemove( &( pxTimer->xTimerListItem ) );
  40a286:	1d25      	adds	r5, r4, #4
  40a288:	4628      	mov	r0, r5
  40a28a:	47b8      	blx	r7
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  40a28c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40a28e:	4620      	mov	r0, r4
  40a290:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  40a292:	69e3      	ldr	r3, [r4, #28]
  40a294:	2b01      	cmp	r3, #1
  40a296:	d1ee      	bne.n	40a276 <prvSampleTimeNow+0x46>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  40a298:	69a3      	ldr	r3, [r4, #24]
  40a29a:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
  40a29c:	459a      	cmp	sl, r3
  40a29e:	d2dc      	bcs.n	40a25a <prvSampleTimeNow+0x2a>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  40a2a0:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  40a2a2:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  40a2a4:	4629      	mov	r1, r5
  40a2a6:	6830      	ldr	r0, [r6, #0]
  40a2a8:	4b0b      	ldr	r3, [pc, #44]	; (40a2d8 <prvSampleTimeNow+0xa8>)
  40a2aa:	4798      	blx	r3
  40a2ac:	e7e3      	b.n	40a276 <prvSampleTimeNow+0x46>
	pxCurrentTimerList = pxOverflowTimerList;
  40a2ae:	4a0b      	ldr	r2, [pc, #44]	; (40a2dc <prvSampleTimeNow+0xac>)
  40a2b0:	6810      	ldr	r0, [r2, #0]
  40a2b2:	4907      	ldr	r1, [pc, #28]	; (40a2d0 <prvSampleTimeNow+0xa0>)
  40a2b4:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
  40a2b6:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
  40a2b8:	2301      	movs	r3, #1
  40a2ba:	f8c9 3000 	str.w	r3, [r9]
  40a2be:	e7c5      	b.n	40a24c <prvSampleTimeNow+0x1c>
  40a2c0:	0040998d 	.word	0x0040998d
  40a2c4:	20011768 	.word	0x20011768
  40a2c8:	0040a1dd 	.word	0x0040a1dd
  40a2cc:	00408d79 	.word	0x00408d79
  40a2d0:	20011738 	.word	0x20011738
  40a2d4:	00408cd9 	.word	0x00408cd9
  40a2d8:	00408c9d 	.word	0x00408c9d
  40a2dc:	2001173c 	.word	0x2001173c

0040a2e0 <prvTimerTask>:
{
  40a2e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40a2e4:	b086      	sub	sp, #24
	uxListRemove( &( pxTimer->xTimerListItem ) );
  40a2e6:	f8df 8168 	ldr.w	r8, [pc, #360]	; 40a450 <prvTimerTask+0x170>
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  40a2ea:	4b4d      	ldr	r3, [pc, #308]	; (40a420 <prvTimerTask+0x140>)
  40a2ec:	681b      	ldr	r3, [r3, #0]
  40a2ee:	681a      	ldr	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  40a2f0:	2a00      	cmp	r2, #0
  40a2f2:	f000 8089 	beq.w	40a408 <prvTimerTask+0x128>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  40a2f6:	68db      	ldr	r3, [r3, #12]
  40a2f8:	681d      	ldr	r5, [r3, #0]
	vTaskSuspendAll();
  40a2fa:	4b4a      	ldr	r3, [pc, #296]	; (40a424 <prvTimerTask+0x144>)
  40a2fc:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40a2fe:	a803      	add	r0, sp, #12
  40a300:	4b49      	ldr	r3, [pc, #292]	; (40a428 <prvTimerTask+0x148>)
  40a302:	4798      	blx	r3
  40a304:	4606      	mov	r6, r0
		if( xTimerListsWereSwitched == pdFALSE )
  40a306:	9b03      	ldr	r3, [sp, #12]
  40a308:	2b00      	cmp	r3, #0
  40a30a:	f040 8086 	bne.w	40a41a <prvTimerTask+0x13a>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  40a30e:	42a8      	cmp	r0, r5
  40a310:	d20f      	bcs.n	40a332 <prvTimerTask+0x52>
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  40a312:	1ba9      	subs	r1, r5, r6
  40a314:	4b45      	ldr	r3, [pc, #276]	; (40a42c <prvTimerTask+0x14c>)
  40a316:	6818      	ldr	r0, [r3, #0]
  40a318:	4b45      	ldr	r3, [pc, #276]	; (40a430 <prvTimerTask+0x150>)
  40a31a:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  40a31c:	4b45      	ldr	r3, [pc, #276]	; (40a434 <prvTimerTask+0x154>)
  40a31e:	4798      	blx	r3
  40a320:	b908      	cbnz	r0, 40a326 <prvTimerTask+0x46>
					portYIELD_WITHIN_API();
  40a322:	4b45      	ldr	r3, [pc, #276]	; (40a438 <prvTimerTask+0x158>)
  40a324:	4798      	blx	r3
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40a326:	a802      	add	r0, sp, #8
  40a328:	4b3f      	ldr	r3, [pc, #252]	; (40a428 <prvTimerTask+0x148>)
  40a32a:	4798      	blx	r3
  40a32c:	4607      	mov	r7, r0
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  40a32e:	4e3f      	ldr	r6, [pc, #252]	; (40a42c <prvTimerTask+0x14c>)
  40a330:	e036      	b.n	40a3a0 <prvTimerTask+0xc0>
				xTaskResumeAll();
  40a332:	4b40      	ldr	r3, [pc, #256]	; (40a434 <prvTimerTask+0x154>)
  40a334:	4798      	blx	r3
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  40a336:	4b3a      	ldr	r3, [pc, #232]	; (40a420 <prvTimerTask+0x140>)
  40a338:	681b      	ldr	r3, [r3, #0]
  40a33a:	68db      	ldr	r3, [r3, #12]
  40a33c:	68dc      	ldr	r4, [r3, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
  40a33e:	1d20      	adds	r0, r4, #4
  40a340:	47c0      	blx	r8
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  40a342:	69e3      	ldr	r3, [r4, #28]
  40a344:	2b01      	cmp	r3, #1
  40a346:	d114      	bne.n	40a372 <prvTimerTask+0x92>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  40a348:	69a1      	ldr	r1, [r4, #24]
  40a34a:	462b      	mov	r3, r5
  40a34c:	4632      	mov	r2, r6
  40a34e:	4429      	add	r1, r5
  40a350:	4620      	mov	r0, r4
  40a352:	4e3a      	ldr	r6, [pc, #232]	; (40a43c <prvTimerTask+0x15c>)
  40a354:	47b0      	blx	r6
  40a356:	2801      	cmp	r0, #1
  40a358:	d10b      	bne.n	40a372 <prvTimerTask+0x92>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  40a35a:	2100      	movs	r1, #0
  40a35c:	9100      	str	r1, [sp, #0]
  40a35e:	460b      	mov	r3, r1
  40a360:	462a      	mov	r2, r5
  40a362:	4620      	mov	r0, r4
  40a364:	4d36      	ldr	r5, [pc, #216]	; (40a440 <prvTimerTask+0x160>)
  40a366:	47a8      	blx	r5
			configASSERT( xResult );
  40a368:	b918      	cbnz	r0, 40a372 <prvTimerTask+0x92>
  40a36a:	4b36      	ldr	r3, [pc, #216]	; (40a444 <prvTimerTask+0x164>)
  40a36c:	4798      	blx	r3
  40a36e:	bf00      	nop
  40a370:	e7fd      	b.n	40a36e <prvTimerTask+0x8e>
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  40a372:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40a374:	4620      	mov	r0, r4
  40a376:	4798      	blx	r3
  40a378:	e7d5      	b.n	40a326 <prvTimerTask+0x46>
		xNextExpireTime = ( portTickType ) 0U;
  40a37a:	2500      	movs	r5, #0
  40a37c:	e7c9      	b.n	40a312 <prvTimerTask+0x32>
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
  40a37e:	9904      	ldr	r1, [sp, #16]
  40a380:	61a1      	str	r1, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  40a382:	b131      	cbz	r1, 40a392 <prvTimerTask+0xb2>
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  40a384:	463b      	mov	r3, r7
  40a386:	463a      	mov	r2, r7
  40a388:	4439      	add	r1, r7
  40a38a:	4620      	mov	r0, r4
  40a38c:	4c2b      	ldr	r4, [pc, #172]	; (40a43c <prvTimerTask+0x15c>)
  40a38e:	47a0      	blx	r4
  40a390:	e006      	b.n	40a3a0 <prvTimerTask+0xc0>
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  40a392:	4b2c      	ldr	r3, [pc, #176]	; (40a444 <prvTimerTask+0x164>)
  40a394:	4798      	blx	r3
  40a396:	bf00      	nop
  40a398:	e7fd      	b.n	40a396 <prvTimerTask+0xb6>
				vPortFree( pxTimer );
  40a39a:	4620      	mov	r0, r4
  40a39c:	4b2a      	ldr	r3, [pc, #168]	; (40a448 <prvTimerTask+0x168>)
  40a39e:	4798      	blx	r3
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  40a3a0:	4d2a      	ldr	r5, [pc, #168]	; (40a44c <prvTimerTask+0x16c>)
  40a3a2:	2300      	movs	r3, #0
  40a3a4:	461a      	mov	r2, r3
  40a3a6:	a903      	add	r1, sp, #12
  40a3a8:	6830      	ldr	r0, [r6, #0]
  40a3aa:	47a8      	blx	r5
  40a3ac:	2800      	cmp	r0, #0
  40a3ae:	d09c      	beq.n	40a2ea <prvTimerTask+0xa>
		pxTimer = xMessage.pxTimer;
  40a3b0:	9c05      	ldr	r4, [sp, #20]
		if( pxTimer != NULL )
  40a3b2:	b11c      	cbz	r4, 40a3bc <prvTimerTask+0xdc>
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  40a3b4:	6963      	ldr	r3, [r4, #20]
  40a3b6:	b10b      	cbz	r3, 40a3bc <prvTimerTask+0xdc>
				uxListRemove( &( pxTimer->xTimerListItem ) );
  40a3b8:	1d20      	adds	r0, r4, #4
  40a3ba:	47c0      	blx	r8
		switch( xMessage.xMessageID )
  40a3bc:	9b03      	ldr	r3, [sp, #12]
  40a3be:	2b02      	cmp	r3, #2
  40a3c0:	d0dd      	beq.n	40a37e <prvTimerTask+0x9e>
  40a3c2:	2b03      	cmp	r3, #3
  40a3c4:	d0e9      	beq.n	40a39a <prvTimerTask+0xba>
  40a3c6:	2b00      	cmp	r3, #0
  40a3c8:	d1eb      	bne.n	40a3a2 <prvTimerTask+0xc2>
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
  40a3ca:	9904      	ldr	r1, [sp, #16]
  40a3cc:	69a0      	ldr	r0, [r4, #24]
  40a3ce:	460b      	mov	r3, r1
  40a3d0:	463a      	mov	r2, r7
  40a3d2:	4401      	add	r1, r0
  40a3d4:	4620      	mov	r0, r4
  40a3d6:	4d19      	ldr	r5, [pc, #100]	; (40a43c <prvTimerTask+0x15c>)
  40a3d8:	47a8      	blx	r5
  40a3da:	2801      	cmp	r0, #1
  40a3dc:	d1e0      	bne.n	40a3a0 <prvTimerTask+0xc0>
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  40a3de:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40a3e0:	4620      	mov	r0, r4
  40a3e2:	4798      	blx	r3
					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  40a3e4:	69e3      	ldr	r3, [r4, #28]
  40a3e6:	2b01      	cmp	r3, #1
  40a3e8:	d1da      	bne.n	40a3a0 <prvTimerTask+0xc0>
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  40a3ea:	69a2      	ldr	r2, [r4, #24]
  40a3ec:	2100      	movs	r1, #0
  40a3ee:	9100      	str	r1, [sp, #0]
  40a3f0:	460b      	mov	r3, r1
  40a3f2:	9804      	ldr	r0, [sp, #16]
  40a3f4:	4402      	add	r2, r0
  40a3f6:	4620      	mov	r0, r4
  40a3f8:	4c11      	ldr	r4, [pc, #68]	; (40a440 <prvTimerTask+0x160>)
  40a3fa:	47a0      	blx	r4
						configASSERT( xResult );
  40a3fc:	2800      	cmp	r0, #0
  40a3fe:	d1cf      	bne.n	40a3a0 <prvTimerTask+0xc0>
  40a400:	4b10      	ldr	r3, [pc, #64]	; (40a444 <prvTimerTask+0x164>)
  40a402:	4798      	blx	r3
  40a404:	bf00      	nop
  40a406:	e7fd      	b.n	40a404 <prvTimerTask+0x124>
	vTaskSuspendAll();
  40a408:	4b06      	ldr	r3, [pc, #24]	; (40a424 <prvTimerTask+0x144>)
  40a40a:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40a40c:	a803      	add	r0, sp, #12
  40a40e:	4b06      	ldr	r3, [pc, #24]	; (40a428 <prvTimerTask+0x148>)
  40a410:	4798      	blx	r3
  40a412:	4606      	mov	r6, r0
		if( xTimerListsWereSwitched == pdFALSE )
  40a414:	9b03      	ldr	r3, [sp, #12]
  40a416:	2b00      	cmp	r3, #0
  40a418:	d0af      	beq.n	40a37a <prvTimerTask+0x9a>
			xTaskResumeAll();
  40a41a:	4b06      	ldr	r3, [pc, #24]	; (40a434 <prvTimerTask+0x154>)
  40a41c:	4798      	blx	r3
  40a41e:	e782      	b.n	40a326 <prvTimerTask+0x46>
  40a420:	20011738 	.word	0x20011738
  40a424:	0040997d 	.word	0x0040997d
  40a428:	0040a231 	.word	0x0040a231
  40a42c:	2001176c 	.word	0x2001176c
  40a430:	004095b1 	.word	0x004095b1
  40a434:	00409ad5 	.word	0x00409ad5
  40a438:	00408d69 	.word	0x00408d69
  40a43c:	0040a0e9 	.word	0x0040a0e9
  40a440:	0040a1dd 	.word	0x0040a1dd
  40a444:	00408d79 	.word	0x00408d79
  40a448:	00408fd9 	.word	0x00408fd9
  40a44c:	00409421 	.word	0x00409421
  40a450:	00408cd9 	.word	0x00408cd9

0040a454 <board_init>:
    ioport_set_pin_dir(pin, IOPORT_DIR_INPUT);                                                                         \
    ioport_set_pin_mode(pin, mode);                                                                                    \
    ioport_set_pin_sense_mode(pin, sense);                                                                             \
  } while (0)

void board_init(void) {
  40a454:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40a456:	2009      	movs	r0, #9
  40a458:	4c7b      	ldr	r4, [pc, #492]	; (40a648 <board_init+0x1f4>)
  40a45a:	47a0      	blx	r4
  40a45c:	200a      	movs	r0, #10
  40a45e:	47a0      	blx	r4
  40a460:	200b      	movs	r0, #11
  40a462:	47a0      	blx	r4
  40a464:	200c      	movs	r0, #12
  40a466:	47a0      	blx	r4
  40a468:	200d      	movs	r0, #13
  40a46a:	47a0      	blx	r4
		base->PIO_PUDR = mask;
  40a46c:	4b77      	ldr	r3, [pc, #476]	; (40a64c <board_init+0x1f8>)
  40a46e:	f44f 62c0 	mov.w	r2, #1536	; 0x600
  40a472:	661a      	str	r2, [r3, #96]	; 0x60
		base->PIO_PPDDR = mask;
  40a474:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a478:	655a      	str	r2, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a47a:	625a      	str	r2, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a47c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a480:	6f19      	ldr	r1, [r3, #112]	; 0x70
  40a482:	f421 61c0 	bic.w	r1, r1, #1536	; 0x600
  40a486:	6719      	str	r1, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] &= ~mask;
  40a488:	6f59      	ldr	r1, [r3, #116]	; 0x74
  40a48a:	f421 61c0 	bic.w	r1, r1, #1536	; 0x600
  40a48e:	6759      	str	r1, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a490:	605a      	str	r2, [r3, #4]
		base->PIO_PUDR = mask;
  40a492:	4a6f      	ldr	r2, [pc, #444]	; (40a650 <board_init+0x1fc>)
  40a494:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  40a498:	6611      	str	r1, [r2, #96]	; 0x60
		base->PIO_PPDDR = mask;
  40a49a:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a49e:	6551      	str	r1, [r2, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a4a0:	6251      	str	r1, [r2, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a4a2:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a4a6:	6f10      	ldr	r0, [r2, #112]	; 0x70
  40a4a8:	f420 5080 	bic.w	r0, r0, #4096	; 0x1000
  40a4ac:	6710      	str	r0, [r2, #112]	; 0x70
		base->PIO_ABCDSR[1] |= mask;
  40a4ae:	6f50      	ldr	r0, [r2, #116]	; 0x74
  40a4b0:	4308      	orrs	r0, r1
  40a4b2:	6750      	str	r0, [r2, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a4b4:	6051      	str	r1, [r2, #4]
		base->PIO_PUDR = mask;
  40a4b6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  40a4ba:	6610      	str	r0, [r2, #96]	; 0x60
		base->PIO_PPDDR = mask;
  40a4bc:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a4c0:	6550      	str	r0, [r2, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a4c2:	6250      	str	r0, [r2, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a4c4:	f8c2 0080 	str.w	r0, [r2, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a4c8:	6f14      	ldr	r4, [r2, #112]	; 0x70
  40a4ca:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
  40a4ce:	6714      	str	r4, [r2, #112]	; 0x70
		base->PIO_ABCDSR[1] |= mask;
  40a4d0:	6f54      	ldr	r4, [r2, #116]	; 0x74
  40a4d2:	4304      	orrs	r4, r0
  40a4d4:	6754      	str	r4, [r2, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a4d6:	6050      	str	r0, [r2, #4]
		base->PIO_PUDR = mask;
  40a4d8:	6619      	str	r1, [r3, #96]	; 0x60
		base->PIO_PPDDR = mask;
  40a4da:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a4de:	6559      	str	r1, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a4e0:	6259      	str	r1, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a4e2:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a4e6:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40a4e8:	f420 5080 	bic.w	r0, r0, #4096	; 0x1000
  40a4ec:	6718      	str	r0, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] &= ~mask;
  40a4ee:	6f58      	ldr	r0, [r3, #116]	; 0x74
  40a4f0:	f420 5080 	bic.w	r0, r0, #4096	; 0x1000
  40a4f4:	6758      	str	r0, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a4f6:	6059      	str	r1, [r3, #4]
		base->PIO_PUDR = mask;
  40a4f8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  40a4fc:	6619      	str	r1, [r3, #96]	; 0x60
		base->PIO_PPDDR = mask;
  40a4fe:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a502:	6559      	str	r1, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a504:	6259      	str	r1, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a506:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a50a:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40a50c:	f420 5000 	bic.w	r0, r0, #8192	; 0x2000
  40a510:	6718      	str	r0, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] &= ~mask;
  40a512:	6f58      	ldr	r0, [r3, #116]	; 0x74
  40a514:	f420 5000 	bic.w	r0, r0, #8192	; 0x2000
  40a518:	6758      	str	r0, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a51a:	6059      	str	r1, [r3, #4]
		base->PIO_PUDR = mask;
  40a51c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  40a520:	6619      	str	r1, [r3, #96]	; 0x60
		base->PIO_PPDDR = mask;
  40a522:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a526:	6559      	str	r1, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a528:	6259      	str	r1, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a52a:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a52e:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40a530:	f420 4080 	bic.w	r0, r0, #16384	; 0x4000
  40a534:	6718      	str	r0, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] &= ~mask;
  40a536:	6f58      	ldr	r0, [r3, #116]	; 0x74
  40a538:	f420 4080 	bic.w	r0, r0, #16384	; 0x4000
  40a53c:	6758      	str	r0, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a53e:	6059      	str	r1, [r3, #4]
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40a540:	2710      	movs	r7, #16
  40a542:	6117      	str	r7, [r2, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40a544:	f8c2 70a0 	str.w	r7, [r2, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40a548:	f44f 6600 	mov.w	r6, #2048	; 0x800
  40a54c:	611e      	str	r6, [r3, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40a54e:	f8c3 60a0 	str.w	r6, [r3, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40a552:	4c40      	ldr	r4, [pc, #256]	; (40a654 <board_init+0x200>)
  40a554:	2504      	movs	r5, #4
  40a556:	6125      	str	r5, [r4, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40a558:	f8c4 50a0 	str.w	r5, [r4, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40a55c:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  40a560:	6118      	str	r0, [r3, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40a562:	f8c3 00a0 	str.w	r0, [r3, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40a566:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  40a56a:	6119      	str	r1, [r3, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40a56c:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40a570:	6317      	str	r7, [r2, #48]	; 0x30
  40a572:	631e      	str	r6, [r3, #48]	; 0x30
  40a574:	6325      	str	r5, [r4, #48]	; 0x30
  40a576:	6318      	str	r0, [r3, #48]	; 0x30
  40a578:	6319      	str	r1, [r3, #48]	; 0x30
		base->PIO_PUER = mask;
  40a57a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40a57e:	665a      	str	r2, [r3, #100]	; 0x64
		base->PIO_PPDDR = mask;
  40a580:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a584:	655a      	str	r2, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a586:	625a      	str	r2, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a588:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a58c:	6f19      	ldr	r1, [r3, #112]	; 0x70
  40a58e:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  40a592:	6719      	str	r1, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] |= mask;
  40a594:	6f59      	ldr	r1, [r3, #116]	; 0x74
  40a596:	4311      	orrs	r1, r2
  40a598:	6759      	str	r1, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a59a:	605a      	str	r2, [r3, #4]
		base->PIO_PUDR = mask;
  40a59c:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40a5a0:	661a      	str	r2, [r3, #96]	; 0x60
		base->PIO_PPDDR = mask;
  40a5a2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a5a6:	655a      	str	r2, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a5a8:	625a      	str	r2, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a5aa:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a5ae:	6f19      	ldr	r1, [r3, #112]	; 0x70
  40a5b0:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
  40a5b4:	6719      	str	r1, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] |= mask;
  40a5b6:	6f59      	ldr	r1, [r3, #116]	; 0x74
  40a5b8:	4311      	orrs	r1, r2
  40a5ba:	6759      	str	r1, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a5bc:	605a      	str	r2, [r3, #4]
		base->PIO_PUER = mask;
  40a5be:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40a5c2:	665a      	str	r2, [r3, #100]	; 0x64
		base->PIO_PPDDR = mask;
  40a5c4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a5c8:	655a      	str	r2, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a5ca:	625a      	str	r2, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a5cc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a5d0:	6f19      	ldr	r1, [r3, #112]	; 0x70
  40a5d2:	f021 4180 	bic.w	r1, r1, #1073741824	; 0x40000000
  40a5d6:	6719      	str	r1, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] |= mask;
  40a5d8:	6f59      	ldr	r1, [r3, #116]	; 0x74
  40a5da:	4311      	orrs	r1, r2
  40a5dc:	6759      	str	r1, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a5de:	605a      	str	r2, [r3, #4]
		base->PIO_PUER = mask;
  40a5e0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  40a5e4:	665a      	str	r2, [r3, #100]	; 0x64
		base->PIO_PPDDR = mask;
  40a5e6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a5ea:	655a      	str	r2, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a5ec:	625a      	str	r2, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a5ee:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a5f2:	6f19      	ldr	r1, [r3, #112]	; 0x70
  40a5f4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  40a5f8:	6719      	str	r1, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] |= mask;
  40a5fa:	6f59      	ldr	r1, [r3, #116]	; 0x74
  40a5fc:	4311      	orrs	r1, r2
  40a5fe:	6759      	str	r1, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a600:	605a      	str	r2, [r3, #4]
		base->PIO_PUER = mask;
  40a602:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  40a606:	665a      	str	r2, [r3, #100]	; 0x64
		base->PIO_PPDDR = mask;
  40a608:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a60c:	655a      	str	r2, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a60e:	625a      	str	r2, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a610:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a614:	6f19      	ldr	r1, [r3, #112]	; 0x70
  40a616:	f021 6180 	bic.w	r1, r1, #67108864	; 0x4000000
  40a61a:	6719      	str	r1, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] |= mask;
  40a61c:	6f59      	ldr	r1, [r3, #116]	; 0x74
  40a61e:	4311      	orrs	r1, r2
  40a620:	6759      	str	r1, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a622:	605a      	str	r2, [r3, #4]
		base->PIO_PUER = mask;
  40a624:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  40a628:	665a      	str	r2, [r3, #100]	; 0x64
		base->PIO_PPDDR = mask;
  40a62a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		base->PIO_MDDR = mask;
  40a62e:	655a      	str	r2, [r3, #84]	; 0x54
		base->PIO_IFDR = mask;
  40a630:	625a      	str	r2, [r3, #36]	; 0x24
		base->PIO_IFSCDR = mask;
  40a632:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABCDSR[0] &= ~mask;
  40a636:	6f19      	ldr	r1, [r3, #112]	; 0x70
  40a638:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
  40a63c:	6719      	str	r1, [r3, #112]	; 0x70
		base->PIO_ABCDSR[1] |= mask;
  40a63e:	6f59      	ldr	r1, [r3, #116]	; 0x74
  40a640:	4311      	orrs	r1, r2
  40a642:	6759      	str	r1, [r3, #116]	; 0x74
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40a644:	605a      	str	r2, [r3, #4]
  40a646:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40a648:	0040ad6d 	.word	0x0040ad6d
  40a64c:	400e0e00 	.word	0x400e0e00
  40a650:	400e1200 	.word	0x400e1200
  40a654:	400e1000 	.word	0x400e1000

0040a658 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  40a658:	b510      	push	{r4, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  40a65a:	480e      	ldr	r0, [pc, #56]	; (40a694 <sysclk_init+0x3c>)
  40a65c:	4b0e      	ldr	r3, [pc, #56]	; (40a698 <sysclk_init+0x40>)
  40a65e:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  40a660:	213e      	movs	r1, #62	; 0x3e
  40a662:	2000      	movs	r0, #0
  40a664:	4b0d      	ldr	r3, [pc, #52]	; (40a69c <sysclk_init+0x44>)
  40a666:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  40a668:	4c0d      	ldr	r4, [pc, #52]	; (40a6a0 <sysclk_init+0x48>)
  40a66a:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  40a66c:	2800      	cmp	r0, #0
  40a66e:	d0fc      	beq.n	40a66a <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  40a670:	4b0c      	ldr	r3, [pc, #48]	; (40a6a4 <sysclk_init+0x4c>)
  40a672:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  40a674:	4a0c      	ldr	r2, [pc, #48]	; (40a6a8 <sysclk_init+0x50>)
  40a676:	4b0d      	ldr	r3, [pc, #52]	; (40a6ac <sysclk_init+0x54>)
  40a678:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	UNUSED(ul_pll_id);
	return pmc_is_locked_pllack();
  40a67a:	4c0d      	ldr	r4, [pc, #52]	; (40a6b0 <sysclk_init+0x58>)
  40a67c:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  40a67e:	2800      	cmp	r0, #0
  40a680:	d0fc      	beq.n	40a67c <sysclk_init+0x24>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  40a682:	2010      	movs	r0, #16
  40a684:	4b0b      	ldr	r3, [pc, #44]	; (40a6b4 <sysclk_init+0x5c>)
  40a686:	4798      	blx	r3
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  40a688:	4b0b      	ldr	r3, [pc, #44]	; (40a6b8 <sysclk_init+0x60>)
  40a68a:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  40a68c:	480b      	ldr	r0, [pc, #44]	; (40a6bc <sysclk_init+0x64>)
  40a68e:	4b02      	ldr	r3, [pc, #8]	; (40a698 <sysclk_init+0x40>)
  40a690:	4798      	blx	r3
  40a692:	bd10      	pop	{r4, pc}
  40a694:	07270e00 	.word	0x07270e00
  40a698:	0040b1e9 	.word	0x0040b1e9
  40a69c:	0040ace9 	.word	0x0040ace9
  40a6a0:	0040ad3d 	.word	0x0040ad3d
  40a6a4:	0040ad4d 	.word	0x0040ad4d
  40a6a8:	200f3f01 	.word	0x200f3f01
  40a6ac:	400e0400 	.word	0x400e0400
  40a6b0:	0040ad5d 	.word	0x0040ad5d
  40a6b4:	0040ac85 	.word	0x0040ac85
  40a6b8:	0040b0dd 	.word	0x0040b0dd
  40a6bc:	05b8d800 	.word	0x05b8d800

0040a6c0 <usart_serial_read_packet>:
 *
 */
status_code_t usart_serial_read_packet(usart_if usart, uint8_t *data,
		size_t len)
{
	while (len) {
  40a6c0:	2a00      	cmp	r2, #0
  40a6c2:	d03f      	beq.n	40a744 <usart_serial_read_packet+0x84>
{
  40a6c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40a6c8:	b083      	sub	sp, #12
  40a6ca:	4606      	mov	r6, r0
  40a6cc:	460c      	mov	r4, r1
  40a6ce:	4693      	mov	fp, r2
  40a6d0:	448b      	add	fp, r1
	if (UART0 == (Uart*)p_usart) {
  40a6d2:	4f1d      	ldr	r7, [pc, #116]	; (40a748 <usart_serial_read_packet+0x88>)
		while (uart_read((Uart*)p_usart, data));
  40a6d4:	4d1d      	ldr	r5, [pc, #116]	; (40a74c <usart_serial_read_packet+0x8c>)
	if (UART1 == (Uart*)p_usart) {
  40a6d6:	f8df a080 	ldr.w	sl, [pc, #128]	; 40a758 <usart_serial_read_packet+0x98>
  40a6da:	e00d      	b.n	40a6f8 <usart_serial_read_packet+0x38>
		while (uart_read((Uart*)p_usart, data));
  40a6dc:	4621      	mov	r1, r4
  40a6de:	4638      	mov	r0, r7
  40a6e0:	47a8      	blx	r5
  40a6e2:	2800      	cmp	r0, #0
  40a6e4:	d1fa      	bne.n	40a6dc <usart_serial_read_packet+0x1c>
  40a6e6:	e010      	b.n	40a70a <usart_serial_read_packet+0x4a>
		while (uart_read((Uart*)p_usart, data));
  40a6e8:	4621      	mov	r1, r4
  40a6ea:	4650      	mov	r0, sl
  40a6ec:	47a8      	blx	r5
  40a6ee:	2800      	cmp	r0, #0
  40a6f0:	d1fa      	bne.n	40a6e8 <usart_serial_read_packet+0x28>
		usart_serial_getchar(usart, data);
		len--;
		data++;
  40a6f2:	3401      	adds	r4, #1
	while (len) {
  40a6f4:	455c      	cmp	r4, fp
  40a6f6:	d021      	beq.n	40a73c <usart_serial_read_packet+0x7c>
	uint32_t val = 0;
  40a6f8:	2300      	movs	r3, #0
  40a6fa:	9301      	str	r3, [sp, #4]
	if (UART0 == (Uart*)p_usart) {
  40a6fc:	42be      	cmp	r6, r7
  40a6fe:	d0ed      	beq.n	40a6dc <usart_serial_read_packet+0x1c>
	if (UART1 == (Uart*)p_usart) {
  40a700:	4556      	cmp	r6, sl
  40a702:	d0f1      	beq.n	40a6e8 <usart_serial_read_packet+0x28>
	if (USART0 == p_usart) {
  40a704:	4b12      	ldr	r3, [pc, #72]	; (40a750 <usart_serial_read_packet+0x90>)
  40a706:	429e      	cmp	r6, r3
  40a708:	d00d      	beq.n	40a726 <usart_serial_read_packet+0x66>
	if (USART1 == p_usart) {
  40a70a:	4b12      	ldr	r3, [pc, #72]	; (40a754 <usart_serial_read_packet+0x94>)
  40a70c:	429e      	cmp	r6, r3
  40a70e:	d1f0      	bne.n	40a6f2 <usart_serial_read_packet+0x32>
		while (usart_read(p_usart, &val));
  40a710:	4699      	mov	r9, r3
  40a712:	f8df 8048 	ldr.w	r8, [pc, #72]	; 40a75c <usart_serial_read_packet+0x9c>
  40a716:	a901      	add	r1, sp, #4
  40a718:	4648      	mov	r0, r9
  40a71a:	47c0      	blx	r8
  40a71c:	2800      	cmp	r0, #0
  40a71e:	d1fa      	bne.n	40a716 <usart_serial_read_packet+0x56>
		*data = (uint8_t)(val & 0xFF);
  40a720:	9b01      	ldr	r3, [sp, #4]
  40a722:	7023      	strb	r3, [r4, #0]
  40a724:	e7e5      	b.n	40a6f2 <usart_serial_read_packet+0x32>
		while (usart_read(p_usart, &val));
  40a726:	4699      	mov	r9, r3
  40a728:	f8df 8030 	ldr.w	r8, [pc, #48]	; 40a75c <usart_serial_read_packet+0x9c>
  40a72c:	a901      	add	r1, sp, #4
  40a72e:	4648      	mov	r0, r9
  40a730:	47c0      	blx	r8
  40a732:	2800      	cmp	r0, #0
  40a734:	d1fa      	bne.n	40a72c <usart_serial_read_packet+0x6c>
		*data = (uint8_t)(val & 0xFF);
  40a736:	9b01      	ldr	r3, [sp, #4]
  40a738:	7023      	strb	r3, [r4, #0]
  40a73a:	e7da      	b.n	40a6f2 <usart_serial_read_packet+0x32>
	}
	return STATUS_OK;
}
  40a73c:	2000      	movs	r0, #0
  40a73e:	b003      	add	sp, #12
  40a740:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a744:	2000      	movs	r0, #0
  40a746:	4770      	bx	lr
  40a748:	400e0600 	.word	0x400e0600
  40a74c:	0040af33 	.word	0x0040af33
  40a750:	400a0000 	.word	0x400a0000
  40a754:	400a4000 	.word	0x400a4000
  40a758:	40060600 	.word	0x40060600
  40a75c:	0040af59 	.word	0x0040af59

0040a760 <spi_master_init>:
 *
 * \param p_spi  Base address of the SPI instance.
 *
 */
void spi_master_init(Spi *p_spi)
{
  40a760:	b510      	push	{r4, lr}
  40a762:	4604      	mov	r4, r0
#if SAMG55
	flexcom_enable(BOARD_FLEXCOM_SPI);
	flexcom_set_opmode(BOARD_FLEXCOM_SPI, FLEXCOM_SPI);
#else
	spi_enable_clock(p_spi);
  40a764:	4b10      	ldr	r3, [pc, #64]	; (40a7a8 <spi_master_init+0x48>)
  40a766:	4798      	blx	r3
	p_spi->SPI_CR = SPI_CR_SWRST;
  40a768:	2380      	movs	r3, #128	; 0x80
  40a76a:	6023      	str	r3, [r4, #0]
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_set_master_mode(Spi *p_spi)
{
	p_spi->SPI_MR |= SPI_MR_MSTR;
  40a76c:	6863      	ldr	r3, [r4, #4]
  40a76e:	f043 0301 	orr.w	r3, r3, #1
  40a772:	6063      	str	r3, [r4, #4]
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_disable_mode_fault_detect(Spi *p_spi)
{
	p_spi->SPI_MR |= SPI_MR_MODFDIS;
  40a774:	6863      	ldr	r3, [r4, #4]
  40a776:	f043 0310 	orr.w	r3, r3, #16
  40a77a:	6063      	str	r3, [r4, #4]
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_disable_loopback(Spi *p_spi)
{
	p_spi->SPI_MR &= (~SPI_MR_LLB);
  40a77c:	6863      	ldr	r3, [r4, #4]
  40a77e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  40a782:	6063      	str	r3, [r4, #4]
#endif
	spi_reset(p_spi);
	spi_set_master_mode(p_spi);
	spi_disable_mode_fault_detect(p_spi);
	spi_disable_loopback(p_spi);
	spi_set_peripheral_chip_select_value(p_spi, DEFAULT_CHIP_ID);
  40a784:	2100      	movs	r1, #0
  40a786:	4620      	mov	r0, r4
  40a788:	4b08      	ldr	r3, [pc, #32]	; (40a7ac <spi_master_init+0x4c>)
  40a78a:	4798      	blx	r3
	p_spi->SPI_MR &= (~SPI_MR_PS);
  40a78c:	6863      	ldr	r3, [r4, #4]
  40a78e:	f023 0302 	bic.w	r3, r3, #2
  40a792:	6063      	str	r3, [r4, #4]
	p_spi->SPI_MR &= (~SPI_MR_PCSDEC);
  40a794:	6863      	ldr	r3, [r4, #4]
  40a796:	f023 0304 	bic.w	r3, r3, #4
  40a79a:	6063      	str	r3, [r4, #4]
	spi_set_fixed_peripheral_select(p_spi);
	spi_disable_peripheral_select_decode(p_spi);
	spi_set_delay_between_chip_select(p_spi, CONFIG_SPI_MASTER_DELAY_BCS);
  40a79c:	2100      	movs	r1, #0
  40a79e:	4620      	mov	r0, r4
  40a7a0:	4b03      	ldr	r3, [pc, #12]	; (40a7b0 <spi_master_init+0x50>)
  40a7a2:	4798      	blx	r3
  40a7a4:	bd10      	pop	{r4, pc}
  40a7a6:	bf00      	nop
  40a7a8:	0040adc1 	.word	0x0040adc1
  40a7ac:	0040add1 	.word	0x0040add1
  40a7b0:	0040ade7 	.word	0x0040ade7

0040a7b4 <spi_master_setup_device>:
 * \param baud_rate Baud rate for communication with slave device in Hz.
 * \param sel_id    Board specific select id.
 */
void spi_master_setup_device(Spi *p_spi, struct spi_device *device,
		spi_flags_t flags, uint32_t baud_rate, board_spi_select_id_t sel_id)
{
  40a7b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40a7b8:	4604      	mov	r4, r0
  40a7ba:	460d      	mov	r5, r1
  40a7bc:	4616      	mov	r6, r2
#if (SAM4L)
    int16_t baud_div = spi_calc_baudrate_div(baud_rate, sysclk_get_pba_hz());
#else
	int16_t baud_div = spi_calc_baudrate_div(baud_rate, sysclk_get_peripheral_hz());
  40a7be:	4915      	ldr	r1, [pc, #84]	; (40a814 <spi_master_setup_device+0x60>)
  40a7c0:	4618      	mov	r0, r3
  40a7c2:	4b15      	ldr	r3, [pc, #84]	; (40a818 <spi_master_setup_device+0x64>)
  40a7c4:	4798      	blx	r3
  40a7c6:	4607      	mov	r7, r0
	/* avoid Cppcheck Warning */
	UNUSED(sel_id);
	if (-1 == baud_div) {
		Assert(0 == "Failed to find baudrate divider");
	}
	spi_set_transfer_delay(p_spi, device->id, CONFIG_SPI_MASTER_DELAY_BS,
  40a7c8:	2300      	movs	r3, #0
  40a7ca:	461a      	mov	r2, r3
  40a7cc:	6829      	ldr	r1, [r5, #0]
  40a7ce:	4620      	mov	r0, r4
  40a7d0:	f8df 805c 	ldr.w	r8, [pc, #92]	; 40a830 <spi_master_setup_device+0x7c>
  40a7d4:	47c0      	blx	r8
			CONFIG_SPI_MASTER_DELAY_BCT);
	spi_set_bits_per_transfer(p_spi, device->id,
  40a7d6:	2208      	movs	r2, #8
  40a7d8:	6829      	ldr	r1, [r5, #0]
  40a7da:	4620      	mov	r0, r4
  40a7dc:	4b0f      	ldr	r3, [pc, #60]	; (40a81c <spi_master_setup_device+0x68>)
  40a7de:	4798      	blx	r3
			CONFIG_SPI_MASTER_BITS_PER_TRANSFER);
	spi_set_baudrate_div(p_spi, device->id, baud_div);
  40a7e0:	b2fa      	uxtb	r2, r7
  40a7e2:	6829      	ldr	r1, [r5, #0]
  40a7e4:	4620      	mov	r0, r4
  40a7e6:	4b0e      	ldr	r3, [pc, #56]	; (40a820 <spi_master_setup_device+0x6c>)
  40a7e8:	4798      	blx	r3
	spi_configure_cs_behavior(p_spi, device->id, SPI_CS_KEEP_LOW);
  40a7ea:	2208      	movs	r2, #8
  40a7ec:	6829      	ldr	r1, [r5, #0]
  40a7ee:	4620      	mov	r0, r4
  40a7f0:	4b0c      	ldr	r3, [pc, #48]	; (40a824 <spi_master_setup_device+0x70>)
  40a7f2:	4798      	blx	r3
	spi_set_clock_polarity(p_spi, device->id, flags >> 1);
  40a7f4:	0872      	lsrs	r2, r6, #1
  40a7f6:	6829      	ldr	r1, [r5, #0]
  40a7f8:	4620      	mov	r0, r4
  40a7fa:	4b0b      	ldr	r3, [pc, #44]	; (40a828 <spi_master_setup_device+0x74>)
  40a7fc:	4798      	blx	r3
	spi_set_clock_phase(p_spi, device->id, ((flags & 0x1) ^ 0x1));
  40a7fe:	f086 0201 	eor.w	r2, r6, #1
  40a802:	f002 0201 	and.w	r2, r2, #1
  40a806:	6829      	ldr	r1, [r5, #0]
  40a808:	4620      	mov	r0, r4
  40a80a:	4b08      	ldr	r3, [pc, #32]	; (40a82c <spi_master_setup_device+0x78>)
  40a80c:	4798      	blx	r3
  40a80e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40a812:	bf00      	nop
  40a814:	05b8d800 	.word	0x05b8d800
  40a818:	0040ae8f 	.word	0x0040ae8f
  40a81c:	0040ae7b 	.word	0x0040ae7b
  40a820:	0040aea5 	.word	0x0040aea5
  40a824:	0040ae35 	.word	0x0040ae35
  40a828:	0040adf9 	.word	0x0040adf9
  40a82c:	0040ae17 	.word	0x0040ae17
  40a830:	0040aecd 	.word	0x0040aecd

0040a834 <spi_transceive_packet>:
{
	uint32_t timeout = SPI_TIMEOUT;
	uint8_t val;
	uint32_t i = 0;

	while (len) {
  40a834:	b13b      	cbz	r3, 40a846 <spi_transceive_packet+0x12>
{
  40a836:	b470      	push	{r4, r5, r6}
  40a838:	461e      	mov	r6, r3
  40a83a:	4615      	mov	r5, r2
  40a83c:	3901      	subs	r1, #1
  40a83e:	4416      	add	r6, r2
 *
 * \return 1 if the SPI Receiver is ready, otherwise 0.
 */
static inline uint32_t spi_is_rx_ready(Spi *p_spi)
{
	if ((p_spi->SPI_SR & (SPI_SR_RDRF | SPI_SR_TXEMPTY))
  40a840:	f240 2401 	movw	r4, #513	; 0x201
  40a844:	e014      	b.n	40a870 <spi_transceive_packet+0x3c>
		rx_data[i] = val;
		i++;
		len--;
	}

	return STATUS_OK;
  40a846:	2000      	movs	r0, #0
  40a848:	4770      	bx	lr
	p_spi->SPI_TDR = SPI_TDR_TD(data);
  40a84a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  40a84e:	60c3      	str	r3, [r0, #12]
		while (!spi_is_rx_ready(p_spi)) {
  40a850:	f643 2399 	movw	r3, #15001	; 0x3a99
	if ((p_spi->SPI_SR & (SPI_SR_RDRF | SPI_SR_TXEMPTY))
  40a854:	6902      	ldr	r2, [r0, #16]
  40a856:	ea34 0202 	bics.w	r2, r4, r2
  40a85a:	d004      	beq.n	40a866 <spi_transceive_packet+0x32>
			if (!timeout--) {
  40a85c:	3b01      	subs	r3, #1
  40a85e:	d1f9      	bne.n	40a854 <spi_transceive_packet+0x20>
				return ERR_TIMEOUT;
  40a860:	f06f 0002 	mvn.w	r0, #2
  40a864:	e00e      	b.n	40a884 <spi_transceive_packet+0x50>
	return (p_spi->SPI_RDR & SPI_RDR_RD_Msk);
  40a866:	6883      	ldr	r3, [r0, #8]
 * \param data      Data to read.
 *
 */
static inline void spi_read_single(Spi *p_spi, uint8_t *data)
{
	*data = (uint8_t)spi_get(p_spi);
  40a868:	f805 3b01 	strb.w	r3, [r5], #1
	while (len) {
  40a86c:	42b5      	cmp	r5, r6
  40a86e:	d00b      	beq.n	40a888 <spi_transceive_packet+0x54>
{
  40a870:	f643 2399 	movw	r3, #15001	; 0x3a99
	if (p_spi->SPI_SR & SPI_SR_TDRE) {
  40a874:	6902      	ldr	r2, [r0, #16]
		while (!spi_is_tx_ready(p_spi)) {
  40a876:	f012 0f02 	tst.w	r2, #2
  40a87a:	d1e6      	bne.n	40a84a <spi_transceive_packet+0x16>
			if (!timeout--) {
  40a87c:	3b01      	subs	r3, #1
  40a87e:	d1f9      	bne.n	40a874 <spi_transceive_packet+0x40>
				return ERR_TIMEOUT;
  40a880:	f06f 0002 	mvn.w	r0, #2
}
  40a884:	bc70      	pop	{r4, r5, r6}
  40a886:	4770      	bx	lr
	return STATUS_OK;
  40a888:	2000      	movs	r0, #0
  40a88a:	e7fb      	b.n	40a884 <spi_transceive_packet+0x50>

0040a88c <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
  40a88c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int nChars = 0;

	if (file != 0) {
  40a890:	b980      	cbnz	r0, 40a8b4 <_read+0x28>
  40a892:	460c      	mov	r4, r1
  40a894:	4690      	mov	r8, r2
		return -1;
	}

	for (; len > 0; --len) {
  40a896:	2a00      	cmp	r2, #0
  40a898:	dd0f      	ble.n	40a8ba <_read+0x2e>
  40a89a:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
  40a89c:	4e08      	ldr	r6, [pc, #32]	; (40a8c0 <_read+0x34>)
  40a89e:	4d09      	ldr	r5, [pc, #36]	; (40a8c4 <_read+0x38>)
  40a8a0:	6830      	ldr	r0, [r6, #0]
  40a8a2:	4621      	mov	r1, r4
  40a8a4:	682b      	ldr	r3, [r5, #0]
  40a8a6:	4798      	blx	r3
		ptr++;
  40a8a8:	3401      	adds	r4, #1
	for (; len > 0; --len) {
  40a8aa:	42bc      	cmp	r4, r7
  40a8ac:	d1f8      	bne.n	40a8a0 <_read+0x14>
		nChars++;
	}
	return nChars;
}
  40a8ae:	4640      	mov	r0, r8
  40a8b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -1;
  40a8b4:	f04f 38ff 	mov.w	r8, #4294967295
  40a8b8:	e7f9      	b.n	40a8ae <_read+0x22>
	for (; len > 0; --len) {
  40a8ba:	4680      	mov	r8, r0
  40a8bc:	e7f7      	b.n	40a8ae <_read+0x22>
  40a8be:	bf00      	nop
  40a8c0:	200117fc 	.word	0x200117fc
  40a8c4:	200117f4 	.word	0x200117f4

0040a8c8 <_write>:
int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
  40a8c8:	3801      	subs	r0, #1
  40a8ca:	2802      	cmp	r0, #2
  40a8cc:	d815      	bhi.n	40a8fa <_write+0x32>
{
  40a8ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40a8d2:	460e      	mov	r6, r1
  40a8d4:	4614      	mov	r4, r2
		return -1;
	}

	for (; len != 0; --len) {
  40a8d6:	b19a      	cbz	r2, 40a900 <_write+0x38>
  40a8d8:	460d      	mov	r5, r1
		if (ptr_put(stdio_base, *ptr++) < 0) {
  40a8da:	f8df 8038 	ldr.w	r8, [pc, #56]	; 40a914 <_write+0x4c>
  40a8de:	4f0c      	ldr	r7, [pc, #48]	; (40a910 <_write+0x48>)
  40a8e0:	f8d8 0000 	ldr.w	r0, [r8]
  40a8e4:	f815 1b01 	ldrb.w	r1, [r5], #1
  40a8e8:	683b      	ldr	r3, [r7, #0]
  40a8ea:	4798      	blx	r3
  40a8ec:	2800      	cmp	r0, #0
  40a8ee:	db0a      	blt.n	40a906 <_write+0x3e>
  40a8f0:	1ba8      	subs	r0, r5, r6
	for (; len != 0; --len) {
  40a8f2:	3c01      	subs	r4, #1
  40a8f4:	d1f4      	bne.n	40a8e0 <_write+0x18>
  40a8f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -1;
  40a8fa:	f04f 30ff 	mov.w	r0, #4294967295
  40a8fe:	4770      	bx	lr
	for (; len != 0; --len) {
  40a900:	4610      	mov	r0, r2
  40a902:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return -1;
  40a906:	f04f 30ff 	mov.w	r0, #4294967295
		}
		++nChars;
	}
	return nChars;
}
  40a90a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40a90e:	bf00      	nop
  40a910:	200117f8 	.word	0x200117f8
  40a914:	200117fc 	.word	0x200117fc

0040a918 <can_enable_interrupt>:
 * \param p_can  Pointer to a CAN peripheral instance.
 * \param dw_mask Interrupt to be enabled.
 */
void can_enable_interrupt(Can *p_can, uint32_t dw_mask)
{
	p_can->CAN_IER = dw_mask;
  40a918:	6041      	str	r1, [r0, #4]
  40a91a:	4770      	bx	lr

0040a91c <can_disable_interrupt>:
 * \param p_can  Pointer to a CAN peripheral instance.
 * \param dw_mask Interrupt to be disabled.
 */
void can_disable_interrupt(Can *p_can, uint32_t dw_mask)
{
	p_can->CAN_IDR = dw_mask;
  40a91c:	6081      	str	r1, [r0, #8]
  40a91e:	4770      	bx	lr

0040a920 <can_global_send_transfer_cmd>:
 */
void can_global_send_transfer_cmd(Can *p_can, uint8_t uc_mask)
{
	uint32_t ul_reg;

	ul_reg = p_can->CAN_TCR & ((uint32_t) ~GLOBAL_MAILBOX_MASK);
  40a920:	6a43      	ldr	r3, [r0, #36]	; 0x24
  40a922:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
	p_can->CAN_TCR = ul_reg | uc_mask;
  40a926:	4319      	orrs	r1, r3
  40a928:	6241      	str	r1, [r0, #36]	; 0x24
  40a92a:	4770      	bx	lr

0040a92c <can_mailbox_get_status>:
 *
 * \retval The mailbox status.
 */
uint32_t can_mailbox_get_status(Can *p_can, uint8_t uc_index)
{
	return (p_can->CAN_MB[uc_index].CAN_MSR);
  40a92c:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  40a930:	f8d1 0210 	ldr.w	r0, [r1, #528]	; 0x210
}
  40a934:	4770      	bx	lr

0040a936 <can_mailbox_send_transfer_cmd>:
{
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;

	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MTCR |
  40a936:	780a      	ldrb	r2, [r1, #0]
			CAN_MCR_MDLC(p_mailbox->uc_length);;
  40a938:	798b      	ldrb	r3, [r1, #6]
  40a93a:	041b      	lsls	r3, r3, #16
  40a93c:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MTCR |
  40a940:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  40a944:	eb00 1042 	add.w	r0, r0, r2, lsl #5
  40a948:	f8c0 321c 	str.w	r3, [r0, #540]	; 0x21c
  40a94c:	4770      	bx	lr

0040a94e <can_mailbox_init>:
 */
void can_mailbox_init(Can *p_can, can_mb_conf_t *p_mailbox)
{
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  40a94e:	680b      	ldr	r3, [r1, #0]
	/* Check the object type of the mailbox. If it's used to disable the
	 * mailbox, reset the whole mailbox. */
	if (!p_mailbox->uc_obj_type) {
  40a950:	790a      	ldrb	r2, [r1, #4]
  40a952:	b31a      	cbz	r2, 40a99c <can_mailbox_init+0x4e>
{
  40a954:	b430      	push	{r4, r5}
  40a956:	b2db      	uxtb	r3, r3
  40a958:	eb00 1243 	add.w	r2, r0, r3, lsl #5
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
		return;
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40a95c:	f8d2 4200 	ldr.w	r4, [r2, #512]	; 0x200
			~CAN_MMR_PRIOR_Msk) |
			(p_mailbox->uc_tx_prio << CAN_MMR_PRIOR_Pos);
  40a960:	79cd      	ldrb	r5, [r1, #7]
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40a962:	f424 2470 	bic.w	r4, r4, #983040	; 0xf0000
			~CAN_MMR_PRIOR_Msk) |
  40a966:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40a96a:	f8c2 4200 	str.w	r4, [r2, #512]	; 0x200

	/* Set the message ID and message acceptance mask for the mailbox in
	 * other modes. */
	if (p_mailbox->uc_id_ver) {
  40a96e:	794c      	ldrb	r4, [r1, #5]
  40a970:	b32c      	cbz	r4, 40a9be <can_mailbox_init+0x70>
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk |
  40a972:	68cc      	ldr	r4, [r1, #12]
  40a974:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
  40a978:	f8c2 4204 	str.w	r4, [r2, #516]	; 0x204
				CAN_MAM_MIDE;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  40a97c:	690c      	ldr	r4, [r1, #16]
  40a97e:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
  40a982:	f8c2 4208 	str.w	r4, [r2, #520]	; 0x208
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40a986:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
			~CAN_MMR_MOT_Msk) |
			(p_mailbox->uc_obj_type << CAN_MMR_MOT_Pos);
  40a98a:	7909      	ldrb	r1, [r1, #4]
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40a98c:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
			~CAN_MMR_MOT_Msk) |
  40a990:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40a994:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
  40a998:	bc30      	pop	{r4, r5}
  40a99a:	4770      	bx	lr
  40a99c:	b2db      	uxtb	r3, r3
  40a99e:	eb00 1043 	add.w	r0, r0, r3, lsl #5
		p_can->CAN_MB[uc_index].CAN_MMR = 0;
  40a9a2:	2300      	movs	r3, #0
  40a9a4:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
		p_can->CAN_MB[uc_index].CAN_MAM = 0;
  40a9a8:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
		p_can->CAN_MB[uc_index].CAN_MID = 0;
  40a9ac:	f8c0 3208 	str.w	r3, [r0, #520]	; 0x208
		p_can->CAN_MB[uc_index].CAN_MDL = 0;
  40a9b0:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
		p_can->CAN_MB[uc_index].CAN_MDH = 0;
  40a9b4:	f8c0 3218 	str.w	r3, [r0, #536]	; 0x218
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
  40a9b8:	f8c0 321c 	str.w	r3, [r0, #540]	; 0x21c
		return;
  40a9bc:	4770      	bx	lr
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
  40a9be:	68cc      	ldr	r4, [r1, #12]
  40a9c0:	f8c2 4204 	str.w	r4, [r2, #516]	; 0x204
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  40a9c4:	690c      	ldr	r4, [r1, #16]
  40a9c6:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  40a9ca:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
  40a9ce:	e7da      	b.n	40a986 <can_mailbox_init+0x38>

0040a9d0 <can_mailbox_read>:
 * \retval Different CAN mailbox transfer status.
 *
 * \note Read the mailbox status before calling this function.
 */
uint32_t can_mailbox_read(Can *p_can, can_mb_conf_t *p_mailbox)
{
  40a9d0:	b570      	push	{r4, r5, r6, lr}
	uint8_t uc_index;
	uint32_t ul_retval;

	ul_retval = 0;
	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
	ul_status = p_mailbox->ul_status;
  40a9d2:	688b      	ldr	r3, [r1, #8]

	/* Check whether there is overwriting happening in Receive with
	 * Overwrite mode,
	 * or there're messages lost in Receive mode. */
	if ((ul_status & CAN_MSR_MRDY) && (ul_status & CAN_MSR_MMI)) {
  40a9d4:	f003 72c0 	and.w	r2, r3, #25165824	; 0x1800000
		ul_retval = CAN_MAILBOX_RX_OVER;
  40a9d8:	f1b2 7fc0 	cmp.w	r2, #25165824	; 0x1800000
  40a9dc:	bf14      	ite	ne
  40a9de:	2500      	movne	r5, #0
  40a9e0:	2502      	moveq	r5, #2
	}

	/* Read the message family ID. */
	p_mailbox->ul_fid = p_can->CAN_MB[uc_index].CAN_MFID &
  40a9e2:	780a      	ldrb	r2, [r1, #0]
  40a9e4:	eb00 1642 	add.w	r6, r0, r2, lsl #5
  40a9e8:	f8d6 420c 	ldr.w	r4, [r6, #524]	; 0x20c
  40a9ec:	f024 4460 	bic.w	r4, r4, #3758096384	; 0xe0000000
  40a9f0:	614c      	str	r4, [r1, #20]
			CAN_MFID_MFID_Msk;

	/* Read received data length. */
	p_mailbox->uc_length
		= (ul_status & CAN_MSR_MDLC_Msk) >> CAN_MSR_MDLC_Pos;
  40a9f2:	f3c3 4303 	ubfx	r3, r3, #16, #4
  40a9f6:	718b      	strb	r3, [r1, #6]

	/* Read received data. */
	p_mailbox->ul_datal = p_can->CAN_MB[uc_index].CAN_MDL;
  40a9f8:	f8d6 4214 	ldr.w	r4, [r6, #532]	; 0x214
  40a9fc:	618c      	str	r4, [r1, #24]
	if (p_mailbox->uc_length > 4) {
  40a9fe:	2b04      	cmp	r3, #4
  40aa00:	d902      	bls.n	40aa08 <can_mailbox_read+0x38>
		p_mailbox->ul_datah = p_can->CAN_MB[uc_index].CAN_MDH;
  40aa02:	f8d6 3218 	ldr.w	r3, [r6, #536]	; 0x218
  40aa06:	61cb      	str	r3, [r1, #28]
	}

	/* Read the mailbox status again to check whether the software needs to
	 * re-read mailbox data register. */
	p_mailbox->ul_status = p_can->CAN_MB[uc_index].CAN_MSR;
  40aa08:	eb00 1242 	add.w	r2, r0, r2, lsl #5
  40aa0c:	f8d2 3210 	ldr.w	r3, [r2, #528]	; 0x210
  40aa10:	608b      	str	r3, [r1, #8]
	ul_status = p_mailbox->ul_status;
	if (ul_status & CAN_MSR_MMI) {
  40aa12:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
		ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN;
  40aa16:	bf18      	it	ne
  40aa18:	f045 0504 	orrne.w	r5, r5, #4
	} else {
		ul_retval |= CAN_MAILBOX_TRANSFER_OK;
	}

	/* Enable next receive process. */
	can_mailbox_send_transfer_cmd(p_can, p_mailbox);
  40aa1c:	4b01      	ldr	r3, [pc, #4]	; (40aa24 <can_mailbox_read+0x54>)
  40aa1e:	4798      	blx	r3

	return ul_retval;
}
  40aa20:	4628      	mov	r0, r5
  40aa22:	bd70      	pop	{r4, r5, r6, pc}
  40aa24:	0040a937 	.word	0x0040a937

0040aa28 <can_mailbox_write>:
	return (p_can->CAN_MB[uc_index].CAN_MSR);
  40aa28:	780b      	ldrb	r3, [r1, #0]
  40aa2a:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  40aa2e:	f8d2 2210 	ldr.w	r2, [r2, #528]	; 0x210
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
	/* Read the mailbox status firstly to check whether the mailbox is ready
	 *or not. */
	p_mailbox->ul_status = can_mailbox_get_status(p_can, uc_index);
  40aa32:	608a      	str	r2, [r1, #8]
	ul_status = p_mailbox->ul_status;
	if (!(ul_status & CAN_MSR_MRDY)) {
  40aa34:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
  40aa38:	d028      	beq.n	40aa8c <can_mailbox_write+0x64>
{
  40aa3a:	b410      	push	{r4}
		return CAN_MAILBOX_NOT_READY;
	}

	/* Write transmit identifier. */
	if (p_mailbox->uc_id_ver) {
  40aa3c:	794a      	ldrb	r2, [r1, #5]
  40aa3e:	b1fa      	cbz	r2, 40aa80 <can_mailbox_write+0x58>
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  40aa40:	690a      	ldr	r2, [r1, #16]
  40aa42:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  40aa46:	eb00 1443 	add.w	r4, r0, r3, lsl #5
  40aa4a:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
	} else {
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
	}

	/* Write transmit data into mailbox data register. */
	p_can->CAN_MB[uc_index].CAN_MDL = p_mailbox->ul_datal;
  40aa4e:	698c      	ldr	r4, [r1, #24]
  40aa50:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  40aa54:	f8c2 4214 	str.w	r4, [r2, #532]	; 0x214
	if (p_mailbox->uc_length > 4) {
  40aa58:	798a      	ldrb	r2, [r1, #6]
  40aa5a:	2a04      	cmp	r2, #4
  40aa5c:	d904      	bls.n	40aa68 <can_mailbox_write+0x40>
		p_can->CAN_MB[uc_index].CAN_MDH = p_mailbox->ul_datah;
  40aa5e:	69cc      	ldr	r4, [r1, #28]
  40aa60:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  40aa64:	f8c2 4218 	str.w	r4, [r2, #536]	; 0x218
	}

	/* Write transmit data length into mailbox control register. */
	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MDLC(p_mailbox->uc_length);
  40aa68:	798a      	ldrb	r2, [r1, #6]
  40aa6a:	0412      	lsls	r2, r2, #16
  40aa6c:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
  40aa70:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  40aa74:	f8c0 221c 	str.w	r2, [r0, #540]	; 0x21c

	return CAN_MAILBOX_TRANSFER_OK;
  40aa78:	2000      	movs	r0, #0
}
  40aa7a:	f85d 4b04 	ldr.w	r4, [sp], #4
  40aa7e:	4770      	bx	lr
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  40aa80:	690c      	ldr	r4, [r1, #16]
  40aa82:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  40aa86:	f8c2 4208 	str.w	r4, [r2, #520]	; 0x208
  40aa8a:	e7e0      	b.n	40aa4e <can_mailbox_write+0x26>
		return CAN_MAILBOX_NOT_READY;
  40aa8c:	2001      	movs	r0, #1
  40aa8e:	4770      	bx	lr

0040aa90 <can_reset_all_mailbox>:
 * \brief Reset the eight mailboxes.
 *
 * \param p_can Pointer to a CAN peripheral instance.
 */
void can_reset_all_mailbox(Can *p_can)
{
  40aa90:	b570      	push	{r4, r5, r6, lr}
  40aa92:	b088      	sub	sp, #32
  40aa94:	4606      	mov	r6, r0
	can_mb_conf_t mb_config_t;

	/* Set the mailbox object type parameter to disable the mailbox. */
	mb_config_t.uc_obj_type = CAN_MB_DISABLE_MODE;
  40aa96:	2400      	movs	r4, #0
  40aa98:	f88d 4004 	strb.w	r4, [sp, #4]

	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
		mb_config_t.ul_mb_idx = i;
		can_mailbox_init(p_can, &mb_config_t);
  40aa9c:	4d04      	ldr	r5, [pc, #16]	; (40aab0 <can_reset_all_mailbox+0x20>)
		mb_config_t.ul_mb_idx = i;
  40aa9e:	9400      	str	r4, [sp, #0]
		can_mailbox_init(p_can, &mb_config_t);
  40aaa0:	4669      	mov	r1, sp
  40aaa2:	4630      	mov	r0, r6
  40aaa4:	47a8      	blx	r5
  40aaa6:	3401      	adds	r4, #1
	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  40aaa8:	2c08      	cmp	r4, #8
  40aaaa:	d1f8      	bne.n	40aa9e <can_reset_all_mailbox+0xe>
	}
}
  40aaac:	b008      	add	sp, #32
  40aaae:	bd70      	pop	{r4, r5, r6, pc}
  40aab0:	0040a94f 	.word	0x0040a94f

0040aab4 <can_init>:
{
  40aab4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  40aab6:	f246 13a8 	movw	r3, #25000	; 0x61a8
  40aaba:	fb03 f402 	mul.w	r4, r3, r2
  40aabe:	190b      	adds	r3, r1, r4
  40aac0:	3b01      	subs	r3, #1
  40aac2:	fbb3 f3f4 	udiv	r3, r3, r4
  40aac6:	2b80      	cmp	r3, #128	; 0x80
  40aac8:	d866      	bhi.n	40ab98 <can_init+0xe4>
	if ((ul_mck / 2)  < ul_baudrate * CAN_MIN_TQ_NUM * 1000) {
  40aaca:	f44f 54fa 	mov.w	r4, #8000	; 0x1f40
  40aace:	fb04 f402 	mul.w	r4, r4, r2
  40aad2:	ebb4 0f51 	cmp.w	r4, r1, lsr #1
  40aad6:	d861      	bhi.n	40ab9c <can_init+0xe8>
  40aad8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  40aadc:	fb03 f202 	mul.w	r2, r3, r2
  40aae0:	2708      	movs	r7, #8
  40aae2:	f04f 36ff 	mov.w	r6, #4294967295
  40aae6:	463b      	mov	r3, r7
  40aae8:	e004      	b.n	40aaf4 <can_init+0x40>
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  40aaea:	3301      	adds	r3, #1
  40aaec:	b2db      	uxtb	r3, r3
  40aaee:	4414      	add	r4, r2
  40aaf0:	2b1a      	cmp	r3, #26
  40aaf2:	d00c      	beq.n	40ab0e <can_init+0x5a>
		if ((ul_mck / (ul_baudrate * i * 1000)) <=
  40aaf4:	fbb1 f5f4 	udiv	r5, r1, r4
  40aaf8:	2d80      	cmp	r5, #128	; 0x80
  40aafa:	d8f6      	bhi.n	40aaea <can_init+0x36>
			ul_cur_mod = ul_mck % (ul_baudrate * i * 1000);
  40aafc:	fb04 1515 	mls	r5, r4, r5, r1
			if (ul_cur_mod < ul_mod) {
  40ab00:	42b5      	cmp	r5, r6
  40ab02:	d2f2      	bcs.n	40aaea <can_init+0x36>
				if (!ul_mod) {
  40ab04:	b115      	cbz	r5, 40ab0c <can_init+0x58>
				ul_mod = ul_cur_mod;
  40ab06:	462e      	mov	r6, r5
				if (!ul_mod) {
  40ab08:	461f      	mov	r7, r3
  40ab0a:	e7ee      	b.n	40aaea <can_init+0x36>
  40ab0c:	461f      	mov	r7, r3
	uc_prescale = ul_mck / (ul_baudrate * uc_tq * 1000);
  40ab0e:	fb02 f207 	mul.w	r2, r2, r7
  40ab12:	fbb1 f1f2 	udiv	r1, r1, r2
	if (uc_prescale < 2) {
  40ab16:	b2cb      	uxtb	r3, r1
  40ab18:	2b01      	cmp	r3, #1
  40ab1a:	d941      	bls.n	40aba0 <can_init+0xec>
  40ab1c:	4604      	mov	r4, r0
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];
  40ab1e:	f1a7 0208 	sub.w	r2, r7, #8
	p_can->CAN_MR &= ~CAN_MR_CANEN;
  40ab22:	6803      	ldr	r3, [r0, #0]
  40ab24:	f023 0301 	bic.w	r3, r3, #1
  40ab28:	6003      	str	r3, [r0, #0]
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  40ab2a:	4d1e      	ldr	r5, [pc, #120]	; (40aba4 <can_init+0xf0>)
  40ab2c:	0056      	lsls	r6, r2, #1
  40ab2e:	18b7      	adds	r7, r6, r2
  40ab30:	eb05 0747 	add.w	r7, r5, r7, lsl #1
  40ab34:	78bb      	ldrb	r3, [r7, #2]
  40ab36:	3b01      	subs	r3, #1
  40ab38:	011b      	lsls	r3, r3, #4
  40ab3a:	f003 0370 	and.w	r3, r3, #112	; 0x70
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  40ab3e:	7878      	ldrb	r0, [r7, #1]
  40ab40:	3801      	subs	r0, #1
  40ab42:	0200      	lsls	r0, r0, #8
  40ab44:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  40ab48:	4303      	orrs	r3, r0
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  40ab4a:	78f8      	ldrb	r0, [r7, #3]
  40ab4c:	3801      	subs	r0, #1
  40ab4e:	f000 0007 	and.w	r0, r0, #7
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  40ab52:	4303      	orrs	r3, r0
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  40ab54:	793a      	ldrb	r2, [r7, #4]
  40ab56:	3a01      	subs	r2, #1
  40ab58:	0312      	lsls	r2, r2, #12
  40ab5a:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  40ab5e:	4313      	orrs	r3, r2
			CAN_BR_BRP(uc_prescale - 1);
  40ab60:	b2ca      	uxtb	r2, r1
  40ab62:	3a01      	subs	r2, #1
  40ab64:	0412      	lsls	r2, r2, #16
  40ab66:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  40ab6a:	4313      	orrs	r3, r2
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  40ab6c:	6163      	str	r3, [r4, #20]
	can_reset_all_mailbox(p_can);
  40ab6e:	4620      	mov	r0, r4
  40ab70:	4b0d      	ldr	r3, [pc, #52]	; (40aba8 <can_init+0xf4>)
  40ab72:	4798      	blx	r3
	p_can->CAN_MR |= CAN_MR_CANEN;
  40ab74:	6823      	ldr	r3, [r4, #0]
  40ab76:	f043 0301 	orr.w	r3, r3, #1
  40ab7a:	6023      	str	r3, [r4, #0]
  40ab7c:	2300      	movs	r3, #0
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  40ab7e:	490b      	ldr	r1, [pc, #44]	; (40abac <can_init+0xf8>)
	return (p_can->CAN_SR);
  40ab80:	6922      	ldr	r2, [r4, #16]
		ul_tick++;
  40ab82:	3301      	adds	r3, #1
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  40ab84:	f412 1f00 	tst.w	r2, #2097152	; 0x200000
  40ab88:	d101      	bne.n	40ab8e <can_init+0xda>
  40ab8a:	428b      	cmp	r3, r1
  40ab8c:	d1f8      	bne.n	40ab80 <can_init+0xcc>
	if (CAN_TIMEOUT == ul_tick) {
  40ab8e:	4807      	ldr	r0, [pc, #28]	; (40abac <can_init+0xf8>)
  40ab90:	1a18      	subs	r0, r3, r0
  40ab92:	bf18      	it	ne
  40ab94:	2001      	movne	r0, #1
  40ab96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 0;
  40ab98:	2000      	movs	r0, #0
  40ab9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40ab9c:	2000      	movs	r0, #0
  40ab9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40aba0:	2000      	movs	r0, #0
}
  40aba2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40aba4:	0040e510 	.word	0x0040e510
  40aba8:	0040aa91 	.word	0x0040aa91
  40abac:	000186a0 	.word	0x000186a0

0040abb0 <pio_get_interrupt_status>:
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  40abb0:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  40abb2:	4770      	bx	lr

0040abb4 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  40abb4:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  40abb6:	4770      	bx	lr

0040abb8 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  40abb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40abbc:	4681      	mov	r9, r0
  40abbe:	460f      	mov	r7, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40abc0:	4b12      	ldr	r3, [pc, #72]	; (40ac0c <pio_handler_process+0x54>)
  40abc2:	4798      	blx	r3
  40abc4:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  40abc6:	4648      	mov	r0, r9
  40abc8:	4b11      	ldr	r3, [pc, #68]	; (40ac10 <pio_handler_process+0x58>)
  40abca:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  40abcc:	4005      	ands	r5, r0
  40abce:	d013      	beq.n	40abf8 <pio_handler_process+0x40>
  40abd0:	4c10      	ldr	r4, [pc, #64]	; (40ac14 <pio_handler_process+0x5c>)
  40abd2:	f104 0660 	add.w	r6, r4, #96	; 0x60
  40abd6:	e003      	b.n	40abe0 <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  40abd8:	42b4      	cmp	r4, r6
  40abda:	d00d      	beq.n	40abf8 <pio_handler_process+0x40>
  40abdc:	3410      	adds	r4, #16
		while (status != 0) {
  40abde:	b15d      	cbz	r5, 40abf8 <pio_handler_process+0x40>
			if (gs_interrupt_sources[i].id == ul_id) {
  40abe0:	6820      	ldr	r0, [r4, #0]
  40abe2:	42b8      	cmp	r0, r7
  40abe4:	d1f8      	bne.n	40abd8 <pio_handler_process+0x20>
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  40abe6:	6861      	ldr	r1, [r4, #4]
  40abe8:	4229      	tst	r1, r5
  40abea:	d0f5      	beq.n	40abd8 <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  40abec:	68e3      	ldr	r3, [r4, #12]
  40abee:	4798      	blx	r3
					status &= ~(gs_interrupt_sources[i].mask);
  40abf0:	6863      	ldr	r3, [r4, #4]
  40abf2:	ea25 0503 	bic.w	r5, r5, r3
  40abf6:	e7ef      	b.n	40abd8 <pio_handler_process+0x20>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  40abf8:	4b07      	ldr	r3, [pc, #28]	; (40ac18 <pio_handler_process+0x60>)
  40abfa:	681b      	ldr	r3, [r3, #0]
  40abfc:	b123      	cbz	r3, 40ac08 <pio_handler_process+0x50>
		if (pio_capture_handler) {
  40abfe:	4b07      	ldr	r3, [pc, #28]	; (40ac1c <pio_handler_process+0x64>)
  40ac00:	681b      	ldr	r3, [r3, #0]
  40ac02:	b10b      	cbz	r3, 40ac08 <pio_handler_process+0x50>
			pio_capture_handler(p_pio);
  40ac04:	4648      	mov	r0, r9
  40ac06:	4798      	blx	r3
  40ac08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40ac0c:	0040abb1 	.word	0x0040abb1
  40ac10:	0040abb5 	.word	0x0040abb5
  40ac14:	20011770 	.word	0x20011770
  40ac18:	20011800 	.word	0x20011800
  40ac1c:	200117e0 	.word	0x200117e0

0040ac20 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  40ac20:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  40ac22:	2109      	movs	r1, #9
  40ac24:	4801      	ldr	r0, [pc, #4]	; (40ac2c <PIOA_Handler+0xc>)
  40ac26:	4b02      	ldr	r3, [pc, #8]	; (40ac30 <PIOA_Handler+0x10>)
  40ac28:	4798      	blx	r3
  40ac2a:	bd08      	pop	{r3, pc}
  40ac2c:	400e0e00 	.word	0x400e0e00
  40ac30:	0040abb9 	.word	0x0040abb9

0040ac34 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  40ac34:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  40ac36:	210a      	movs	r1, #10
  40ac38:	4801      	ldr	r0, [pc, #4]	; (40ac40 <PIOB_Handler+0xc>)
  40ac3a:	4b02      	ldr	r3, [pc, #8]	; (40ac44 <PIOB_Handler+0x10>)
  40ac3c:	4798      	blx	r3
  40ac3e:	bd08      	pop	{r3, pc}
  40ac40:	400e1000 	.word	0x400e1000
  40ac44:	0040abb9 	.word	0x0040abb9

0040ac48 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  40ac48:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
  40ac4a:	210b      	movs	r1, #11
  40ac4c:	4801      	ldr	r0, [pc, #4]	; (40ac54 <PIOC_Handler+0xc>)
  40ac4e:	4b02      	ldr	r3, [pc, #8]	; (40ac58 <PIOC_Handler+0x10>)
  40ac50:	4798      	blx	r3
  40ac52:	bd08      	pop	{r3, pc}
  40ac54:	400e1200 	.word	0x400e1200
  40ac58:	0040abb9 	.word	0x0040abb9

0040ac5c <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
  40ac5c:	b508      	push	{r3, lr}
	pio_handler_process(PIOD, ID_PIOD);
  40ac5e:	210c      	movs	r1, #12
  40ac60:	4801      	ldr	r0, [pc, #4]	; (40ac68 <PIOD_Handler+0xc>)
  40ac62:	4b02      	ldr	r3, [pc, #8]	; (40ac6c <PIOD_Handler+0x10>)
  40ac64:	4798      	blx	r3
  40ac66:	bd08      	pop	{r3, pc}
  40ac68:	400e1400 	.word	0x400e1400
  40ac6c:	0040abb9 	.word	0x0040abb9

0040ac70 <PIOE_Handler>:
/**
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
  40ac70:	b508      	push	{r3, lr}
	pio_handler_process(PIOE, ID_PIOE);
  40ac72:	210d      	movs	r1, #13
  40ac74:	4801      	ldr	r0, [pc, #4]	; (40ac7c <PIOE_Handler+0xc>)
  40ac76:	4b02      	ldr	r3, [pc, #8]	; (40ac80 <PIOE_Handler+0x10>)
  40ac78:	4798      	blx	r3
  40ac7a:	bd08      	pop	{r3, pc}
  40ac7c:	400e1600 	.word	0x400e1600
  40ac80:	0040abb9 	.word	0x0040abb9

0040ac84 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  40ac84:	4a17      	ldr	r2, [pc, #92]	; (40ace4 <pmc_switch_mck_to_pllack+0x60>)
  40ac86:	6b13      	ldr	r3, [r2, #48]	; 0x30
  40ac88:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  40ac8c:	4318      	orrs	r0, r3
  40ac8e:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40ac90:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40ac92:	f013 0f08 	tst.w	r3, #8
  40ac96:	d10a      	bne.n	40acae <pmc_switch_mck_to_pllack+0x2a>
  40ac98:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40ac9c:	4911      	ldr	r1, [pc, #68]	; (40ace4 <pmc_switch_mck_to_pllack+0x60>)
  40ac9e:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  40aca0:	f012 0f08 	tst.w	r2, #8
  40aca4:	d103      	bne.n	40acae <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40aca6:	3b01      	subs	r3, #1
  40aca8:	d1f9      	bne.n	40ac9e <pmc_switch_mck_to_pllack+0x1a>
			return 1;
  40acaa:	2001      	movs	r0, #1
  40acac:	4770      	bx	lr
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40acae:	4a0d      	ldr	r2, [pc, #52]	; (40ace4 <pmc_switch_mck_to_pllack+0x60>)
  40acb0:	6b13      	ldr	r3, [r2, #48]	; 0x30
  40acb2:	f023 0303 	bic.w	r3, r3, #3
  40acb6:	f043 0302 	orr.w	r3, r3, #2
  40acba:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40acbc:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40acbe:	f013 0f08 	tst.w	r3, #8
  40acc2:	d10a      	bne.n	40acda <pmc_switch_mck_to_pllack+0x56>
  40acc4:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40acc8:	4906      	ldr	r1, [pc, #24]	; (40ace4 <pmc_switch_mck_to_pllack+0x60>)
  40acca:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  40accc:	f012 0f08 	tst.w	r2, #8
  40acd0:	d105      	bne.n	40acde <pmc_switch_mck_to_pllack+0x5a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40acd2:	3b01      	subs	r3, #1
  40acd4:	d1f9      	bne.n	40acca <pmc_switch_mck_to_pllack+0x46>
			return 1;
  40acd6:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  40acd8:	4770      	bx	lr
	return 0;
  40acda:	2000      	movs	r0, #0
  40acdc:	4770      	bx	lr
  40acde:	2000      	movs	r0, #0
  40ace0:	4770      	bx	lr
  40ace2:	bf00      	nop
  40ace4:	400e0400 	.word	0x400e0400

0040ace8 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  40ace8:	b9c8      	cbnz	r0, 40ad1e <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40acea:	4a11      	ldr	r2, [pc, #68]	; (40ad30 <pmc_switch_mainck_to_xtal+0x48>)
  40acec:	6a13      	ldr	r3, [r2, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40acee:	0209      	lsls	r1, r1, #8
  40acf0:	b289      	uxth	r1, r1
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40acf2:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  40acf6:	f023 0303 	bic.w	r3, r3, #3
  40acfa:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40acfe:	f043 0301 	orr.w	r3, r3, #1
  40ad02:	430b      	orrs	r3, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40ad04:	6213      	str	r3, [r2, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  40ad06:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40ad08:	f013 0f01 	tst.w	r3, #1
  40ad0c:	d0fb      	beq.n	40ad06 <pmc_switch_mainck_to_xtal+0x1e>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  40ad0e:	4a08      	ldr	r2, [pc, #32]	; (40ad30 <pmc_switch_mainck_to_xtal+0x48>)
  40ad10:	6a13      	ldr	r3, [r2, #32]
  40ad12:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  40ad16:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  40ad1a:	6213      	str	r3, [r2, #32]
  40ad1c:	4770      	bx	lr
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40ad1e:	4904      	ldr	r1, [pc, #16]	; (40ad30 <pmc_switch_mainck_to_xtal+0x48>)
  40ad20:	6a0b      	ldr	r3, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40ad22:	4a04      	ldr	r2, [pc, #16]	; (40ad34 <pmc_switch_mainck_to_xtal+0x4c>)
  40ad24:	401a      	ands	r2, r3
  40ad26:	4b04      	ldr	r3, [pc, #16]	; (40ad38 <pmc_switch_mainck_to_xtal+0x50>)
  40ad28:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40ad2a:	620b      	str	r3, [r1, #32]
  40ad2c:	4770      	bx	lr
  40ad2e:	bf00      	nop
  40ad30:	400e0400 	.word	0x400e0400
  40ad34:	fec8fffc 	.word	0xfec8fffc
  40ad38:	01370002 	.word	0x01370002

0040ad3c <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  40ad3c:	4b02      	ldr	r3, [pc, #8]	; (40ad48 <pmc_osc_is_ready_mainck+0xc>)
  40ad3e:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40ad40:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  40ad44:	4770      	bx	lr
  40ad46:	bf00      	nop
  40ad48:	400e0400 	.word	0x400e0400

0040ad4c <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  40ad4c:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40ad50:	4b01      	ldr	r3, [pc, #4]	; (40ad58 <pmc_disable_pllack+0xc>)
  40ad52:	629a      	str	r2, [r3, #40]	; 0x28
  40ad54:	4770      	bx	lr
  40ad56:	bf00      	nop
  40ad58:	400e0400 	.word	0x400e0400

0040ad5c <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  40ad5c:	4b02      	ldr	r3, [pc, #8]	; (40ad68 <pmc_is_locked_pllack+0xc>)
  40ad5e:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40ad60:	f000 0002 	and.w	r0, r0, #2
  40ad64:	4770      	bx	lr
  40ad66:	bf00      	nop
  40ad68:	400e0400 	.word	0x400e0400

0040ad6c <pmc_enable_periph_clk>:
	PMC->PMC_PCR = ul_id & 0x7F;
	pcr = PMC->PMC_PCR | PMC_PCR_EN | PMC_PCR_CMD;
	PMC->PMC_PCR = pcr;
	return 0;
#else
	if (ul_id > MAX_PERIPH_ID) {
  40ad6c:	282f      	cmp	r0, #47	; 0x2f
  40ad6e:	d81e      	bhi.n	40adae <pmc_enable_periph_clk+0x42>
		return 1;
	}

	if (ul_id < 32) {
  40ad70:	281f      	cmp	r0, #31
  40ad72:	d80c      	bhi.n	40ad8e <pmc_enable_periph_clk+0x22>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  40ad74:	4b11      	ldr	r3, [pc, #68]	; (40adbc <pmc_enable_periph_clk+0x50>)
  40ad76:	699a      	ldr	r2, [r3, #24]
  40ad78:	2301      	movs	r3, #1
  40ad7a:	4083      	lsls	r3, r0
  40ad7c:	4393      	bics	r3, r2
  40ad7e:	d018      	beq.n	40adb2 <pmc_enable_periph_clk+0x46>
			PMC->PMC_PCER0 = 1 << ul_id;
  40ad80:	2301      	movs	r3, #1
  40ad82:	fa03 f000 	lsl.w	r0, r3, r0
  40ad86:	4b0d      	ldr	r3, [pc, #52]	; (40adbc <pmc_enable_periph_clk+0x50>)
  40ad88:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  40ad8a:	2000      	movs	r0, #0
  40ad8c:	4770      	bx	lr
		ul_id -= 32;
  40ad8e:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40ad90:	4b0a      	ldr	r3, [pc, #40]	; (40adbc <pmc_enable_periph_clk+0x50>)
  40ad92:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40ad96:	2301      	movs	r3, #1
  40ad98:	4083      	lsls	r3, r0
  40ad9a:	4393      	bics	r3, r2
  40ad9c:	d00b      	beq.n	40adb6 <pmc_enable_periph_clk+0x4a>
			PMC->PMC_PCER1 = 1 << ul_id;
  40ad9e:	2301      	movs	r3, #1
  40ada0:	fa03 f000 	lsl.w	r0, r3, r0
  40ada4:	4b05      	ldr	r3, [pc, #20]	; (40adbc <pmc_enable_periph_clk+0x50>)
  40ada6:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	return 0;
  40adaa:	2000      	movs	r0, #0
  40adac:	4770      	bx	lr
		return 1;
  40adae:	2001      	movs	r0, #1
  40adb0:	4770      	bx	lr
	return 0;
  40adb2:	2000      	movs	r0, #0
  40adb4:	4770      	bx	lr
  40adb6:	2000      	movs	r0, #0
#endif /* defined(REG_PMC_PCR) && !SAMG55 */
}
  40adb8:	4770      	bx	lr
  40adba:	bf00      	nop
  40adbc:	400e0400 	.word	0x400e0400

0040adc0 <spi_enable_clock>:
 * \brief Enable SPI clock.
 *
 * \param p_spi Pointer to an SPI instance.
 */
void spi_enable_clock(Spi *p_spi)
{
  40adc0:	b508      	push	{r3, lr}
  40adc2:	2013      	movs	r0, #19
  40adc4:	4b01      	ldr	r3, [pc, #4]	; (40adcc <spi_enable_clock+0xc>)
  40adc6:	4798      	blx	r3
  40adc8:	bd08      	pop	{r3, pc}
  40adca:	bf00      	nop
  40adcc:	0040ad6d 	.word	0x0040ad6d

0040add0 <spi_set_peripheral_chip_select_value>:
 *                 \ref spi_enable_peripheral_select_decode,
 *                 \ref spi_disable_peripheral_select_decode.
 */
void spi_set_peripheral_chip_select_value(Spi *p_spi, uint32_t ul_value)
{
	p_spi->SPI_MR &= (~SPI_MR_PCS_Msk);
  40add0:	6843      	ldr	r3, [r0, #4]
  40add2:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
  40add6:	6043      	str	r3, [r0, #4]
	p_spi->SPI_MR |= SPI_MR_PCS(ul_value);
  40add8:	6843      	ldr	r3, [r0, #4]
  40adda:	0409      	lsls	r1, r1, #16
  40addc:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
  40ade0:	4319      	orrs	r1, r3
  40ade2:	6041      	str	r1, [r0, #4]
  40ade4:	4770      	bx	lr

0040ade6 <spi_set_delay_between_chip_select>:
 * \param p_spi Pointer to an SPI instance.
 * \param ul_delay Delay between chip selects (in number of MCK clocks).
 */
void spi_set_delay_between_chip_select(Spi *p_spi, uint32_t ul_delay)
{
	p_spi->SPI_MR &= (~SPI_MR_DLYBCS_Msk);
  40ade6:	6843      	ldr	r3, [r0, #4]
  40ade8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  40adec:	6043      	str	r3, [r0, #4]
	p_spi->SPI_MR |= SPI_MR_DLYBCS(ul_delay);
  40adee:	6843      	ldr	r3, [r0, #4]
  40adf0:	ea43 6101 	orr.w	r1, r3, r1, lsl #24
  40adf4:	6041      	str	r1, [r0, #4]
  40adf6:	4770      	bx	lr

0040adf8 <spi_set_clock_polarity>:
 * \param ul_polarity Default clock state is logical one(high)/zero(low).
 */
void spi_set_clock_polarity(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_polarity)
{
	if (ul_polarity) {
  40adf8:	b932      	cbnz	r2, 40ae08 <spi_set_clock_polarity+0x10>
  40adfa:	eb00 0081 	add.w	r0, r0, r1, lsl #2
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CPOL;
	} else {
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CPOL);
  40adfe:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae00:	f023 0301 	bic.w	r3, r3, #1
  40ae04:	6303      	str	r3, [r0, #48]	; 0x30
  40ae06:	4770      	bx	lr
  40ae08:	eb00 0081 	add.w	r0, r0, r1, lsl #2
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CPOL;
  40ae0c:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae0e:	f043 0301 	orr.w	r3, r3, #1
  40ae12:	6303      	str	r3, [r0, #48]	; 0x30
  40ae14:	4770      	bx	lr

0040ae16 <spi_set_clock_phase>:
 *  \param ul_pcs_ch Peripheral Chip Select channel (0~3).
 *  \param ul_phase Data capture on the rising/falling edge of clock.
 */
void spi_set_clock_phase(Spi *p_spi, uint32_t ul_pcs_ch, uint32_t ul_phase)
{
	if (ul_phase) {
  40ae16:	b932      	cbnz	r2, 40ae26 <spi_set_clock_phase+0x10>
  40ae18:	eb00 0081 	add.w	r0, r0, r1, lsl #2
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_NCPHA;
	} else {
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_NCPHA);
  40ae1c:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae1e:	f023 0302 	bic.w	r3, r3, #2
  40ae22:	6303      	str	r3, [r0, #48]	; 0x30
  40ae24:	4770      	bx	lr
  40ae26:	eb00 0081 	add.w	r0, r0, r1, lsl #2
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_NCPHA;
  40ae2a:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae2c:	f043 0302 	orr.w	r3, r3, #2
  40ae30:	6303      	str	r3, [r0, #48]	; 0x30
  40ae32:	4770      	bx	lr

0040ae34 <spi_configure_cs_behavior>:
 * \param ul_cs_behavior Behavior of the Chip Select after transfer.
 */
void spi_configure_cs_behavior(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_cs_behavior)
{
	if (ul_cs_behavior == SPI_CS_RISE_FORCED) {
  40ae34:	2a04      	cmp	r2, #4
  40ae36:	d003      	beq.n	40ae40 <spi_configure_cs_behavior+0xc>
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CSNAAT;
	} else if (ul_cs_behavior == SPI_CS_RISE_NO_TX) {
  40ae38:	b16a      	cbz	r2, 40ae56 <spi_configure_cs_behavior+0x22>
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSNAAT);
	} else if (ul_cs_behavior == SPI_CS_KEEP_LOW) {
  40ae3a:	2a08      	cmp	r2, #8
  40ae3c:	d016      	beq.n	40ae6c <spi_configure_cs_behavior+0x38>
  40ae3e:	4770      	bx	lr
  40ae40:	eb00 0081 	add.w	r0, r0, r1, lsl #2
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
  40ae44:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae46:	f023 0308 	bic.w	r3, r3, #8
  40ae4a:	6303      	str	r3, [r0, #48]	; 0x30
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CSNAAT;
  40ae4c:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae4e:	f043 0304 	orr.w	r3, r3, #4
  40ae52:	6303      	str	r3, [r0, #48]	; 0x30
  40ae54:	4770      	bx	lr
  40ae56:	eb00 0081 	add.w	r0, r0, r1, lsl #2
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
  40ae5a:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae5c:	f023 0308 	bic.w	r3, r3, #8
  40ae60:	6303      	str	r3, [r0, #48]	; 0x30
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSNAAT);
  40ae62:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae64:	f023 0304 	bic.w	r3, r3, #4
  40ae68:	6303      	str	r3, [r0, #48]	; 0x30
  40ae6a:	4770      	bx	lr
  40ae6c:	eb00 0081 	add.w	r0, r0, r1, lsl #2
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CSAAT;
  40ae70:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40ae72:	f043 0308 	orr.w	r3, r3, #8
  40ae76:	6303      	str	r3, [r0, #48]	; 0x30
	}
}
  40ae78:	e7e1      	b.n	40ae3e <spi_configure_cs_behavior+0xa>

0040ae7a <spi_set_bits_per_transfer>:
 * \param ul_bits Number of bits (8~16), use the pattern defined
 *        in the device header file.
 */
void spi_set_bits_per_transfer(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_bits)
{
  40ae7a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_BITS_Msk);
  40ae7e:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  40ae80:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  40ae84:	630b      	str	r3, [r1, #48]	; 0x30
	p_spi->SPI_CSR[ul_pcs_ch] |= ul_bits;
  40ae86:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  40ae88:	431a      	orrs	r2, r3
  40ae8a:	630a      	str	r2, [r1, #48]	; 0x30
  40ae8c:	4770      	bx	lr

0040ae8e <spi_calc_baudrate_div>:
 *   \retval > 0  Success.
 *   \retval < 0  Error.
 */
int16_t spi_calc_baudrate_div(const uint32_t baudrate, uint32_t mck)
{
	int baud_div = div_ceil(mck, baudrate);
  40ae8e:	1e43      	subs	r3, r0, #1
  40ae90:	4419      	add	r1, r3
  40ae92:	fbb1 f0f0 	udiv	r0, r1, r0

	/* The value of baud_div is from 1 to 255 in the SCBR field. */
	if (baud_div <= 0 || baud_div > 255) {
  40ae96:	1e43      	subs	r3, r0, #1
  40ae98:	2bfe      	cmp	r3, #254	; 0xfe
		return -1;
	}

	return baud_div;
  40ae9a:	bf94      	ite	ls
  40ae9c:	b200      	sxthls	r0, r0
		return -1;
  40ae9e:	f04f 30ff 	movhi.w	r0, #4294967295
}
  40aea2:	4770      	bx	lr

0040aea4 <spi_set_baudrate_div>:
 */
int16_t spi_set_baudrate_div(Spi *p_spi, uint32_t ul_pcs_ch,
		uint8_t uc_baudrate_divider)
{
    /* Programming the SCBR field to 0 is forbidden */
    if (!uc_baudrate_divider){
  40aea4:	b17a      	cbz	r2, 40aec6 <spi_set_baudrate_div+0x22>
{
  40aea6:	b410      	push	{r4}
  40aea8:	4614      	mov	r4, r2
  40aeaa:	eb00 0181 	add.w	r1, r0, r1, lsl #2
        return -1;
	}
	p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_SCBR_Msk);
  40aeae:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  40aeb0:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
  40aeb4:	630b      	str	r3, [r1, #48]	; 0x30
	p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_SCBR(uc_baudrate_divider);
  40aeb6:	6b0a      	ldr	r2, [r1, #48]	; 0x30
  40aeb8:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  40aebc:	630a      	str	r2, [r1, #48]	; 0x30
    return 0;
  40aebe:	2000      	movs	r0, #0
}
  40aec0:	f85d 4b04 	ldr.w	r4, [sp], #4
  40aec4:	4770      	bx	lr
        return -1;
  40aec6:	f04f 30ff 	mov.w	r0, #4294967295
  40aeca:	4770      	bx	lr

0040aecc <spi_set_transfer_delay>:
 * \param uc_dlybs Delay before SPCK (in number of MCK clocks).
 * \param uc_dlybct Delay between consecutive transfers (in number of MCK clocks).
 */
void spi_set_transfer_delay(Spi *p_spi, uint32_t ul_pcs_ch,
		uint8_t uc_dlybs, uint8_t uc_dlybct)
{
  40aecc:	b410      	push	{r4}
  40aece:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	p_spi->SPI_CSR[ul_pcs_ch] &= ~(SPI_CSR_DLYBS_Msk | SPI_CSR_DLYBCT_Msk);
  40aed2:	6b08      	ldr	r0, [r1, #48]	; 0x30
  40aed4:	b280      	uxth	r0, r0
  40aed6:	6308      	str	r0, [r1, #48]	; 0x30
	p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_DLYBS(uc_dlybs)
  40aed8:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  40aeda:	ea44 6303 	orr.w	r3, r4, r3, lsl #24
  40aede:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  40aee2:	630b      	str	r3, [r1, #48]	; 0x30
			| SPI_CSR_DLYBCT(uc_dlybct);
}
  40aee4:	f85d 4b04 	ldr.w	r4, [sp], #4
  40aee8:	4770      	bx	lr

0040aeea <uart_init>:
 *
 * \retval 0 Success.
 * \retval 1 Bad baud rate generator value.
 */
uint32_t uart_init(Uart *p_uart, const sam_uart_opt_t *p_uart_opt)
{
  40aeea:	b410      	push	{r4}
	uint32_t cd = 0;

	/* Reset and disable receiver & transmitter */
	p_uart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX
  40aeec:	23ac      	movs	r3, #172	; 0xac
  40aeee:	6003      	str	r3, [r0, #0]
			| UART_CR_RXDIS | UART_CR_TXDIS;

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
  40aef0:	680b      	ldr	r3, [r1, #0]
  40aef2:	684a      	ldr	r2, [r1, #4]
  40aef4:	fbb3 f3f2 	udiv	r3, r3, r2
  40aef8:	091b      	lsrs	r3, r3, #4
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
  40aefa:	1e5c      	subs	r4, r3, #1
  40aefc:	f64f 72fe 	movw	r2, #65534	; 0xfffe
  40af00:	4294      	cmp	r4, r2
  40af02:	d80c      	bhi.n	40af1e <uart_init+0x34>
		return 1;

	p_uart->UART_BRGR = cd;
  40af04:	6203      	str	r3, [r0, #32]
	/* Configure mode */
	p_uart->UART_MR = p_uart_opt->ul_mode;
  40af06:	688b      	ldr	r3, [r1, #8]
  40af08:	6043      	str	r3, [r0, #4]

#if (!SAMV71 && !SAMV70 && !SAME70 && !SAMS70)
	/* Disable PDC channel */
	p_uart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
  40af0a:	f240 2302 	movw	r3, #514	; 0x202
  40af0e:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
#endif

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  40af12:	2350      	movs	r3, #80	; 0x50
  40af14:	6003      	str	r3, [r0, #0]

	return 0;
  40af16:	2000      	movs	r0, #0
}
  40af18:	f85d 4b04 	ldr.w	r4, [sp], #4
  40af1c:	4770      	bx	lr
		return 1;
  40af1e:	2001      	movs	r0, #1
  40af20:	e7fa      	b.n	40af18 <uart_init+0x2e>

0040af22 <uart_write>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  40af22:	6943      	ldr	r3, [r0, #20]
  40af24:	f013 0f02 	tst.w	r3, #2
		return 1;

	/* Send character */
	p_uart->UART_THR = uc_data;
  40af28:	bf1a      	itte	ne
  40af2a:	61c1      	strne	r1, [r0, #28]
	return 0;
  40af2c:	2000      	movne	r0, #0
		return 1;
  40af2e:	2001      	moveq	r0, #1
}
  40af30:	4770      	bx	lr

0040af32 <uart_read>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
  40af32:	6943      	ldr	r3, [r0, #20]
  40af34:	f013 0f01 	tst.w	r3, #1
		return 1;

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
  40af38:	bf1d      	ittte	ne
  40af3a:	6983      	ldrne	r3, [r0, #24]
  40af3c:	700b      	strbne	r3, [r1, #0]
	return 0;
  40af3e:	2000      	movne	r0, #0
		return 1;
  40af40:	2001      	moveq	r0, #1
}
  40af42:	4770      	bx	lr

0040af44 <usart_write>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  40af44:	6943      	ldr	r3, [r0, #20]
  40af46:	f013 0f02 	tst.w	r3, #2
		return 1;
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  40af4a:	bf1d      	ittte	ne
  40af4c:	f3c1 0108 	ubfxne	r1, r1, #0, #9
  40af50:	61c1      	strne	r1, [r0, #28]
	return 0;
  40af52:	2000      	movne	r0, #0
		return 1;
  40af54:	2001      	moveq	r0, #1
}
  40af56:	4770      	bx	lr

0040af58 <usart_read>:
 * \retval 0 on success.
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  40af58:	6943      	ldr	r3, [r0, #20]
  40af5a:	f013 0f01 	tst.w	r3, #1
  40af5e:	d005      	beq.n	40af6c <usart_read+0x14>
		return 1;
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  40af60:	6983      	ldr	r3, [r0, #24]
  40af62:	f3c3 0308 	ubfx	r3, r3, #0, #9
  40af66:	600b      	str	r3, [r1, #0]

	return 0;
  40af68:	2000      	movs	r0, #0
  40af6a:	4770      	bx	lr
		return 1;
  40af6c:	2001      	movs	r0, #1
}
  40af6e:	4770      	bx	lr

0040af70 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  40af70:	e7fe      	b.n	40af70 <Dummy_Handler>
	...

0040af74 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  40af74:	b500      	push	{lr}
  40af76:	b083      	sub	sp, #12

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
  40af78:	4b25      	ldr	r3, [pc, #148]	; (40b010 <Reset_Handler+0x9c>)
  40af7a:	4a26      	ldr	r2, [pc, #152]	; (40b014 <Reset_Handler+0xa0>)
  40af7c:	429a      	cmp	r2, r3
  40af7e:	d010      	beq.n	40afa2 <Reset_Handler+0x2e>
		for (; pDest < &_erelocate;) {
  40af80:	4b25      	ldr	r3, [pc, #148]	; (40b018 <Reset_Handler+0xa4>)
  40af82:	4a23      	ldr	r2, [pc, #140]	; (40b010 <Reset_Handler+0x9c>)
  40af84:	429a      	cmp	r2, r3
  40af86:	d20c      	bcs.n	40afa2 <Reset_Handler+0x2e>
  40af88:	3b01      	subs	r3, #1
  40af8a:	1a9b      	subs	r3, r3, r2
  40af8c:	f023 0303 	bic.w	r3, r3, #3
  40af90:	3304      	adds	r3, #4
  40af92:	4413      	add	r3, r2
  40af94:	491f      	ldr	r1, [pc, #124]	; (40b014 <Reset_Handler+0xa0>)
			*pDest++ = *pSrc++;
  40af96:	f851 0b04 	ldr.w	r0, [r1], #4
  40af9a:	f842 0b04 	str.w	r0, [r2], #4
		for (; pDest < &_erelocate;) {
  40af9e:	429a      	cmp	r2, r3
  40afa0:	d1f9      	bne.n	40af96 <Reset_Handler+0x22>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40afa2:	4b1e      	ldr	r3, [pc, #120]	; (40b01c <Reset_Handler+0xa8>)
  40afa4:	4a1e      	ldr	r2, [pc, #120]	; (40b020 <Reset_Handler+0xac>)
  40afa6:	429a      	cmp	r2, r3
  40afa8:	d20a      	bcs.n	40afc0 <Reset_Handler+0x4c>
  40afaa:	3b01      	subs	r3, #1
  40afac:	1a9b      	subs	r3, r3, r2
  40afae:	f023 0303 	bic.w	r3, r3, #3
  40afb2:	3304      	adds	r3, #4
  40afb4:	4413      	add	r3, r2
		*pDest++ = 0;
  40afb6:	2100      	movs	r1, #0
  40afb8:	f842 1b04 	str.w	r1, [r2], #4
	for (pDest = &_szero; pDest < &_ezero;) {
  40afbc:	4293      	cmp	r3, r2
  40afbe:	d1fb      	bne.n	40afb8 <Reset_Handler+0x44>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  40afc0:	4a18      	ldr	r2, [pc, #96]	; (40b024 <Reset_Handler+0xb0>)
  40afc2:	4b19      	ldr	r3, [pc, #100]	; (40b028 <Reset_Handler+0xb4>)
  40afc4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40afc8:	6093      	str	r3, [r2, #8]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  40afca:	f3ef 8310 	mrs	r3, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = cpu_irq_is_enabled();
  40afce:	fab3 f383 	clz	r3, r3
  40afd2:	095b      	lsrs	r3, r3, #5
  40afd4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
  40afd6:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
  40afd8:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  40afdc:	2200      	movs	r2, #0
  40afde:	4b13      	ldr	r3, [pc, #76]	; (40b02c <Reset_Handler+0xb8>)
  40afe0:	701a      	strb	r2, [r3, #0]
	return flags;
  40afe2:	9901      	ldr	r1, [sp, #4]
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
	REG_CPACR |=  (0xFu << 20);
  40afe4:	4a12      	ldr	r2, [pc, #72]	; (40b030 <Reset_Handler+0xbc>)
  40afe6:	6813      	ldr	r3, [r2, #0]
  40afe8:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  40afec:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
  40afee:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  40aff2:	f3bf 8f6f 	isb	sy
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
  40aff6:	b129      	cbz	r1, 40b004 <Reset_Handler+0x90>
		cpu_irq_enable();
  40aff8:	2201      	movs	r2, #1
  40affa:	4b0c      	ldr	r3, [pc, #48]	; (40b02c <Reset_Handler+0xb8>)
  40affc:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("dmb 0xF":::"memory");
  40affe:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  40b002:	b662      	cpsie	i
#if __FPU_USED
	fpu_enable();
#endif

	/* Initialize the C library */
	__libc_init_array();
  40b004:	4b0b      	ldr	r3, [pc, #44]	; (40b034 <Reset_Handler+0xc0>)
  40b006:	4798      	blx	r3

	/* Branch to main function */
	main();
  40b008:	4b0b      	ldr	r3, [pc, #44]	; (40b038 <Reset_Handler+0xc4>)
  40b00a:	4798      	blx	r3
  40b00c:	e7fe      	b.n	40b00c <Reset_Handler+0x98>
  40b00e:	bf00      	nop
  40b010:	20000000 	.word	0x20000000
  40b014:	0040e770 	.word	0x0040e770
  40b018:	200001f0 	.word	0x200001f0
  40b01c:	20011808 	.word	0x20011808
  40b020:	200001f0 	.word	0x200001f0
  40b024:	e000ed00 	.word	0xe000ed00
  40b028:	00400000 	.word	0x00400000
  40b02c:	20000018 	.word	0x20000018
  40b030:	e000ed88 	.word	0xe000ed88
  40b034:	0040c209 	.word	0x0040c209
  40b038:	0040054d 	.word	0x0040054d

0040b03c <SystemInit>:
 * Initialize the System and update the SystemFrequency variable.
 */
void SystemInit( void )
{
	/* Set FWS according to SYS_BOARD_MCKR configuration */
	EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  40b03c:	4a1f      	ldr	r2, [pc, #124]	; (40b0bc <SystemInit+0x80>)
  40b03e:	4b20      	ldr	r3, [pc, #128]	; (40b0c0 <SystemInit+0x84>)
  40b040:	601a      	str	r2, [r3, #0]

	/* Initialize main oscillator */
	if ( !(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) ) {
  40b042:	f5a3 63c0 	sub.w	r3, r3, #1536	; 0x600
  40b046:	6a1b      	ldr	r3, [r3, #32]
  40b048:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  40b04c:	d107      	bne.n	40b05e <SystemInit+0x22>
		PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT |
  40b04e:	4a1d      	ldr	r2, [pc, #116]	; (40b0c4 <SystemInit+0x88>)
  40b050:	4b1d      	ldr	r3, [pc, #116]	; (40b0c8 <SystemInit+0x8c>)
  40b052:	621a      	str	r2, [r3, #32]
				CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;

		while ( !(PMC->PMC_SR & PMC_SR_MOSCXTS) ) {
  40b054:	461a      	mov	r2, r3
  40b056:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40b058:	f013 0f01 	tst.w	r3, #1
  40b05c:	d0fb      	beq.n	40b056 <SystemInit+0x1a>
		}
	}

	/* Switch to 3-20MHz Xtal oscillator */
	PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT |
  40b05e:	4a1b      	ldr	r2, [pc, #108]	; (40b0cc <SystemInit+0x90>)
  40b060:	4b19      	ldr	r3, [pc, #100]	; (40b0c8 <SystemInit+0x8c>)
  40b062:	621a      	str	r2, [r3, #32]
			CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN |
			CKGR_MOR_MOSCSEL;

	while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) ) {
  40b064:	461a      	mov	r2, r3
  40b066:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40b068:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  40b06c:	d0fb      	beq.n	40b066 <SystemInit+0x2a>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) |
  40b06e:	4a16      	ldr	r2, [pc, #88]	; (40b0c8 <SystemInit+0x8c>)
  40b070:	6b13      	ldr	r3, [r2, #48]	; 0x30
  40b072:	f023 0303 	bic.w	r3, r3, #3
  40b076:	f043 0301 	orr.w	r3, r3, #1
  40b07a:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_MAIN_CLK;

	while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) ) {
  40b07c:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40b07e:	f013 0f08 	tst.w	r3, #8
  40b082:	d0fb      	beq.n	40b07c <SystemInit+0x40>
	}

	/* Initialize PLLA */
	PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
  40b084:	4a12      	ldr	r2, [pc, #72]	; (40b0d0 <SystemInit+0x94>)
  40b086:	4b10      	ldr	r3, [pc, #64]	; (40b0c8 <SystemInit+0x8c>)
  40b088:	629a      	str	r2, [r3, #40]	; 0x28
	while ( !(PMC->PMC_SR & PMC_SR_LOCKA) ) {
  40b08a:	461a      	mov	r2, r3
  40b08c:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40b08e:	f013 0f02 	tst.w	r3, #2
  40b092:	d0fb      	beq.n	40b08c <SystemInit+0x50>
	}

	/* Switch to main clock */
	PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) |
  40b094:	2211      	movs	r2, #17
  40b096:	4b0c      	ldr	r3, [pc, #48]	; (40b0c8 <SystemInit+0x8c>)
  40b098:	631a      	str	r2, [r3, #48]	; 0x30
			PMC_MCKR_CSS_MAIN_CLK;
	while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) ) {
  40b09a:	461a      	mov	r2, r3
  40b09c:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40b09e:	f013 0f08 	tst.w	r3, #8
  40b0a2:	d0fb      	beq.n	40b09c <SystemInit+0x60>
	}

	/* Switch to PLLA */
	PMC->PMC_MCKR = SYS_BOARD_MCKR;
  40b0a4:	2212      	movs	r2, #18
  40b0a6:	4b08      	ldr	r3, [pc, #32]	; (40b0c8 <SystemInit+0x8c>)
  40b0a8:	631a      	str	r2, [r3, #48]	; 0x30
	while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) ) {
  40b0aa:	461a      	mov	r2, r3
  40b0ac:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40b0ae:	f013 0f08 	tst.w	r3, #8
  40b0b2:	d0fb      	beq.n	40b0ac <SystemInit+0x70>
	}

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
  40b0b4:	4a07      	ldr	r2, [pc, #28]	; (40b0d4 <SystemInit+0x98>)
  40b0b6:	4b08      	ldr	r3, [pc, #32]	; (40b0d8 <SystemInit+0x9c>)
  40b0b8:	601a      	str	r2, [r3, #0]
  40b0ba:	4770      	bx	lr
  40b0bc:	04000500 	.word	0x04000500
  40b0c0:	400e0a00 	.word	0x400e0a00
  40b0c4:	00370809 	.word	0x00370809
  40b0c8:	400e0400 	.word	0x400e0400
  40b0cc:	01370809 	.word	0x01370809
  40b0d0:	20133f01 	.word	0x20133f01
  40b0d4:	07270e00 	.word	0x07270e00
  40b0d8:	2000001c 	.word	0x2000001c

0040b0dc <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  40b0dc:	4b3b      	ldr	r3, [pc, #236]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b0de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40b0e0:	f003 0303 	and.w	r3, r3, #3
  40b0e4:	2b01      	cmp	r3, #1
  40b0e6:	d01d      	beq.n	40b124 <SystemCoreClockUpdate+0x48>
  40b0e8:	b183      	cbz	r3, 40b10c <SystemCoreClockUpdate+0x30>
  40b0ea:	2b02      	cmp	r3, #2
  40b0ec:	d036      	beq.n	40b15c <SystemCoreClockUpdate+0x80>

	default:
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  40b0ee:	4b37      	ldr	r3, [pc, #220]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b0f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40b0f2:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40b0f6:	2b70      	cmp	r3, #112	; 0x70
  40b0f8:	d05f      	beq.n	40b1ba <SystemCoreClockUpdate+0xde>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
  40b0fa:	4b34      	ldr	r3, [pc, #208]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b0fc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  40b0fe:	4934      	ldr	r1, [pc, #208]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b100:	f3c2 1202 	ubfx	r2, r2, #4, #3
  40b104:	680b      	ldr	r3, [r1, #0]
  40b106:	40d3      	lsrs	r3, r2
  40b108:	600b      	str	r3, [r1, #0]
  40b10a:	4770      	bx	lr
		if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40b10c:	4b31      	ldr	r3, [pc, #196]	; (40b1d4 <SystemCoreClockUpdate+0xf8>)
  40b10e:	695b      	ldr	r3, [r3, #20]
  40b110:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40b114:	bf14      	ite	ne
  40b116:	f44f 4200 	movne.w	r2, #32768	; 0x8000
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40b11a:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  40b11e:	4b2c      	ldr	r3, [pc, #176]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b120:	601a      	str	r2, [r3, #0]
  40b122:	e7e4      	b.n	40b0ee <SystemCoreClockUpdate+0x12>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40b124:	4b29      	ldr	r3, [pc, #164]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b126:	6a1b      	ldr	r3, [r3, #32]
  40b128:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  40b12c:	d003      	beq.n	40b136 <SystemCoreClockUpdate+0x5a>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  40b12e:	4a2a      	ldr	r2, [pc, #168]	; (40b1d8 <SystemCoreClockUpdate+0xfc>)
  40b130:	4b27      	ldr	r3, [pc, #156]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b132:	601a      	str	r2, [r3, #0]
  40b134:	e7db      	b.n	40b0ee <SystemCoreClockUpdate+0x12>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40b136:	4a29      	ldr	r2, [pc, #164]	; (40b1dc <SystemCoreClockUpdate+0x100>)
  40b138:	4b25      	ldr	r3, [pc, #148]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b13a:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  40b13c:	4b23      	ldr	r3, [pc, #140]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b13e:	6a1b      	ldr	r3, [r3, #32]
  40b140:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40b144:	2b10      	cmp	r3, #16
  40b146:	d005      	beq.n	40b154 <SystemCoreClockUpdate+0x78>
  40b148:	2b20      	cmp	r3, #32
  40b14a:	d1d0      	bne.n	40b0ee <SystemCoreClockUpdate+0x12>
				SystemCoreClock *= 3U;
  40b14c:	4a22      	ldr	r2, [pc, #136]	; (40b1d8 <SystemCoreClockUpdate+0xfc>)
  40b14e:	4b20      	ldr	r3, [pc, #128]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b150:	601a      	str	r2, [r3, #0]
				break;
  40b152:	e7cc      	b.n	40b0ee <SystemCoreClockUpdate+0x12>
				SystemCoreClock *= 2U;
  40b154:	4a22      	ldr	r2, [pc, #136]	; (40b1e0 <SystemCoreClockUpdate+0x104>)
  40b156:	4b1e      	ldr	r3, [pc, #120]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b158:	601a      	str	r2, [r3, #0]
				break;
  40b15a:	e7c8      	b.n	40b0ee <SystemCoreClockUpdate+0x12>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40b15c:	4b1b      	ldr	r3, [pc, #108]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b15e:	6a1b      	ldr	r3, [r3, #32]
  40b160:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  40b164:	d016      	beq.n	40b194 <SystemCoreClockUpdate+0xb8>
			SystemCoreClock = CHIP_FREQ_XTAL_12M ;
  40b166:	4a1c      	ldr	r2, [pc, #112]	; (40b1d8 <SystemCoreClockUpdate+0xfc>)
  40b168:	4b19      	ldr	r3, [pc, #100]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b16a:	601a      	str	r2, [r3, #0]
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK)
  40b16c:	4b17      	ldr	r3, [pc, #92]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b16e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40b170:	f003 0303 	and.w	r3, r3, #3
  40b174:	2b02      	cmp	r3, #2
  40b176:	d1ba      	bne.n	40b0ee <SystemCoreClockUpdate+0x12>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  40b178:	4a14      	ldr	r2, [pc, #80]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b17a:	6a91      	ldr	r1, [r2, #40]	; 0x28
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  40b17c:	6a92      	ldr	r2, [r2, #40]	; 0x28
  40b17e:	4814      	ldr	r0, [pc, #80]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  40b180:	f3c1 410a 	ubfx	r1, r1, #16, #11
  40b184:	6803      	ldr	r3, [r0, #0]
  40b186:	fb01 3303 	mla	r3, r1, r3, r3
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  40b18a:	b2d2      	uxtb	r2, r2
  40b18c:	fbb3 f3f2 	udiv	r3, r3, r2
  40b190:	6003      	str	r3, [r0, #0]
  40b192:	e7ac      	b.n	40b0ee <SystemCoreClockUpdate+0x12>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40b194:	4a11      	ldr	r2, [pc, #68]	; (40b1dc <SystemCoreClockUpdate+0x100>)
  40b196:	4b0e      	ldr	r3, [pc, #56]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b198:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  40b19a:	4b0c      	ldr	r3, [pc, #48]	; (40b1cc <SystemCoreClockUpdate+0xf0>)
  40b19c:	6a1b      	ldr	r3, [r3, #32]
  40b19e:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40b1a2:	2b10      	cmp	r3, #16
  40b1a4:	d005      	beq.n	40b1b2 <SystemCoreClockUpdate+0xd6>
  40b1a6:	2b20      	cmp	r3, #32
  40b1a8:	d1e0      	bne.n	40b16c <SystemCoreClockUpdate+0x90>
				SystemCoreClock *= 3U;
  40b1aa:	4a0b      	ldr	r2, [pc, #44]	; (40b1d8 <SystemCoreClockUpdate+0xfc>)
  40b1ac:	4b08      	ldr	r3, [pc, #32]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b1ae:	601a      	str	r2, [r3, #0]
				break;
  40b1b0:	e7dc      	b.n	40b16c <SystemCoreClockUpdate+0x90>
				SystemCoreClock *= 2U;
  40b1b2:	4a0b      	ldr	r2, [pc, #44]	; (40b1e0 <SystemCoreClockUpdate+0x104>)
  40b1b4:	4b06      	ldr	r3, [pc, #24]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b1b6:	601a      	str	r2, [r3, #0]
				break;
  40b1b8:	e7d8      	b.n	40b16c <SystemCoreClockUpdate+0x90>
		SystemCoreClock /= 3U;
  40b1ba:	4a05      	ldr	r2, [pc, #20]	; (40b1d0 <SystemCoreClockUpdate+0xf4>)
  40b1bc:	6813      	ldr	r3, [r2, #0]
  40b1be:	4909      	ldr	r1, [pc, #36]	; (40b1e4 <SystemCoreClockUpdate+0x108>)
  40b1c0:	fba1 1303 	umull	r1, r3, r1, r3
  40b1c4:	085b      	lsrs	r3, r3, #1
  40b1c6:	6013      	str	r3, [r2, #0]
  40b1c8:	4770      	bx	lr
  40b1ca:	bf00      	nop
  40b1cc:	400e0400 	.word	0x400e0400
  40b1d0:	2000001c 	.word	0x2000001c
  40b1d4:	400e1810 	.word	0x400e1810
  40b1d8:	00b71b00 	.word	0x00b71b00
  40b1dc:	003d0900 	.word	0x003d0900
  40b1e0:	007a1200 	.word	0x007a1200
  40b1e4:	aaaaaaab 	.word	0xaaaaaaab

0040b1e8 <system_init_flash>:
 * Initialize flash.
 */
void system_init_flash( uint32_t ul_clk )
{
	/* Set FWS for embedded Flash access according to operating frequency */
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  40b1e8:	4b12      	ldr	r3, [pc, #72]	; (40b234 <system_init_flash+0x4c>)
  40b1ea:	4298      	cmp	r0, r3
  40b1ec:	d911      	bls.n	40b212 <system_init_flash+0x2a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if (ul_clk < CHIP_FREQ_FWS_1) {
  40b1ee:	4b12      	ldr	r3, [pc, #72]	; (40b238 <system_init_flash+0x50>)
  40b1f0:	4298      	cmp	r0, r3
  40b1f2:	d913      	bls.n	40b21c <system_init_flash+0x34>
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if (ul_clk < CHIP_FREQ_FWS_2) {
  40b1f4:	4b11      	ldr	r3, [pc, #68]	; (40b23c <system_init_flash+0x54>)
  40b1f6:	4298      	cmp	r0, r3
  40b1f8:	d914      	bls.n	40b224 <system_init_flash+0x3c>
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  40b1fa:	4b11      	ldr	r3, [pc, #68]	; (40b240 <system_init_flash+0x58>)
  40b1fc:	4298      	cmp	r0, r3
  40b1fe:	d915      	bls.n	40b22c <system_init_flash+0x44>
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  40b200:	4b10      	ldr	r3, [pc, #64]	; (40b244 <system_init_flash+0x5c>)
  40b202:	4298      	cmp	r0, r3
						EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  40b204:	bf94      	ite	ls
  40b206:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
					} else {
						EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  40b20a:	4a0f      	ldrhi	r2, [pc, #60]	; (40b248 <system_init_flash+0x60>)
  40b20c:	4b0f      	ldr	r3, [pc, #60]	; (40b24c <system_init_flash+0x64>)
  40b20e:	601a      	str	r2, [r3, #0]
  40b210:	4770      	bx	lr
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  40b212:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  40b216:	4b0d      	ldr	r3, [pc, #52]	; (40b24c <system_init_flash+0x64>)
  40b218:	601a      	str	r2, [r3, #0]
  40b21a:	4770      	bx	lr
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  40b21c:	4a0c      	ldr	r2, [pc, #48]	; (40b250 <system_init_flash+0x68>)
  40b21e:	4b0b      	ldr	r3, [pc, #44]	; (40b24c <system_init_flash+0x64>)
  40b220:	601a      	str	r2, [r3, #0]
  40b222:	4770      	bx	lr
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  40b224:	4a0b      	ldr	r2, [pc, #44]	; (40b254 <system_init_flash+0x6c>)
  40b226:	4b09      	ldr	r3, [pc, #36]	; (40b24c <system_init_flash+0x64>)
  40b228:	601a      	str	r2, [r3, #0]
  40b22a:	4770      	bx	lr
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  40b22c:	4a0a      	ldr	r2, [pc, #40]	; (40b258 <system_init_flash+0x70>)
  40b22e:	4b07      	ldr	r3, [pc, #28]	; (40b24c <system_init_flash+0x64>)
  40b230:	601a      	str	r2, [r3, #0]
  40b232:	4770      	bx	lr
  40b234:	01312cff 	.word	0x01312cff
  40b238:	026259ff 	.word	0x026259ff
  40b23c:	039386ff 	.word	0x039386ff
  40b240:	04c4b3ff 	.word	0x04c4b3ff
  40b244:	05f5e0ff 	.word	0x05f5e0ff
  40b248:	04000500 	.word	0x04000500
  40b24c:	400e0a00 	.word	0x400e0a00
  40b250:	04000100 	.word	0x04000100
  40b254:	04000200 	.word	0x04000200
  40b258:	04000300 	.word	0x04000300

0040b25c <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  40b25c:	4b0a      	ldr	r3, [pc, #40]	; (40b288 <_sbrk+0x2c>)
  40b25e:	681b      	ldr	r3, [r3, #0]
  40b260:	b153      	cbz	r3, 40b278 <_sbrk+0x1c>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
  40b262:	4b09      	ldr	r3, [pc, #36]	; (40b288 <_sbrk+0x2c>)
  40b264:	681b      	ldr	r3, [r3, #0]

	if (((int)prev_heap + incr) > ramend) {
  40b266:	181a      	adds	r2, r3, r0
  40b268:	4908      	ldr	r1, [pc, #32]	; (40b28c <_sbrk+0x30>)
  40b26a:	4291      	cmp	r1, r2
  40b26c:	db08      	blt.n	40b280 <_sbrk+0x24>
		return (caddr_t) -1;	
	}

	heap += incr;
  40b26e:	4610      	mov	r0, r2
  40b270:	4a05      	ldr	r2, [pc, #20]	; (40b288 <_sbrk+0x2c>)
  40b272:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap;
  40b274:	4618      	mov	r0, r3
  40b276:	4770      	bx	lr
		heap = (unsigned char *)&_end;
  40b278:	4a05      	ldr	r2, [pc, #20]	; (40b290 <_sbrk+0x34>)
  40b27a:	4b03      	ldr	r3, [pc, #12]	; (40b288 <_sbrk+0x2c>)
  40b27c:	601a      	str	r2, [r3, #0]
  40b27e:	e7f0      	b.n	40b262 <_sbrk+0x6>
		return (caddr_t) -1;	
  40b280:	f04f 30ff 	mov.w	r0, #4294967295
}
  40b284:	4770      	bx	lr
  40b286:	bf00      	nop
  40b288:	200117e4 	.word	0x200117e4
  40b28c:	2001fffc 	.word	0x2001fffc
  40b290:	20014808 	.word	0x20014808

0040b294 <_close>:
}

extern int _close(int file)
{
	return -1;
}
  40b294:	f04f 30ff 	mov.w	r0, #4294967295
  40b298:	4770      	bx	lr

0040b29a <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
  40b29a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  40b29e:	604b      	str	r3, [r1, #4]

	return 0;
}
  40b2a0:	2000      	movs	r0, #0
  40b2a2:	4770      	bx	lr

0040b2a4 <_lseek>:
}

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
  40b2a4:	2000      	movs	r0, #0
  40b2a6:	4770      	bx	lr

0040b2a8 <_exit>:

extern void _exit(int status)
{
	asm("BKPT #0");
  40b2a8:	be00      	bkpt	0x0000
  40b2aa:	e7fe      	b.n	40b2aa <_exit+0x2>

0040b2ac <_kill>:
	for (;;);
}

extern void _kill(int pid, int sig)
{
  40b2ac:	4770      	bx	lr

0040b2ae <_getpid>:
}

extern int _getpid(void)
{
	return -1;
}
  40b2ae:	f04f 30ff 	mov.w	r0, #4294967295
  40b2b2:	4770      	bx	lr

0040b2b4 <_ZdlPvj>:
  40b2b4:	f000 b813 	b.w	40b2de <_ZdlPv>

0040b2b8 <_Znwj>:
  40b2b8:	b510      	push	{r4, lr}
  40b2ba:	2800      	cmp	r0, #0
  40b2bc:	bf14      	ite	ne
  40b2be:	4604      	movne	r4, r0
  40b2c0:	2401      	moveq	r4, #1
  40b2c2:	4620      	mov	r0, r4
  40b2c4:	f000 ffc4 	bl	40c250 <malloc>
  40b2c8:	b930      	cbnz	r0, 40b2d8 <_Znwj+0x20>
  40b2ca:	f000 f80b 	bl	40b2e4 <_ZSt15get_new_handlerv>
  40b2ce:	b908      	cbnz	r0, 40b2d4 <_Znwj+0x1c>
  40b2d0:	f000 ff92 	bl	40c1f8 <abort>
  40b2d4:	4780      	blx	r0
  40b2d6:	e7f4      	b.n	40b2c2 <_Znwj+0xa>
  40b2d8:	bd10      	pop	{r4, pc}

0040b2da <_Znaj>:
  40b2da:	f7ff bfed 	b.w	40b2b8 <_Znwj>

0040b2de <_ZdlPv>:
  40b2de:	f000 bfbf 	b.w	40c260 <free>
	...

0040b2e4 <_ZSt15get_new_handlerv>:
  40b2e4:	4b02      	ldr	r3, [pc, #8]	; (40b2f0 <_ZSt15get_new_handlerv+0xc>)
  40b2e6:	6818      	ldr	r0, [r3, #0]
  40b2e8:	f3bf 8f5b 	dmb	ish
  40b2ec:	4770      	bx	lr
  40b2ee:	bf00      	nop
  40b2f0:	200117e8 	.word	0x200117e8

0040b2f4 <roundf>:
  40b2f4:	b508      	push	{r3, lr}
  40b2f6:	f3c0 53c7 	ubfx	r3, r0, #23, #8
  40b2fa:	3b7f      	subs	r3, #127	; 0x7f
  40b2fc:	2b16      	cmp	r3, #22
  40b2fe:	4601      	mov	r1, r0
  40b300:	dc0e      	bgt.n	40b320 <roundf+0x2c>
  40b302:	2b00      	cmp	r3, #0
  40b304:	4602      	mov	r2, r0
  40b306:	db12      	blt.n	40b32e <roundf+0x3a>
  40b308:	480c      	ldr	r0, [pc, #48]	; (40b33c <roundf+0x48>)
  40b30a:	4118      	asrs	r0, r3
  40b30c:	4201      	tst	r1, r0
  40b30e:	d005      	beq.n	40b31c <roundf+0x28>
  40b310:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  40b314:	4119      	asrs	r1, r3
  40b316:	4411      	add	r1, r2
  40b318:	ea21 0100 	bic.w	r1, r1, r0
  40b31c:	4608      	mov	r0, r1
  40b31e:	bd08      	pop	{r3, pc}
  40b320:	2b80      	cmp	r3, #128	; 0x80
  40b322:	d1fb      	bne.n	40b31c <roundf+0x28>
  40b324:	f000 fc54 	bl	40bbd0 <__addsf3>
  40b328:	4601      	mov	r1, r0
  40b32a:	4608      	mov	r0, r1
  40b32c:	bd08      	pop	{r3, pc}
  40b32e:	3301      	adds	r3, #1
  40b330:	f000 4100 	and.w	r1, r0, #2147483648	; 0x80000000
  40b334:	d1f2      	bne.n	40b31c <roundf+0x28>
  40b336:	f041 517e 	orr.w	r1, r1, #1065353216	; 0x3f800000
  40b33a:	e7ef      	b.n	40b31c <roundf+0x28>
  40b33c:	007fffff 	.word	0x007fffff

0040b340 <__aeabi_drsub>:
  40b340:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  40b344:	e002      	b.n	40b34c <__adddf3>
  40b346:	bf00      	nop

0040b348 <__aeabi_dsub>:
  40b348:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0040b34c <__adddf3>:
  40b34c:	b530      	push	{r4, r5, lr}
  40b34e:	ea4f 0441 	mov.w	r4, r1, lsl #1
  40b352:	ea4f 0543 	mov.w	r5, r3, lsl #1
  40b356:	ea94 0f05 	teq	r4, r5
  40b35a:	bf08      	it	eq
  40b35c:	ea90 0f02 	teqeq	r0, r2
  40b360:	bf1f      	itttt	ne
  40b362:	ea54 0c00 	orrsne.w	ip, r4, r0
  40b366:	ea55 0c02 	orrsne.w	ip, r5, r2
  40b36a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  40b36e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  40b372:	f000 80e2 	beq.w	40b53a <__adddf3+0x1ee>
  40b376:	ea4f 5454 	mov.w	r4, r4, lsr #21
  40b37a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  40b37e:	bfb8      	it	lt
  40b380:	426d      	neglt	r5, r5
  40b382:	dd0c      	ble.n	40b39e <__adddf3+0x52>
  40b384:	442c      	add	r4, r5
  40b386:	ea80 0202 	eor.w	r2, r0, r2
  40b38a:	ea81 0303 	eor.w	r3, r1, r3
  40b38e:	ea82 0000 	eor.w	r0, r2, r0
  40b392:	ea83 0101 	eor.w	r1, r3, r1
  40b396:	ea80 0202 	eor.w	r2, r0, r2
  40b39a:	ea81 0303 	eor.w	r3, r1, r3
  40b39e:	2d36      	cmp	r5, #54	; 0x36
  40b3a0:	bf88      	it	hi
  40b3a2:	bd30      	pophi	{r4, r5, pc}
  40b3a4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  40b3a8:	ea4f 3101 	mov.w	r1, r1, lsl #12
  40b3ac:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  40b3b0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  40b3b4:	d002      	beq.n	40b3bc <__adddf3+0x70>
  40b3b6:	4240      	negs	r0, r0
  40b3b8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  40b3bc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  40b3c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
  40b3c4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  40b3c8:	d002      	beq.n	40b3d0 <__adddf3+0x84>
  40b3ca:	4252      	negs	r2, r2
  40b3cc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  40b3d0:	ea94 0f05 	teq	r4, r5
  40b3d4:	f000 80a7 	beq.w	40b526 <__adddf3+0x1da>
  40b3d8:	f1a4 0401 	sub.w	r4, r4, #1
  40b3dc:	f1d5 0e20 	rsbs	lr, r5, #32
  40b3e0:	db0d      	blt.n	40b3fe <__adddf3+0xb2>
  40b3e2:	fa02 fc0e 	lsl.w	ip, r2, lr
  40b3e6:	fa22 f205 	lsr.w	r2, r2, r5
  40b3ea:	1880      	adds	r0, r0, r2
  40b3ec:	f141 0100 	adc.w	r1, r1, #0
  40b3f0:	fa03 f20e 	lsl.w	r2, r3, lr
  40b3f4:	1880      	adds	r0, r0, r2
  40b3f6:	fa43 f305 	asr.w	r3, r3, r5
  40b3fa:	4159      	adcs	r1, r3
  40b3fc:	e00e      	b.n	40b41c <__adddf3+0xd0>
  40b3fe:	f1a5 0520 	sub.w	r5, r5, #32
  40b402:	f10e 0e20 	add.w	lr, lr, #32
  40b406:	2a01      	cmp	r2, #1
  40b408:	fa03 fc0e 	lsl.w	ip, r3, lr
  40b40c:	bf28      	it	cs
  40b40e:	f04c 0c02 	orrcs.w	ip, ip, #2
  40b412:	fa43 f305 	asr.w	r3, r3, r5
  40b416:	18c0      	adds	r0, r0, r3
  40b418:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  40b41c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  40b420:	d507      	bpl.n	40b432 <__adddf3+0xe6>
  40b422:	f04f 0e00 	mov.w	lr, #0
  40b426:	f1dc 0c00 	rsbs	ip, ip, #0
  40b42a:	eb7e 0000 	sbcs.w	r0, lr, r0
  40b42e:	eb6e 0101 	sbc.w	r1, lr, r1
  40b432:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  40b436:	d31b      	bcc.n	40b470 <__adddf3+0x124>
  40b438:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  40b43c:	d30c      	bcc.n	40b458 <__adddf3+0x10c>
  40b43e:	0849      	lsrs	r1, r1, #1
  40b440:	ea5f 0030 	movs.w	r0, r0, rrx
  40b444:	ea4f 0c3c 	mov.w	ip, ip, rrx
  40b448:	f104 0401 	add.w	r4, r4, #1
  40b44c:	ea4f 5244 	mov.w	r2, r4, lsl #21
  40b450:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  40b454:	f080 809a 	bcs.w	40b58c <__adddf3+0x240>
  40b458:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  40b45c:	bf08      	it	eq
  40b45e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  40b462:	f150 0000 	adcs.w	r0, r0, #0
  40b466:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40b46a:	ea41 0105 	orr.w	r1, r1, r5
  40b46e:	bd30      	pop	{r4, r5, pc}
  40b470:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  40b474:	4140      	adcs	r0, r0
  40b476:	eb41 0101 	adc.w	r1, r1, r1
  40b47a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40b47e:	f1a4 0401 	sub.w	r4, r4, #1
  40b482:	d1e9      	bne.n	40b458 <__adddf3+0x10c>
  40b484:	f091 0f00 	teq	r1, #0
  40b488:	bf04      	itt	eq
  40b48a:	4601      	moveq	r1, r0
  40b48c:	2000      	moveq	r0, #0
  40b48e:	fab1 f381 	clz	r3, r1
  40b492:	bf08      	it	eq
  40b494:	3320      	addeq	r3, #32
  40b496:	f1a3 030b 	sub.w	r3, r3, #11
  40b49a:	f1b3 0220 	subs.w	r2, r3, #32
  40b49e:	da0c      	bge.n	40b4ba <__adddf3+0x16e>
  40b4a0:	320c      	adds	r2, #12
  40b4a2:	dd08      	ble.n	40b4b6 <__adddf3+0x16a>
  40b4a4:	f102 0c14 	add.w	ip, r2, #20
  40b4a8:	f1c2 020c 	rsb	r2, r2, #12
  40b4ac:	fa01 f00c 	lsl.w	r0, r1, ip
  40b4b0:	fa21 f102 	lsr.w	r1, r1, r2
  40b4b4:	e00c      	b.n	40b4d0 <__adddf3+0x184>
  40b4b6:	f102 0214 	add.w	r2, r2, #20
  40b4ba:	bfd8      	it	le
  40b4bc:	f1c2 0c20 	rsble	ip, r2, #32
  40b4c0:	fa01 f102 	lsl.w	r1, r1, r2
  40b4c4:	fa20 fc0c 	lsr.w	ip, r0, ip
  40b4c8:	bfdc      	itt	le
  40b4ca:	ea41 010c 	orrle.w	r1, r1, ip
  40b4ce:	4090      	lslle	r0, r2
  40b4d0:	1ae4      	subs	r4, r4, r3
  40b4d2:	bfa2      	ittt	ge
  40b4d4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  40b4d8:	4329      	orrge	r1, r5
  40b4da:	bd30      	popge	{r4, r5, pc}
  40b4dc:	ea6f 0404 	mvn.w	r4, r4
  40b4e0:	3c1f      	subs	r4, #31
  40b4e2:	da1c      	bge.n	40b51e <__adddf3+0x1d2>
  40b4e4:	340c      	adds	r4, #12
  40b4e6:	dc0e      	bgt.n	40b506 <__adddf3+0x1ba>
  40b4e8:	f104 0414 	add.w	r4, r4, #20
  40b4ec:	f1c4 0220 	rsb	r2, r4, #32
  40b4f0:	fa20 f004 	lsr.w	r0, r0, r4
  40b4f4:	fa01 f302 	lsl.w	r3, r1, r2
  40b4f8:	ea40 0003 	orr.w	r0, r0, r3
  40b4fc:	fa21 f304 	lsr.w	r3, r1, r4
  40b500:	ea45 0103 	orr.w	r1, r5, r3
  40b504:	bd30      	pop	{r4, r5, pc}
  40b506:	f1c4 040c 	rsb	r4, r4, #12
  40b50a:	f1c4 0220 	rsb	r2, r4, #32
  40b50e:	fa20 f002 	lsr.w	r0, r0, r2
  40b512:	fa01 f304 	lsl.w	r3, r1, r4
  40b516:	ea40 0003 	orr.w	r0, r0, r3
  40b51a:	4629      	mov	r1, r5
  40b51c:	bd30      	pop	{r4, r5, pc}
  40b51e:	fa21 f004 	lsr.w	r0, r1, r4
  40b522:	4629      	mov	r1, r5
  40b524:	bd30      	pop	{r4, r5, pc}
  40b526:	f094 0f00 	teq	r4, #0
  40b52a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  40b52e:	bf06      	itte	eq
  40b530:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  40b534:	3401      	addeq	r4, #1
  40b536:	3d01      	subne	r5, #1
  40b538:	e74e      	b.n	40b3d8 <__adddf3+0x8c>
  40b53a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  40b53e:	bf18      	it	ne
  40b540:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  40b544:	d029      	beq.n	40b59a <__adddf3+0x24e>
  40b546:	ea94 0f05 	teq	r4, r5
  40b54a:	bf08      	it	eq
  40b54c:	ea90 0f02 	teqeq	r0, r2
  40b550:	d005      	beq.n	40b55e <__adddf3+0x212>
  40b552:	ea54 0c00 	orrs.w	ip, r4, r0
  40b556:	bf04      	itt	eq
  40b558:	4619      	moveq	r1, r3
  40b55a:	4610      	moveq	r0, r2
  40b55c:	bd30      	pop	{r4, r5, pc}
  40b55e:	ea91 0f03 	teq	r1, r3
  40b562:	bf1e      	ittt	ne
  40b564:	2100      	movne	r1, #0
  40b566:	2000      	movne	r0, #0
  40b568:	bd30      	popne	{r4, r5, pc}
  40b56a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  40b56e:	d105      	bne.n	40b57c <__adddf3+0x230>
  40b570:	0040      	lsls	r0, r0, #1
  40b572:	4149      	adcs	r1, r1
  40b574:	bf28      	it	cs
  40b576:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  40b57a:	bd30      	pop	{r4, r5, pc}
  40b57c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  40b580:	bf3c      	itt	cc
  40b582:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  40b586:	bd30      	popcc	{r4, r5, pc}
  40b588:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  40b58c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  40b590:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  40b594:	f04f 0000 	mov.w	r0, #0
  40b598:	bd30      	pop	{r4, r5, pc}
  40b59a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  40b59e:	bf1a      	itte	ne
  40b5a0:	4619      	movne	r1, r3
  40b5a2:	4610      	movne	r0, r2
  40b5a4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  40b5a8:	bf1c      	itt	ne
  40b5aa:	460b      	movne	r3, r1
  40b5ac:	4602      	movne	r2, r0
  40b5ae:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  40b5b2:	bf06      	itte	eq
  40b5b4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  40b5b8:	ea91 0f03 	teqeq	r1, r3
  40b5bc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  40b5c0:	bd30      	pop	{r4, r5, pc}
  40b5c2:	bf00      	nop

0040b5c4 <__aeabi_ui2d>:
  40b5c4:	f090 0f00 	teq	r0, #0
  40b5c8:	bf04      	itt	eq
  40b5ca:	2100      	moveq	r1, #0
  40b5cc:	4770      	bxeq	lr
  40b5ce:	b530      	push	{r4, r5, lr}
  40b5d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
  40b5d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40b5d8:	f04f 0500 	mov.w	r5, #0
  40b5dc:	f04f 0100 	mov.w	r1, #0
  40b5e0:	e750      	b.n	40b484 <__adddf3+0x138>
  40b5e2:	bf00      	nop

0040b5e4 <__aeabi_i2d>:
  40b5e4:	f090 0f00 	teq	r0, #0
  40b5e8:	bf04      	itt	eq
  40b5ea:	2100      	moveq	r1, #0
  40b5ec:	4770      	bxeq	lr
  40b5ee:	b530      	push	{r4, r5, lr}
  40b5f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
  40b5f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40b5f8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  40b5fc:	bf48      	it	mi
  40b5fe:	4240      	negmi	r0, r0
  40b600:	f04f 0100 	mov.w	r1, #0
  40b604:	e73e      	b.n	40b484 <__adddf3+0x138>
  40b606:	bf00      	nop

0040b608 <__aeabi_f2d>:
  40b608:	0042      	lsls	r2, r0, #1
  40b60a:	ea4f 01e2 	mov.w	r1, r2, asr #3
  40b60e:	ea4f 0131 	mov.w	r1, r1, rrx
  40b612:	ea4f 7002 	mov.w	r0, r2, lsl #28
  40b616:	bf1f      	itttt	ne
  40b618:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  40b61c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  40b620:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  40b624:	4770      	bxne	lr
  40b626:	f092 0f00 	teq	r2, #0
  40b62a:	bf14      	ite	ne
  40b62c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  40b630:	4770      	bxeq	lr
  40b632:	b530      	push	{r4, r5, lr}
  40b634:	f44f 7460 	mov.w	r4, #896	; 0x380
  40b638:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  40b63c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  40b640:	e720      	b.n	40b484 <__adddf3+0x138>
  40b642:	bf00      	nop

0040b644 <__aeabi_ul2d>:
  40b644:	ea50 0201 	orrs.w	r2, r0, r1
  40b648:	bf08      	it	eq
  40b64a:	4770      	bxeq	lr
  40b64c:	b530      	push	{r4, r5, lr}
  40b64e:	f04f 0500 	mov.w	r5, #0
  40b652:	e00a      	b.n	40b66a <__aeabi_l2d+0x16>

0040b654 <__aeabi_l2d>:
  40b654:	ea50 0201 	orrs.w	r2, r0, r1
  40b658:	bf08      	it	eq
  40b65a:	4770      	bxeq	lr
  40b65c:	b530      	push	{r4, r5, lr}
  40b65e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  40b662:	d502      	bpl.n	40b66a <__aeabi_l2d+0x16>
  40b664:	4240      	negs	r0, r0
  40b666:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  40b66a:	f44f 6480 	mov.w	r4, #1024	; 0x400
  40b66e:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40b672:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  40b676:	f43f aedc 	beq.w	40b432 <__adddf3+0xe6>
  40b67a:	f04f 0203 	mov.w	r2, #3
  40b67e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  40b682:	bf18      	it	ne
  40b684:	3203      	addne	r2, #3
  40b686:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  40b68a:	bf18      	it	ne
  40b68c:	3203      	addne	r2, #3
  40b68e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  40b692:	f1c2 0320 	rsb	r3, r2, #32
  40b696:	fa00 fc03 	lsl.w	ip, r0, r3
  40b69a:	fa20 f002 	lsr.w	r0, r0, r2
  40b69e:	fa01 fe03 	lsl.w	lr, r1, r3
  40b6a2:	ea40 000e 	orr.w	r0, r0, lr
  40b6a6:	fa21 f102 	lsr.w	r1, r1, r2
  40b6aa:	4414      	add	r4, r2
  40b6ac:	e6c1      	b.n	40b432 <__adddf3+0xe6>
  40b6ae:	bf00      	nop

0040b6b0 <__aeabi_dmul>:
  40b6b0:	b570      	push	{r4, r5, r6, lr}
  40b6b2:	f04f 0cff 	mov.w	ip, #255	; 0xff
  40b6b6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  40b6ba:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  40b6be:	bf1d      	ittte	ne
  40b6c0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  40b6c4:	ea94 0f0c 	teqne	r4, ip
  40b6c8:	ea95 0f0c 	teqne	r5, ip
  40b6cc:	f000 f8de 	bleq	40b88c <__aeabi_dmul+0x1dc>
  40b6d0:	442c      	add	r4, r5
  40b6d2:	ea81 0603 	eor.w	r6, r1, r3
  40b6d6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  40b6da:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  40b6de:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  40b6e2:	bf18      	it	ne
  40b6e4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  40b6e8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40b6ec:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  40b6f0:	d038      	beq.n	40b764 <__aeabi_dmul+0xb4>
  40b6f2:	fba0 ce02 	umull	ip, lr, r0, r2
  40b6f6:	f04f 0500 	mov.w	r5, #0
  40b6fa:	fbe1 e502 	umlal	lr, r5, r1, r2
  40b6fe:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  40b702:	fbe0 e503 	umlal	lr, r5, r0, r3
  40b706:	f04f 0600 	mov.w	r6, #0
  40b70a:	fbe1 5603 	umlal	r5, r6, r1, r3
  40b70e:	f09c 0f00 	teq	ip, #0
  40b712:	bf18      	it	ne
  40b714:	f04e 0e01 	orrne.w	lr, lr, #1
  40b718:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  40b71c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  40b720:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  40b724:	d204      	bcs.n	40b730 <__aeabi_dmul+0x80>
  40b726:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  40b72a:	416d      	adcs	r5, r5
  40b72c:	eb46 0606 	adc.w	r6, r6, r6
  40b730:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  40b734:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  40b738:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  40b73c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  40b740:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  40b744:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  40b748:	bf88      	it	hi
  40b74a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  40b74e:	d81e      	bhi.n	40b78e <__aeabi_dmul+0xde>
  40b750:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  40b754:	bf08      	it	eq
  40b756:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  40b75a:	f150 0000 	adcs.w	r0, r0, #0
  40b75e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40b762:	bd70      	pop	{r4, r5, r6, pc}
  40b764:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  40b768:	ea46 0101 	orr.w	r1, r6, r1
  40b76c:	ea40 0002 	orr.w	r0, r0, r2
  40b770:	ea81 0103 	eor.w	r1, r1, r3
  40b774:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  40b778:	bfc2      	ittt	gt
  40b77a:	ebd4 050c 	rsbsgt	r5, r4, ip
  40b77e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  40b782:	bd70      	popgt	{r4, r5, r6, pc}
  40b784:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40b788:	f04f 0e00 	mov.w	lr, #0
  40b78c:	3c01      	subs	r4, #1
  40b78e:	f300 80ab 	bgt.w	40b8e8 <__aeabi_dmul+0x238>
  40b792:	f114 0f36 	cmn.w	r4, #54	; 0x36
  40b796:	bfde      	ittt	le
  40b798:	2000      	movle	r0, #0
  40b79a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  40b79e:	bd70      	pople	{r4, r5, r6, pc}
  40b7a0:	f1c4 0400 	rsb	r4, r4, #0
  40b7a4:	3c20      	subs	r4, #32
  40b7a6:	da35      	bge.n	40b814 <__aeabi_dmul+0x164>
  40b7a8:	340c      	adds	r4, #12
  40b7aa:	dc1b      	bgt.n	40b7e4 <__aeabi_dmul+0x134>
  40b7ac:	f104 0414 	add.w	r4, r4, #20
  40b7b0:	f1c4 0520 	rsb	r5, r4, #32
  40b7b4:	fa00 f305 	lsl.w	r3, r0, r5
  40b7b8:	fa20 f004 	lsr.w	r0, r0, r4
  40b7bc:	fa01 f205 	lsl.w	r2, r1, r5
  40b7c0:	ea40 0002 	orr.w	r0, r0, r2
  40b7c4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  40b7c8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  40b7cc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  40b7d0:	fa21 f604 	lsr.w	r6, r1, r4
  40b7d4:	eb42 0106 	adc.w	r1, r2, r6
  40b7d8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  40b7dc:	bf08      	it	eq
  40b7de:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  40b7e2:	bd70      	pop	{r4, r5, r6, pc}
  40b7e4:	f1c4 040c 	rsb	r4, r4, #12
  40b7e8:	f1c4 0520 	rsb	r5, r4, #32
  40b7ec:	fa00 f304 	lsl.w	r3, r0, r4
  40b7f0:	fa20 f005 	lsr.w	r0, r0, r5
  40b7f4:	fa01 f204 	lsl.w	r2, r1, r4
  40b7f8:	ea40 0002 	orr.w	r0, r0, r2
  40b7fc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40b800:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  40b804:	f141 0100 	adc.w	r1, r1, #0
  40b808:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  40b80c:	bf08      	it	eq
  40b80e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  40b812:	bd70      	pop	{r4, r5, r6, pc}
  40b814:	f1c4 0520 	rsb	r5, r4, #32
  40b818:	fa00 f205 	lsl.w	r2, r0, r5
  40b81c:	ea4e 0e02 	orr.w	lr, lr, r2
  40b820:	fa20 f304 	lsr.w	r3, r0, r4
  40b824:	fa01 f205 	lsl.w	r2, r1, r5
  40b828:	ea43 0302 	orr.w	r3, r3, r2
  40b82c:	fa21 f004 	lsr.w	r0, r1, r4
  40b830:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40b834:	fa21 f204 	lsr.w	r2, r1, r4
  40b838:	ea20 0002 	bic.w	r0, r0, r2
  40b83c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  40b840:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  40b844:	bf08      	it	eq
  40b846:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  40b84a:	bd70      	pop	{r4, r5, r6, pc}
  40b84c:	f094 0f00 	teq	r4, #0
  40b850:	d10f      	bne.n	40b872 <__aeabi_dmul+0x1c2>
  40b852:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  40b856:	0040      	lsls	r0, r0, #1
  40b858:	eb41 0101 	adc.w	r1, r1, r1
  40b85c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40b860:	bf08      	it	eq
  40b862:	3c01      	subeq	r4, #1
  40b864:	d0f7      	beq.n	40b856 <__aeabi_dmul+0x1a6>
  40b866:	ea41 0106 	orr.w	r1, r1, r6
  40b86a:	f095 0f00 	teq	r5, #0
  40b86e:	bf18      	it	ne
  40b870:	4770      	bxne	lr
  40b872:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  40b876:	0052      	lsls	r2, r2, #1
  40b878:	eb43 0303 	adc.w	r3, r3, r3
  40b87c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  40b880:	bf08      	it	eq
  40b882:	3d01      	subeq	r5, #1
  40b884:	d0f7      	beq.n	40b876 <__aeabi_dmul+0x1c6>
  40b886:	ea43 0306 	orr.w	r3, r3, r6
  40b88a:	4770      	bx	lr
  40b88c:	ea94 0f0c 	teq	r4, ip
  40b890:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  40b894:	bf18      	it	ne
  40b896:	ea95 0f0c 	teqne	r5, ip
  40b89a:	d00c      	beq.n	40b8b6 <__aeabi_dmul+0x206>
  40b89c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  40b8a0:	bf18      	it	ne
  40b8a2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  40b8a6:	d1d1      	bne.n	40b84c <__aeabi_dmul+0x19c>
  40b8a8:	ea81 0103 	eor.w	r1, r1, r3
  40b8ac:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40b8b0:	f04f 0000 	mov.w	r0, #0
  40b8b4:	bd70      	pop	{r4, r5, r6, pc}
  40b8b6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  40b8ba:	bf06      	itte	eq
  40b8bc:	4610      	moveq	r0, r2
  40b8be:	4619      	moveq	r1, r3
  40b8c0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  40b8c4:	d019      	beq.n	40b8fa <__aeabi_dmul+0x24a>
  40b8c6:	ea94 0f0c 	teq	r4, ip
  40b8ca:	d102      	bne.n	40b8d2 <__aeabi_dmul+0x222>
  40b8cc:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  40b8d0:	d113      	bne.n	40b8fa <__aeabi_dmul+0x24a>
  40b8d2:	ea95 0f0c 	teq	r5, ip
  40b8d6:	d105      	bne.n	40b8e4 <__aeabi_dmul+0x234>
  40b8d8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  40b8dc:	bf1c      	itt	ne
  40b8de:	4610      	movne	r0, r2
  40b8e0:	4619      	movne	r1, r3
  40b8e2:	d10a      	bne.n	40b8fa <__aeabi_dmul+0x24a>
  40b8e4:	ea81 0103 	eor.w	r1, r1, r3
  40b8e8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40b8ec:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  40b8f0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  40b8f4:	f04f 0000 	mov.w	r0, #0
  40b8f8:	bd70      	pop	{r4, r5, r6, pc}
  40b8fa:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  40b8fe:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  40b902:	bd70      	pop	{r4, r5, r6, pc}

0040b904 <__aeabi_ddiv>:
  40b904:	b570      	push	{r4, r5, r6, lr}
  40b906:	f04f 0cff 	mov.w	ip, #255	; 0xff
  40b90a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  40b90e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  40b912:	bf1d      	ittte	ne
  40b914:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  40b918:	ea94 0f0c 	teqne	r4, ip
  40b91c:	ea95 0f0c 	teqne	r5, ip
  40b920:	f000 f8a7 	bleq	40ba72 <__aeabi_ddiv+0x16e>
  40b924:	eba4 0405 	sub.w	r4, r4, r5
  40b928:	ea81 0e03 	eor.w	lr, r1, r3
  40b92c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  40b930:	ea4f 3101 	mov.w	r1, r1, lsl #12
  40b934:	f000 8088 	beq.w	40ba48 <__aeabi_ddiv+0x144>
  40b938:	ea4f 3303 	mov.w	r3, r3, lsl #12
  40b93c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  40b940:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  40b944:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  40b948:	ea4f 2202 	mov.w	r2, r2, lsl #8
  40b94c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  40b950:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  40b954:	ea4f 2600 	mov.w	r6, r0, lsl #8
  40b958:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  40b95c:	429d      	cmp	r5, r3
  40b95e:	bf08      	it	eq
  40b960:	4296      	cmpeq	r6, r2
  40b962:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  40b966:	f504 7440 	add.w	r4, r4, #768	; 0x300
  40b96a:	d202      	bcs.n	40b972 <__aeabi_ddiv+0x6e>
  40b96c:	085b      	lsrs	r3, r3, #1
  40b96e:	ea4f 0232 	mov.w	r2, r2, rrx
  40b972:	1ab6      	subs	r6, r6, r2
  40b974:	eb65 0503 	sbc.w	r5, r5, r3
  40b978:	085b      	lsrs	r3, r3, #1
  40b97a:	ea4f 0232 	mov.w	r2, r2, rrx
  40b97e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  40b982:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  40b986:	ebb6 0e02 	subs.w	lr, r6, r2
  40b98a:	eb75 0e03 	sbcs.w	lr, r5, r3
  40b98e:	bf22      	ittt	cs
  40b990:	1ab6      	subcs	r6, r6, r2
  40b992:	4675      	movcs	r5, lr
  40b994:	ea40 000c 	orrcs.w	r0, r0, ip
  40b998:	085b      	lsrs	r3, r3, #1
  40b99a:	ea4f 0232 	mov.w	r2, r2, rrx
  40b99e:	ebb6 0e02 	subs.w	lr, r6, r2
  40b9a2:	eb75 0e03 	sbcs.w	lr, r5, r3
  40b9a6:	bf22      	ittt	cs
  40b9a8:	1ab6      	subcs	r6, r6, r2
  40b9aa:	4675      	movcs	r5, lr
  40b9ac:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  40b9b0:	085b      	lsrs	r3, r3, #1
  40b9b2:	ea4f 0232 	mov.w	r2, r2, rrx
  40b9b6:	ebb6 0e02 	subs.w	lr, r6, r2
  40b9ba:	eb75 0e03 	sbcs.w	lr, r5, r3
  40b9be:	bf22      	ittt	cs
  40b9c0:	1ab6      	subcs	r6, r6, r2
  40b9c2:	4675      	movcs	r5, lr
  40b9c4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  40b9c8:	085b      	lsrs	r3, r3, #1
  40b9ca:	ea4f 0232 	mov.w	r2, r2, rrx
  40b9ce:	ebb6 0e02 	subs.w	lr, r6, r2
  40b9d2:	eb75 0e03 	sbcs.w	lr, r5, r3
  40b9d6:	bf22      	ittt	cs
  40b9d8:	1ab6      	subcs	r6, r6, r2
  40b9da:	4675      	movcs	r5, lr
  40b9dc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  40b9e0:	ea55 0e06 	orrs.w	lr, r5, r6
  40b9e4:	d018      	beq.n	40ba18 <__aeabi_ddiv+0x114>
  40b9e6:	ea4f 1505 	mov.w	r5, r5, lsl #4
  40b9ea:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  40b9ee:	ea4f 1606 	mov.w	r6, r6, lsl #4
  40b9f2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  40b9f6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  40b9fa:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  40b9fe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  40ba02:	d1c0      	bne.n	40b986 <__aeabi_ddiv+0x82>
  40ba04:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40ba08:	d10b      	bne.n	40ba22 <__aeabi_ddiv+0x11e>
  40ba0a:	ea41 0100 	orr.w	r1, r1, r0
  40ba0e:	f04f 0000 	mov.w	r0, #0
  40ba12:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  40ba16:	e7b6      	b.n	40b986 <__aeabi_ddiv+0x82>
  40ba18:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40ba1c:	bf04      	itt	eq
  40ba1e:	4301      	orreq	r1, r0
  40ba20:	2000      	moveq	r0, #0
  40ba22:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  40ba26:	bf88      	it	hi
  40ba28:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  40ba2c:	f63f aeaf 	bhi.w	40b78e <__aeabi_dmul+0xde>
  40ba30:	ebb5 0c03 	subs.w	ip, r5, r3
  40ba34:	bf04      	itt	eq
  40ba36:	ebb6 0c02 	subseq.w	ip, r6, r2
  40ba3a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  40ba3e:	f150 0000 	adcs.w	r0, r0, #0
  40ba42:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40ba46:	bd70      	pop	{r4, r5, r6, pc}
  40ba48:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  40ba4c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  40ba50:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  40ba54:	bfc2      	ittt	gt
  40ba56:	ebd4 050c 	rsbsgt	r5, r4, ip
  40ba5a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  40ba5e:	bd70      	popgt	{r4, r5, r6, pc}
  40ba60:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40ba64:	f04f 0e00 	mov.w	lr, #0
  40ba68:	3c01      	subs	r4, #1
  40ba6a:	e690      	b.n	40b78e <__aeabi_dmul+0xde>
  40ba6c:	ea45 0e06 	orr.w	lr, r5, r6
  40ba70:	e68d      	b.n	40b78e <__aeabi_dmul+0xde>
  40ba72:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  40ba76:	ea94 0f0c 	teq	r4, ip
  40ba7a:	bf08      	it	eq
  40ba7c:	ea95 0f0c 	teqeq	r5, ip
  40ba80:	f43f af3b 	beq.w	40b8fa <__aeabi_dmul+0x24a>
  40ba84:	ea94 0f0c 	teq	r4, ip
  40ba88:	d10a      	bne.n	40baa0 <__aeabi_ddiv+0x19c>
  40ba8a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  40ba8e:	f47f af34 	bne.w	40b8fa <__aeabi_dmul+0x24a>
  40ba92:	ea95 0f0c 	teq	r5, ip
  40ba96:	f47f af25 	bne.w	40b8e4 <__aeabi_dmul+0x234>
  40ba9a:	4610      	mov	r0, r2
  40ba9c:	4619      	mov	r1, r3
  40ba9e:	e72c      	b.n	40b8fa <__aeabi_dmul+0x24a>
  40baa0:	ea95 0f0c 	teq	r5, ip
  40baa4:	d106      	bne.n	40bab4 <__aeabi_ddiv+0x1b0>
  40baa6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  40baaa:	f43f aefd 	beq.w	40b8a8 <__aeabi_dmul+0x1f8>
  40baae:	4610      	mov	r0, r2
  40bab0:	4619      	mov	r1, r3
  40bab2:	e722      	b.n	40b8fa <__aeabi_dmul+0x24a>
  40bab4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  40bab8:	bf18      	it	ne
  40baba:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  40babe:	f47f aec5 	bne.w	40b84c <__aeabi_dmul+0x19c>
  40bac2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  40bac6:	f47f af0d 	bne.w	40b8e4 <__aeabi_dmul+0x234>
  40baca:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  40bace:	f47f aeeb 	bne.w	40b8a8 <__aeabi_dmul+0x1f8>
  40bad2:	e712      	b.n	40b8fa <__aeabi_dmul+0x24a>

0040bad4 <__aeabi_d2iz>:
  40bad4:	ea4f 0241 	mov.w	r2, r1, lsl #1
  40bad8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  40badc:	d215      	bcs.n	40bb0a <__aeabi_d2iz+0x36>
  40bade:	d511      	bpl.n	40bb04 <__aeabi_d2iz+0x30>
  40bae0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  40bae4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  40bae8:	d912      	bls.n	40bb10 <__aeabi_d2iz+0x3c>
  40baea:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  40baee:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  40baf2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  40baf6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  40bafa:	fa23 f002 	lsr.w	r0, r3, r2
  40bafe:	bf18      	it	ne
  40bb00:	4240      	negne	r0, r0
  40bb02:	4770      	bx	lr
  40bb04:	f04f 0000 	mov.w	r0, #0
  40bb08:	4770      	bx	lr
  40bb0a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  40bb0e:	d105      	bne.n	40bb1c <__aeabi_d2iz+0x48>
  40bb10:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  40bb14:	bf08      	it	eq
  40bb16:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  40bb1a:	4770      	bx	lr
  40bb1c:	f04f 0000 	mov.w	r0, #0
  40bb20:	4770      	bx	lr
  40bb22:	bf00      	nop

0040bb24 <__aeabi_d2f>:
  40bb24:	ea4f 0241 	mov.w	r2, r1, lsl #1
  40bb28:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
  40bb2c:	bf24      	itt	cs
  40bb2e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
  40bb32:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
  40bb36:	d90d      	bls.n	40bb54 <__aeabi_d2f+0x30>
  40bb38:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  40bb3c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
  40bb40:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
  40bb44:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  40bb48:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
  40bb4c:	bf08      	it	eq
  40bb4e:	f020 0001 	biceq.w	r0, r0, #1
  40bb52:	4770      	bx	lr
  40bb54:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
  40bb58:	d121      	bne.n	40bb9e <__aeabi_d2f+0x7a>
  40bb5a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
  40bb5e:	bfbc      	itt	lt
  40bb60:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
  40bb64:	4770      	bxlt	lr
  40bb66:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40bb6a:	ea4f 5252 	mov.w	r2, r2, lsr #21
  40bb6e:	f1c2 0218 	rsb	r2, r2, #24
  40bb72:	f1c2 0c20 	rsb	ip, r2, #32
  40bb76:	fa10 f30c 	lsls.w	r3, r0, ip
  40bb7a:	fa20 f002 	lsr.w	r0, r0, r2
  40bb7e:	bf18      	it	ne
  40bb80:	f040 0001 	orrne.w	r0, r0, #1
  40bb84:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  40bb88:	ea4f 23d3 	mov.w	r3, r3, lsr #11
  40bb8c:	fa03 fc0c 	lsl.w	ip, r3, ip
  40bb90:	ea40 000c 	orr.w	r0, r0, ip
  40bb94:	fa23 f302 	lsr.w	r3, r3, r2
  40bb98:	ea4f 0343 	mov.w	r3, r3, lsl #1
  40bb9c:	e7cc      	b.n	40bb38 <__aeabi_d2f+0x14>
  40bb9e:	ea7f 5362 	mvns.w	r3, r2, asr #21
  40bba2:	d107      	bne.n	40bbb4 <__aeabi_d2f+0x90>
  40bba4:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
  40bba8:	bf1e      	ittt	ne
  40bbaa:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
  40bbae:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
  40bbb2:	4770      	bxne	lr
  40bbb4:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
  40bbb8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  40bbbc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  40bbc0:	4770      	bx	lr
  40bbc2:	bf00      	nop

0040bbc4 <__aeabi_frsub>:
  40bbc4:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
  40bbc8:	e002      	b.n	40bbd0 <__addsf3>
  40bbca:	bf00      	nop

0040bbcc <__aeabi_fsub>:
  40bbcc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0040bbd0 <__addsf3>:
  40bbd0:	0042      	lsls	r2, r0, #1
  40bbd2:	bf1f      	itttt	ne
  40bbd4:	ea5f 0341 	movsne.w	r3, r1, lsl #1
  40bbd8:	ea92 0f03 	teqne	r2, r3
  40bbdc:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
  40bbe0:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  40bbe4:	d06a      	beq.n	40bcbc <__addsf3+0xec>
  40bbe6:	ea4f 6212 	mov.w	r2, r2, lsr #24
  40bbea:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
  40bbee:	bfc1      	itttt	gt
  40bbf0:	18d2      	addgt	r2, r2, r3
  40bbf2:	4041      	eorgt	r1, r0
  40bbf4:	4048      	eorgt	r0, r1
  40bbf6:	4041      	eorgt	r1, r0
  40bbf8:	bfb8      	it	lt
  40bbfa:	425b      	neglt	r3, r3
  40bbfc:	2b19      	cmp	r3, #25
  40bbfe:	bf88      	it	hi
  40bc00:	4770      	bxhi	lr
  40bc02:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
  40bc06:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  40bc0a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
  40bc0e:	bf18      	it	ne
  40bc10:	4240      	negne	r0, r0
  40bc12:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  40bc16:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  40bc1a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  40bc1e:	bf18      	it	ne
  40bc20:	4249      	negne	r1, r1
  40bc22:	ea92 0f03 	teq	r2, r3
  40bc26:	d03f      	beq.n	40bca8 <__addsf3+0xd8>
  40bc28:	f1a2 0201 	sub.w	r2, r2, #1
  40bc2c:	fa41 fc03 	asr.w	ip, r1, r3
  40bc30:	eb10 000c 	adds.w	r0, r0, ip
  40bc34:	f1c3 0320 	rsb	r3, r3, #32
  40bc38:	fa01 f103 	lsl.w	r1, r1, r3
  40bc3c:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  40bc40:	d502      	bpl.n	40bc48 <__addsf3+0x78>
  40bc42:	4249      	negs	r1, r1
  40bc44:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
  40bc48:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
  40bc4c:	d313      	bcc.n	40bc76 <__addsf3+0xa6>
  40bc4e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
  40bc52:	d306      	bcc.n	40bc62 <__addsf3+0x92>
  40bc54:	0840      	lsrs	r0, r0, #1
  40bc56:	ea4f 0131 	mov.w	r1, r1, rrx
  40bc5a:	f102 0201 	add.w	r2, r2, #1
  40bc5e:	2afe      	cmp	r2, #254	; 0xfe
  40bc60:	d251      	bcs.n	40bd06 <__addsf3+0x136>
  40bc62:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
  40bc66:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  40bc6a:	bf08      	it	eq
  40bc6c:	f020 0001 	biceq.w	r0, r0, #1
  40bc70:	ea40 0003 	orr.w	r0, r0, r3
  40bc74:	4770      	bx	lr
  40bc76:	0049      	lsls	r1, r1, #1
  40bc78:	eb40 0000 	adc.w	r0, r0, r0
  40bc7c:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
  40bc80:	f1a2 0201 	sub.w	r2, r2, #1
  40bc84:	d1ed      	bne.n	40bc62 <__addsf3+0x92>
  40bc86:	fab0 fc80 	clz	ip, r0
  40bc8a:	f1ac 0c08 	sub.w	ip, ip, #8
  40bc8e:	ebb2 020c 	subs.w	r2, r2, ip
  40bc92:	fa00 f00c 	lsl.w	r0, r0, ip
  40bc96:	bfaa      	itet	ge
  40bc98:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
  40bc9c:	4252      	neglt	r2, r2
  40bc9e:	4318      	orrge	r0, r3
  40bca0:	bfbc      	itt	lt
  40bca2:	40d0      	lsrlt	r0, r2
  40bca4:	4318      	orrlt	r0, r3
  40bca6:	4770      	bx	lr
  40bca8:	f092 0f00 	teq	r2, #0
  40bcac:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
  40bcb0:	bf06      	itte	eq
  40bcb2:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
  40bcb6:	3201      	addeq	r2, #1
  40bcb8:	3b01      	subne	r3, #1
  40bcba:	e7b5      	b.n	40bc28 <__addsf3+0x58>
  40bcbc:	ea4f 0341 	mov.w	r3, r1, lsl #1
  40bcc0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  40bcc4:	bf18      	it	ne
  40bcc6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  40bcca:	d021      	beq.n	40bd10 <__addsf3+0x140>
  40bccc:	ea92 0f03 	teq	r2, r3
  40bcd0:	d004      	beq.n	40bcdc <__addsf3+0x10c>
  40bcd2:	f092 0f00 	teq	r2, #0
  40bcd6:	bf08      	it	eq
  40bcd8:	4608      	moveq	r0, r1
  40bcda:	4770      	bx	lr
  40bcdc:	ea90 0f01 	teq	r0, r1
  40bce0:	bf1c      	itt	ne
  40bce2:	2000      	movne	r0, #0
  40bce4:	4770      	bxne	lr
  40bce6:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
  40bcea:	d104      	bne.n	40bcf6 <__addsf3+0x126>
  40bcec:	0040      	lsls	r0, r0, #1
  40bcee:	bf28      	it	cs
  40bcf0:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
  40bcf4:	4770      	bx	lr
  40bcf6:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
  40bcfa:	bf3c      	itt	cc
  40bcfc:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
  40bd00:	4770      	bxcc	lr
  40bd02:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  40bd06:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
  40bd0a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  40bd0e:	4770      	bx	lr
  40bd10:	ea7f 6222 	mvns.w	r2, r2, asr #24
  40bd14:	bf16      	itet	ne
  40bd16:	4608      	movne	r0, r1
  40bd18:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
  40bd1c:	4601      	movne	r1, r0
  40bd1e:	0242      	lsls	r2, r0, #9
  40bd20:	bf06      	itte	eq
  40bd22:	ea5f 2341 	movseq.w	r3, r1, lsl #9
  40bd26:	ea90 0f01 	teqeq	r0, r1
  40bd2a:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
  40bd2e:	4770      	bx	lr

0040bd30 <__aeabi_ui2f>:
  40bd30:	f04f 0300 	mov.w	r3, #0
  40bd34:	e004      	b.n	40bd40 <__aeabi_i2f+0x8>
  40bd36:	bf00      	nop

0040bd38 <__aeabi_i2f>:
  40bd38:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
  40bd3c:	bf48      	it	mi
  40bd3e:	4240      	negmi	r0, r0
  40bd40:	ea5f 0c00 	movs.w	ip, r0
  40bd44:	bf08      	it	eq
  40bd46:	4770      	bxeq	lr
  40bd48:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
  40bd4c:	4601      	mov	r1, r0
  40bd4e:	f04f 0000 	mov.w	r0, #0
  40bd52:	e01c      	b.n	40bd8e <__aeabi_l2f+0x2a>

0040bd54 <__aeabi_ul2f>:
  40bd54:	ea50 0201 	orrs.w	r2, r0, r1
  40bd58:	bf08      	it	eq
  40bd5a:	4770      	bxeq	lr
  40bd5c:	f04f 0300 	mov.w	r3, #0
  40bd60:	e00a      	b.n	40bd78 <__aeabi_l2f+0x14>
  40bd62:	bf00      	nop

0040bd64 <__aeabi_l2f>:
  40bd64:	ea50 0201 	orrs.w	r2, r0, r1
  40bd68:	bf08      	it	eq
  40bd6a:	4770      	bxeq	lr
  40bd6c:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
  40bd70:	d502      	bpl.n	40bd78 <__aeabi_l2f+0x14>
  40bd72:	4240      	negs	r0, r0
  40bd74:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  40bd78:	ea5f 0c01 	movs.w	ip, r1
  40bd7c:	bf02      	ittt	eq
  40bd7e:	4684      	moveq	ip, r0
  40bd80:	4601      	moveq	r1, r0
  40bd82:	2000      	moveq	r0, #0
  40bd84:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
  40bd88:	bf08      	it	eq
  40bd8a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
  40bd8e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
  40bd92:	fabc f28c 	clz	r2, ip
  40bd96:	3a08      	subs	r2, #8
  40bd98:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
  40bd9c:	db10      	blt.n	40bdc0 <__aeabi_l2f+0x5c>
  40bd9e:	fa01 fc02 	lsl.w	ip, r1, r2
  40bda2:	4463      	add	r3, ip
  40bda4:	fa00 fc02 	lsl.w	ip, r0, r2
  40bda8:	f1c2 0220 	rsb	r2, r2, #32
  40bdac:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  40bdb0:	fa20 f202 	lsr.w	r2, r0, r2
  40bdb4:	eb43 0002 	adc.w	r0, r3, r2
  40bdb8:	bf08      	it	eq
  40bdba:	f020 0001 	biceq.w	r0, r0, #1
  40bdbe:	4770      	bx	lr
  40bdc0:	f102 0220 	add.w	r2, r2, #32
  40bdc4:	fa01 fc02 	lsl.w	ip, r1, r2
  40bdc8:	f1c2 0220 	rsb	r2, r2, #32
  40bdcc:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
  40bdd0:	fa21 f202 	lsr.w	r2, r1, r2
  40bdd4:	eb43 0002 	adc.w	r0, r3, r2
  40bdd8:	bf08      	it	eq
  40bdda:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
  40bdde:	4770      	bx	lr

0040bde0 <__aeabi_fmul>:
  40bde0:	f04f 0cff 	mov.w	ip, #255	; 0xff
  40bde4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
  40bde8:	bf1e      	ittt	ne
  40bdea:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
  40bdee:	ea92 0f0c 	teqne	r2, ip
  40bdf2:	ea93 0f0c 	teqne	r3, ip
  40bdf6:	d06f      	beq.n	40bed8 <__aeabi_fmul+0xf8>
  40bdf8:	441a      	add	r2, r3
  40bdfa:	ea80 0c01 	eor.w	ip, r0, r1
  40bdfe:	0240      	lsls	r0, r0, #9
  40be00:	bf18      	it	ne
  40be02:	ea5f 2141 	movsne.w	r1, r1, lsl #9
  40be06:	d01e      	beq.n	40be46 <__aeabi_fmul+0x66>
  40be08:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  40be0c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
  40be10:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
  40be14:	fba0 3101 	umull	r3, r1, r0, r1
  40be18:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
  40be1c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
  40be20:	bf3e      	ittt	cc
  40be22:	0049      	lslcc	r1, r1, #1
  40be24:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
  40be28:	005b      	lslcc	r3, r3, #1
  40be2a:	ea40 0001 	orr.w	r0, r0, r1
  40be2e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
  40be32:	2afd      	cmp	r2, #253	; 0xfd
  40be34:	d81d      	bhi.n	40be72 <__aeabi_fmul+0x92>
  40be36:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
  40be3a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  40be3e:	bf08      	it	eq
  40be40:	f020 0001 	biceq.w	r0, r0, #1
  40be44:	4770      	bx	lr
  40be46:	f090 0f00 	teq	r0, #0
  40be4a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
  40be4e:	bf08      	it	eq
  40be50:	0249      	lsleq	r1, r1, #9
  40be52:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
  40be56:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
  40be5a:	3a7f      	subs	r2, #127	; 0x7f
  40be5c:	bfc2      	ittt	gt
  40be5e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
  40be62:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
  40be66:	4770      	bxgt	lr
  40be68:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  40be6c:	f04f 0300 	mov.w	r3, #0
  40be70:	3a01      	subs	r2, #1
  40be72:	dc5d      	bgt.n	40bf30 <__aeabi_fmul+0x150>
  40be74:	f112 0f19 	cmn.w	r2, #25
  40be78:	bfdc      	itt	le
  40be7a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
  40be7e:	4770      	bxle	lr
  40be80:	f1c2 0200 	rsb	r2, r2, #0
  40be84:	0041      	lsls	r1, r0, #1
  40be86:	fa21 f102 	lsr.w	r1, r1, r2
  40be8a:	f1c2 0220 	rsb	r2, r2, #32
  40be8e:	fa00 fc02 	lsl.w	ip, r0, r2
  40be92:	ea5f 0031 	movs.w	r0, r1, rrx
  40be96:	f140 0000 	adc.w	r0, r0, #0
  40be9a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
  40be9e:	bf08      	it	eq
  40bea0:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
  40bea4:	4770      	bx	lr
  40bea6:	f092 0f00 	teq	r2, #0
  40beaa:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
  40beae:	bf02      	ittt	eq
  40beb0:	0040      	lsleq	r0, r0, #1
  40beb2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
  40beb6:	3a01      	subeq	r2, #1
  40beb8:	d0f9      	beq.n	40beae <__aeabi_fmul+0xce>
  40beba:	ea40 000c 	orr.w	r0, r0, ip
  40bebe:	f093 0f00 	teq	r3, #0
  40bec2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  40bec6:	bf02      	ittt	eq
  40bec8:	0049      	lsleq	r1, r1, #1
  40beca:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
  40bece:	3b01      	subeq	r3, #1
  40bed0:	d0f9      	beq.n	40bec6 <__aeabi_fmul+0xe6>
  40bed2:	ea41 010c 	orr.w	r1, r1, ip
  40bed6:	e78f      	b.n	40bdf8 <__aeabi_fmul+0x18>
  40bed8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
  40bedc:	ea92 0f0c 	teq	r2, ip
  40bee0:	bf18      	it	ne
  40bee2:	ea93 0f0c 	teqne	r3, ip
  40bee6:	d00a      	beq.n	40befe <__aeabi_fmul+0x11e>
  40bee8:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
  40beec:	bf18      	it	ne
  40beee:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
  40bef2:	d1d8      	bne.n	40bea6 <__aeabi_fmul+0xc6>
  40bef4:	ea80 0001 	eor.w	r0, r0, r1
  40bef8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
  40befc:	4770      	bx	lr
  40befe:	f090 0f00 	teq	r0, #0
  40bf02:	bf17      	itett	ne
  40bf04:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
  40bf08:	4608      	moveq	r0, r1
  40bf0a:	f091 0f00 	teqne	r1, #0
  40bf0e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
  40bf12:	d014      	beq.n	40bf3e <__aeabi_fmul+0x15e>
  40bf14:	ea92 0f0c 	teq	r2, ip
  40bf18:	d101      	bne.n	40bf1e <__aeabi_fmul+0x13e>
  40bf1a:	0242      	lsls	r2, r0, #9
  40bf1c:	d10f      	bne.n	40bf3e <__aeabi_fmul+0x15e>
  40bf1e:	ea93 0f0c 	teq	r3, ip
  40bf22:	d103      	bne.n	40bf2c <__aeabi_fmul+0x14c>
  40bf24:	024b      	lsls	r3, r1, #9
  40bf26:	bf18      	it	ne
  40bf28:	4608      	movne	r0, r1
  40bf2a:	d108      	bne.n	40bf3e <__aeabi_fmul+0x15e>
  40bf2c:	ea80 0001 	eor.w	r0, r0, r1
  40bf30:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
  40bf34:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  40bf38:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  40bf3c:	4770      	bx	lr
  40bf3e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  40bf42:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
  40bf46:	4770      	bx	lr

0040bf48 <__aeabi_fdiv>:
  40bf48:	f04f 0cff 	mov.w	ip, #255	; 0xff
  40bf4c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
  40bf50:	bf1e      	ittt	ne
  40bf52:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
  40bf56:	ea92 0f0c 	teqne	r2, ip
  40bf5a:	ea93 0f0c 	teqne	r3, ip
  40bf5e:	d069      	beq.n	40c034 <__aeabi_fdiv+0xec>
  40bf60:	eba2 0203 	sub.w	r2, r2, r3
  40bf64:	ea80 0c01 	eor.w	ip, r0, r1
  40bf68:	0249      	lsls	r1, r1, #9
  40bf6a:	ea4f 2040 	mov.w	r0, r0, lsl #9
  40bf6e:	d037      	beq.n	40bfe0 <__aeabi_fdiv+0x98>
  40bf70:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  40bf74:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
  40bf78:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
  40bf7c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
  40bf80:	428b      	cmp	r3, r1
  40bf82:	bf38      	it	cc
  40bf84:	005b      	lslcc	r3, r3, #1
  40bf86:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
  40bf8a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
  40bf8e:	428b      	cmp	r3, r1
  40bf90:	bf24      	itt	cs
  40bf92:	1a5b      	subcs	r3, r3, r1
  40bf94:	ea40 000c 	orrcs.w	r0, r0, ip
  40bf98:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
  40bf9c:	bf24      	itt	cs
  40bf9e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
  40bfa2:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  40bfa6:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
  40bfaa:	bf24      	itt	cs
  40bfac:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
  40bfb0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  40bfb4:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
  40bfb8:	bf24      	itt	cs
  40bfba:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
  40bfbe:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  40bfc2:	011b      	lsls	r3, r3, #4
  40bfc4:	bf18      	it	ne
  40bfc6:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
  40bfca:	d1e0      	bne.n	40bf8e <__aeabi_fdiv+0x46>
  40bfcc:	2afd      	cmp	r2, #253	; 0xfd
  40bfce:	f63f af50 	bhi.w	40be72 <__aeabi_fmul+0x92>
  40bfd2:	428b      	cmp	r3, r1
  40bfd4:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  40bfd8:	bf08      	it	eq
  40bfda:	f020 0001 	biceq.w	r0, r0, #1
  40bfde:	4770      	bx	lr
  40bfe0:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
  40bfe4:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
  40bfe8:	327f      	adds	r2, #127	; 0x7f
  40bfea:	bfc2      	ittt	gt
  40bfec:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
  40bff0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
  40bff4:	4770      	bxgt	lr
  40bff6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  40bffa:	f04f 0300 	mov.w	r3, #0
  40bffe:	3a01      	subs	r2, #1
  40c000:	e737      	b.n	40be72 <__aeabi_fmul+0x92>
  40c002:	f092 0f00 	teq	r2, #0
  40c006:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
  40c00a:	bf02      	ittt	eq
  40c00c:	0040      	lsleq	r0, r0, #1
  40c00e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
  40c012:	3a01      	subeq	r2, #1
  40c014:	d0f9      	beq.n	40c00a <__aeabi_fdiv+0xc2>
  40c016:	ea40 000c 	orr.w	r0, r0, ip
  40c01a:	f093 0f00 	teq	r3, #0
  40c01e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  40c022:	bf02      	ittt	eq
  40c024:	0049      	lsleq	r1, r1, #1
  40c026:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
  40c02a:	3b01      	subeq	r3, #1
  40c02c:	d0f9      	beq.n	40c022 <__aeabi_fdiv+0xda>
  40c02e:	ea41 010c 	orr.w	r1, r1, ip
  40c032:	e795      	b.n	40bf60 <__aeabi_fdiv+0x18>
  40c034:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
  40c038:	ea92 0f0c 	teq	r2, ip
  40c03c:	d108      	bne.n	40c050 <__aeabi_fdiv+0x108>
  40c03e:	0242      	lsls	r2, r0, #9
  40c040:	f47f af7d 	bne.w	40bf3e <__aeabi_fmul+0x15e>
  40c044:	ea93 0f0c 	teq	r3, ip
  40c048:	f47f af70 	bne.w	40bf2c <__aeabi_fmul+0x14c>
  40c04c:	4608      	mov	r0, r1
  40c04e:	e776      	b.n	40bf3e <__aeabi_fmul+0x15e>
  40c050:	ea93 0f0c 	teq	r3, ip
  40c054:	d104      	bne.n	40c060 <__aeabi_fdiv+0x118>
  40c056:	024b      	lsls	r3, r1, #9
  40c058:	f43f af4c 	beq.w	40bef4 <__aeabi_fmul+0x114>
  40c05c:	4608      	mov	r0, r1
  40c05e:	e76e      	b.n	40bf3e <__aeabi_fmul+0x15e>
  40c060:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
  40c064:	bf18      	it	ne
  40c066:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
  40c06a:	d1ca      	bne.n	40c002 <__aeabi_fdiv+0xba>
  40c06c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
  40c070:	f47f af5c 	bne.w	40bf2c <__aeabi_fmul+0x14c>
  40c074:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
  40c078:	f47f af3c 	bne.w	40bef4 <__aeabi_fmul+0x114>
  40c07c:	e75f      	b.n	40bf3e <__aeabi_fmul+0x15e>
  40c07e:	bf00      	nop

0040c080 <__gesf2>:
  40c080:	f04f 3cff 	mov.w	ip, #4294967295
  40c084:	e006      	b.n	40c094 <__cmpsf2+0x4>
  40c086:	bf00      	nop

0040c088 <__lesf2>:
  40c088:	f04f 0c01 	mov.w	ip, #1
  40c08c:	e002      	b.n	40c094 <__cmpsf2+0x4>
  40c08e:	bf00      	nop

0040c090 <__cmpsf2>:
  40c090:	f04f 0c01 	mov.w	ip, #1
  40c094:	f84d cd04 	str.w	ip, [sp, #-4]!
  40c098:	ea4f 0240 	mov.w	r2, r0, lsl #1
  40c09c:	ea4f 0341 	mov.w	r3, r1, lsl #1
  40c0a0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  40c0a4:	bf18      	it	ne
  40c0a6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  40c0aa:	d011      	beq.n	40c0d0 <__cmpsf2+0x40>
  40c0ac:	b001      	add	sp, #4
  40c0ae:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
  40c0b2:	bf18      	it	ne
  40c0b4:	ea90 0f01 	teqne	r0, r1
  40c0b8:	bf58      	it	pl
  40c0ba:	ebb2 0003 	subspl.w	r0, r2, r3
  40c0be:	bf88      	it	hi
  40c0c0:	17c8      	asrhi	r0, r1, #31
  40c0c2:	bf38      	it	cc
  40c0c4:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
  40c0c8:	bf18      	it	ne
  40c0ca:	f040 0001 	orrne.w	r0, r0, #1
  40c0ce:	4770      	bx	lr
  40c0d0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  40c0d4:	d102      	bne.n	40c0dc <__cmpsf2+0x4c>
  40c0d6:	ea5f 2c40 	movs.w	ip, r0, lsl #9
  40c0da:	d105      	bne.n	40c0e8 <__cmpsf2+0x58>
  40c0dc:	ea7f 6c23 	mvns.w	ip, r3, asr #24
  40c0e0:	d1e4      	bne.n	40c0ac <__cmpsf2+0x1c>
  40c0e2:	ea5f 2c41 	movs.w	ip, r1, lsl #9
  40c0e6:	d0e1      	beq.n	40c0ac <__cmpsf2+0x1c>
  40c0e8:	f85d 0b04 	ldr.w	r0, [sp], #4
  40c0ec:	4770      	bx	lr
  40c0ee:	bf00      	nop

0040c0f0 <__aeabi_cfrcmple>:
  40c0f0:	4684      	mov	ip, r0
  40c0f2:	4608      	mov	r0, r1
  40c0f4:	4661      	mov	r1, ip
  40c0f6:	e7ff      	b.n	40c0f8 <__aeabi_cfcmpeq>

0040c0f8 <__aeabi_cfcmpeq>:
  40c0f8:	b50f      	push	{r0, r1, r2, r3, lr}
  40c0fa:	f7ff ffc9 	bl	40c090 <__cmpsf2>
  40c0fe:	2800      	cmp	r0, #0
  40c100:	bf48      	it	mi
  40c102:	f110 0f00 	cmnmi.w	r0, #0
  40c106:	bd0f      	pop	{r0, r1, r2, r3, pc}

0040c108 <__aeabi_fcmpeq>:
  40c108:	f84d ed08 	str.w	lr, [sp, #-8]!
  40c10c:	f7ff fff4 	bl	40c0f8 <__aeabi_cfcmpeq>
  40c110:	bf0c      	ite	eq
  40c112:	2001      	moveq	r0, #1
  40c114:	2000      	movne	r0, #0
  40c116:	f85d fb08 	ldr.w	pc, [sp], #8
  40c11a:	bf00      	nop

0040c11c <__aeabi_fcmplt>:
  40c11c:	f84d ed08 	str.w	lr, [sp, #-8]!
  40c120:	f7ff ffea 	bl	40c0f8 <__aeabi_cfcmpeq>
  40c124:	bf34      	ite	cc
  40c126:	2001      	movcc	r0, #1
  40c128:	2000      	movcs	r0, #0
  40c12a:	f85d fb08 	ldr.w	pc, [sp], #8
  40c12e:	bf00      	nop

0040c130 <__aeabi_fcmple>:
  40c130:	f84d ed08 	str.w	lr, [sp, #-8]!
  40c134:	f7ff ffe0 	bl	40c0f8 <__aeabi_cfcmpeq>
  40c138:	bf94      	ite	ls
  40c13a:	2001      	movls	r0, #1
  40c13c:	2000      	movhi	r0, #0
  40c13e:	f85d fb08 	ldr.w	pc, [sp], #8
  40c142:	bf00      	nop

0040c144 <__aeabi_fcmpge>:
  40c144:	f84d ed08 	str.w	lr, [sp, #-8]!
  40c148:	f7ff ffd2 	bl	40c0f0 <__aeabi_cfrcmple>
  40c14c:	bf94      	ite	ls
  40c14e:	2001      	movls	r0, #1
  40c150:	2000      	movhi	r0, #0
  40c152:	f85d fb08 	ldr.w	pc, [sp], #8
  40c156:	bf00      	nop

0040c158 <__aeabi_fcmpgt>:
  40c158:	f84d ed08 	str.w	lr, [sp, #-8]!
  40c15c:	f7ff ffc8 	bl	40c0f0 <__aeabi_cfrcmple>
  40c160:	bf34      	ite	cc
  40c162:	2001      	movcc	r0, #1
  40c164:	2000      	movcs	r0, #0
  40c166:	f85d fb08 	ldr.w	pc, [sp], #8
  40c16a:	bf00      	nop

0040c16c <__aeabi_f2iz>:
  40c16c:	ea4f 0240 	mov.w	r2, r0, lsl #1
  40c170:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
  40c174:	d30f      	bcc.n	40c196 <__aeabi_f2iz+0x2a>
  40c176:	f04f 039e 	mov.w	r3, #158	; 0x9e
  40c17a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
  40c17e:	d90d      	bls.n	40c19c <__aeabi_f2iz+0x30>
  40c180:	ea4f 2300 	mov.w	r3, r0, lsl #8
  40c184:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  40c188:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
  40c18c:	fa23 f002 	lsr.w	r0, r3, r2
  40c190:	bf18      	it	ne
  40c192:	4240      	negne	r0, r0
  40c194:	4770      	bx	lr
  40c196:	f04f 0000 	mov.w	r0, #0
  40c19a:	4770      	bx	lr
  40c19c:	f112 0f61 	cmn.w	r2, #97	; 0x61
  40c1a0:	d101      	bne.n	40c1a6 <__aeabi_f2iz+0x3a>
  40c1a2:	0242      	lsls	r2, r0, #9
  40c1a4:	d105      	bne.n	40c1b2 <__aeabi_f2iz+0x46>
  40c1a6:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
  40c1aa:	bf08      	it	eq
  40c1ac:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  40c1b0:	4770      	bx	lr
  40c1b2:	f04f 0000 	mov.w	r0, #0
  40c1b6:	4770      	bx	lr

0040c1b8 <__aeabi_f2uiz>:
  40c1b8:	0042      	lsls	r2, r0, #1
  40c1ba:	d20e      	bcs.n	40c1da <__aeabi_f2uiz+0x22>
  40c1bc:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
  40c1c0:	d30b      	bcc.n	40c1da <__aeabi_f2uiz+0x22>
  40c1c2:	f04f 039e 	mov.w	r3, #158	; 0x9e
  40c1c6:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
  40c1ca:	d409      	bmi.n	40c1e0 <__aeabi_f2uiz+0x28>
  40c1cc:	ea4f 2300 	mov.w	r3, r0, lsl #8
  40c1d0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  40c1d4:	fa23 f002 	lsr.w	r0, r3, r2
  40c1d8:	4770      	bx	lr
  40c1da:	f04f 0000 	mov.w	r0, #0
  40c1de:	4770      	bx	lr
  40c1e0:	f112 0f61 	cmn.w	r2, #97	; 0x61
  40c1e4:	d101      	bne.n	40c1ea <__aeabi_f2uiz+0x32>
  40c1e6:	0242      	lsls	r2, r0, #9
  40c1e8:	d102      	bne.n	40c1f0 <__aeabi_f2uiz+0x38>
  40c1ea:	f04f 30ff 	mov.w	r0, #4294967295
  40c1ee:	4770      	bx	lr
  40c1f0:	f04f 0000 	mov.w	r0, #0
  40c1f4:	4770      	bx	lr
  40c1f6:	bf00      	nop

0040c1f8 <abort>:
  40c1f8:	b508      	push	{r3, lr}
  40c1fa:	2006      	movs	r0, #6
  40c1fc:	f000 f9e6 	bl	40c5cc <raise>
  40c200:	2001      	movs	r0, #1
  40c202:	f7ff f851 	bl	40b2a8 <_exit>
	...

0040c208 <__libc_init_array>:
  40c208:	b570      	push	{r4, r5, r6, lr}
  40c20a:	4e0d      	ldr	r6, [pc, #52]	; (40c240 <__libc_init_array+0x38>)
  40c20c:	4c0d      	ldr	r4, [pc, #52]	; (40c244 <__libc_init_array+0x3c>)
  40c20e:	1ba4      	subs	r4, r4, r6
  40c210:	10a4      	asrs	r4, r4, #2
  40c212:	2500      	movs	r5, #0
  40c214:	42a5      	cmp	r5, r4
  40c216:	d109      	bne.n	40c22c <__libc_init_array+0x24>
  40c218:	4e0b      	ldr	r6, [pc, #44]	; (40c248 <__libc_init_array+0x40>)
  40c21a:	4c0c      	ldr	r4, [pc, #48]	; (40c24c <__libc_init_array+0x44>)
  40c21c:	f002 fa94 	bl	40e748 <_init>
  40c220:	1ba4      	subs	r4, r4, r6
  40c222:	10a4      	asrs	r4, r4, #2
  40c224:	2500      	movs	r5, #0
  40c226:	42a5      	cmp	r5, r4
  40c228:	d105      	bne.n	40c236 <__libc_init_array+0x2e>
  40c22a:	bd70      	pop	{r4, r5, r6, pc}
  40c22c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  40c230:	4798      	blx	r3
  40c232:	3501      	adds	r5, #1
  40c234:	e7ee      	b.n	40c214 <__libc_init_array+0xc>
  40c236:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  40c23a:	4798      	blx	r3
  40c23c:	3501      	adds	r5, #1
  40c23e:	e7f2      	b.n	40c226 <__libc_init_array+0x1e>
  40c240:	0040e754 	.word	0x0040e754
  40c244:	0040e754 	.word	0x0040e754
  40c248:	0040e754 	.word	0x0040e754
  40c24c:	0040e760 	.word	0x0040e760

0040c250 <malloc>:
  40c250:	4b02      	ldr	r3, [pc, #8]	; (40c25c <malloc+0xc>)
  40c252:	4601      	mov	r1, r0
  40c254:	6818      	ldr	r0, [r3, #0]
  40c256:	f000 b86d 	b.w	40c334 <_malloc_r>
  40c25a:	bf00      	nop
  40c25c:	20000020 	.word	0x20000020

0040c260 <free>:
  40c260:	4b02      	ldr	r3, [pc, #8]	; (40c26c <free+0xc>)
  40c262:	4601      	mov	r1, r0
  40c264:	6818      	ldr	r0, [r3, #0]
  40c266:	f000 b817 	b.w	40c298 <_free_r>
  40c26a:	bf00      	nop
  40c26c:	20000020 	.word	0x20000020

0040c270 <memcpy>:
  40c270:	b510      	push	{r4, lr}
  40c272:	1e43      	subs	r3, r0, #1
  40c274:	440a      	add	r2, r1
  40c276:	4291      	cmp	r1, r2
  40c278:	d100      	bne.n	40c27c <memcpy+0xc>
  40c27a:	bd10      	pop	{r4, pc}
  40c27c:	f811 4b01 	ldrb.w	r4, [r1], #1
  40c280:	f803 4f01 	strb.w	r4, [r3, #1]!
  40c284:	e7f7      	b.n	40c276 <memcpy+0x6>

0040c286 <memset>:
  40c286:	4402      	add	r2, r0
  40c288:	4603      	mov	r3, r0
  40c28a:	4293      	cmp	r3, r2
  40c28c:	d100      	bne.n	40c290 <memset+0xa>
  40c28e:	4770      	bx	lr
  40c290:	f803 1b01 	strb.w	r1, [r3], #1
  40c294:	e7f9      	b.n	40c28a <memset+0x4>
	...

0040c298 <_free_r>:
  40c298:	b538      	push	{r3, r4, r5, lr}
  40c29a:	4605      	mov	r5, r0
  40c29c:	2900      	cmp	r1, #0
  40c29e:	d045      	beq.n	40c32c <_free_r+0x94>
  40c2a0:	f851 3c04 	ldr.w	r3, [r1, #-4]
  40c2a4:	1f0c      	subs	r4, r1, #4
  40c2a6:	2b00      	cmp	r3, #0
  40c2a8:	bfb8      	it	lt
  40c2aa:	18e4      	addlt	r4, r4, r3
  40c2ac:	f000 fc5e 	bl	40cb6c <__malloc_lock>
  40c2b0:	4a1f      	ldr	r2, [pc, #124]	; (40c330 <_free_r+0x98>)
  40c2b2:	6813      	ldr	r3, [r2, #0]
  40c2b4:	4610      	mov	r0, r2
  40c2b6:	b933      	cbnz	r3, 40c2c6 <_free_r+0x2e>
  40c2b8:	6063      	str	r3, [r4, #4]
  40c2ba:	6014      	str	r4, [r2, #0]
  40c2bc:	4628      	mov	r0, r5
  40c2be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40c2c2:	f000 bc54 	b.w	40cb6e <__malloc_unlock>
  40c2c6:	42a3      	cmp	r3, r4
  40c2c8:	d90c      	bls.n	40c2e4 <_free_r+0x4c>
  40c2ca:	6821      	ldr	r1, [r4, #0]
  40c2cc:	1862      	adds	r2, r4, r1
  40c2ce:	4293      	cmp	r3, r2
  40c2d0:	bf04      	itt	eq
  40c2d2:	681a      	ldreq	r2, [r3, #0]
  40c2d4:	685b      	ldreq	r3, [r3, #4]
  40c2d6:	6063      	str	r3, [r4, #4]
  40c2d8:	bf04      	itt	eq
  40c2da:	1852      	addeq	r2, r2, r1
  40c2dc:	6022      	streq	r2, [r4, #0]
  40c2de:	6004      	str	r4, [r0, #0]
  40c2e0:	e7ec      	b.n	40c2bc <_free_r+0x24>
  40c2e2:	4613      	mov	r3, r2
  40c2e4:	685a      	ldr	r2, [r3, #4]
  40c2e6:	b10a      	cbz	r2, 40c2ec <_free_r+0x54>
  40c2e8:	42a2      	cmp	r2, r4
  40c2ea:	d9fa      	bls.n	40c2e2 <_free_r+0x4a>
  40c2ec:	6819      	ldr	r1, [r3, #0]
  40c2ee:	1858      	adds	r0, r3, r1
  40c2f0:	42a0      	cmp	r0, r4
  40c2f2:	d10b      	bne.n	40c30c <_free_r+0x74>
  40c2f4:	6820      	ldr	r0, [r4, #0]
  40c2f6:	4401      	add	r1, r0
  40c2f8:	1858      	adds	r0, r3, r1
  40c2fa:	4282      	cmp	r2, r0
  40c2fc:	6019      	str	r1, [r3, #0]
  40c2fe:	d1dd      	bne.n	40c2bc <_free_r+0x24>
  40c300:	6810      	ldr	r0, [r2, #0]
  40c302:	6852      	ldr	r2, [r2, #4]
  40c304:	605a      	str	r2, [r3, #4]
  40c306:	4401      	add	r1, r0
  40c308:	6019      	str	r1, [r3, #0]
  40c30a:	e7d7      	b.n	40c2bc <_free_r+0x24>
  40c30c:	d902      	bls.n	40c314 <_free_r+0x7c>
  40c30e:	230c      	movs	r3, #12
  40c310:	602b      	str	r3, [r5, #0]
  40c312:	e7d3      	b.n	40c2bc <_free_r+0x24>
  40c314:	6820      	ldr	r0, [r4, #0]
  40c316:	1821      	adds	r1, r4, r0
  40c318:	428a      	cmp	r2, r1
  40c31a:	bf04      	itt	eq
  40c31c:	6811      	ldreq	r1, [r2, #0]
  40c31e:	6852      	ldreq	r2, [r2, #4]
  40c320:	6062      	str	r2, [r4, #4]
  40c322:	bf04      	itt	eq
  40c324:	1809      	addeq	r1, r1, r0
  40c326:	6021      	streq	r1, [r4, #0]
  40c328:	605c      	str	r4, [r3, #4]
  40c32a:	e7c7      	b.n	40c2bc <_free_r+0x24>
  40c32c:	bd38      	pop	{r3, r4, r5, pc}
  40c32e:	bf00      	nop
  40c330:	200117ec 	.word	0x200117ec

0040c334 <_malloc_r>:
  40c334:	b570      	push	{r4, r5, r6, lr}
  40c336:	1ccd      	adds	r5, r1, #3
  40c338:	f025 0503 	bic.w	r5, r5, #3
  40c33c:	3508      	adds	r5, #8
  40c33e:	2d0c      	cmp	r5, #12
  40c340:	bf38      	it	cc
  40c342:	250c      	movcc	r5, #12
  40c344:	2d00      	cmp	r5, #0
  40c346:	4606      	mov	r6, r0
  40c348:	db01      	blt.n	40c34e <_malloc_r+0x1a>
  40c34a:	42a9      	cmp	r1, r5
  40c34c:	d903      	bls.n	40c356 <_malloc_r+0x22>
  40c34e:	230c      	movs	r3, #12
  40c350:	6033      	str	r3, [r6, #0]
  40c352:	2000      	movs	r0, #0
  40c354:	bd70      	pop	{r4, r5, r6, pc}
  40c356:	f000 fc09 	bl	40cb6c <__malloc_lock>
  40c35a:	4a23      	ldr	r2, [pc, #140]	; (40c3e8 <_malloc_r+0xb4>)
  40c35c:	6814      	ldr	r4, [r2, #0]
  40c35e:	4621      	mov	r1, r4
  40c360:	b991      	cbnz	r1, 40c388 <_malloc_r+0x54>
  40c362:	4c22      	ldr	r4, [pc, #136]	; (40c3ec <_malloc_r+0xb8>)
  40c364:	6823      	ldr	r3, [r4, #0]
  40c366:	b91b      	cbnz	r3, 40c370 <_malloc_r+0x3c>
  40c368:	4630      	mov	r0, r6
  40c36a:	f000 f841 	bl	40c3f0 <_sbrk_r>
  40c36e:	6020      	str	r0, [r4, #0]
  40c370:	4629      	mov	r1, r5
  40c372:	4630      	mov	r0, r6
  40c374:	f000 f83c 	bl	40c3f0 <_sbrk_r>
  40c378:	1c43      	adds	r3, r0, #1
  40c37a:	d126      	bne.n	40c3ca <_malloc_r+0x96>
  40c37c:	230c      	movs	r3, #12
  40c37e:	6033      	str	r3, [r6, #0]
  40c380:	4630      	mov	r0, r6
  40c382:	f000 fbf4 	bl	40cb6e <__malloc_unlock>
  40c386:	e7e4      	b.n	40c352 <_malloc_r+0x1e>
  40c388:	680b      	ldr	r3, [r1, #0]
  40c38a:	1b5b      	subs	r3, r3, r5
  40c38c:	d41a      	bmi.n	40c3c4 <_malloc_r+0x90>
  40c38e:	2b0b      	cmp	r3, #11
  40c390:	d90f      	bls.n	40c3b2 <_malloc_r+0x7e>
  40c392:	600b      	str	r3, [r1, #0]
  40c394:	50cd      	str	r5, [r1, r3]
  40c396:	18cc      	adds	r4, r1, r3
  40c398:	4630      	mov	r0, r6
  40c39a:	f000 fbe8 	bl	40cb6e <__malloc_unlock>
  40c39e:	f104 000b 	add.w	r0, r4, #11
  40c3a2:	1d23      	adds	r3, r4, #4
  40c3a4:	f020 0007 	bic.w	r0, r0, #7
  40c3a8:	1ac3      	subs	r3, r0, r3
  40c3aa:	d01b      	beq.n	40c3e4 <_malloc_r+0xb0>
  40c3ac:	425a      	negs	r2, r3
  40c3ae:	50e2      	str	r2, [r4, r3]
  40c3b0:	bd70      	pop	{r4, r5, r6, pc}
  40c3b2:	428c      	cmp	r4, r1
  40c3b4:	bf0d      	iteet	eq
  40c3b6:	6863      	ldreq	r3, [r4, #4]
  40c3b8:	684b      	ldrne	r3, [r1, #4]
  40c3ba:	6063      	strne	r3, [r4, #4]
  40c3bc:	6013      	streq	r3, [r2, #0]
  40c3be:	bf18      	it	ne
  40c3c0:	460c      	movne	r4, r1
  40c3c2:	e7e9      	b.n	40c398 <_malloc_r+0x64>
  40c3c4:	460c      	mov	r4, r1
  40c3c6:	6849      	ldr	r1, [r1, #4]
  40c3c8:	e7ca      	b.n	40c360 <_malloc_r+0x2c>
  40c3ca:	1cc4      	adds	r4, r0, #3
  40c3cc:	f024 0403 	bic.w	r4, r4, #3
  40c3d0:	42a0      	cmp	r0, r4
  40c3d2:	d005      	beq.n	40c3e0 <_malloc_r+0xac>
  40c3d4:	1a21      	subs	r1, r4, r0
  40c3d6:	4630      	mov	r0, r6
  40c3d8:	f000 f80a 	bl	40c3f0 <_sbrk_r>
  40c3dc:	3001      	adds	r0, #1
  40c3de:	d0cd      	beq.n	40c37c <_malloc_r+0x48>
  40c3e0:	6025      	str	r5, [r4, #0]
  40c3e2:	e7d9      	b.n	40c398 <_malloc_r+0x64>
  40c3e4:	bd70      	pop	{r4, r5, r6, pc}
  40c3e6:	bf00      	nop
  40c3e8:	200117ec 	.word	0x200117ec
  40c3ec:	200117f0 	.word	0x200117f0

0040c3f0 <_sbrk_r>:
  40c3f0:	b538      	push	{r3, r4, r5, lr}
  40c3f2:	4c06      	ldr	r4, [pc, #24]	; (40c40c <_sbrk_r+0x1c>)
  40c3f4:	2300      	movs	r3, #0
  40c3f6:	4605      	mov	r5, r0
  40c3f8:	4608      	mov	r0, r1
  40c3fa:	6023      	str	r3, [r4, #0]
  40c3fc:	f7fe ff2e 	bl	40b25c <_sbrk>
  40c400:	1c43      	adds	r3, r0, #1
  40c402:	d102      	bne.n	40c40a <_sbrk_r+0x1a>
  40c404:	6823      	ldr	r3, [r4, #0]
  40c406:	b103      	cbz	r3, 40c40a <_sbrk_r+0x1a>
  40c408:	602b      	str	r3, [r5, #0]
  40c40a:	bd38      	pop	{r3, r4, r5, pc}
  40c40c:	20011804 	.word	0x20011804

0040c410 <setbuf>:
  40c410:	2900      	cmp	r1, #0
  40c412:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40c416:	bf0c      	ite	eq
  40c418:	2202      	moveq	r2, #2
  40c41a:	2200      	movne	r2, #0
  40c41c:	f000 b800 	b.w	40c420 <setvbuf>

0040c420 <setvbuf>:
  40c420:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  40c424:	461d      	mov	r5, r3
  40c426:	4b51      	ldr	r3, [pc, #324]	; (40c56c <setvbuf+0x14c>)
  40c428:	681e      	ldr	r6, [r3, #0]
  40c42a:	4604      	mov	r4, r0
  40c42c:	460f      	mov	r7, r1
  40c42e:	4690      	mov	r8, r2
  40c430:	b126      	cbz	r6, 40c43c <setvbuf+0x1c>
  40c432:	69b3      	ldr	r3, [r6, #24]
  40c434:	b913      	cbnz	r3, 40c43c <setvbuf+0x1c>
  40c436:	4630      	mov	r0, r6
  40c438:	f000 fad8 	bl	40c9ec <__sinit>
  40c43c:	4b4c      	ldr	r3, [pc, #304]	; (40c570 <setvbuf+0x150>)
  40c43e:	429c      	cmp	r4, r3
  40c440:	d152      	bne.n	40c4e8 <setvbuf+0xc8>
  40c442:	6874      	ldr	r4, [r6, #4]
  40c444:	f1b8 0f02 	cmp.w	r8, #2
  40c448:	d006      	beq.n	40c458 <setvbuf+0x38>
  40c44a:	f1b8 0f01 	cmp.w	r8, #1
  40c44e:	f200 8089 	bhi.w	40c564 <setvbuf+0x144>
  40c452:	2d00      	cmp	r5, #0
  40c454:	f2c0 8086 	blt.w	40c564 <setvbuf+0x144>
  40c458:	4621      	mov	r1, r4
  40c45a:	4630      	mov	r0, r6
  40c45c:	f000 fa5c 	bl	40c918 <_fflush_r>
  40c460:	6b61      	ldr	r1, [r4, #52]	; 0x34
  40c462:	b141      	cbz	r1, 40c476 <setvbuf+0x56>
  40c464:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40c468:	4299      	cmp	r1, r3
  40c46a:	d002      	beq.n	40c472 <setvbuf+0x52>
  40c46c:	4630      	mov	r0, r6
  40c46e:	f7ff ff13 	bl	40c298 <_free_r>
  40c472:	2300      	movs	r3, #0
  40c474:	6363      	str	r3, [r4, #52]	; 0x34
  40c476:	2300      	movs	r3, #0
  40c478:	61a3      	str	r3, [r4, #24]
  40c47a:	6063      	str	r3, [r4, #4]
  40c47c:	89a3      	ldrh	r3, [r4, #12]
  40c47e:	061b      	lsls	r3, r3, #24
  40c480:	d503      	bpl.n	40c48a <setvbuf+0x6a>
  40c482:	6921      	ldr	r1, [r4, #16]
  40c484:	4630      	mov	r0, r6
  40c486:	f7ff ff07 	bl	40c298 <_free_r>
  40c48a:	89a3      	ldrh	r3, [r4, #12]
  40c48c:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
  40c490:	f023 0303 	bic.w	r3, r3, #3
  40c494:	f1b8 0f02 	cmp.w	r8, #2
  40c498:	81a3      	strh	r3, [r4, #12]
  40c49a:	d05d      	beq.n	40c558 <setvbuf+0x138>
  40c49c:	ab01      	add	r3, sp, #4
  40c49e:	466a      	mov	r2, sp
  40c4a0:	4621      	mov	r1, r4
  40c4a2:	4630      	mov	r0, r6
  40c4a4:	f000 fb3e 	bl	40cb24 <__swhatbuf_r>
  40c4a8:	89a3      	ldrh	r3, [r4, #12]
  40c4aa:	4318      	orrs	r0, r3
  40c4ac:	81a0      	strh	r0, [r4, #12]
  40c4ae:	bb2d      	cbnz	r5, 40c4fc <setvbuf+0xdc>
  40c4b0:	9d00      	ldr	r5, [sp, #0]
  40c4b2:	4628      	mov	r0, r5
  40c4b4:	f7ff fecc 	bl	40c250 <malloc>
  40c4b8:	4607      	mov	r7, r0
  40c4ba:	2800      	cmp	r0, #0
  40c4bc:	d14e      	bne.n	40c55c <setvbuf+0x13c>
  40c4be:	f8dd 9000 	ldr.w	r9, [sp]
  40c4c2:	45a9      	cmp	r9, r5
  40c4c4:	d13c      	bne.n	40c540 <setvbuf+0x120>
  40c4c6:	f04f 30ff 	mov.w	r0, #4294967295
  40c4ca:	89a3      	ldrh	r3, [r4, #12]
  40c4cc:	f043 0302 	orr.w	r3, r3, #2
  40c4d0:	81a3      	strh	r3, [r4, #12]
  40c4d2:	2300      	movs	r3, #0
  40c4d4:	60a3      	str	r3, [r4, #8]
  40c4d6:	f104 0347 	add.w	r3, r4, #71	; 0x47
  40c4da:	6023      	str	r3, [r4, #0]
  40c4dc:	6123      	str	r3, [r4, #16]
  40c4de:	2301      	movs	r3, #1
  40c4e0:	6163      	str	r3, [r4, #20]
  40c4e2:	b003      	add	sp, #12
  40c4e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40c4e8:	4b22      	ldr	r3, [pc, #136]	; (40c574 <setvbuf+0x154>)
  40c4ea:	429c      	cmp	r4, r3
  40c4ec:	d101      	bne.n	40c4f2 <setvbuf+0xd2>
  40c4ee:	68b4      	ldr	r4, [r6, #8]
  40c4f0:	e7a8      	b.n	40c444 <setvbuf+0x24>
  40c4f2:	4b21      	ldr	r3, [pc, #132]	; (40c578 <setvbuf+0x158>)
  40c4f4:	429c      	cmp	r4, r3
  40c4f6:	bf08      	it	eq
  40c4f8:	68f4      	ldreq	r4, [r6, #12]
  40c4fa:	e7a3      	b.n	40c444 <setvbuf+0x24>
  40c4fc:	2f00      	cmp	r7, #0
  40c4fe:	d0d8      	beq.n	40c4b2 <setvbuf+0x92>
  40c500:	69b3      	ldr	r3, [r6, #24]
  40c502:	b913      	cbnz	r3, 40c50a <setvbuf+0xea>
  40c504:	4630      	mov	r0, r6
  40c506:	f000 fa71 	bl	40c9ec <__sinit>
  40c50a:	f1b8 0f01 	cmp.w	r8, #1
  40c50e:	bf08      	it	eq
  40c510:	89a3      	ldrheq	r3, [r4, #12]
  40c512:	6027      	str	r7, [r4, #0]
  40c514:	bf04      	itt	eq
  40c516:	f043 0301 	orreq.w	r3, r3, #1
  40c51a:	81a3      	strheq	r3, [r4, #12]
  40c51c:	89a3      	ldrh	r3, [r4, #12]
  40c51e:	6127      	str	r7, [r4, #16]
  40c520:	f013 0008 	ands.w	r0, r3, #8
  40c524:	6165      	str	r5, [r4, #20]
  40c526:	d01b      	beq.n	40c560 <setvbuf+0x140>
  40c528:	f013 0001 	ands.w	r0, r3, #1
  40c52c:	bf18      	it	ne
  40c52e:	426d      	negne	r5, r5
  40c530:	f04f 0300 	mov.w	r3, #0
  40c534:	bf1d      	ittte	ne
  40c536:	60a3      	strne	r3, [r4, #8]
  40c538:	61a5      	strne	r5, [r4, #24]
  40c53a:	4618      	movne	r0, r3
  40c53c:	60a5      	streq	r5, [r4, #8]
  40c53e:	e7d0      	b.n	40c4e2 <setvbuf+0xc2>
  40c540:	4648      	mov	r0, r9
  40c542:	f7ff fe85 	bl	40c250 <malloc>
  40c546:	4607      	mov	r7, r0
  40c548:	2800      	cmp	r0, #0
  40c54a:	d0bc      	beq.n	40c4c6 <setvbuf+0xa6>
  40c54c:	89a3      	ldrh	r3, [r4, #12]
  40c54e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40c552:	81a3      	strh	r3, [r4, #12]
  40c554:	464d      	mov	r5, r9
  40c556:	e7d3      	b.n	40c500 <setvbuf+0xe0>
  40c558:	2000      	movs	r0, #0
  40c55a:	e7b6      	b.n	40c4ca <setvbuf+0xaa>
  40c55c:	46a9      	mov	r9, r5
  40c55e:	e7f5      	b.n	40c54c <setvbuf+0x12c>
  40c560:	60a0      	str	r0, [r4, #8]
  40c562:	e7be      	b.n	40c4e2 <setvbuf+0xc2>
  40c564:	f04f 30ff 	mov.w	r0, #4294967295
  40c568:	e7bb      	b.n	40c4e2 <setvbuf+0xc2>
  40c56a:	bf00      	nop
  40c56c:	20000020 	.word	0x20000020
  40c570:	0040e5a0 	.word	0x0040e5a0
  40c574:	0040e5c0 	.word	0x0040e5c0
  40c578:	0040e580 	.word	0x0040e580

0040c57c <_raise_r>:
  40c57c:	291f      	cmp	r1, #31
  40c57e:	b538      	push	{r3, r4, r5, lr}
  40c580:	4604      	mov	r4, r0
  40c582:	460d      	mov	r5, r1
  40c584:	d904      	bls.n	40c590 <_raise_r+0x14>
  40c586:	2316      	movs	r3, #22
  40c588:	6003      	str	r3, [r0, #0]
  40c58a:	f04f 30ff 	mov.w	r0, #4294967295
  40c58e:	bd38      	pop	{r3, r4, r5, pc}
  40c590:	6c42      	ldr	r2, [r0, #68]	; 0x44
  40c592:	b112      	cbz	r2, 40c59a <_raise_r+0x1e>
  40c594:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
  40c598:	b94b      	cbnz	r3, 40c5ae <_raise_r+0x32>
  40c59a:	4620      	mov	r0, r4
  40c59c:	f000 f830 	bl	40c600 <_getpid_r>
  40c5a0:	462a      	mov	r2, r5
  40c5a2:	4601      	mov	r1, r0
  40c5a4:	4620      	mov	r0, r4
  40c5a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40c5aa:	f000 b817 	b.w	40c5dc <_kill_r>
  40c5ae:	2b01      	cmp	r3, #1
  40c5b0:	d00a      	beq.n	40c5c8 <_raise_r+0x4c>
  40c5b2:	1c59      	adds	r1, r3, #1
  40c5b4:	d103      	bne.n	40c5be <_raise_r+0x42>
  40c5b6:	2316      	movs	r3, #22
  40c5b8:	6003      	str	r3, [r0, #0]
  40c5ba:	2001      	movs	r0, #1
  40c5bc:	bd38      	pop	{r3, r4, r5, pc}
  40c5be:	2400      	movs	r4, #0
  40c5c0:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
  40c5c4:	4628      	mov	r0, r5
  40c5c6:	4798      	blx	r3
  40c5c8:	2000      	movs	r0, #0
  40c5ca:	bd38      	pop	{r3, r4, r5, pc}

0040c5cc <raise>:
  40c5cc:	4b02      	ldr	r3, [pc, #8]	; (40c5d8 <raise+0xc>)
  40c5ce:	4601      	mov	r1, r0
  40c5d0:	6818      	ldr	r0, [r3, #0]
  40c5d2:	f7ff bfd3 	b.w	40c57c <_raise_r>
  40c5d6:	bf00      	nop
  40c5d8:	20000020 	.word	0x20000020

0040c5dc <_kill_r>:
  40c5dc:	b538      	push	{r3, r4, r5, lr}
  40c5de:	4c07      	ldr	r4, [pc, #28]	; (40c5fc <_kill_r+0x20>)
  40c5e0:	2300      	movs	r3, #0
  40c5e2:	4605      	mov	r5, r0
  40c5e4:	4608      	mov	r0, r1
  40c5e6:	4611      	mov	r1, r2
  40c5e8:	6023      	str	r3, [r4, #0]
  40c5ea:	f7fe fe5f 	bl	40b2ac <_kill>
  40c5ee:	1c43      	adds	r3, r0, #1
  40c5f0:	d102      	bne.n	40c5f8 <_kill_r+0x1c>
  40c5f2:	6823      	ldr	r3, [r4, #0]
  40c5f4:	b103      	cbz	r3, 40c5f8 <_kill_r+0x1c>
  40c5f6:	602b      	str	r3, [r5, #0]
  40c5f8:	bd38      	pop	{r3, r4, r5, pc}
  40c5fa:	bf00      	nop
  40c5fc:	20011804 	.word	0x20011804

0040c600 <_getpid_r>:
  40c600:	f7fe be55 	b.w	40b2ae <_getpid>

0040c604 <sniprintf>:
  40c604:	b40c      	push	{r2, r3}
  40c606:	b530      	push	{r4, r5, lr}
  40c608:	4b17      	ldr	r3, [pc, #92]	; (40c668 <sniprintf+0x64>)
  40c60a:	1e0c      	subs	r4, r1, #0
  40c60c:	b09d      	sub	sp, #116	; 0x74
  40c60e:	681d      	ldr	r5, [r3, #0]
  40c610:	da08      	bge.n	40c624 <sniprintf+0x20>
  40c612:	238b      	movs	r3, #139	; 0x8b
  40c614:	602b      	str	r3, [r5, #0]
  40c616:	f04f 30ff 	mov.w	r0, #4294967295
  40c61a:	b01d      	add	sp, #116	; 0x74
  40c61c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  40c620:	b002      	add	sp, #8
  40c622:	4770      	bx	lr
  40c624:	f44f 7302 	mov.w	r3, #520	; 0x208
  40c628:	f8ad 3014 	strh.w	r3, [sp, #20]
  40c62c:	bf14      	ite	ne
  40c62e:	f104 33ff 	addne.w	r3, r4, #4294967295
  40c632:	4623      	moveq	r3, r4
  40c634:	9304      	str	r3, [sp, #16]
  40c636:	9307      	str	r3, [sp, #28]
  40c638:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40c63c:	9002      	str	r0, [sp, #8]
  40c63e:	9006      	str	r0, [sp, #24]
  40c640:	f8ad 3016 	strh.w	r3, [sp, #22]
  40c644:	9a20      	ldr	r2, [sp, #128]	; 0x80
  40c646:	ab21      	add	r3, sp, #132	; 0x84
  40c648:	a902      	add	r1, sp, #8
  40c64a:	4628      	mov	r0, r5
  40c64c:	9301      	str	r3, [sp, #4]
  40c64e:	f000 faeb 	bl	40cc28 <_svfiprintf_r>
  40c652:	1c43      	adds	r3, r0, #1
  40c654:	bfbc      	itt	lt
  40c656:	238b      	movlt	r3, #139	; 0x8b
  40c658:	602b      	strlt	r3, [r5, #0]
  40c65a:	2c00      	cmp	r4, #0
  40c65c:	d0dd      	beq.n	40c61a <sniprintf+0x16>
  40c65e:	9b02      	ldr	r3, [sp, #8]
  40c660:	2200      	movs	r2, #0
  40c662:	701a      	strb	r2, [r3, #0]
  40c664:	e7d9      	b.n	40c61a <sniprintf+0x16>
  40c666:	bf00      	nop
  40c668:	20000020 	.word	0x20000020

0040c66c <siscanf>:
  40c66c:	b40e      	push	{r1, r2, r3}
  40c66e:	b530      	push	{r4, r5, lr}
  40c670:	b09c      	sub	sp, #112	; 0x70
  40c672:	ac1f      	add	r4, sp, #124	; 0x7c
  40c674:	f44f 7201 	mov.w	r2, #516	; 0x204
  40c678:	f854 5b04 	ldr.w	r5, [r4], #4
  40c67c:	f8ad 2014 	strh.w	r2, [sp, #20]
  40c680:	9002      	str	r0, [sp, #8]
  40c682:	9006      	str	r0, [sp, #24]
  40c684:	f000 f881 	bl	40c78a <strlen>
  40c688:	4b0b      	ldr	r3, [pc, #44]	; (40c6b8 <siscanf+0x4c>)
  40c68a:	9003      	str	r0, [sp, #12]
  40c68c:	9007      	str	r0, [sp, #28]
  40c68e:	930b      	str	r3, [sp, #44]	; 0x2c
  40c690:	480a      	ldr	r0, [pc, #40]	; (40c6bc <siscanf+0x50>)
  40c692:	9401      	str	r4, [sp, #4]
  40c694:	2300      	movs	r3, #0
  40c696:	930f      	str	r3, [sp, #60]	; 0x3c
  40c698:	9314      	str	r3, [sp, #80]	; 0x50
  40c69a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40c69e:	f8ad 3016 	strh.w	r3, [sp, #22]
  40c6a2:	462a      	mov	r2, r5
  40c6a4:	4623      	mov	r3, r4
  40c6a6:	a902      	add	r1, sp, #8
  40c6a8:	6800      	ldr	r0, [r0, #0]
  40c6aa:	f000 fc0b 	bl	40cec4 <__ssvfiscanf_r>
  40c6ae:	b01c      	add	sp, #112	; 0x70
  40c6b0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  40c6b4:	b003      	add	sp, #12
  40c6b6:	4770      	bx	lr
  40c6b8:	0040c6e3 	.word	0x0040c6e3
  40c6bc:	20000020 	.word	0x20000020

0040c6c0 <__sread>:
  40c6c0:	b510      	push	{r4, lr}
  40c6c2:	460c      	mov	r4, r1
  40c6c4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40c6c8:	f001 f83e 	bl	40d748 <_read_r>
  40c6cc:	2800      	cmp	r0, #0
  40c6ce:	bfab      	itete	ge
  40c6d0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
  40c6d2:	89a3      	ldrhlt	r3, [r4, #12]
  40c6d4:	181b      	addge	r3, r3, r0
  40c6d6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
  40c6da:	bfac      	ite	ge
  40c6dc:	6563      	strge	r3, [r4, #84]	; 0x54
  40c6de:	81a3      	strhlt	r3, [r4, #12]
  40c6e0:	bd10      	pop	{r4, pc}

0040c6e2 <__seofread>:
  40c6e2:	2000      	movs	r0, #0
  40c6e4:	4770      	bx	lr

0040c6e6 <__swrite>:
  40c6e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40c6ea:	461f      	mov	r7, r3
  40c6ec:	898b      	ldrh	r3, [r1, #12]
  40c6ee:	05db      	lsls	r3, r3, #23
  40c6f0:	4605      	mov	r5, r0
  40c6f2:	460c      	mov	r4, r1
  40c6f4:	4616      	mov	r6, r2
  40c6f6:	d505      	bpl.n	40c704 <__swrite+0x1e>
  40c6f8:	2302      	movs	r3, #2
  40c6fa:	2200      	movs	r2, #0
  40c6fc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40c700:	f000 f9fe 	bl	40cb00 <_lseek_r>
  40c704:	89a3      	ldrh	r3, [r4, #12]
  40c706:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40c70a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  40c70e:	81a3      	strh	r3, [r4, #12]
  40c710:	4632      	mov	r2, r6
  40c712:	463b      	mov	r3, r7
  40c714:	4628      	mov	r0, r5
  40c716:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40c71a:	f000 b853 	b.w	40c7c4 <_write_r>

0040c71e <__sseek>:
  40c71e:	b510      	push	{r4, lr}
  40c720:	460c      	mov	r4, r1
  40c722:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40c726:	f000 f9eb 	bl	40cb00 <_lseek_r>
  40c72a:	1c43      	adds	r3, r0, #1
  40c72c:	89a3      	ldrh	r3, [r4, #12]
  40c72e:	bf15      	itete	ne
  40c730:	6560      	strne	r0, [r4, #84]	; 0x54
  40c732:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  40c736:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  40c73a:	81a3      	strheq	r3, [r4, #12]
  40c73c:	bf18      	it	ne
  40c73e:	81a3      	strhne	r3, [r4, #12]
  40c740:	bd10      	pop	{r4, pc}

0040c742 <__sclose>:
  40c742:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40c746:	f000 b84f 	b.w	40c7e8 <_close_r>

0040c74a <strchr>:
  40c74a:	b2c9      	uxtb	r1, r1
  40c74c:	4603      	mov	r3, r0
  40c74e:	f810 2b01 	ldrb.w	r2, [r0], #1
  40c752:	b11a      	cbz	r2, 40c75c <strchr+0x12>
  40c754:	4291      	cmp	r1, r2
  40c756:	d1f9      	bne.n	40c74c <strchr+0x2>
  40c758:	4618      	mov	r0, r3
  40c75a:	4770      	bx	lr
  40c75c:	2900      	cmp	r1, #0
  40c75e:	bf0c      	ite	eq
  40c760:	4618      	moveq	r0, r3
  40c762:	2000      	movne	r0, #0
  40c764:	4770      	bx	lr

0040c766 <strcmp>:
  40c766:	f810 2b01 	ldrb.w	r2, [r0], #1
  40c76a:	f811 3b01 	ldrb.w	r3, [r1], #1
  40c76e:	2a01      	cmp	r2, #1
  40c770:	bf28      	it	cs
  40c772:	429a      	cmpcs	r2, r3
  40c774:	d0f7      	beq.n	40c766 <strcmp>
  40c776:	1ad0      	subs	r0, r2, r3
  40c778:	4770      	bx	lr

0040c77a <strcpy>:
  40c77a:	4603      	mov	r3, r0
  40c77c:	f811 2b01 	ldrb.w	r2, [r1], #1
  40c780:	f803 2b01 	strb.w	r2, [r3], #1
  40c784:	2a00      	cmp	r2, #0
  40c786:	d1f9      	bne.n	40c77c <strcpy+0x2>
  40c788:	4770      	bx	lr

0040c78a <strlen>:
  40c78a:	4603      	mov	r3, r0
  40c78c:	f813 2b01 	ldrb.w	r2, [r3], #1
  40c790:	2a00      	cmp	r2, #0
  40c792:	d1fb      	bne.n	40c78c <strlen+0x2>
  40c794:	1a18      	subs	r0, r3, r0
  40c796:	3801      	subs	r0, #1
  40c798:	4770      	bx	lr

0040c79a <strncpy>:
  40c79a:	b570      	push	{r4, r5, r6, lr}
  40c79c:	4604      	mov	r4, r0
  40c79e:	b902      	cbnz	r2, 40c7a2 <strncpy+0x8>
  40c7a0:	bd70      	pop	{r4, r5, r6, pc}
  40c7a2:	4623      	mov	r3, r4
  40c7a4:	f811 5b01 	ldrb.w	r5, [r1], #1
  40c7a8:	f803 5b01 	strb.w	r5, [r3], #1
  40c7ac:	1e56      	subs	r6, r2, #1
  40c7ae:	b91d      	cbnz	r5, 40c7b8 <strncpy+0x1e>
  40c7b0:	4414      	add	r4, r2
  40c7b2:	42a3      	cmp	r3, r4
  40c7b4:	d103      	bne.n	40c7be <strncpy+0x24>
  40c7b6:	bd70      	pop	{r4, r5, r6, pc}
  40c7b8:	461c      	mov	r4, r3
  40c7ba:	4632      	mov	r2, r6
  40c7bc:	e7ef      	b.n	40c79e <strncpy+0x4>
  40c7be:	f803 5b01 	strb.w	r5, [r3], #1
  40c7c2:	e7f6      	b.n	40c7b2 <strncpy+0x18>

0040c7c4 <_write_r>:
  40c7c4:	b538      	push	{r3, r4, r5, lr}
  40c7c6:	4c07      	ldr	r4, [pc, #28]	; (40c7e4 <_write_r+0x20>)
  40c7c8:	4605      	mov	r5, r0
  40c7ca:	4608      	mov	r0, r1
  40c7cc:	4611      	mov	r1, r2
  40c7ce:	2200      	movs	r2, #0
  40c7d0:	6022      	str	r2, [r4, #0]
  40c7d2:	461a      	mov	r2, r3
  40c7d4:	f7fe f878 	bl	40a8c8 <_write>
  40c7d8:	1c43      	adds	r3, r0, #1
  40c7da:	d102      	bne.n	40c7e2 <_write_r+0x1e>
  40c7dc:	6823      	ldr	r3, [r4, #0]
  40c7de:	b103      	cbz	r3, 40c7e2 <_write_r+0x1e>
  40c7e0:	602b      	str	r3, [r5, #0]
  40c7e2:	bd38      	pop	{r3, r4, r5, pc}
  40c7e4:	20011804 	.word	0x20011804

0040c7e8 <_close_r>:
  40c7e8:	b538      	push	{r3, r4, r5, lr}
  40c7ea:	4c06      	ldr	r4, [pc, #24]	; (40c804 <_close_r+0x1c>)
  40c7ec:	2300      	movs	r3, #0
  40c7ee:	4605      	mov	r5, r0
  40c7f0:	4608      	mov	r0, r1
  40c7f2:	6023      	str	r3, [r4, #0]
  40c7f4:	f7fe fd4e 	bl	40b294 <_close>
  40c7f8:	1c43      	adds	r3, r0, #1
  40c7fa:	d102      	bne.n	40c802 <_close_r+0x1a>
  40c7fc:	6823      	ldr	r3, [r4, #0]
  40c7fe:	b103      	cbz	r3, 40c802 <_close_r+0x1a>
  40c800:	602b      	str	r3, [r5, #0]
  40c802:	bd38      	pop	{r3, r4, r5, pc}
  40c804:	20011804 	.word	0x20011804

0040c808 <__sflush_r>:
  40c808:	898a      	ldrh	r2, [r1, #12]
  40c80a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40c80e:	4605      	mov	r5, r0
  40c810:	0710      	lsls	r0, r2, #28
  40c812:	460c      	mov	r4, r1
  40c814:	d45a      	bmi.n	40c8cc <__sflush_r+0xc4>
  40c816:	684b      	ldr	r3, [r1, #4]
  40c818:	2b00      	cmp	r3, #0
  40c81a:	dc05      	bgt.n	40c828 <__sflush_r+0x20>
  40c81c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  40c81e:	2b00      	cmp	r3, #0
  40c820:	dc02      	bgt.n	40c828 <__sflush_r+0x20>
  40c822:	2000      	movs	r0, #0
  40c824:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c828:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  40c82a:	2e00      	cmp	r6, #0
  40c82c:	d0f9      	beq.n	40c822 <__sflush_r+0x1a>
  40c82e:	2300      	movs	r3, #0
  40c830:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
  40c834:	682f      	ldr	r7, [r5, #0]
  40c836:	602b      	str	r3, [r5, #0]
  40c838:	d033      	beq.n	40c8a2 <__sflush_r+0x9a>
  40c83a:	6d60      	ldr	r0, [r4, #84]	; 0x54
  40c83c:	89a3      	ldrh	r3, [r4, #12]
  40c83e:	075a      	lsls	r2, r3, #29
  40c840:	d505      	bpl.n	40c84e <__sflush_r+0x46>
  40c842:	6863      	ldr	r3, [r4, #4]
  40c844:	1ac0      	subs	r0, r0, r3
  40c846:	6b63      	ldr	r3, [r4, #52]	; 0x34
  40c848:	b10b      	cbz	r3, 40c84e <__sflush_r+0x46>
  40c84a:	6c23      	ldr	r3, [r4, #64]	; 0x40
  40c84c:	1ac0      	subs	r0, r0, r3
  40c84e:	2300      	movs	r3, #0
  40c850:	4602      	mov	r2, r0
  40c852:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  40c854:	6a21      	ldr	r1, [r4, #32]
  40c856:	4628      	mov	r0, r5
  40c858:	47b0      	blx	r6
  40c85a:	1c43      	adds	r3, r0, #1
  40c85c:	89a3      	ldrh	r3, [r4, #12]
  40c85e:	d106      	bne.n	40c86e <__sflush_r+0x66>
  40c860:	6829      	ldr	r1, [r5, #0]
  40c862:	291d      	cmp	r1, #29
  40c864:	d84b      	bhi.n	40c8fe <__sflush_r+0xf6>
  40c866:	4a2b      	ldr	r2, [pc, #172]	; (40c914 <__sflush_r+0x10c>)
  40c868:	40ca      	lsrs	r2, r1
  40c86a:	07d6      	lsls	r6, r2, #31
  40c86c:	d547      	bpl.n	40c8fe <__sflush_r+0xf6>
  40c86e:	2200      	movs	r2, #0
  40c870:	6062      	str	r2, [r4, #4]
  40c872:	04d9      	lsls	r1, r3, #19
  40c874:	6922      	ldr	r2, [r4, #16]
  40c876:	6022      	str	r2, [r4, #0]
  40c878:	d504      	bpl.n	40c884 <__sflush_r+0x7c>
  40c87a:	1c42      	adds	r2, r0, #1
  40c87c:	d101      	bne.n	40c882 <__sflush_r+0x7a>
  40c87e:	682b      	ldr	r3, [r5, #0]
  40c880:	b903      	cbnz	r3, 40c884 <__sflush_r+0x7c>
  40c882:	6560      	str	r0, [r4, #84]	; 0x54
  40c884:	6b61      	ldr	r1, [r4, #52]	; 0x34
  40c886:	602f      	str	r7, [r5, #0]
  40c888:	2900      	cmp	r1, #0
  40c88a:	d0ca      	beq.n	40c822 <__sflush_r+0x1a>
  40c88c:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40c890:	4299      	cmp	r1, r3
  40c892:	d002      	beq.n	40c89a <__sflush_r+0x92>
  40c894:	4628      	mov	r0, r5
  40c896:	f7ff fcff 	bl	40c298 <_free_r>
  40c89a:	2000      	movs	r0, #0
  40c89c:	6360      	str	r0, [r4, #52]	; 0x34
  40c89e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c8a2:	6a21      	ldr	r1, [r4, #32]
  40c8a4:	2301      	movs	r3, #1
  40c8a6:	4628      	mov	r0, r5
  40c8a8:	47b0      	blx	r6
  40c8aa:	1c41      	adds	r1, r0, #1
  40c8ac:	d1c6      	bne.n	40c83c <__sflush_r+0x34>
  40c8ae:	682b      	ldr	r3, [r5, #0]
  40c8b0:	2b00      	cmp	r3, #0
  40c8b2:	d0c3      	beq.n	40c83c <__sflush_r+0x34>
  40c8b4:	2b1d      	cmp	r3, #29
  40c8b6:	d001      	beq.n	40c8bc <__sflush_r+0xb4>
  40c8b8:	2b16      	cmp	r3, #22
  40c8ba:	d101      	bne.n	40c8c0 <__sflush_r+0xb8>
  40c8bc:	602f      	str	r7, [r5, #0]
  40c8be:	e7b0      	b.n	40c822 <__sflush_r+0x1a>
  40c8c0:	89a3      	ldrh	r3, [r4, #12]
  40c8c2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40c8c6:	81a3      	strh	r3, [r4, #12]
  40c8c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c8cc:	690f      	ldr	r7, [r1, #16]
  40c8ce:	2f00      	cmp	r7, #0
  40c8d0:	d0a7      	beq.n	40c822 <__sflush_r+0x1a>
  40c8d2:	0793      	lsls	r3, r2, #30
  40c8d4:	680e      	ldr	r6, [r1, #0]
  40c8d6:	bf08      	it	eq
  40c8d8:	694b      	ldreq	r3, [r1, #20]
  40c8da:	600f      	str	r7, [r1, #0]
  40c8dc:	bf18      	it	ne
  40c8de:	2300      	movne	r3, #0
  40c8e0:	eba6 0807 	sub.w	r8, r6, r7
  40c8e4:	608b      	str	r3, [r1, #8]
  40c8e6:	f1b8 0f00 	cmp.w	r8, #0
  40c8ea:	dd9a      	ble.n	40c822 <__sflush_r+0x1a>
  40c8ec:	4643      	mov	r3, r8
  40c8ee:	463a      	mov	r2, r7
  40c8f0:	6a21      	ldr	r1, [r4, #32]
  40c8f2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  40c8f4:	4628      	mov	r0, r5
  40c8f6:	47b0      	blx	r6
  40c8f8:	2800      	cmp	r0, #0
  40c8fa:	dc07      	bgt.n	40c90c <__sflush_r+0x104>
  40c8fc:	89a3      	ldrh	r3, [r4, #12]
  40c8fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40c902:	81a3      	strh	r3, [r4, #12]
  40c904:	f04f 30ff 	mov.w	r0, #4294967295
  40c908:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c90c:	4407      	add	r7, r0
  40c90e:	eba8 0800 	sub.w	r8, r8, r0
  40c912:	e7e8      	b.n	40c8e6 <__sflush_r+0xde>
  40c914:	20400001 	.word	0x20400001

0040c918 <_fflush_r>:
  40c918:	b538      	push	{r3, r4, r5, lr}
  40c91a:	690b      	ldr	r3, [r1, #16]
  40c91c:	4605      	mov	r5, r0
  40c91e:	460c      	mov	r4, r1
  40c920:	b1db      	cbz	r3, 40c95a <_fflush_r+0x42>
  40c922:	b118      	cbz	r0, 40c92c <_fflush_r+0x14>
  40c924:	6983      	ldr	r3, [r0, #24]
  40c926:	b90b      	cbnz	r3, 40c92c <_fflush_r+0x14>
  40c928:	f000 f860 	bl	40c9ec <__sinit>
  40c92c:	4b0c      	ldr	r3, [pc, #48]	; (40c960 <_fflush_r+0x48>)
  40c92e:	429c      	cmp	r4, r3
  40c930:	d109      	bne.n	40c946 <_fflush_r+0x2e>
  40c932:	686c      	ldr	r4, [r5, #4]
  40c934:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40c938:	b17b      	cbz	r3, 40c95a <_fflush_r+0x42>
  40c93a:	4621      	mov	r1, r4
  40c93c:	4628      	mov	r0, r5
  40c93e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40c942:	f7ff bf61 	b.w	40c808 <__sflush_r>
  40c946:	4b07      	ldr	r3, [pc, #28]	; (40c964 <_fflush_r+0x4c>)
  40c948:	429c      	cmp	r4, r3
  40c94a:	d101      	bne.n	40c950 <_fflush_r+0x38>
  40c94c:	68ac      	ldr	r4, [r5, #8]
  40c94e:	e7f1      	b.n	40c934 <_fflush_r+0x1c>
  40c950:	4b05      	ldr	r3, [pc, #20]	; (40c968 <_fflush_r+0x50>)
  40c952:	429c      	cmp	r4, r3
  40c954:	bf08      	it	eq
  40c956:	68ec      	ldreq	r4, [r5, #12]
  40c958:	e7ec      	b.n	40c934 <_fflush_r+0x1c>
  40c95a:	2000      	movs	r0, #0
  40c95c:	bd38      	pop	{r3, r4, r5, pc}
  40c95e:	bf00      	nop
  40c960:	0040e5a0 	.word	0x0040e5a0
  40c964:	0040e5c0 	.word	0x0040e5c0
  40c968:	0040e580 	.word	0x0040e580

0040c96c <_cleanup_r>:
  40c96c:	4901      	ldr	r1, [pc, #4]	; (40c974 <_cleanup_r+0x8>)
  40c96e:	f000 b8a9 	b.w	40cac4 <_fwalk_reent>
  40c972:	bf00      	nop
  40c974:	0040c919 	.word	0x0040c919

0040c978 <std.isra.0>:
  40c978:	2300      	movs	r3, #0
  40c97a:	b510      	push	{r4, lr}
  40c97c:	4604      	mov	r4, r0
  40c97e:	6003      	str	r3, [r0, #0]
  40c980:	6043      	str	r3, [r0, #4]
  40c982:	6083      	str	r3, [r0, #8]
  40c984:	8181      	strh	r1, [r0, #12]
  40c986:	6643      	str	r3, [r0, #100]	; 0x64
  40c988:	81c2      	strh	r2, [r0, #14]
  40c98a:	6103      	str	r3, [r0, #16]
  40c98c:	6143      	str	r3, [r0, #20]
  40c98e:	6183      	str	r3, [r0, #24]
  40c990:	4619      	mov	r1, r3
  40c992:	2208      	movs	r2, #8
  40c994:	305c      	adds	r0, #92	; 0x5c
  40c996:	f7ff fc76 	bl	40c286 <memset>
  40c99a:	4b05      	ldr	r3, [pc, #20]	; (40c9b0 <std.isra.0+0x38>)
  40c99c:	6263      	str	r3, [r4, #36]	; 0x24
  40c99e:	4b05      	ldr	r3, [pc, #20]	; (40c9b4 <std.isra.0+0x3c>)
  40c9a0:	62a3      	str	r3, [r4, #40]	; 0x28
  40c9a2:	4b05      	ldr	r3, [pc, #20]	; (40c9b8 <std.isra.0+0x40>)
  40c9a4:	62e3      	str	r3, [r4, #44]	; 0x2c
  40c9a6:	4b05      	ldr	r3, [pc, #20]	; (40c9bc <std.isra.0+0x44>)
  40c9a8:	6224      	str	r4, [r4, #32]
  40c9aa:	6323      	str	r3, [r4, #48]	; 0x30
  40c9ac:	bd10      	pop	{r4, pc}
  40c9ae:	bf00      	nop
  40c9b0:	0040c6c1 	.word	0x0040c6c1
  40c9b4:	0040c6e7 	.word	0x0040c6e7
  40c9b8:	0040c71f 	.word	0x0040c71f
  40c9bc:	0040c743 	.word	0x0040c743

0040c9c0 <__sfmoreglue>:
  40c9c0:	b570      	push	{r4, r5, r6, lr}
  40c9c2:	1e4a      	subs	r2, r1, #1
  40c9c4:	2568      	movs	r5, #104	; 0x68
  40c9c6:	4355      	muls	r5, r2
  40c9c8:	460e      	mov	r6, r1
  40c9ca:	f105 0174 	add.w	r1, r5, #116	; 0x74
  40c9ce:	f7ff fcb1 	bl	40c334 <_malloc_r>
  40c9d2:	4604      	mov	r4, r0
  40c9d4:	b140      	cbz	r0, 40c9e8 <__sfmoreglue+0x28>
  40c9d6:	2100      	movs	r1, #0
  40c9d8:	e880 0042 	stmia.w	r0, {r1, r6}
  40c9dc:	300c      	adds	r0, #12
  40c9de:	60a0      	str	r0, [r4, #8]
  40c9e0:	f105 0268 	add.w	r2, r5, #104	; 0x68
  40c9e4:	f7ff fc4f 	bl	40c286 <memset>
  40c9e8:	4620      	mov	r0, r4
  40c9ea:	bd70      	pop	{r4, r5, r6, pc}

0040c9ec <__sinit>:
  40c9ec:	6983      	ldr	r3, [r0, #24]
  40c9ee:	b510      	push	{r4, lr}
  40c9f0:	4604      	mov	r4, r0
  40c9f2:	bb33      	cbnz	r3, 40ca42 <__sinit+0x56>
  40c9f4:	6483      	str	r3, [r0, #72]	; 0x48
  40c9f6:	64c3      	str	r3, [r0, #76]	; 0x4c
  40c9f8:	6503      	str	r3, [r0, #80]	; 0x50
  40c9fa:	4b12      	ldr	r3, [pc, #72]	; (40ca44 <__sinit+0x58>)
  40c9fc:	4a12      	ldr	r2, [pc, #72]	; (40ca48 <__sinit+0x5c>)
  40c9fe:	681b      	ldr	r3, [r3, #0]
  40ca00:	6282      	str	r2, [r0, #40]	; 0x28
  40ca02:	4298      	cmp	r0, r3
  40ca04:	bf04      	itt	eq
  40ca06:	2301      	moveq	r3, #1
  40ca08:	6183      	streq	r3, [r0, #24]
  40ca0a:	f000 f81f 	bl	40ca4c <__sfp>
  40ca0e:	6060      	str	r0, [r4, #4]
  40ca10:	4620      	mov	r0, r4
  40ca12:	f000 f81b 	bl	40ca4c <__sfp>
  40ca16:	60a0      	str	r0, [r4, #8]
  40ca18:	4620      	mov	r0, r4
  40ca1a:	f000 f817 	bl	40ca4c <__sfp>
  40ca1e:	2200      	movs	r2, #0
  40ca20:	60e0      	str	r0, [r4, #12]
  40ca22:	2104      	movs	r1, #4
  40ca24:	6860      	ldr	r0, [r4, #4]
  40ca26:	f7ff ffa7 	bl	40c978 <std.isra.0>
  40ca2a:	2201      	movs	r2, #1
  40ca2c:	2109      	movs	r1, #9
  40ca2e:	68a0      	ldr	r0, [r4, #8]
  40ca30:	f7ff ffa2 	bl	40c978 <std.isra.0>
  40ca34:	2202      	movs	r2, #2
  40ca36:	2112      	movs	r1, #18
  40ca38:	68e0      	ldr	r0, [r4, #12]
  40ca3a:	f7ff ff9d 	bl	40c978 <std.isra.0>
  40ca3e:	2301      	movs	r3, #1
  40ca40:	61a3      	str	r3, [r4, #24]
  40ca42:	bd10      	pop	{r4, pc}
  40ca44:	0040e57c 	.word	0x0040e57c
  40ca48:	0040c96d 	.word	0x0040c96d

0040ca4c <__sfp>:
  40ca4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40ca4e:	4b1c      	ldr	r3, [pc, #112]	; (40cac0 <__sfp+0x74>)
  40ca50:	681e      	ldr	r6, [r3, #0]
  40ca52:	69b3      	ldr	r3, [r6, #24]
  40ca54:	4607      	mov	r7, r0
  40ca56:	b913      	cbnz	r3, 40ca5e <__sfp+0x12>
  40ca58:	4630      	mov	r0, r6
  40ca5a:	f7ff ffc7 	bl	40c9ec <__sinit>
  40ca5e:	3648      	adds	r6, #72	; 0x48
  40ca60:	68b4      	ldr	r4, [r6, #8]
  40ca62:	6873      	ldr	r3, [r6, #4]
  40ca64:	3b01      	subs	r3, #1
  40ca66:	d503      	bpl.n	40ca70 <__sfp+0x24>
  40ca68:	6833      	ldr	r3, [r6, #0]
  40ca6a:	b133      	cbz	r3, 40ca7a <__sfp+0x2e>
  40ca6c:	6836      	ldr	r6, [r6, #0]
  40ca6e:	e7f7      	b.n	40ca60 <__sfp+0x14>
  40ca70:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  40ca74:	b16d      	cbz	r5, 40ca92 <__sfp+0x46>
  40ca76:	3468      	adds	r4, #104	; 0x68
  40ca78:	e7f4      	b.n	40ca64 <__sfp+0x18>
  40ca7a:	2104      	movs	r1, #4
  40ca7c:	4638      	mov	r0, r7
  40ca7e:	f7ff ff9f 	bl	40c9c0 <__sfmoreglue>
  40ca82:	6030      	str	r0, [r6, #0]
  40ca84:	2800      	cmp	r0, #0
  40ca86:	d1f1      	bne.n	40ca6c <__sfp+0x20>
  40ca88:	230c      	movs	r3, #12
  40ca8a:	603b      	str	r3, [r7, #0]
  40ca8c:	4604      	mov	r4, r0
  40ca8e:	4620      	mov	r0, r4
  40ca90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40ca92:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40ca96:	81e3      	strh	r3, [r4, #14]
  40ca98:	2301      	movs	r3, #1
  40ca9a:	81a3      	strh	r3, [r4, #12]
  40ca9c:	6665      	str	r5, [r4, #100]	; 0x64
  40ca9e:	6025      	str	r5, [r4, #0]
  40caa0:	60a5      	str	r5, [r4, #8]
  40caa2:	6065      	str	r5, [r4, #4]
  40caa4:	6125      	str	r5, [r4, #16]
  40caa6:	6165      	str	r5, [r4, #20]
  40caa8:	61a5      	str	r5, [r4, #24]
  40caaa:	2208      	movs	r2, #8
  40caac:	4629      	mov	r1, r5
  40caae:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  40cab2:	f7ff fbe8 	bl	40c286 <memset>
  40cab6:	6365      	str	r5, [r4, #52]	; 0x34
  40cab8:	63a5      	str	r5, [r4, #56]	; 0x38
  40caba:	64a5      	str	r5, [r4, #72]	; 0x48
  40cabc:	64e5      	str	r5, [r4, #76]	; 0x4c
  40cabe:	e7e6      	b.n	40ca8e <__sfp+0x42>
  40cac0:	0040e57c 	.word	0x0040e57c

0040cac4 <_fwalk_reent>:
  40cac4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40cac8:	4680      	mov	r8, r0
  40caca:	4689      	mov	r9, r1
  40cacc:	f100 0448 	add.w	r4, r0, #72	; 0x48
  40cad0:	2600      	movs	r6, #0
  40cad2:	b914      	cbnz	r4, 40cada <_fwalk_reent+0x16>
  40cad4:	4630      	mov	r0, r6
  40cad6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40cada:	68a5      	ldr	r5, [r4, #8]
  40cadc:	6867      	ldr	r7, [r4, #4]
  40cade:	3f01      	subs	r7, #1
  40cae0:	d501      	bpl.n	40cae6 <_fwalk_reent+0x22>
  40cae2:	6824      	ldr	r4, [r4, #0]
  40cae4:	e7f5      	b.n	40cad2 <_fwalk_reent+0xe>
  40cae6:	89ab      	ldrh	r3, [r5, #12]
  40cae8:	2b01      	cmp	r3, #1
  40caea:	d907      	bls.n	40cafc <_fwalk_reent+0x38>
  40caec:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
  40caf0:	3301      	adds	r3, #1
  40caf2:	d003      	beq.n	40cafc <_fwalk_reent+0x38>
  40caf4:	4629      	mov	r1, r5
  40caf6:	4640      	mov	r0, r8
  40caf8:	47c8      	blx	r9
  40cafa:	4306      	orrs	r6, r0
  40cafc:	3568      	adds	r5, #104	; 0x68
  40cafe:	e7ee      	b.n	40cade <_fwalk_reent+0x1a>

0040cb00 <_lseek_r>:
  40cb00:	b538      	push	{r3, r4, r5, lr}
  40cb02:	4c07      	ldr	r4, [pc, #28]	; (40cb20 <_lseek_r+0x20>)
  40cb04:	4605      	mov	r5, r0
  40cb06:	4608      	mov	r0, r1
  40cb08:	4611      	mov	r1, r2
  40cb0a:	2200      	movs	r2, #0
  40cb0c:	6022      	str	r2, [r4, #0]
  40cb0e:	461a      	mov	r2, r3
  40cb10:	f7fe fbc8 	bl	40b2a4 <_lseek>
  40cb14:	1c43      	adds	r3, r0, #1
  40cb16:	d102      	bne.n	40cb1e <_lseek_r+0x1e>
  40cb18:	6823      	ldr	r3, [r4, #0]
  40cb1a:	b103      	cbz	r3, 40cb1e <_lseek_r+0x1e>
  40cb1c:	602b      	str	r3, [r5, #0]
  40cb1e:	bd38      	pop	{r3, r4, r5, pc}
  40cb20:	20011804 	.word	0x20011804

0040cb24 <__swhatbuf_r>:
  40cb24:	b570      	push	{r4, r5, r6, lr}
  40cb26:	460e      	mov	r6, r1
  40cb28:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40cb2c:	2900      	cmp	r1, #0
  40cb2e:	b090      	sub	sp, #64	; 0x40
  40cb30:	4614      	mov	r4, r2
  40cb32:	461d      	mov	r5, r3
  40cb34:	da07      	bge.n	40cb46 <__swhatbuf_r+0x22>
  40cb36:	2300      	movs	r3, #0
  40cb38:	602b      	str	r3, [r5, #0]
  40cb3a:	89b3      	ldrh	r3, [r6, #12]
  40cb3c:	061a      	lsls	r2, r3, #24
  40cb3e:	d410      	bmi.n	40cb62 <__swhatbuf_r+0x3e>
  40cb40:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40cb44:	e00e      	b.n	40cb64 <__swhatbuf_r+0x40>
  40cb46:	aa01      	add	r2, sp, #4
  40cb48:	f000 ff9e 	bl	40da88 <_fstat_r>
  40cb4c:	2800      	cmp	r0, #0
  40cb4e:	dbf2      	blt.n	40cb36 <__swhatbuf_r+0x12>
  40cb50:	9a02      	ldr	r2, [sp, #8]
  40cb52:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  40cb56:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
  40cb5a:	425a      	negs	r2, r3
  40cb5c:	415a      	adcs	r2, r3
  40cb5e:	602a      	str	r2, [r5, #0]
  40cb60:	e7ee      	b.n	40cb40 <__swhatbuf_r+0x1c>
  40cb62:	2340      	movs	r3, #64	; 0x40
  40cb64:	2000      	movs	r0, #0
  40cb66:	6023      	str	r3, [r4, #0]
  40cb68:	b010      	add	sp, #64	; 0x40
  40cb6a:	bd70      	pop	{r4, r5, r6, pc}

0040cb6c <__malloc_lock>:
  40cb6c:	4770      	bx	lr

0040cb6e <__malloc_unlock>:
  40cb6e:	4770      	bx	lr

0040cb70 <__ssputs_r>:
  40cb70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40cb74:	688e      	ldr	r6, [r1, #8]
  40cb76:	429e      	cmp	r6, r3
  40cb78:	4682      	mov	sl, r0
  40cb7a:	460c      	mov	r4, r1
  40cb7c:	4691      	mov	r9, r2
  40cb7e:	4698      	mov	r8, r3
  40cb80:	d835      	bhi.n	40cbee <__ssputs_r+0x7e>
  40cb82:	898a      	ldrh	r2, [r1, #12]
  40cb84:	f412 6f90 	tst.w	r2, #1152	; 0x480
  40cb88:	d031      	beq.n	40cbee <__ssputs_r+0x7e>
  40cb8a:	6825      	ldr	r5, [r4, #0]
  40cb8c:	6909      	ldr	r1, [r1, #16]
  40cb8e:	1a6f      	subs	r7, r5, r1
  40cb90:	6965      	ldr	r5, [r4, #20]
  40cb92:	2302      	movs	r3, #2
  40cb94:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  40cb98:	fb95 f5f3 	sdiv	r5, r5, r3
  40cb9c:	f108 0301 	add.w	r3, r8, #1
  40cba0:	443b      	add	r3, r7
  40cba2:	429d      	cmp	r5, r3
  40cba4:	bf38      	it	cc
  40cba6:	461d      	movcc	r5, r3
  40cba8:	0553      	lsls	r3, r2, #21
  40cbaa:	d531      	bpl.n	40cc10 <__ssputs_r+0xa0>
  40cbac:	4629      	mov	r1, r5
  40cbae:	f7ff fbc1 	bl	40c334 <_malloc_r>
  40cbb2:	4606      	mov	r6, r0
  40cbb4:	b950      	cbnz	r0, 40cbcc <__ssputs_r+0x5c>
  40cbb6:	230c      	movs	r3, #12
  40cbb8:	f8ca 3000 	str.w	r3, [sl]
  40cbbc:	89a3      	ldrh	r3, [r4, #12]
  40cbbe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40cbc2:	81a3      	strh	r3, [r4, #12]
  40cbc4:	f04f 30ff 	mov.w	r0, #4294967295
  40cbc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40cbcc:	463a      	mov	r2, r7
  40cbce:	6921      	ldr	r1, [r4, #16]
  40cbd0:	f7ff fb4e 	bl	40c270 <memcpy>
  40cbd4:	89a3      	ldrh	r3, [r4, #12]
  40cbd6:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
  40cbda:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40cbde:	81a3      	strh	r3, [r4, #12]
  40cbe0:	6126      	str	r6, [r4, #16]
  40cbe2:	6165      	str	r5, [r4, #20]
  40cbe4:	443e      	add	r6, r7
  40cbe6:	1bed      	subs	r5, r5, r7
  40cbe8:	6026      	str	r6, [r4, #0]
  40cbea:	60a5      	str	r5, [r4, #8]
  40cbec:	4646      	mov	r6, r8
  40cbee:	4546      	cmp	r6, r8
  40cbf0:	bf28      	it	cs
  40cbf2:	4646      	movcs	r6, r8
  40cbf4:	4632      	mov	r2, r6
  40cbf6:	4649      	mov	r1, r9
  40cbf8:	6820      	ldr	r0, [r4, #0]
  40cbfa:	f000 ffd1 	bl	40dba0 <memmove>
  40cbfe:	68a3      	ldr	r3, [r4, #8]
  40cc00:	1b9b      	subs	r3, r3, r6
  40cc02:	60a3      	str	r3, [r4, #8]
  40cc04:	6823      	ldr	r3, [r4, #0]
  40cc06:	441e      	add	r6, r3
  40cc08:	6026      	str	r6, [r4, #0]
  40cc0a:	2000      	movs	r0, #0
  40cc0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40cc10:	462a      	mov	r2, r5
  40cc12:	f000 ffdf 	bl	40dbd4 <_realloc_r>
  40cc16:	4606      	mov	r6, r0
  40cc18:	2800      	cmp	r0, #0
  40cc1a:	d1e1      	bne.n	40cbe0 <__ssputs_r+0x70>
  40cc1c:	6921      	ldr	r1, [r4, #16]
  40cc1e:	4650      	mov	r0, sl
  40cc20:	f7ff fb3a 	bl	40c298 <_free_r>
  40cc24:	e7c7      	b.n	40cbb6 <__ssputs_r+0x46>
	...

0040cc28 <_svfiprintf_r>:
  40cc28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40cc2c:	b09d      	sub	sp, #116	; 0x74
  40cc2e:	4680      	mov	r8, r0
  40cc30:	9303      	str	r3, [sp, #12]
  40cc32:	898b      	ldrh	r3, [r1, #12]
  40cc34:	061c      	lsls	r4, r3, #24
  40cc36:	460d      	mov	r5, r1
  40cc38:	4616      	mov	r6, r2
  40cc3a:	d50f      	bpl.n	40cc5c <_svfiprintf_r+0x34>
  40cc3c:	690b      	ldr	r3, [r1, #16]
  40cc3e:	b96b      	cbnz	r3, 40cc5c <_svfiprintf_r+0x34>
  40cc40:	2140      	movs	r1, #64	; 0x40
  40cc42:	f7ff fb77 	bl	40c334 <_malloc_r>
  40cc46:	6028      	str	r0, [r5, #0]
  40cc48:	6128      	str	r0, [r5, #16]
  40cc4a:	b928      	cbnz	r0, 40cc58 <_svfiprintf_r+0x30>
  40cc4c:	230c      	movs	r3, #12
  40cc4e:	f8c8 3000 	str.w	r3, [r8]
  40cc52:	f04f 30ff 	mov.w	r0, #4294967295
  40cc56:	e0c5      	b.n	40cde4 <_svfiprintf_r+0x1bc>
  40cc58:	2340      	movs	r3, #64	; 0x40
  40cc5a:	616b      	str	r3, [r5, #20]
  40cc5c:	2300      	movs	r3, #0
  40cc5e:	9309      	str	r3, [sp, #36]	; 0x24
  40cc60:	2320      	movs	r3, #32
  40cc62:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  40cc66:	2330      	movs	r3, #48	; 0x30
  40cc68:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
  40cc6c:	f04f 0b01 	mov.w	fp, #1
  40cc70:	4637      	mov	r7, r6
  40cc72:	463c      	mov	r4, r7
  40cc74:	f814 3b01 	ldrb.w	r3, [r4], #1
  40cc78:	2b00      	cmp	r3, #0
  40cc7a:	d13c      	bne.n	40ccf6 <_svfiprintf_r+0xce>
  40cc7c:	ebb7 0a06 	subs.w	sl, r7, r6
  40cc80:	d00b      	beq.n	40cc9a <_svfiprintf_r+0x72>
  40cc82:	4653      	mov	r3, sl
  40cc84:	4632      	mov	r2, r6
  40cc86:	4629      	mov	r1, r5
  40cc88:	4640      	mov	r0, r8
  40cc8a:	f7ff ff71 	bl	40cb70 <__ssputs_r>
  40cc8e:	3001      	adds	r0, #1
  40cc90:	f000 80a3 	beq.w	40cdda <_svfiprintf_r+0x1b2>
  40cc94:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40cc96:	4453      	add	r3, sl
  40cc98:	9309      	str	r3, [sp, #36]	; 0x24
  40cc9a:	783b      	ldrb	r3, [r7, #0]
  40cc9c:	2b00      	cmp	r3, #0
  40cc9e:	f000 809c 	beq.w	40cdda <_svfiprintf_r+0x1b2>
  40cca2:	2300      	movs	r3, #0
  40cca4:	f04f 32ff 	mov.w	r2, #4294967295
  40cca8:	9304      	str	r3, [sp, #16]
  40ccaa:	9307      	str	r3, [sp, #28]
  40ccac:	9205      	str	r2, [sp, #20]
  40ccae:	9306      	str	r3, [sp, #24]
  40ccb0:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
  40ccb4:	931a      	str	r3, [sp, #104]	; 0x68
  40ccb6:	2205      	movs	r2, #5
  40ccb8:	7821      	ldrb	r1, [r4, #0]
  40ccba:	4850      	ldr	r0, [pc, #320]	; (40cdfc <_svfiprintf_r+0x1d4>)
  40ccbc:	f000 ff20 	bl	40db00 <memchr>
  40ccc0:	1c67      	adds	r7, r4, #1
  40ccc2:	9b04      	ldr	r3, [sp, #16]
  40ccc4:	b9d8      	cbnz	r0, 40ccfe <_svfiprintf_r+0xd6>
  40ccc6:	06d9      	lsls	r1, r3, #27
  40ccc8:	bf44      	itt	mi
  40ccca:	2220      	movmi	r2, #32
  40cccc:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  40ccd0:	071a      	lsls	r2, r3, #28
  40ccd2:	bf44      	itt	mi
  40ccd4:	222b      	movmi	r2, #43	; 0x2b
  40ccd6:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  40ccda:	7822      	ldrb	r2, [r4, #0]
  40ccdc:	2a2a      	cmp	r2, #42	; 0x2a
  40ccde:	d016      	beq.n	40cd0e <_svfiprintf_r+0xe6>
  40cce0:	9a07      	ldr	r2, [sp, #28]
  40cce2:	2100      	movs	r1, #0
  40cce4:	200a      	movs	r0, #10
  40cce6:	4627      	mov	r7, r4
  40cce8:	3401      	adds	r4, #1
  40ccea:	783b      	ldrb	r3, [r7, #0]
  40ccec:	3b30      	subs	r3, #48	; 0x30
  40ccee:	2b09      	cmp	r3, #9
  40ccf0:	d951      	bls.n	40cd96 <_svfiprintf_r+0x16e>
  40ccf2:	b1c9      	cbz	r1, 40cd28 <_svfiprintf_r+0x100>
  40ccf4:	e011      	b.n	40cd1a <_svfiprintf_r+0xf2>
  40ccf6:	2b25      	cmp	r3, #37	; 0x25
  40ccf8:	d0c0      	beq.n	40cc7c <_svfiprintf_r+0x54>
  40ccfa:	4627      	mov	r7, r4
  40ccfc:	e7b9      	b.n	40cc72 <_svfiprintf_r+0x4a>
  40ccfe:	4a3f      	ldr	r2, [pc, #252]	; (40cdfc <_svfiprintf_r+0x1d4>)
  40cd00:	1a80      	subs	r0, r0, r2
  40cd02:	fa0b f000 	lsl.w	r0, fp, r0
  40cd06:	4318      	orrs	r0, r3
  40cd08:	9004      	str	r0, [sp, #16]
  40cd0a:	463c      	mov	r4, r7
  40cd0c:	e7d3      	b.n	40ccb6 <_svfiprintf_r+0x8e>
  40cd0e:	9a03      	ldr	r2, [sp, #12]
  40cd10:	1d11      	adds	r1, r2, #4
  40cd12:	6812      	ldr	r2, [r2, #0]
  40cd14:	9103      	str	r1, [sp, #12]
  40cd16:	2a00      	cmp	r2, #0
  40cd18:	db01      	blt.n	40cd1e <_svfiprintf_r+0xf6>
  40cd1a:	9207      	str	r2, [sp, #28]
  40cd1c:	e004      	b.n	40cd28 <_svfiprintf_r+0x100>
  40cd1e:	4252      	negs	r2, r2
  40cd20:	f043 0302 	orr.w	r3, r3, #2
  40cd24:	9207      	str	r2, [sp, #28]
  40cd26:	9304      	str	r3, [sp, #16]
  40cd28:	783b      	ldrb	r3, [r7, #0]
  40cd2a:	2b2e      	cmp	r3, #46	; 0x2e
  40cd2c:	d10e      	bne.n	40cd4c <_svfiprintf_r+0x124>
  40cd2e:	787b      	ldrb	r3, [r7, #1]
  40cd30:	2b2a      	cmp	r3, #42	; 0x2a
  40cd32:	f107 0101 	add.w	r1, r7, #1
  40cd36:	d132      	bne.n	40cd9e <_svfiprintf_r+0x176>
  40cd38:	9b03      	ldr	r3, [sp, #12]
  40cd3a:	1d1a      	adds	r2, r3, #4
  40cd3c:	681b      	ldr	r3, [r3, #0]
  40cd3e:	9203      	str	r2, [sp, #12]
  40cd40:	2b00      	cmp	r3, #0
  40cd42:	bfb8      	it	lt
  40cd44:	f04f 33ff 	movlt.w	r3, #4294967295
  40cd48:	3702      	adds	r7, #2
  40cd4a:	9305      	str	r3, [sp, #20]
  40cd4c:	4c2c      	ldr	r4, [pc, #176]	; (40ce00 <_svfiprintf_r+0x1d8>)
  40cd4e:	7839      	ldrb	r1, [r7, #0]
  40cd50:	2203      	movs	r2, #3
  40cd52:	4620      	mov	r0, r4
  40cd54:	f000 fed4 	bl	40db00 <memchr>
  40cd58:	b138      	cbz	r0, 40cd6a <_svfiprintf_r+0x142>
  40cd5a:	2340      	movs	r3, #64	; 0x40
  40cd5c:	1b00      	subs	r0, r0, r4
  40cd5e:	fa03 f000 	lsl.w	r0, r3, r0
  40cd62:	9b04      	ldr	r3, [sp, #16]
  40cd64:	4303      	orrs	r3, r0
  40cd66:	9304      	str	r3, [sp, #16]
  40cd68:	3701      	adds	r7, #1
  40cd6a:	7839      	ldrb	r1, [r7, #0]
  40cd6c:	4825      	ldr	r0, [pc, #148]	; (40ce04 <_svfiprintf_r+0x1dc>)
  40cd6e:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
  40cd72:	2206      	movs	r2, #6
  40cd74:	1c7e      	adds	r6, r7, #1
  40cd76:	f000 fec3 	bl	40db00 <memchr>
  40cd7a:	2800      	cmp	r0, #0
  40cd7c:	d035      	beq.n	40cdea <_svfiprintf_r+0x1c2>
  40cd7e:	4b22      	ldr	r3, [pc, #136]	; (40ce08 <_svfiprintf_r+0x1e0>)
  40cd80:	b9fb      	cbnz	r3, 40cdc2 <_svfiprintf_r+0x19a>
  40cd82:	9b03      	ldr	r3, [sp, #12]
  40cd84:	3307      	adds	r3, #7
  40cd86:	f023 0307 	bic.w	r3, r3, #7
  40cd8a:	3308      	adds	r3, #8
  40cd8c:	9303      	str	r3, [sp, #12]
  40cd8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40cd90:	444b      	add	r3, r9
  40cd92:	9309      	str	r3, [sp, #36]	; 0x24
  40cd94:	e76c      	b.n	40cc70 <_svfiprintf_r+0x48>
  40cd96:	fb00 3202 	mla	r2, r0, r2, r3
  40cd9a:	2101      	movs	r1, #1
  40cd9c:	e7a3      	b.n	40cce6 <_svfiprintf_r+0xbe>
  40cd9e:	2300      	movs	r3, #0
  40cda0:	9305      	str	r3, [sp, #20]
  40cda2:	4618      	mov	r0, r3
  40cda4:	240a      	movs	r4, #10
  40cda6:	460f      	mov	r7, r1
  40cda8:	3101      	adds	r1, #1
  40cdaa:	783a      	ldrb	r2, [r7, #0]
  40cdac:	3a30      	subs	r2, #48	; 0x30
  40cdae:	2a09      	cmp	r2, #9
  40cdb0:	d903      	bls.n	40cdba <_svfiprintf_r+0x192>
  40cdb2:	2b00      	cmp	r3, #0
  40cdb4:	d0ca      	beq.n	40cd4c <_svfiprintf_r+0x124>
  40cdb6:	9005      	str	r0, [sp, #20]
  40cdb8:	e7c8      	b.n	40cd4c <_svfiprintf_r+0x124>
  40cdba:	fb04 2000 	mla	r0, r4, r0, r2
  40cdbe:	2301      	movs	r3, #1
  40cdc0:	e7f1      	b.n	40cda6 <_svfiprintf_r+0x17e>
  40cdc2:	ab03      	add	r3, sp, #12
  40cdc4:	9300      	str	r3, [sp, #0]
  40cdc6:	462a      	mov	r2, r5
  40cdc8:	4b10      	ldr	r3, [pc, #64]	; (40ce0c <_svfiprintf_r+0x1e4>)
  40cdca:	a904      	add	r1, sp, #16
  40cdcc:	4640      	mov	r0, r8
  40cdce:	f3af 8000 	nop.w
  40cdd2:	f1b0 3fff 	cmp.w	r0, #4294967295
  40cdd6:	4681      	mov	r9, r0
  40cdd8:	d1d9      	bne.n	40cd8e <_svfiprintf_r+0x166>
  40cdda:	89ab      	ldrh	r3, [r5, #12]
  40cddc:	065b      	lsls	r3, r3, #25
  40cdde:	f53f af38 	bmi.w	40cc52 <_svfiprintf_r+0x2a>
  40cde2:	9809      	ldr	r0, [sp, #36]	; 0x24
  40cde4:	b01d      	add	sp, #116	; 0x74
  40cde6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40cdea:	ab03      	add	r3, sp, #12
  40cdec:	9300      	str	r3, [sp, #0]
  40cdee:	462a      	mov	r2, r5
  40cdf0:	4b06      	ldr	r3, [pc, #24]	; (40ce0c <_svfiprintf_r+0x1e4>)
  40cdf2:	a904      	add	r1, sp, #16
  40cdf4:	4640      	mov	r0, r8
  40cdf6:	f000 fa2f 	bl	40d258 <_printf_i>
  40cdfa:	e7ea      	b.n	40cdd2 <_svfiprintf_r+0x1aa>
  40cdfc:	0040e5e0 	.word	0x0040e5e0
  40ce00:	0040e5e6 	.word	0x0040e5e6
  40ce04:	0040e5ea 	.word	0x0040e5ea
  40ce08:	00000000 	.word	0x00000000
  40ce0c:	0040cb71 	.word	0x0040cb71

0040ce10 <_sungetc_r>:
  40ce10:	b538      	push	{r3, r4, r5, lr}
  40ce12:	1c4b      	adds	r3, r1, #1
  40ce14:	4614      	mov	r4, r2
  40ce16:	d103      	bne.n	40ce20 <_sungetc_r+0x10>
  40ce18:	f04f 35ff 	mov.w	r5, #4294967295
  40ce1c:	4628      	mov	r0, r5
  40ce1e:	bd38      	pop	{r3, r4, r5, pc}
  40ce20:	8993      	ldrh	r3, [r2, #12]
  40ce22:	f023 0320 	bic.w	r3, r3, #32
  40ce26:	8193      	strh	r3, [r2, #12]
  40ce28:	6b53      	ldr	r3, [r2, #52]	; 0x34
  40ce2a:	6852      	ldr	r2, [r2, #4]
  40ce2c:	b2cd      	uxtb	r5, r1
  40ce2e:	b18b      	cbz	r3, 40ce54 <_sungetc_r+0x44>
  40ce30:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  40ce32:	429a      	cmp	r2, r3
  40ce34:	da08      	bge.n	40ce48 <_sungetc_r+0x38>
  40ce36:	6823      	ldr	r3, [r4, #0]
  40ce38:	1e5a      	subs	r2, r3, #1
  40ce3a:	6022      	str	r2, [r4, #0]
  40ce3c:	f803 5c01 	strb.w	r5, [r3, #-1]
  40ce40:	6863      	ldr	r3, [r4, #4]
  40ce42:	3301      	adds	r3, #1
  40ce44:	6063      	str	r3, [r4, #4]
  40ce46:	e7e9      	b.n	40ce1c <_sungetc_r+0xc>
  40ce48:	4621      	mov	r1, r4
  40ce4a:	f000 fde1 	bl	40da10 <__submore>
  40ce4e:	2800      	cmp	r0, #0
  40ce50:	d0f1      	beq.n	40ce36 <_sungetc_r+0x26>
  40ce52:	e7e1      	b.n	40ce18 <_sungetc_r+0x8>
  40ce54:	6921      	ldr	r1, [r4, #16]
  40ce56:	6823      	ldr	r3, [r4, #0]
  40ce58:	b151      	cbz	r1, 40ce70 <_sungetc_r+0x60>
  40ce5a:	4299      	cmp	r1, r3
  40ce5c:	d208      	bcs.n	40ce70 <_sungetc_r+0x60>
  40ce5e:	f813 1c01 	ldrb.w	r1, [r3, #-1]
  40ce62:	428d      	cmp	r5, r1
  40ce64:	d104      	bne.n	40ce70 <_sungetc_r+0x60>
  40ce66:	3b01      	subs	r3, #1
  40ce68:	3201      	adds	r2, #1
  40ce6a:	6023      	str	r3, [r4, #0]
  40ce6c:	6062      	str	r2, [r4, #4]
  40ce6e:	e7d5      	b.n	40ce1c <_sungetc_r+0xc>
  40ce70:	63e3      	str	r3, [r4, #60]	; 0x3c
  40ce72:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40ce76:	6363      	str	r3, [r4, #52]	; 0x34
  40ce78:	2303      	movs	r3, #3
  40ce7a:	63a3      	str	r3, [r4, #56]	; 0x38
  40ce7c:	4623      	mov	r3, r4
  40ce7e:	6422      	str	r2, [r4, #64]	; 0x40
  40ce80:	f803 5f46 	strb.w	r5, [r3, #70]!
  40ce84:	6023      	str	r3, [r4, #0]
  40ce86:	2301      	movs	r3, #1
  40ce88:	e7dc      	b.n	40ce44 <_sungetc_r+0x34>

0040ce8a <__ssrefill_r>:
  40ce8a:	b510      	push	{r4, lr}
  40ce8c:	460c      	mov	r4, r1
  40ce8e:	6b49      	ldr	r1, [r1, #52]	; 0x34
  40ce90:	b169      	cbz	r1, 40ceae <__ssrefill_r+0x24>
  40ce92:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40ce96:	4299      	cmp	r1, r3
  40ce98:	d001      	beq.n	40ce9e <__ssrefill_r+0x14>
  40ce9a:	f7ff f9fd 	bl	40c298 <_free_r>
  40ce9e:	6c23      	ldr	r3, [r4, #64]	; 0x40
  40cea0:	6063      	str	r3, [r4, #4]
  40cea2:	2000      	movs	r0, #0
  40cea4:	6360      	str	r0, [r4, #52]	; 0x34
  40cea6:	b113      	cbz	r3, 40ceae <__ssrefill_r+0x24>
  40cea8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40ceaa:	6023      	str	r3, [r4, #0]
  40ceac:	bd10      	pop	{r4, pc}
  40ceae:	6923      	ldr	r3, [r4, #16]
  40ceb0:	6023      	str	r3, [r4, #0]
  40ceb2:	2300      	movs	r3, #0
  40ceb4:	6063      	str	r3, [r4, #4]
  40ceb6:	89a3      	ldrh	r3, [r4, #12]
  40ceb8:	f043 0320 	orr.w	r3, r3, #32
  40cebc:	81a3      	strh	r3, [r4, #12]
  40cebe:	f04f 30ff 	mov.w	r0, #4294967295
  40cec2:	bd10      	pop	{r4, pc}

0040cec4 <__ssvfiscanf_r>:
  40cec4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40cec8:	f5ad 7d25 	sub.w	sp, sp, #660	; 0x294
  40cecc:	f10d 080c 	add.w	r8, sp, #12
  40ced0:	9301      	str	r3, [sp, #4]
  40ced2:	2300      	movs	r3, #0
  40ced4:	9346      	str	r3, [sp, #280]	; 0x118
  40ced6:	9347      	str	r3, [sp, #284]	; 0x11c
  40ced8:	4ba0      	ldr	r3, [pc, #640]	; (40d15c <__ssvfiscanf_r+0x298>)
  40ceda:	93a2      	str	r3, [sp, #648]	; 0x288
  40cedc:	f8df 9284 	ldr.w	r9, [pc, #644]	; 40d164 <__ssvfiscanf_r+0x2a0>
  40cee0:	4b9f      	ldr	r3, [pc, #636]	; (40d160 <__ssvfiscanf_r+0x29c>)
  40cee2:	f8cd 8120 	str.w	r8, [sp, #288]	; 0x120
  40cee6:	4606      	mov	r6, r0
  40cee8:	460c      	mov	r4, r1
  40ceea:	93a3      	str	r3, [sp, #652]	; 0x28c
  40ceec:	4692      	mov	sl, r2
  40ceee:	270a      	movs	r7, #10
  40cef0:	f89a 3000 	ldrb.w	r3, [sl]
  40cef4:	2b00      	cmp	r3, #0
  40cef6:	f000 812f 	beq.w	40d158 <__ssvfiscanf_r+0x294>
  40cefa:	f000 fddb 	bl	40dab4 <__locale_ctype_ptr>
  40cefe:	f89a b000 	ldrb.w	fp, [sl]
  40cf02:	4458      	add	r0, fp
  40cf04:	7843      	ldrb	r3, [r0, #1]
  40cf06:	f013 0308 	ands.w	r3, r3, #8
  40cf0a:	d143      	bne.n	40cf94 <__ssvfiscanf_r+0xd0>
  40cf0c:	f1bb 0f25 	cmp.w	fp, #37	; 0x25
  40cf10:	f10a 0501 	add.w	r5, sl, #1
  40cf14:	f040 8099 	bne.w	40d04a <__ssvfiscanf_r+0x186>
  40cf18:	9345      	str	r3, [sp, #276]	; 0x114
  40cf1a:	9343      	str	r3, [sp, #268]	; 0x10c
  40cf1c:	f89a 3001 	ldrb.w	r3, [sl, #1]
  40cf20:	2b2a      	cmp	r3, #42	; 0x2a
  40cf22:	d103      	bne.n	40cf2c <__ssvfiscanf_r+0x68>
  40cf24:	2310      	movs	r3, #16
  40cf26:	9343      	str	r3, [sp, #268]	; 0x10c
  40cf28:	f10a 0502 	add.w	r5, sl, #2
  40cf2c:	7829      	ldrb	r1, [r5, #0]
  40cf2e:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
  40cf32:	2a09      	cmp	r2, #9
  40cf34:	46aa      	mov	sl, r5
  40cf36:	f105 0501 	add.w	r5, r5, #1
  40cf3a:	d941      	bls.n	40cfc0 <__ssvfiscanf_r+0xfc>
  40cf3c:	2203      	movs	r2, #3
  40cf3e:	4889      	ldr	r0, [pc, #548]	; (40d164 <__ssvfiscanf_r+0x2a0>)
  40cf40:	f000 fdde 	bl	40db00 <memchr>
  40cf44:	b138      	cbz	r0, 40cf56 <__ssvfiscanf_r+0x92>
  40cf46:	eba0 0309 	sub.w	r3, r0, r9
  40cf4a:	2001      	movs	r0, #1
  40cf4c:	4098      	lsls	r0, r3
  40cf4e:	9b43      	ldr	r3, [sp, #268]	; 0x10c
  40cf50:	4318      	orrs	r0, r3
  40cf52:	9043      	str	r0, [sp, #268]	; 0x10c
  40cf54:	46aa      	mov	sl, r5
  40cf56:	f89a 3000 	ldrb.w	r3, [sl]
  40cf5a:	2b67      	cmp	r3, #103	; 0x67
  40cf5c:	f10a 0501 	add.w	r5, sl, #1
  40cf60:	d84a      	bhi.n	40cff8 <__ssvfiscanf_r+0x134>
  40cf62:	2b65      	cmp	r3, #101	; 0x65
  40cf64:	f080 80b7 	bcs.w	40d0d6 <__ssvfiscanf_r+0x212>
  40cf68:	2b47      	cmp	r3, #71	; 0x47
  40cf6a:	d82f      	bhi.n	40cfcc <__ssvfiscanf_r+0x108>
  40cf6c:	2b45      	cmp	r3, #69	; 0x45
  40cf6e:	f080 80b2 	bcs.w	40d0d6 <__ssvfiscanf_r+0x212>
  40cf72:	2b00      	cmp	r3, #0
  40cf74:	f000 8082 	beq.w	40d07c <__ssvfiscanf_r+0x1b8>
  40cf78:	2b25      	cmp	r3, #37	; 0x25
  40cf7a:	d066      	beq.n	40d04a <__ssvfiscanf_r+0x186>
  40cf7c:	2303      	movs	r3, #3
  40cf7e:	9349      	str	r3, [sp, #292]	; 0x124
  40cf80:	9744      	str	r7, [sp, #272]	; 0x110
  40cf82:	e045      	b.n	40d010 <__ssvfiscanf_r+0x14c>
  40cf84:	9947      	ldr	r1, [sp, #284]	; 0x11c
  40cf86:	3101      	adds	r1, #1
  40cf88:	9147      	str	r1, [sp, #284]	; 0x11c
  40cf8a:	6861      	ldr	r1, [r4, #4]
  40cf8c:	3301      	adds	r3, #1
  40cf8e:	3901      	subs	r1, #1
  40cf90:	6061      	str	r1, [r4, #4]
  40cf92:	6023      	str	r3, [r4, #0]
  40cf94:	6863      	ldr	r3, [r4, #4]
  40cf96:	2b00      	cmp	r3, #0
  40cf98:	dd0b      	ble.n	40cfb2 <__ssvfiscanf_r+0xee>
  40cf9a:	f000 fd8b 	bl	40dab4 <__locale_ctype_ptr>
  40cf9e:	6823      	ldr	r3, [r4, #0]
  40cfa0:	7819      	ldrb	r1, [r3, #0]
  40cfa2:	4408      	add	r0, r1
  40cfa4:	7841      	ldrb	r1, [r0, #1]
  40cfa6:	070d      	lsls	r5, r1, #28
  40cfa8:	d4ec      	bmi.n	40cf84 <__ssvfiscanf_r+0xc0>
  40cfaa:	f10a 0501 	add.w	r5, sl, #1
  40cfae:	46aa      	mov	sl, r5
  40cfb0:	e79e      	b.n	40cef0 <__ssvfiscanf_r+0x2c>
  40cfb2:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
  40cfb4:	4621      	mov	r1, r4
  40cfb6:	4630      	mov	r0, r6
  40cfb8:	4798      	blx	r3
  40cfba:	2800      	cmp	r0, #0
  40cfbc:	d0ed      	beq.n	40cf9a <__ssvfiscanf_r+0xd6>
  40cfbe:	e7f4      	b.n	40cfaa <__ssvfiscanf_r+0xe6>
  40cfc0:	9b45      	ldr	r3, [sp, #276]	; 0x114
  40cfc2:	fb07 1303 	mla	r3, r7, r3, r1
  40cfc6:	3b30      	subs	r3, #48	; 0x30
  40cfc8:	9345      	str	r3, [sp, #276]	; 0x114
  40cfca:	e7af      	b.n	40cf2c <__ssvfiscanf_r+0x68>
  40cfcc:	2b5b      	cmp	r3, #91	; 0x5b
  40cfce:	d061      	beq.n	40d094 <__ssvfiscanf_r+0x1d0>
  40cfd0:	d80c      	bhi.n	40cfec <__ssvfiscanf_r+0x128>
  40cfd2:	2b58      	cmp	r3, #88	; 0x58
  40cfd4:	d1d2      	bne.n	40cf7c <__ssvfiscanf_r+0xb8>
  40cfd6:	9a43      	ldr	r2, [sp, #268]	; 0x10c
  40cfd8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  40cfdc:	9243      	str	r2, [sp, #268]	; 0x10c
  40cfde:	2210      	movs	r2, #16
  40cfe0:	9244      	str	r2, [sp, #272]	; 0x110
  40cfe2:	2b6f      	cmp	r3, #111	; 0x6f
  40cfe4:	bfb4      	ite	lt
  40cfe6:	2303      	movlt	r3, #3
  40cfe8:	2304      	movge	r3, #4
  40cfea:	e010      	b.n	40d00e <__ssvfiscanf_r+0x14a>
  40cfec:	2b63      	cmp	r3, #99	; 0x63
  40cfee:	d05c      	beq.n	40d0aa <__ssvfiscanf_r+0x1e6>
  40cff0:	2b64      	cmp	r3, #100	; 0x64
  40cff2:	d1c3      	bne.n	40cf7c <__ssvfiscanf_r+0xb8>
  40cff4:	9744      	str	r7, [sp, #272]	; 0x110
  40cff6:	e7f4      	b.n	40cfe2 <__ssvfiscanf_r+0x11e>
  40cff8:	2b70      	cmp	r3, #112	; 0x70
  40cffa:	d042      	beq.n	40d082 <__ssvfiscanf_r+0x1be>
  40cffc:	d81d      	bhi.n	40d03a <__ssvfiscanf_r+0x176>
  40cffe:	2b6e      	cmp	r3, #110	; 0x6e
  40d000:	d059      	beq.n	40d0b6 <__ssvfiscanf_r+0x1f2>
  40d002:	d843      	bhi.n	40d08c <__ssvfiscanf_r+0x1c8>
  40d004:	2b69      	cmp	r3, #105	; 0x69
  40d006:	d1b9      	bne.n	40cf7c <__ssvfiscanf_r+0xb8>
  40d008:	2300      	movs	r3, #0
  40d00a:	9344      	str	r3, [sp, #272]	; 0x110
  40d00c:	2303      	movs	r3, #3
  40d00e:	9349      	str	r3, [sp, #292]	; 0x124
  40d010:	6863      	ldr	r3, [r4, #4]
  40d012:	2b00      	cmp	r3, #0
  40d014:	dd61      	ble.n	40d0da <__ssvfiscanf_r+0x216>
  40d016:	9b43      	ldr	r3, [sp, #268]	; 0x10c
  40d018:	0659      	lsls	r1, r3, #25
  40d01a:	d56f      	bpl.n	40d0fc <__ssvfiscanf_r+0x238>
  40d01c:	9b49      	ldr	r3, [sp, #292]	; 0x124
  40d01e:	2b02      	cmp	r3, #2
  40d020:	dc7c      	bgt.n	40d11c <__ssvfiscanf_r+0x258>
  40d022:	ab01      	add	r3, sp, #4
  40d024:	4622      	mov	r2, r4
  40d026:	a943      	add	r1, sp, #268	; 0x10c
  40d028:	4630      	mov	r0, r6
  40d02a:	f000 fa35 	bl	40d498 <_scanf_chars>
  40d02e:	2801      	cmp	r0, #1
  40d030:	f000 8092 	beq.w	40d158 <__ssvfiscanf_r+0x294>
  40d034:	2802      	cmp	r0, #2
  40d036:	d1ba      	bne.n	40cfae <__ssvfiscanf_r+0xea>
  40d038:	e01d      	b.n	40d076 <__ssvfiscanf_r+0x1b2>
  40d03a:	2b75      	cmp	r3, #117	; 0x75
  40d03c:	d0da      	beq.n	40cff4 <__ssvfiscanf_r+0x130>
  40d03e:	2b78      	cmp	r3, #120	; 0x78
  40d040:	d0c9      	beq.n	40cfd6 <__ssvfiscanf_r+0x112>
  40d042:	2b73      	cmp	r3, #115	; 0x73
  40d044:	d19a      	bne.n	40cf7c <__ssvfiscanf_r+0xb8>
  40d046:	2302      	movs	r3, #2
  40d048:	e7e1      	b.n	40d00e <__ssvfiscanf_r+0x14a>
  40d04a:	6863      	ldr	r3, [r4, #4]
  40d04c:	2b00      	cmp	r3, #0
  40d04e:	dd0c      	ble.n	40d06a <__ssvfiscanf_r+0x1a6>
  40d050:	6823      	ldr	r3, [r4, #0]
  40d052:	781a      	ldrb	r2, [r3, #0]
  40d054:	4593      	cmp	fp, r2
  40d056:	d17f      	bne.n	40d158 <__ssvfiscanf_r+0x294>
  40d058:	3301      	adds	r3, #1
  40d05a:	6862      	ldr	r2, [r4, #4]
  40d05c:	6023      	str	r3, [r4, #0]
  40d05e:	9b47      	ldr	r3, [sp, #284]	; 0x11c
  40d060:	3a01      	subs	r2, #1
  40d062:	3301      	adds	r3, #1
  40d064:	6062      	str	r2, [r4, #4]
  40d066:	9347      	str	r3, [sp, #284]	; 0x11c
  40d068:	e7a1      	b.n	40cfae <__ssvfiscanf_r+0xea>
  40d06a:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
  40d06c:	4621      	mov	r1, r4
  40d06e:	4630      	mov	r0, r6
  40d070:	4798      	blx	r3
  40d072:	2800      	cmp	r0, #0
  40d074:	d0ec      	beq.n	40d050 <__ssvfiscanf_r+0x18c>
  40d076:	9846      	ldr	r0, [sp, #280]	; 0x118
  40d078:	2800      	cmp	r0, #0
  40d07a:	d163      	bne.n	40d144 <__ssvfiscanf_r+0x280>
  40d07c:	f04f 30ff 	mov.w	r0, #4294967295
  40d080:	e066      	b.n	40d150 <__ssvfiscanf_r+0x28c>
  40d082:	9a43      	ldr	r2, [sp, #268]	; 0x10c
  40d084:	f042 0220 	orr.w	r2, r2, #32
  40d088:	9243      	str	r2, [sp, #268]	; 0x10c
  40d08a:	e7a4      	b.n	40cfd6 <__ssvfiscanf_r+0x112>
  40d08c:	2308      	movs	r3, #8
  40d08e:	9344      	str	r3, [sp, #272]	; 0x110
  40d090:	2304      	movs	r3, #4
  40d092:	e7bc      	b.n	40d00e <__ssvfiscanf_r+0x14a>
  40d094:	4629      	mov	r1, r5
  40d096:	4640      	mov	r0, r8
  40d098:	f000 fb68 	bl	40d76c <__sccl>
  40d09c:	9b43      	ldr	r3, [sp, #268]	; 0x10c
  40d09e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40d0a2:	9343      	str	r3, [sp, #268]	; 0x10c
  40d0a4:	4605      	mov	r5, r0
  40d0a6:	2301      	movs	r3, #1
  40d0a8:	e7b1      	b.n	40d00e <__ssvfiscanf_r+0x14a>
  40d0aa:	9b43      	ldr	r3, [sp, #268]	; 0x10c
  40d0ac:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40d0b0:	9343      	str	r3, [sp, #268]	; 0x10c
  40d0b2:	2300      	movs	r3, #0
  40d0b4:	e7ab      	b.n	40d00e <__ssvfiscanf_r+0x14a>
  40d0b6:	9a43      	ldr	r2, [sp, #268]	; 0x10c
  40d0b8:	06d0      	lsls	r0, r2, #27
  40d0ba:	f53f af78 	bmi.w	40cfae <__ssvfiscanf_r+0xea>
  40d0be:	f012 0f01 	tst.w	r2, #1
  40d0c2:	9a01      	ldr	r2, [sp, #4]
  40d0c4:	9b47      	ldr	r3, [sp, #284]	; 0x11c
  40d0c6:	f102 0104 	add.w	r1, r2, #4
  40d0ca:	9101      	str	r1, [sp, #4]
  40d0cc:	6812      	ldr	r2, [r2, #0]
  40d0ce:	bf14      	ite	ne
  40d0d0:	8013      	strhne	r3, [r2, #0]
  40d0d2:	6013      	streq	r3, [r2, #0]
  40d0d4:	e76b      	b.n	40cfae <__ssvfiscanf_r+0xea>
  40d0d6:	2305      	movs	r3, #5
  40d0d8:	e799      	b.n	40d00e <__ssvfiscanf_r+0x14a>
  40d0da:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
  40d0dc:	4621      	mov	r1, r4
  40d0de:	4630      	mov	r0, r6
  40d0e0:	4798      	blx	r3
  40d0e2:	2800      	cmp	r0, #0
  40d0e4:	d097      	beq.n	40d016 <__ssvfiscanf_r+0x152>
  40d0e6:	e7c6      	b.n	40d076 <__ssvfiscanf_r+0x1b2>
  40d0e8:	9a47      	ldr	r2, [sp, #284]	; 0x11c
  40d0ea:	3201      	adds	r2, #1
  40d0ec:	9247      	str	r2, [sp, #284]	; 0x11c
  40d0ee:	6862      	ldr	r2, [r4, #4]
  40d0f0:	3a01      	subs	r2, #1
  40d0f2:	2a00      	cmp	r2, #0
  40d0f4:	6062      	str	r2, [r4, #4]
  40d0f6:	dd0a      	ble.n	40d10e <__ssvfiscanf_r+0x24a>
  40d0f8:	3301      	adds	r3, #1
  40d0fa:	6023      	str	r3, [r4, #0]
  40d0fc:	f000 fcda 	bl	40dab4 <__locale_ctype_ptr>
  40d100:	6823      	ldr	r3, [r4, #0]
  40d102:	781a      	ldrb	r2, [r3, #0]
  40d104:	4410      	add	r0, r2
  40d106:	7842      	ldrb	r2, [r0, #1]
  40d108:	0712      	lsls	r2, r2, #28
  40d10a:	d4ed      	bmi.n	40d0e8 <__ssvfiscanf_r+0x224>
  40d10c:	e786      	b.n	40d01c <__ssvfiscanf_r+0x158>
  40d10e:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
  40d110:	4621      	mov	r1, r4
  40d112:	4630      	mov	r0, r6
  40d114:	4798      	blx	r3
  40d116:	2800      	cmp	r0, #0
  40d118:	d0f0      	beq.n	40d0fc <__ssvfiscanf_r+0x238>
  40d11a:	e7ac      	b.n	40d076 <__ssvfiscanf_r+0x1b2>
  40d11c:	2b04      	cmp	r3, #4
  40d11e:	dc06      	bgt.n	40d12e <__ssvfiscanf_r+0x26a>
  40d120:	ab01      	add	r3, sp, #4
  40d122:	4622      	mov	r2, r4
  40d124:	a943      	add	r1, sp, #268	; 0x10c
  40d126:	4630      	mov	r0, r6
  40d128:	f000 fa1a 	bl	40d560 <_scanf_i>
  40d12c:	e77f      	b.n	40d02e <__ssvfiscanf_r+0x16a>
  40d12e:	4b0e      	ldr	r3, [pc, #56]	; (40d168 <__ssvfiscanf_r+0x2a4>)
  40d130:	2b00      	cmp	r3, #0
  40d132:	f43f af3c 	beq.w	40cfae <__ssvfiscanf_r+0xea>
  40d136:	ab01      	add	r3, sp, #4
  40d138:	4622      	mov	r2, r4
  40d13a:	a943      	add	r1, sp, #268	; 0x10c
  40d13c:	4630      	mov	r0, r6
  40d13e:	f3af 8000 	nop.w
  40d142:	e774      	b.n	40d02e <__ssvfiscanf_r+0x16a>
  40d144:	89a3      	ldrh	r3, [r4, #12]
  40d146:	f013 0f40 	tst.w	r3, #64	; 0x40
  40d14a:	bf18      	it	ne
  40d14c:	f04f 30ff 	movne.w	r0, #4294967295
  40d150:	f50d 7d25 	add.w	sp, sp, #660	; 0x294
  40d154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40d158:	9846      	ldr	r0, [sp, #280]	; 0x118
  40d15a:	e7f9      	b.n	40d150 <__ssvfiscanf_r+0x28c>
  40d15c:	0040ce11 	.word	0x0040ce11
  40d160:	0040ce8b 	.word	0x0040ce8b
  40d164:	0040e5e6 	.word	0x0040e5e6
  40d168:	00000000 	.word	0x00000000

0040d16c <_printf_common>:
  40d16c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40d170:	4691      	mov	r9, r2
  40d172:	461f      	mov	r7, r3
  40d174:	688a      	ldr	r2, [r1, #8]
  40d176:	690b      	ldr	r3, [r1, #16]
  40d178:	f8dd 8020 	ldr.w	r8, [sp, #32]
  40d17c:	4293      	cmp	r3, r2
  40d17e:	bfb8      	it	lt
  40d180:	4613      	movlt	r3, r2
  40d182:	f8c9 3000 	str.w	r3, [r9]
  40d186:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
  40d18a:	4606      	mov	r6, r0
  40d18c:	460c      	mov	r4, r1
  40d18e:	b112      	cbz	r2, 40d196 <_printf_common+0x2a>
  40d190:	3301      	adds	r3, #1
  40d192:	f8c9 3000 	str.w	r3, [r9]
  40d196:	6823      	ldr	r3, [r4, #0]
  40d198:	0699      	lsls	r1, r3, #26
  40d19a:	bf42      	ittt	mi
  40d19c:	f8d9 3000 	ldrmi.w	r3, [r9]
  40d1a0:	3302      	addmi	r3, #2
  40d1a2:	f8c9 3000 	strmi.w	r3, [r9]
  40d1a6:	6825      	ldr	r5, [r4, #0]
  40d1a8:	f015 0506 	ands.w	r5, r5, #6
  40d1ac:	d107      	bne.n	40d1be <_printf_common+0x52>
  40d1ae:	f104 0a19 	add.w	sl, r4, #25
  40d1b2:	68e3      	ldr	r3, [r4, #12]
  40d1b4:	f8d9 2000 	ldr.w	r2, [r9]
  40d1b8:	1a9b      	subs	r3, r3, r2
  40d1ba:	429d      	cmp	r5, r3
  40d1bc:	db29      	blt.n	40d212 <_printf_common+0xa6>
  40d1be:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
  40d1c2:	6822      	ldr	r2, [r4, #0]
  40d1c4:	3300      	adds	r3, #0
  40d1c6:	bf18      	it	ne
  40d1c8:	2301      	movne	r3, #1
  40d1ca:	0692      	lsls	r2, r2, #26
  40d1cc:	d42e      	bmi.n	40d22c <_printf_common+0xc0>
  40d1ce:	f104 0243 	add.w	r2, r4, #67	; 0x43
  40d1d2:	4639      	mov	r1, r7
  40d1d4:	4630      	mov	r0, r6
  40d1d6:	47c0      	blx	r8
  40d1d8:	3001      	adds	r0, #1
  40d1da:	d021      	beq.n	40d220 <_printf_common+0xb4>
  40d1dc:	6823      	ldr	r3, [r4, #0]
  40d1de:	68e5      	ldr	r5, [r4, #12]
  40d1e0:	f8d9 2000 	ldr.w	r2, [r9]
  40d1e4:	f003 0306 	and.w	r3, r3, #6
  40d1e8:	2b04      	cmp	r3, #4
  40d1ea:	bf08      	it	eq
  40d1ec:	1aad      	subeq	r5, r5, r2
  40d1ee:	68a3      	ldr	r3, [r4, #8]
  40d1f0:	6922      	ldr	r2, [r4, #16]
  40d1f2:	bf0c      	ite	eq
  40d1f4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
  40d1f8:	2500      	movne	r5, #0
  40d1fa:	4293      	cmp	r3, r2
  40d1fc:	bfc4      	itt	gt
  40d1fe:	1a9b      	subgt	r3, r3, r2
  40d200:	18ed      	addgt	r5, r5, r3
  40d202:	f04f 0900 	mov.w	r9, #0
  40d206:	341a      	adds	r4, #26
  40d208:	454d      	cmp	r5, r9
  40d20a:	d11b      	bne.n	40d244 <_printf_common+0xd8>
  40d20c:	2000      	movs	r0, #0
  40d20e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40d212:	2301      	movs	r3, #1
  40d214:	4652      	mov	r2, sl
  40d216:	4639      	mov	r1, r7
  40d218:	4630      	mov	r0, r6
  40d21a:	47c0      	blx	r8
  40d21c:	3001      	adds	r0, #1
  40d21e:	d103      	bne.n	40d228 <_printf_common+0xbc>
  40d220:	f04f 30ff 	mov.w	r0, #4294967295
  40d224:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40d228:	3501      	adds	r5, #1
  40d22a:	e7c2      	b.n	40d1b2 <_printf_common+0x46>
  40d22c:	18e1      	adds	r1, r4, r3
  40d22e:	1c5a      	adds	r2, r3, #1
  40d230:	2030      	movs	r0, #48	; 0x30
  40d232:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
  40d236:	4422      	add	r2, r4
  40d238:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
  40d23c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
  40d240:	3302      	adds	r3, #2
  40d242:	e7c4      	b.n	40d1ce <_printf_common+0x62>
  40d244:	2301      	movs	r3, #1
  40d246:	4622      	mov	r2, r4
  40d248:	4639      	mov	r1, r7
  40d24a:	4630      	mov	r0, r6
  40d24c:	47c0      	blx	r8
  40d24e:	3001      	adds	r0, #1
  40d250:	d0e6      	beq.n	40d220 <_printf_common+0xb4>
  40d252:	f109 0901 	add.w	r9, r9, #1
  40d256:	e7d7      	b.n	40d208 <_printf_common+0x9c>

0040d258 <_printf_i>:
  40d258:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40d25c:	4617      	mov	r7, r2
  40d25e:	7e0a      	ldrb	r2, [r1, #24]
  40d260:	b085      	sub	sp, #20
  40d262:	2a6e      	cmp	r2, #110	; 0x6e
  40d264:	4698      	mov	r8, r3
  40d266:	4606      	mov	r6, r0
  40d268:	460c      	mov	r4, r1
  40d26a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40d26c:	f101 0e43 	add.w	lr, r1, #67	; 0x43
  40d270:	f000 80bc 	beq.w	40d3ec <_printf_i+0x194>
  40d274:	d81a      	bhi.n	40d2ac <_printf_i+0x54>
  40d276:	2a63      	cmp	r2, #99	; 0x63
  40d278:	d02e      	beq.n	40d2d8 <_printf_i+0x80>
  40d27a:	d80a      	bhi.n	40d292 <_printf_i+0x3a>
  40d27c:	2a00      	cmp	r2, #0
  40d27e:	f000 80c8 	beq.w	40d412 <_printf_i+0x1ba>
  40d282:	2a58      	cmp	r2, #88	; 0x58
  40d284:	f000 808a 	beq.w	40d39c <_printf_i+0x144>
  40d288:	f104 0542 	add.w	r5, r4, #66	; 0x42
  40d28c:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  40d290:	e02a      	b.n	40d2e8 <_printf_i+0x90>
  40d292:	2a64      	cmp	r2, #100	; 0x64
  40d294:	d001      	beq.n	40d29a <_printf_i+0x42>
  40d296:	2a69      	cmp	r2, #105	; 0x69
  40d298:	d1f6      	bne.n	40d288 <_printf_i+0x30>
  40d29a:	6821      	ldr	r1, [r4, #0]
  40d29c:	681a      	ldr	r2, [r3, #0]
  40d29e:	f011 0f80 	tst.w	r1, #128	; 0x80
  40d2a2:	d023      	beq.n	40d2ec <_printf_i+0x94>
  40d2a4:	1d11      	adds	r1, r2, #4
  40d2a6:	6019      	str	r1, [r3, #0]
  40d2a8:	6813      	ldr	r3, [r2, #0]
  40d2aa:	e027      	b.n	40d2fc <_printf_i+0xa4>
  40d2ac:	2a73      	cmp	r2, #115	; 0x73
  40d2ae:	f000 80b4 	beq.w	40d41a <_printf_i+0x1c2>
  40d2b2:	d808      	bhi.n	40d2c6 <_printf_i+0x6e>
  40d2b4:	2a6f      	cmp	r2, #111	; 0x6f
  40d2b6:	d02a      	beq.n	40d30e <_printf_i+0xb6>
  40d2b8:	2a70      	cmp	r2, #112	; 0x70
  40d2ba:	d1e5      	bne.n	40d288 <_printf_i+0x30>
  40d2bc:	680a      	ldr	r2, [r1, #0]
  40d2be:	f042 0220 	orr.w	r2, r2, #32
  40d2c2:	600a      	str	r2, [r1, #0]
  40d2c4:	e003      	b.n	40d2ce <_printf_i+0x76>
  40d2c6:	2a75      	cmp	r2, #117	; 0x75
  40d2c8:	d021      	beq.n	40d30e <_printf_i+0xb6>
  40d2ca:	2a78      	cmp	r2, #120	; 0x78
  40d2cc:	d1dc      	bne.n	40d288 <_printf_i+0x30>
  40d2ce:	2278      	movs	r2, #120	; 0x78
  40d2d0:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
  40d2d4:	496e      	ldr	r1, [pc, #440]	; (40d490 <_printf_i+0x238>)
  40d2d6:	e064      	b.n	40d3a2 <_printf_i+0x14a>
  40d2d8:	681a      	ldr	r2, [r3, #0]
  40d2da:	f101 0542 	add.w	r5, r1, #66	; 0x42
  40d2de:	1d11      	adds	r1, r2, #4
  40d2e0:	6019      	str	r1, [r3, #0]
  40d2e2:	6813      	ldr	r3, [r2, #0]
  40d2e4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  40d2e8:	2301      	movs	r3, #1
  40d2ea:	e0a3      	b.n	40d434 <_printf_i+0x1dc>
  40d2ec:	f011 0f40 	tst.w	r1, #64	; 0x40
  40d2f0:	f102 0104 	add.w	r1, r2, #4
  40d2f4:	6019      	str	r1, [r3, #0]
  40d2f6:	d0d7      	beq.n	40d2a8 <_printf_i+0x50>
  40d2f8:	f9b2 3000 	ldrsh.w	r3, [r2]
  40d2fc:	2b00      	cmp	r3, #0
  40d2fe:	da03      	bge.n	40d308 <_printf_i+0xb0>
  40d300:	222d      	movs	r2, #45	; 0x2d
  40d302:	425b      	negs	r3, r3
  40d304:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
  40d308:	4962      	ldr	r1, [pc, #392]	; (40d494 <_printf_i+0x23c>)
  40d30a:	220a      	movs	r2, #10
  40d30c:	e017      	b.n	40d33e <_printf_i+0xe6>
  40d30e:	6820      	ldr	r0, [r4, #0]
  40d310:	6819      	ldr	r1, [r3, #0]
  40d312:	f010 0f80 	tst.w	r0, #128	; 0x80
  40d316:	d003      	beq.n	40d320 <_printf_i+0xc8>
  40d318:	1d08      	adds	r0, r1, #4
  40d31a:	6018      	str	r0, [r3, #0]
  40d31c:	680b      	ldr	r3, [r1, #0]
  40d31e:	e006      	b.n	40d32e <_printf_i+0xd6>
  40d320:	f010 0f40 	tst.w	r0, #64	; 0x40
  40d324:	f101 0004 	add.w	r0, r1, #4
  40d328:	6018      	str	r0, [r3, #0]
  40d32a:	d0f7      	beq.n	40d31c <_printf_i+0xc4>
  40d32c:	880b      	ldrh	r3, [r1, #0]
  40d32e:	4959      	ldr	r1, [pc, #356]	; (40d494 <_printf_i+0x23c>)
  40d330:	2a6f      	cmp	r2, #111	; 0x6f
  40d332:	bf14      	ite	ne
  40d334:	220a      	movne	r2, #10
  40d336:	2208      	moveq	r2, #8
  40d338:	2000      	movs	r0, #0
  40d33a:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
  40d33e:	6865      	ldr	r5, [r4, #4]
  40d340:	60a5      	str	r5, [r4, #8]
  40d342:	2d00      	cmp	r5, #0
  40d344:	f2c0 809c 	blt.w	40d480 <_printf_i+0x228>
  40d348:	6820      	ldr	r0, [r4, #0]
  40d34a:	f020 0004 	bic.w	r0, r0, #4
  40d34e:	6020      	str	r0, [r4, #0]
  40d350:	2b00      	cmp	r3, #0
  40d352:	d13f      	bne.n	40d3d4 <_printf_i+0x17c>
  40d354:	2d00      	cmp	r5, #0
  40d356:	f040 8095 	bne.w	40d484 <_printf_i+0x22c>
  40d35a:	4675      	mov	r5, lr
  40d35c:	2a08      	cmp	r2, #8
  40d35e:	d10b      	bne.n	40d378 <_printf_i+0x120>
  40d360:	6823      	ldr	r3, [r4, #0]
  40d362:	07da      	lsls	r2, r3, #31
  40d364:	d508      	bpl.n	40d378 <_printf_i+0x120>
  40d366:	6923      	ldr	r3, [r4, #16]
  40d368:	6862      	ldr	r2, [r4, #4]
  40d36a:	429a      	cmp	r2, r3
  40d36c:	bfde      	ittt	le
  40d36e:	2330      	movle	r3, #48	; 0x30
  40d370:	f805 3c01 	strble.w	r3, [r5, #-1]
  40d374:	f105 35ff 	addle.w	r5, r5, #4294967295
  40d378:	ebae 0305 	sub.w	r3, lr, r5
  40d37c:	6123      	str	r3, [r4, #16]
  40d37e:	f8cd 8000 	str.w	r8, [sp]
  40d382:	463b      	mov	r3, r7
  40d384:	aa03      	add	r2, sp, #12
  40d386:	4621      	mov	r1, r4
  40d388:	4630      	mov	r0, r6
  40d38a:	f7ff feef 	bl	40d16c <_printf_common>
  40d38e:	3001      	adds	r0, #1
  40d390:	d155      	bne.n	40d43e <_printf_i+0x1e6>
  40d392:	f04f 30ff 	mov.w	r0, #4294967295
  40d396:	b005      	add	sp, #20
  40d398:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40d39c:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
  40d3a0:	493c      	ldr	r1, [pc, #240]	; (40d494 <_printf_i+0x23c>)
  40d3a2:	6822      	ldr	r2, [r4, #0]
  40d3a4:	6818      	ldr	r0, [r3, #0]
  40d3a6:	f012 0f80 	tst.w	r2, #128	; 0x80
  40d3aa:	f100 0504 	add.w	r5, r0, #4
  40d3ae:	601d      	str	r5, [r3, #0]
  40d3b0:	d001      	beq.n	40d3b6 <_printf_i+0x15e>
  40d3b2:	6803      	ldr	r3, [r0, #0]
  40d3b4:	e002      	b.n	40d3bc <_printf_i+0x164>
  40d3b6:	0655      	lsls	r5, r2, #25
  40d3b8:	d5fb      	bpl.n	40d3b2 <_printf_i+0x15a>
  40d3ba:	8803      	ldrh	r3, [r0, #0]
  40d3bc:	07d0      	lsls	r0, r2, #31
  40d3be:	bf44      	itt	mi
  40d3c0:	f042 0220 	orrmi.w	r2, r2, #32
  40d3c4:	6022      	strmi	r2, [r4, #0]
  40d3c6:	b91b      	cbnz	r3, 40d3d0 <_printf_i+0x178>
  40d3c8:	6822      	ldr	r2, [r4, #0]
  40d3ca:	f022 0220 	bic.w	r2, r2, #32
  40d3ce:	6022      	str	r2, [r4, #0]
  40d3d0:	2210      	movs	r2, #16
  40d3d2:	e7b1      	b.n	40d338 <_printf_i+0xe0>
  40d3d4:	4675      	mov	r5, lr
  40d3d6:	fbb3 f0f2 	udiv	r0, r3, r2
  40d3da:	fb02 3310 	mls	r3, r2, r0, r3
  40d3de:	5ccb      	ldrb	r3, [r1, r3]
  40d3e0:	f805 3d01 	strb.w	r3, [r5, #-1]!
  40d3e4:	4603      	mov	r3, r0
  40d3e6:	2800      	cmp	r0, #0
  40d3e8:	d1f5      	bne.n	40d3d6 <_printf_i+0x17e>
  40d3ea:	e7b7      	b.n	40d35c <_printf_i+0x104>
  40d3ec:	6808      	ldr	r0, [r1, #0]
  40d3ee:	681a      	ldr	r2, [r3, #0]
  40d3f0:	6949      	ldr	r1, [r1, #20]
  40d3f2:	f010 0f80 	tst.w	r0, #128	; 0x80
  40d3f6:	d004      	beq.n	40d402 <_printf_i+0x1aa>
  40d3f8:	1d10      	adds	r0, r2, #4
  40d3fa:	6018      	str	r0, [r3, #0]
  40d3fc:	6813      	ldr	r3, [r2, #0]
  40d3fe:	6019      	str	r1, [r3, #0]
  40d400:	e007      	b.n	40d412 <_printf_i+0x1ba>
  40d402:	f010 0f40 	tst.w	r0, #64	; 0x40
  40d406:	f102 0004 	add.w	r0, r2, #4
  40d40a:	6018      	str	r0, [r3, #0]
  40d40c:	6813      	ldr	r3, [r2, #0]
  40d40e:	d0f6      	beq.n	40d3fe <_printf_i+0x1a6>
  40d410:	8019      	strh	r1, [r3, #0]
  40d412:	2300      	movs	r3, #0
  40d414:	6123      	str	r3, [r4, #16]
  40d416:	4675      	mov	r5, lr
  40d418:	e7b1      	b.n	40d37e <_printf_i+0x126>
  40d41a:	681a      	ldr	r2, [r3, #0]
  40d41c:	1d11      	adds	r1, r2, #4
  40d41e:	6019      	str	r1, [r3, #0]
  40d420:	6815      	ldr	r5, [r2, #0]
  40d422:	6862      	ldr	r2, [r4, #4]
  40d424:	2100      	movs	r1, #0
  40d426:	4628      	mov	r0, r5
  40d428:	f000 fb6a 	bl	40db00 <memchr>
  40d42c:	b108      	cbz	r0, 40d432 <_printf_i+0x1da>
  40d42e:	1b40      	subs	r0, r0, r5
  40d430:	6060      	str	r0, [r4, #4]
  40d432:	6863      	ldr	r3, [r4, #4]
  40d434:	6123      	str	r3, [r4, #16]
  40d436:	2300      	movs	r3, #0
  40d438:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  40d43c:	e79f      	b.n	40d37e <_printf_i+0x126>
  40d43e:	6923      	ldr	r3, [r4, #16]
  40d440:	462a      	mov	r2, r5
  40d442:	4639      	mov	r1, r7
  40d444:	4630      	mov	r0, r6
  40d446:	47c0      	blx	r8
  40d448:	3001      	adds	r0, #1
  40d44a:	d0a2      	beq.n	40d392 <_printf_i+0x13a>
  40d44c:	6823      	ldr	r3, [r4, #0]
  40d44e:	079b      	lsls	r3, r3, #30
  40d450:	d507      	bpl.n	40d462 <_printf_i+0x20a>
  40d452:	2500      	movs	r5, #0
  40d454:	f104 0919 	add.w	r9, r4, #25
  40d458:	68e3      	ldr	r3, [r4, #12]
  40d45a:	9a03      	ldr	r2, [sp, #12]
  40d45c:	1a9b      	subs	r3, r3, r2
  40d45e:	429d      	cmp	r5, r3
  40d460:	db05      	blt.n	40d46e <_printf_i+0x216>
  40d462:	68e0      	ldr	r0, [r4, #12]
  40d464:	9b03      	ldr	r3, [sp, #12]
  40d466:	4298      	cmp	r0, r3
  40d468:	bfb8      	it	lt
  40d46a:	4618      	movlt	r0, r3
  40d46c:	e793      	b.n	40d396 <_printf_i+0x13e>
  40d46e:	2301      	movs	r3, #1
  40d470:	464a      	mov	r2, r9
  40d472:	4639      	mov	r1, r7
  40d474:	4630      	mov	r0, r6
  40d476:	47c0      	blx	r8
  40d478:	3001      	adds	r0, #1
  40d47a:	d08a      	beq.n	40d392 <_printf_i+0x13a>
  40d47c:	3501      	adds	r5, #1
  40d47e:	e7eb      	b.n	40d458 <_printf_i+0x200>
  40d480:	2b00      	cmp	r3, #0
  40d482:	d1a7      	bne.n	40d3d4 <_printf_i+0x17c>
  40d484:	780b      	ldrb	r3, [r1, #0]
  40d486:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  40d48a:	f104 0542 	add.w	r5, r4, #66	; 0x42
  40d48e:	e765      	b.n	40d35c <_printf_i+0x104>
  40d490:	0040e602 	.word	0x0040e602
  40d494:	0040e5f1 	.word	0x0040e5f1

0040d498 <_scanf_chars>:
  40d498:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40d49c:	4615      	mov	r5, r2
  40d49e:	688a      	ldr	r2, [r1, #8]
  40d4a0:	4680      	mov	r8, r0
  40d4a2:	460c      	mov	r4, r1
  40d4a4:	b932      	cbnz	r2, 40d4b4 <_scanf_chars+0x1c>
  40d4a6:	698a      	ldr	r2, [r1, #24]
  40d4a8:	2a00      	cmp	r2, #0
  40d4aa:	bf0c      	ite	eq
  40d4ac:	2201      	moveq	r2, #1
  40d4ae:	f04f 32ff 	movne.w	r2, #4294967295
  40d4b2:	608a      	str	r2, [r1, #8]
  40d4b4:	6822      	ldr	r2, [r4, #0]
  40d4b6:	06d1      	lsls	r1, r2, #27
  40d4b8:	bf5f      	itttt	pl
  40d4ba:	681a      	ldrpl	r2, [r3, #0]
  40d4bc:	1d11      	addpl	r1, r2, #4
  40d4be:	6019      	strpl	r1, [r3, #0]
  40d4c0:	6817      	ldrpl	r7, [r2, #0]
  40d4c2:	2600      	movs	r6, #0
  40d4c4:	69a3      	ldr	r3, [r4, #24]
  40d4c6:	b1db      	cbz	r3, 40d500 <_scanf_chars+0x68>
  40d4c8:	2b01      	cmp	r3, #1
  40d4ca:	d107      	bne.n	40d4dc <_scanf_chars+0x44>
  40d4cc:	682b      	ldr	r3, [r5, #0]
  40d4ce:	6962      	ldr	r2, [r4, #20]
  40d4d0:	781b      	ldrb	r3, [r3, #0]
  40d4d2:	5cd3      	ldrb	r3, [r2, r3]
  40d4d4:	b9a3      	cbnz	r3, 40d500 <_scanf_chars+0x68>
  40d4d6:	2e00      	cmp	r6, #0
  40d4d8:	d132      	bne.n	40d540 <_scanf_chars+0xa8>
  40d4da:	e006      	b.n	40d4ea <_scanf_chars+0x52>
  40d4dc:	2b02      	cmp	r3, #2
  40d4de:	d007      	beq.n	40d4f0 <_scanf_chars+0x58>
  40d4e0:	2e00      	cmp	r6, #0
  40d4e2:	d12d      	bne.n	40d540 <_scanf_chars+0xa8>
  40d4e4:	69a3      	ldr	r3, [r4, #24]
  40d4e6:	2b01      	cmp	r3, #1
  40d4e8:	d12a      	bne.n	40d540 <_scanf_chars+0xa8>
  40d4ea:	2001      	movs	r0, #1
  40d4ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40d4f0:	f000 fae0 	bl	40dab4 <__locale_ctype_ptr>
  40d4f4:	682b      	ldr	r3, [r5, #0]
  40d4f6:	781b      	ldrb	r3, [r3, #0]
  40d4f8:	4418      	add	r0, r3
  40d4fa:	7843      	ldrb	r3, [r0, #1]
  40d4fc:	071b      	lsls	r3, r3, #28
  40d4fe:	d4ef      	bmi.n	40d4e0 <_scanf_chars+0x48>
  40d500:	6823      	ldr	r3, [r4, #0]
  40d502:	06da      	lsls	r2, r3, #27
  40d504:	bf5e      	ittt	pl
  40d506:	682b      	ldrpl	r3, [r5, #0]
  40d508:	781b      	ldrbpl	r3, [r3, #0]
  40d50a:	703b      	strbpl	r3, [r7, #0]
  40d50c:	682a      	ldr	r2, [r5, #0]
  40d50e:	686b      	ldr	r3, [r5, #4]
  40d510:	f102 0201 	add.w	r2, r2, #1
  40d514:	602a      	str	r2, [r5, #0]
  40d516:	68a2      	ldr	r2, [r4, #8]
  40d518:	f103 33ff 	add.w	r3, r3, #4294967295
  40d51c:	f102 32ff 	add.w	r2, r2, #4294967295
  40d520:	606b      	str	r3, [r5, #4]
  40d522:	f106 0601 	add.w	r6, r6, #1
  40d526:	bf58      	it	pl
  40d528:	3701      	addpl	r7, #1
  40d52a:	60a2      	str	r2, [r4, #8]
  40d52c:	b142      	cbz	r2, 40d540 <_scanf_chars+0xa8>
  40d52e:	2b00      	cmp	r3, #0
  40d530:	dcc8      	bgt.n	40d4c4 <_scanf_chars+0x2c>
  40d532:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
  40d536:	4629      	mov	r1, r5
  40d538:	4640      	mov	r0, r8
  40d53a:	4798      	blx	r3
  40d53c:	2800      	cmp	r0, #0
  40d53e:	d0c1      	beq.n	40d4c4 <_scanf_chars+0x2c>
  40d540:	6823      	ldr	r3, [r4, #0]
  40d542:	f013 0310 	ands.w	r3, r3, #16
  40d546:	d105      	bne.n	40d554 <_scanf_chars+0xbc>
  40d548:	68e2      	ldr	r2, [r4, #12]
  40d54a:	3201      	adds	r2, #1
  40d54c:	60e2      	str	r2, [r4, #12]
  40d54e:	69a2      	ldr	r2, [r4, #24]
  40d550:	b102      	cbz	r2, 40d554 <_scanf_chars+0xbc>
  40d552:	703b      	strb	r3, [r7, #0]
  40d554:	6923      	ldr	r3, [r4, #16]
  40d556:	441e      	add	r6, r3
  40d558:	6126      	str	r6, [r4, #16]
  40d55a:	2000      	movs	r0, #0
  40d55c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0040d560 <_scanf_i>:
  40d560:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40d564:	469a      	mov	sl, r3
  40d566:	4b74      	ldr	r3, [pc, #464]	; (40d738 <_scanf_i+0x1d8>)
  40d568:	460c      	mov	r4, r1
  40d56a:	4683      	mov	fp, r0
  40d56c:	4616      	mov	r6, r2
  40d56e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  40d572:	b087      	sub	sp, #28
  40d574:	ab03      	add	r3, sp, #12
  40d576:	68a7      	ldr	r7, [r4, #8]
  40d578:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  40d57c:	4b6f      	ldr	r3, [pc, #444]	; (40d73c <_scanf_i+0x1dc>)
  40d57e:	69a1      	ldr	r1, [r4, #24]
  40d580:	4a6f      	ldr	r2, [pc, #444]	; (40d740 <_scanf_i+0x1e0>)
  40d582:	2903      	cmp	r1, #3
  40d584:	bf18      	it	ne
  40d586:	461a      	movne	r2, r3
  40d588:	1e7b      	subs	r3, r7, #1
  40d58a:	f5b3 7fae 	cmp.w	r3, #348	; 0x15c
  40d58e:	bf84      	itt	hi
  40d590:	f240 135d 	movwhi	r3, #349	; 0x15d
  40d594:	60a3      	strhi	r3, [r4, #8]
  40d596:	6823      	ldr	r3, [r4, #0]
  40d598:	9200      	str	r2, [sp, #0]
  40d59a:	f443 6350 	orr.w	r3, r3, #3328	; 0xd00
  40d59e:	bf88      	it	hi
  40d5a0:	f46f 75ae 	mvnhi.w	r5, #348	; 0x15c
  40d5a4:	f104 091c 	add.w	r9, r4, #28
  40d5a8:	6023      	str	r3, [r4, #0]
  40d5aa:	bf8c      	ite	hi
  40d5ac:	197f      	addhi	r7, r7, r5
  40d5ae:	2700      	movls	r7, #0
  40d5b0:	464b      	mov	r3, r9
  40d5b2:	f04f 0800 	mov.w	r8, #0
  40d5b6:	9301      	str	r3, [sp, #4]
  40d5b8:	6831      	ldr	r1, [r6, #0]
  40d5ba:	ab03      	add	r3, sp, #12
  40d5bc:	2202      	movs	r2, #2
  40d5be:	f853 0028 	ldr.w	r0, [r3, r8, lsl #2]
  40d5c2:	7809      	ldrb	r1, [r1, #0]
  40d5c4:	f000 fa9c 	bl	40db00 <memchr>
  40d5c8:	9b01      	ldr	r3, [sp, #4]
  40d5ca:	b328      	cbz	r0, 40d618 <_scanf_i+0xb8>
  40d5cc:	f1b8 0f01 	cmp.w	r8, #1
  40d5d0:	d156      	bne.n	40d680 <_scanf_i+0x120>
  40d5d2:	6862      	ldr	r2, [r4, #4]
  40d5d4:	b92a      	cbnz	r2, 40d5e2 <_scanf_i+0x82>
  40d5d6:	2208      	movs	r2, #8
  40d5d8:	6062      	str	r2, [r4, #4]
  40d5da:	6822      	ldr	r2, [r4, #0]
  40d5dc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  40d5e0:	6022      	str	r2, [r4, #0]
  40d5e2:	6822      	ldr	r2, [r4, #0]
  40d5e4:	f422 62a0 	bic.w	r2, r2, #1280	; 0x500
  40d5e8:	6022      	str	r2, [r4, #0]
  40d5ea:	68a2      	ldr	r2, [r4, #8]
  40d5ec:	1e51      	subs	r1, r2, #1
  40d5ee:	60a1      	str	r1, [r4, #8]
  40d5f0:	b192      	cbz	r2, 40d618 <_scanf_i+0xb8>
  40d5f2:	6832      	ldr	r2, [r6, #0]
  40d5f4:	1c51      	adds	r1, r2, #1
  40d5f6:	6031      	str	r1, [r6, #0]
  40d5f8:	7812      	ldrb	r2, [r2, #0]
  40d5fa:	701a      	strb	r2, [r3, #0]
  40d5fc:	1c5d      	adds	r5, r3, #1
  40d5fe:	6873      	ldr	r3, [r6, #4]
  40d600:	3b01      	subs	r3, #1
  40d602:	2b00      	cmp	r3, #0
  40d604:	6073      	str	r3, [r6, #4]
  40d606:	dc06      	bgt.n	40d616 <_scanf_i+0xb6>
  40d608:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
  40d60c:	4631      	mov	r1, r6
  40d60e:	4658      	mov	r0, fp
  40d610:	4798      	blx	r3
  40d612:	2800      	cmp	r0, #0
  40d614:	d176      	bne.n	40d704 <_scanf_i+0x1a4>
  40d616:	462b      	mov	r3, r5
  40d618:	f108 0801 	add.w	r8, r8, #1
  40d61c:	f1b8 0f03 	cmp.w	r8, #3
  40d620:	d1c9      	bne.n	40d5b6 <_scanf_i+0x56>
  40d622:	6862      	ldr	r2, [r4, #4]
  40d624:	b90a      	cbnz	r2, 40d62a <_scanf_i+0xca>
  40d626:	220a      	movs	r2, #10
  40d628:	6062      	str	r2, [r4, #4]
  40d62a:	6862      	ldr	r2, [r4, #4]
  40d62c:	4945      	ldr	r1, [pc, #276]	; (40d744 <_scanf_i+0x1e4>)
  40d62e:	6960      	ldr	r0, [r4, #20]
  40d630:	9301      	str	r3, [sp, #4]
  40d632:	1a89      	subs	r1, r1, r2
  40d634:	f000 f89a 	bl	40d76c <__sccl>
  40d638:	9b01      	ldr	r3, [sp, #4]
  40d63a:	f04f 0800 	mov.w	r8, #0
  40d63e:	461d      	mov	r5, r3
  40d640:	68a3      	ldr	r3, [r4, #8]
  40d642:	2b00      	cmp	r3, #0
  40d644:	d038      	beq.n	40d6b8 <_scanf_i+0x158>
  40d646:	6831      	ldr	r1, [r6, #0]
  40d648:	6960      	ldr	r0, [r4, #20]
  40d64a:	780a      	ldrb	r2, [r1, #0]
  40d64c:	5c80      	ldrb	r0, [r0, r2]
  40d64e:	2800      	cmp	r0, #0
  40d650:	d032      	beq.n	40d6b8 <_scanf_i+0x158>
  40d652:	2a30      	cmp	r2, #48	; 0x30
  40d654:	6822      	ldr	r2, [r4, #0]
  40d656:	d121      	bne.n	40d69c <_scanf_i+0x13c>
  40d658:	0510      	lsls	r0, r2, #20
  40d65a:	d51f      	bpl.n	40d69c <_scanf_i+0x13c>
  40d65c:	f108 0801 	add.w	r8, r8, #1
  40d660:	b117      	cbz	r7, 40d668 <_scanf_i+0x108>
  40d662:	3301      	adds	r3, #1
  40d664:	3f01      	subs	r7, #1
  40d666:	60a3      	str	r3, [r4, #8]
  40d668:	6873      	ldr	r3, [r6, #4]
  40d66a:	3b01      	subs	r3, #1
  40d66c:	2b00      	cmp	r3, #0
  40d66e:	6073      	str	r3, [r6, #4]
  40d670:	dd1b      	ble.n	40d6aa <_scanf_i+0x14a>
  40d672:	6833      	ldr	r3, [r6, #0]
  40d674:	3301      	adds	r3, #1
  40d676:	6033      	str	r3, [r6, #0]
  40d678:	68a3      	ldr	r3, [r4, #8]
  40d67a:	3b01      	subs	r3, #1
  40d67c:	60a3      	str	r3, [r4, #8]
  40d67e:	e7df      	b.n	40d640 <_scanf_i+0xe0>
  40d680:	f1b8 0f02 	cmp.w	r8, #2
  40d684:	d1b1      	bne.n	40d5ea <_scanf_i+0x8a>
  40d686:	6822      	ldr	r2, [r4, #0]
  40d688:	f402 61c0 	and.w	r1, r2, #1536	; 0x600
  40d68c:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  40d690:	d1c2      	bne.n	40d618 <_scanf_i+0xb8>
  40d692:	2110      	movs	r1, #16
  40d694:	6061      	str	r1, [r4, #4]
  40d696:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  40d69a:	e7a5      	b.n	40d5e8 <_scanf_i+0x88>
  40d69c:	f422 6210 	bic.w	r2, r2, #2304	; 0x900
  40d6a0:	6022      	str	r2, [r4, #0]
  40d6a2:	780b      	ldrb	r3, [r1, #0]
  40d6a4:	702b      	strb	r3, [r5, #0]
  40d6a6:	3501      	adds	r5, #1
  40d6a8:	e7de      	b.n	40d668 <_scanf_i+0x108>
  40d6aa:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
  40d6ae:	4631      	mov	r1, r6
  40d6b0:	4658      	mov	r0, fp
  40d6b2:	4798      	blx	r3
  40d6b4:	2800      	cmp	r0, #0
  40d6b6:	d0df      	beq.n	40d678 <_scanf_i+0x118>
  40d6b8:	6823      	ldr	r3, [r4, #0]
  40d6ba:	05d9      	lsls	r1, r3, #23
  40d6bc:	d50c      	bpl.n	40d6d8 <_scanf_i+0x178>
  40d6be:	454d      	cmp	r5, r9
  40d6c0:	d908      	bls.n	40d6d4 <_scanf_i+0x174>
  40d6c2:	f815 1c01 	ldrb.w	r1, [r5, #-1]
  40d6c6:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
  40d6ca:	4632      	mov	r2, r6
  40d6cc:	4658      	mov	r0, fp
  40d6ce:	4798      	blx	r3
  40d6d0:	1e6f      	subs	r7, r5, #1
  40d6d2:	463d      	mov	r5, r7
  40d6d4:	454d      	cmp	r5, r9
  40d6d6:	d02c      	beq.n	40d732 <_scanf_i+0x1d2>
  40d6d8:	6822      	ldr	r2, [r4, #0]
  40d6da:	f012 0210 	ands.w	r2, r2, #16
  40d6de:	d11e      	bne.n	40d71e <_scanf_i+0x1be>
  40d6e0:	702a      	strb	r2, [r5, #0]
  40d6e2:	6863      	ldr	r3, [r4, #4]
  40d6e4:	9e00      	ldr	r6, [sp, #0]
  40d6e6:	4649      	mov	r1, r9
  40d6e8:	4658      	mov	r0, fp
  40d6ea:	47b0      	blx	r6
  40d6ec:	6822      	ldr	r2, [r4, #0]
  40d6ee:	f8da 3000 	ldr.w	r3, [sl]
  40d6f2:	f012 0f20 	tst.w	r2, #32
  40d6f6:	d008      	beq.n	40d70a <_scanf_i+0x1aa>
  40d6f8:	1d1a      	adds	r2, r3, #4
  40d6fa:	f8ca 2000 	str.w	r2, [sl]
  40d6fe:	681b      	ldr	r3, [r3, #0]
  40d700:	6018      	str	r0, [r3, #0]
  40d702:	e009      	b.n	40d718 <_scanf_i+0x1b8>
  40d704:	f04f 0800 	mov.w	r8, #0
  40d708:	e7d6      	b.n	40d6b8 <_scanf_i+0x158>
  40d70a:	07d2      	lsls	r2, r2, #31
  40d70c:	d5f4      	bpl.n	40d6f8 <_scanf_i+0x198>
  40d70e:	1d1a      	adds	r2, r3, #4
  40d710:	f8ca 2000 	str.w	r2, [sl]
  40d714:	681b      	ldr	r3, [r3, #0]
  40d716:	8018      	strh	r0, [r3, #0]
  40d718:	68e3      	ldr	r3, [r4, #12]
  40d71a:	3301      	adds	r3, #1
  40d71c:	60e3      	str	r3, [r4, #12]
  40d71e:	eba5 0509 	sub.w	r5, r5, r9
  40d722:	44a8      	add	r8, r5
  40d724:	6925      	ldr	r5, [r4, #16]
  40d726:	4445      	add	r5, r8
  40d728:	6125      	str	r5, [r4, #16]
  40d72a:	2000      	movs	r0, #0
  40d72c:	b007      	add	sp, #28
  40d72e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40d732:	2001      	movs	r0, #1
  40d734:	e7fa      	b.n	40d72c <_scanf_i+0x1cc>
  40d736:	bf00      	nop
  40d738:	0040e614 	.word	0x0040e614
  40d73c:	0040d9ed 	.word	0x0040d9ed
  40d740:	0040d8cd 	.word	0x0040d8cd
  40d744:	0040e630 	.word	0x0040e630

0040d748 <_read_r>:
  40d748:	b538      	push	{r3, r4, r5, lr}
  40d74a:	4c07      	ldr	r4, [pc, #28]	; (40d768 <_read_r+0x20>)
  40d74c:	4605      	mov	r5, r0
  40d74e:	4608      	mov	r0, r1
  40d750:	4611      	mov	r1, r2
  40d752:	2200      	movs	r2, #0
  40d754:	6022      	str	r2, [r4, #0]
  40d756:	461a      	mov	r2, r3
  40d758:	f7fd f898 	bl	40a88c <_read>
  40d75c:	1c43      	adds	r3, r0, #1
  40d75e:	d102      	bne.n	40d766 <_read_r+0x1e>
  40d760:	6823      	ldr	r3, [r4, #0]
  40d762:	b103      	cbz	r3, 40d766 <_read_r+0x1e>
  40d764:	602b      	str	r3, [r5, #0]
  40d766:	bd38      	pop	{r3, r4, r5, pc}
  40d768:	20011804 	.word	0x20011804

0040d76c <__sccl>:
  40d76c:	b570      	push	{r4, r5, r6, lr}
  40d76e:	780b      	ldrb	r3, [r1, #0]
  40d770:	2b5e      	cmp	r3, #94	; 0x5e
  40d772:	bf13      	iteet	ne
  40d774:	1c4a      	addne	r2, r1, #1
  40d776:	1c8a      	addeq	r2, r1, #2
  40d778:	784b      	ldrbeq	r3, [r1, #1]
  40d77a:	2100      	movne	r1, #0
  40d77c:	bf08      	it	eq
  40d77e:	2101      	moveq	r1, #1
  40d780:	1e44      	subs	r4, r0, #1
  40d782:	f100 05ff 	add.w	r5, r0, #255	; 0xff
  40d786:	f804 1f01 	strb.w	r1, [r4, #1]!
  40d78a:	42a5      	cmp	r5, r4
  40d78c:	d1fb      	bne.n	40d786 <__sccl+0x1a>
  40d78e:	b913      	cbnz	r3, 40d796 <__sccl+0x2a>
  40d790:	3a01      	subs	r2, #1
  40d792:	4610      	mov	r0, r2
  40d794:	bd70      	pop	{r4, r5, r6, pc}
  40d796:	f081 0401 	eor.w	r4, r1, #1
  40d79a:	54c4      	strb	r4, [r0, r3]
  40d79c:	4611      	mov	r1, r2
  40d79e:	780d      	ldrb	r5, [r1, #0]
  40d7a0:	2d2d      	cmp	r5, #45	; 0x2d
  40d7a2:	f101 0201 	add.w	r2, r1, #1
  40d7a6:	d006      	beq.n	40d7b6 <__sccl+0x4a>
  40d7a8:	2d5d      	cmp	r5, #93	; 0x5d
  40d7aa:	d0f2      	beq.n	40d792 <__sccl+0x26>
  40d7ac:	b90d      	cbnz	r5, 40d7b2 <__sccl+0x46>
  40d7ae:	460a      	mov	r2, r1
  40d7b0:	e7ef      	b.n	40d792 <__sccl+0x26>
  40d7b2:	462b      	mov	r3, r5
  40d7b4:	e7f1      	b.n	40d79a <__sccl+0x2e>
  40d7b6:	784e      	ldrb	r6, [r1, #1]
  40d7b8:	2e5d      	cmp	r6, #93	; 0x5d
  40d7ba:	d0fa      	beq.n	40d7b2 <__sccl+0x46>
  40d7bc:	42b3      	cmp	r3, r6
  40d7be:	dcf8      	bgt.n	40d7b2 <__sccl+0x46>
  40d7c0:	3102      	adds	r1, #2
  40d7c2:	3301      	adds	r3, #1
  40d7c4:	429e      	cmp	r6, r3
  40d7c6:	54c4      	strb	r4, [r0, r3]
  40d7c8:	dcfb      	bgt.n	40d7c2 <__sccl+0x56>
  40d7ca:	e7e8      	b.n	40d79e <__sccl+0x32>

0040d7cc <_strtol_l.isra.0>:
  40d7cc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40d7d0:	4680      	mov	r8, r0
  40d7d2:	4689      	mov	r9, r1
  40d7d4:	4692      	mov	sl, r2
  40d7d6:	461f      	mov	r7, r3
  40d7d8:	468b      	mov	fp, r1
  40d7da:	465d      	mov	r5, fp
  40d7dc:	980a      	ldr	r0, [sp, #40]	; 0x28
  40d7de:	f815 4b01 	ldrb.w	r4, [r5], #1
  40d7e2:	f000 f963 	bl	40daac <__locale_ctype_ptr_l>
  40d7e6:	4420      	add	r0, r4
  40d7e8:	7846      	ldrb	r6, [r0, #1]
  40d7ea:	f016 0608 	ands.w	r6, r6, #8
  40d7ee:	d10b      	bne.n	40d808 <_strtol_l.isra.0+0x3c>
  40d7f0:	2c2d      	cmp	r4, #45	; 0x2d
  40d7f2:	d10b      	bne.n	40d80c <_strtol_l.isra.0+0x40>
  40d7f4:	782c      	ldrb	r4, [r5, #0]
  40d7f6:	2601      	movs	r6, #1
  40d7f8:	f10b 0502 	add.w	r5, fp, #2
  40d7fc:	b167      	cbz	r7, 40d818 <_strtol_l.isra.0+0x4c>
  40d7fe:	2f10      	cmp	r7, #16
  40d800:	d114      	bne.n	40d82c <_strtol_l.isra.0+0x60>
  40d802:	2c30      	cmp	r4, #48	; 0x30
  40d804:	d00a      	beq.n	40d81c <_strtol_l.isra.0+0x50>
  40d806:	e011      	b.n	40d82c <_strtol_l.isra.0+0x60>
  40d808:	46ab      	mov	fp, r5
  40d80a:	e7e6      	b.n	40d7da <_strtol_l.isra.0+0xe>
  40d80c:	2c2b      	cmp	r4, #43	; 0x2b
  40d80e:	bf04      	itt	eq
  40d810:	782c      	ldrbeq	r4, [r5, #0]
  40d812:	f10b 0502 	addeq.w	r5, fp, #2
  40d816:	e7f1      	b.n	40d7fc <_strtol_l.isra.0+0x30>
  40d818:	2c30      	cmp	r4, #48	; 0x30
  40d81a:	d127      	bne.n	40d86c <_strtol_l.isra.0+0xa0>
  40d81c:	782b      	ldrb	r3, [r5, #0]
  40d81e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  40d822:	2b58      	cmp	r3, #88	; 0x58
  40d824:	d14b      	bne.n	40d8be <_strtol_l.isra.0+0xf2>
  40d826:	786c      	ldrb	r4, [r5, #1]
  40d828:	2710      	movs	r7, #16
  40d82a:	3502      	adds	r5, #2
  40d82c:	2e00      	cmp	r6, #0
  40d82e:	bf0c      	ite	eq
  40d830:	f06f 4100 	mvneq.w	r1, #2147483648	; 0x80000000
  40d834:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
  40d838:	2200      	movs	r2, #0
  40d83a:	fbb1 fef7 	udiv	lr, r1, r7
  40d83e:	4610      	mov	r0, r2
  40d840:	fb07 1c1e 	mls	ip, r7, lr, r1
  40d844:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
  40d848:	2b09      	cmp	r3, #9
  40d84a:	d811      	bhi.n	40d870 <_strtol_l.isra.0+0xa4>
  40d84c:	461c      	mov	r4, r3
  40d84e:	42a7      	cmp	r7, r4
  40d850:	dd1d      	ble.n	40d88e <_strtol_l.isra.0+0xc2>
  40d852:	1c53      	adds	r3, r2, #1
  40d854:	d007      	beq.n	40d866 <_strtol_l.isra.0+0x9a>
  40d856:	4586      	cmp	lr, r0
  40d858:	d316      	bcc.n	40d888 <_strtol_l.isra.0+0xbc>
  40d85a:	d101      	bne.n	40d860 <_strtol_l.isra.0+0x94>
  40d85c:	45a4      	cmp	ip, r4
  40d85e:	db13      	blt.n	40d888 <_strtol_l.isra.0+0xbc>
  40d860:	fb00 4007 	mla	r0, r0, r7, r4
  40d864:	2201      	movs	r2, #1
  40d866:	f815 4b01 	ldrb.w	r4, [r5], #1
  40d86a:	e7eb      	b.n	40d844 <_strtol_l.isra.0+0x78>
  40d86c:	270a      	movs	r7, #10
  40d86e:	e7dd      	b.n	40d82c <_strtol_l.isra.0+0x60>
  40d870:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
  40d874:	2b19      	cmp	r3, #25
  40d876:	d801      	bhi.n	40d87c <_strtol_l.isra.0+0xb0>
  40d878:	3c37      	subs	r4, #55	; 0x37
  40d87a:	e7e8      	b.n	40d84e <_strtol_l.isra.0+0x82>
  40d87c:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
  40d880:	2b19      	cmp	r3, #25
  40d882:	d804      	bhi.n	40d88e <_strtol_l.isra.0+0xc2>
  40d884:	3c57      	subs	r4, #87	; 0x57
  40d886:	e7e2      	b.n	40d84e <_strtol_l.isra.0+0x82>
  40d888:	f04f 32ff 	mov.w	r2, #4294967295
  40d88c:	e7eb      	b.n	40d866 <_strtol_l.isra.0+0x9a>
  40d88e:	1c53      	adds	r3, r2, #1
  40d890:	d108      	bne.n	40d8a4 <_strtol_l.isra.0+0xd8>
  40d892:	2322      	movs	r3, #34	; 0x22
  40d894:	f8c8 3000 	str.w	r3, [r8]
  40d898:	4608      	mov	r0, r1
  40d89a:	f1ba 0f00 	cmp.w	sl, #0
  40d89e:	d107      	bne.n	40d8b0 <_strtol_l.isra.0+0xe4>
  40d8a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40d8a4:	b106      	cbz	r6, 40d8a8 <_strtol_l.isra.0+0xdc>
  40d8a6:	4240      	negs	r0, r0
  40d8a8:	f1ba 0f00 	cmp.w	sl, #0
  40d8ac:	d00c      	beq.n	40d8c8 <_strtol_l.isra.0+0xfc>
  40d8ae:	b122      	cbz	r2, 40d8ba <_strtol_l.isra.0+0xee>
  40d8b0:	3d01      	subs	r5, #1
  40d8b2:	f8ca 5000 	str.w	r5, [sl]
  40d8b6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40d8ba:	464d      	mov	r5, r9
  40d8bc:	e7f9      	b.n	40d8b2 <_strtol_l.isra.0+0xe6>
  40d8be:	2430      	movs	r4, #48	; 0x30
  40d8c0:	2f00      	cmp	r7, #0
  40d8c2:	d1b3      	bne.n	40d82c <_strtol_l.isra.0+0x60>
  40d8c4:	2708      	movs	r7, #8
  40d8c6:	e7b1      	b.n	40d82c <_strtol_l.isra.0+0x60>
  40d8c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0040d8cc <_strtol_r>:
  40d8cc:	b537      	push	{r0, r1, r2, r4, r5, lr}
  40d8ce:	4c06      	ldr	r4, [pc, #24]	; (40d8e8 <_strtol_r+0x1c>)
  40d8d0:	4d06      	ldr	r5, [pc, #24]	; (40d8ec <_strtol_r+0x20>)
  40d8d2:	6824      	ldr	r4, [r4, #0]
  40d8d4:	6a24      	ldr	r4, [r4, #32]
  40d8d6:	2c00      	cmp	r4, #0
  40d8d8:	bf08      	it	eq
  40d8da:	462c      	moveq	r4, r5
  40d8dc:	9400      	str	r4, [sp, #0]
  40d8de:	f7ff ff75 	bl	40d7cc <_strtol_l.isra.0>
  40d8e2:	b003      	add	sp, #12
  40d8e4:	bd30      	pop	{r4, r5, pc}
  40d8e6:	bf00      	nop
  40d8e8:	20000020 	.word	0x20000020
  40d8ec:	20000084 	.word	0x20000084

0040d8f0 <_strtoul_l.isra.0>:
  40d8f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40d8f4:	4680      	mov	r8, r0
  40d8f6:	4689      	mov	r9, r1
  40d8f8:	4692      	mov	sl, r2
  40d8fa:	461e      	mov	r6, r3
  40d8fc:	460f      	mov	r7, r1
  40d8fe:	463d      	mov	r5, r7
  40d900:	9808      	ldr	r0, [sp, #32]
  40d902:	f815 4b01 	ldrb.w	r4, [r5], #1
  40d906:	f000 f8d1 	bl	40daac <__locale_ctype_ptr_l>
  40d90a:	4420      	add	r0, r4
  40d90c:	7843      	ldrb	r3, [r0, #1]
  40d90e:	f013 0308 	ands.w	r3, r3, #8
  40d912:	d10a      	bne.n	40d92a <_strtoul_l.isra.0+0x3a>
  40d914:	2c2d      	cmp	r4, #45	; 0x2d
  40d916:	d10a      	bne.n	40d92e <_strtoul_l.isra.0+0x3e>
  40d918:	782c      	ldrb	r4, [r5, #0]
  40d91a:	2301      	movs	r3, #1
  40d91c:	1cbd      	adds	r5, r7, #2
  40d91e:	b15e      	cbz	r6, 40d938 <_strtoul_l.isra.0+0x48>
  40d920:	2e10      	cmp	r6, #16
  40d922:	d113      	bne.n	40d94c <_strtoul_l.isra.0+0x5c>
  40d924:	2c30      	cmp	r4, #48	; 0x30
  40d926:	d009      	beq.n	40d93c <_strtoul_l.isra.0+0x4c>
  40d928:	e010      	b.n	40d94c <_strtoul_l.isra.0+0x5c>
  40d92a:	462f      	mov	r7, r5
  40d92c:	e7e7      	b.n	40d8fe <_strtoul_l.isra.0+0xe>
  40d92e:	2c2b      	cmp	r4, #43	; 0x2b
  40d930:	bf04      	itt	eq
  40d932:	782c      	ldrbeq	r4, [r5, #0]
  40d934:	1cbd      	addeq	r5, r7, #2
  40d936:	e7f2      	b.n	40d91e <_strtoul_l.isra.0+0x2e>
  40d938:	2c30      	cmp	r4, #48	; 0x30
  40d93a:	d125      	bne.n	40d988 <_strtoul_l.isra.0+0x98>
  40d93c:	782a      	ldrb	r2, [r5, #0]
  40d93e:	f002 02df 	and.w	r2, r2, #223	; 0xdf
  40d942:	2a58      	cmp	r2, #88	; 0x58
  40d944:	d14a      	bne.n	40d9dc <_strtoul_l.isra.0+0xec>
  40d946:	786c      	ldrb	r4, [r5, #1]
  40d948:	2610      	movs	r6, #16
  40d94a:	3502      	adds	r5, #2
  40d94c:	f04f 31ff 	mov.w	r1, #4294967295
  40d950:	2700      	movs	r7, #0
  40d952:	fbb1 f1f6 	udiv	r1, r1, r6
  40d956:	fb06 fe01 	mul.w	lr, r6, r1
  40d95a:	ea6f 0e0e 	mvn.w	lr, lr
  40d95e:	4638      	mov	r0, r7
  40d960:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
  40d964:	2a09      	cmp	r2, #9
  40d966:	d811      	bhi.n	40d98c <_strtoul_l.isra.0+0x9c>
  40d968:	4614      	mov	r4, r2
  40d96a:	42a6      	cmp	r6, r4
  40d96c:	dd1d      	ble.n	40d9aa <_strtoul_l.isra.0+0xba>
  40d96e:	2f00      	cmp	r7, #0
  40d970:	db18      	blt.n	40d9a4 <_strtoul_l.isra.0+0xb4>
  40d972:	4281      	cmp	r1, r0
  40d974:	d316      	bcc.n	40d9a4 <_strtoul_l.isra.0+0xb4>
  40d976:	d101      	bne.n	40d97c <_strtoul_l.isra.0+0x8c>
  40d978:	45a6      	cmp	lr, r4
  40d97a:	db13      	blt.n	40d9a4 <_strtoul_l.isra.0+0xb4>
  40d97c:	fb00 4006 	mla	r0, r0, r6, r4
  40d980:	2701      	movs	r7, #1
  40d982:	f815 4b01 	ldrb.w	r4, [r5], #1
  40d986:	e7eb      	b.n	40d960 <_strtoul_l.isra.0+0x70>
  40d988:	260a      	movs	r6, #10
  40d98a:	e7df      	b.n	40d94c <_strtoul_l.isra.0+0x5c>
  40d98c:	f1a4 0241 	sub.w	r2, r4, #65	; 0x41
  40d990:	2a19      	cmp	r2, #25
  40d992:	d801      	bhi.n	40d998 <_strtoul_l.isra.0+0xa8>
  40d994:	3c37      	subs	r4, #55	; 0x37
  40d996:	e7e8      	b.n	40d96a <_strtoul_l.isra.0+0x7a>
  40d998:	f1a4 0261 	sub.w	r2, r4, #97	; 0x61
  40d99c:	2a19      	cmp	r2, #25
  40d99e:	d804      	bhi.n	40d9aa <_strtoul_l.isra.0+0xba>
  40d9a0:	3c57      	subs	r4, #87	; 0x57
  40d9a2:	e7e2      	b.n	40d96a <_strtoul_l.isra.0+0x7a>
  40d9a4:	f04f 37ff 	mov.w	r7, #4294967295
  40d9a8:	e7eb      	b.n	40d982 <_strtoul_l.isra.0+0x92>
  40d9aa:	2f00      	cmp	r7, #0
  40d9ac:	da09      	bge.n	40d9c2 <_strtoul_l.isra.0+0xd2>
  40d9ae:	2322      	movs	r3, #34	; 0x22
  40d9b0:	f8c8 3000 	str.w	r3, [r8]
  40d9b4:	f04f 30ff 	mov.w	r0, #4294967295
  40d9b8:	f1ba 0f00 	cmp.w	sl, #0
  40d9bc:	d107      	bne.n	40d9ce <_strtoul_l.isra.0+0xde>
  40d9be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40d9c2:	b103      	cbz	r3, 40d9c6 <_strtoul_l.isra.0+0xd6>
  40d9c4:	4240      	negs	r0, r0
  40d9c6:	f1ba 0f00 	cmp.w	sl, #0
  40d9ca:	d00c      	beq.n	40d9e6 <_strtoul_l.isra.0+0xf6>
  40d9cc:	b127      	cbz	r7, 40d9d8 <_strtoul_l.isra.0+0xe8>
  40d9ce:	3d01      	subs	r5, #1
  40d9d0:	f8ca 5000 	str.w	r5, [sl]
  40d9d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40d9d8:	464d      	mov	r5, r9
  40d9da:	e7f9      	b.n	40d9d0 <_strtoul_l.isra.0+0xe0>
  40d9dc:	2430      	movs	r4, #48	; 0x30
  40d9de:	2e00      	cmp	r6, #0
  40d9e0:	d1b4      	bne.n	40d94c <_strtoul_l.isra.0+0x5c>
  40d9e2:	2608      	movs	r6, #8
  40d9e4:	e7b2      	b.n	40d94c <_strtoul_l.isra.0+0x5c>
  40d9e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

0040d9ec <_strtoul_r>:
  40d9ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
  40d9ee:	4c06      	ldr	r4, [pc, #24]	; (40da08 <_strtoul_r+0x1c>)
  40d9f0:	4d06      	ldr	r5, [pc, #24]	; (40da0c <_strtoul_r+0x20>)
  40d9f2:	6824      	ldr	r4, [r4, #0]
  40d9f4:	6a24      	ldr	r4, [r4, #32]
  40d9f6:	2c00      	cmp	r4, #0
  40d9f8:	bf08      	it	eq
  40d9fa:	462c      	moveq	r4, r5
  40d9fc:	9400      	str	r4, [sp, #0]
  40d9fe:	f7ff ff77 	bl	40d8f0 <_strtoul_l.isra.0>
  40da02:	b003      	add	sp, #12
  40da04:	bd30      	pop	{r4, r5, pc}
  40da06:	bf00      	nop
  40da08:	20000020 	.word	0x20000020
  40da0c:	20000084 	.word	0x20000084

0040da10 <__submore>:
  40da10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40da14:	460c      	mov	r4, r1
  40da16:	6b49      	ldr	r1, [r1, #52]	; 0x34
  40da18:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40da1c:	4299      	cmp	r1, r3
  40da1e:	d11e      	bne.n	40da5e <__submore+0x4e>
  40da20:	f44f 6180 	mov.w	r1, #1024	; 0x400
  40da24:	f7fe fc86 	bl	40c334 <_malloc_r>
  40da28:	b918      	cbnz	r0, 40da32 <__submore+0x22>
  40da2a:	f04f 30ff 	mov.w	r0, #4294967295
  40da2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40da32:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40da36:	63a3      	str	r3, [r4, #56]	; 0x38
  40da38:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
  40da3c:	6360      	str	r0, [r4, #52]	; 0x34
  40da3e:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
  40da42:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  40da46:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
  40da4a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  40da4e:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
  40da52:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
  40da56:	6020      	str	r0, [r4, #0]
  40da58:	2000      	movs	r0, #0
  40da5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40da5e:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  40da60:	0077      	lsls	r7, r6, #1
  40da62:	463a      	mov	r2, r7
  40da64:	f000 f8b6 	bl	40dbd4 <_realloc_r>
  40da68:	4605      	mov	r5, r0
  40da6a:	2800      	cmp	r0, #0
  40da6c:	d0dd      	beq.n	40da2a <__submore+0x1a>
  40da6e:	eb00 0806 	add.w	r8, r0, r6
  40da72:	4601      	mov	r1, r0
  40da74:	4632      	mov	r2, r6
  40da76:	4640      	mov	r0, r8
  40da78:	f7fe fbfa 	bl	40c270 <memcpy>
  40da7c:	f8c4 8000 	str.w	r8, [r4]
  40da80:	6365      	str	r5, [r4, #52]	; 0x34
  40da82:	63a7      	str	r7, [r4, #56]	; 0x38
  40da84:	e7e8      	b.n	40da58 <__submore+0x48>
	...

0040da88 <_fstat_r>:
  40da88:	b538      	push	{r3, r4, r5, lr}
  40da8a:	4c07      	ldr	r4, [pc, #28]	; (40daa8 <_fstat_r+0x20>)
  40da8c:	2300      	movs	r3, #0
  40da8e:	4605      	mov	r5, r0
  40da90:	4608      	mov	r0, r1
  40da92:	4611      	mov	r1, r2
  40da94:	6023      	str	r3, [r4, #0]
  40da96:	f7fd fc00 	bl	40b29a <_fstat>
  40da9a:	1c43      	adds	r3, r0, #1
  40da9c:	d102      	bne.n	40daa4 <_fstat_r+0x1c>
  40da9e:	6823      	ldr	r3, [r4, #0]
  40daa0:	b103      	cbz	r3, 40daa4 <_fstat_r+0x1c>
  40daa2:	602b      	str	r3, [r5, #0]
  40daa4:	bd38      	pop	{r3, r4, r5, pc}
  40daa6:	bf00      	nop
  40daa8:	20011804 	.word	0x20011804

0040daac <__locale_ctype_ptr_l>:
  40daac:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
  40dab0:	4770      	bx	lr
	...

0040dab4 <__locale_ctype_ptr>:
  40dab4:	4b04      	ldr	r3, [pc, #16]	; (40dac8 <__locale_ctype_ptr+0x14>)
  40dab6:	4a05      	ldr	r2, [pc, #20]	; (40dacc <__locale_ctype_ptr+0x18>)
  40dab8:	681b      	ldr	r3, [r3, #0]
  40daba:	6a1b      	ldr	r3, [r3, #32]
  40dabc:	2b00      	cmp	r3, #0
  40dabe:	bf08      	it	eq
  40dac0:	4613      	moveq	r3, r2
  40dac2:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
  40dac6:	4770      	bx	lr
  40dac8:	20000020 	.word	0x20000020
  40dacc:	20000084 	.word	0x20000084

0040dad0 <__ascii_mbtowc>:
  40dad0:	b082      	sub	sp, #8
  40dad2:	b901      	cbnz	r1, 40dad6 <__ascii_mbtowc+0x6>
  40dad4:	a901      	add	r1, sp, #4
  40dad6:	b142      	cbz	r2, 40daea <__ascii_mbtowc+0x1a>
  40dad8:	b14b      	cbz	r3, 40daee <__ascii_mbtowc+0x1e>
  40dada:	7813      	ldrb	r3, [r2, #0]
  40dadc:	600b      	str	r3, [r1, #0]
  40dade:	7812      	ldrb	r2, [r2, #0]
  40dae0:	1c10      	adds	r0, r2, #0
  40dae2:	bf18      	it	ne
  40dae4:	2001      	movne	r0, #1
  40dae6:	b002      	add	sp, #8
  40dae8:	4770      	bx	lr
  40daea:	4610      	mov	r0, r2
  40daec:	e7fb      	b.n	40dae6 <__ascii_mbtowc+0x16>
  40daee:	f06f 0001 	mvn.w	r0, #1
  40daf2:	e7f8      	b.n	40dae6 <__ascii_mbtowc+0x16>
	...

0040db00 <memchr>:
  40db00:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  40db04:	2a10      	cmp	r2, #16
  40db06:	db2b      	blt.n	40db60 <memchr+0x60>
  40db08:	f010 0f07 	tst.w	r0, #7
  40db0c:	d008      	beq.n	40db20 <memchr+0x20>
  40db0e:	f810 3b01 	ldrb.w	r3, [r0], #1
  40db12:	3a01      	subs	r2, #1
  40db14:	428b      	cmp	r3, r1
  40db16:	d02d      	beq.n	40db74 <memchr+0x74>
  40db18:	f010 0f07 	tst.w	r0, #7
  40db1c:	b342      	cbz	r2, 40db70 <memchr+0x70>
  40db1e:	d1f6      	bne.n	40db0e <memchr+0xe>
  40db20:	b4f0      	push	{r4, r5, r6, r7}
  40db22:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  40db26:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  40db2a:	f022 0407 	bic.w	r4, r2, #7
  40db2e:	f07f 0700 	mvns.w	r7, #0
  40db32:	2300      	movs	r3, #0
  40db34:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  40db38:	3c08      	subs	r4, #8
  40db3a:	ea85 0501 	eor.w	r5, r5, r1
  40db3e:	ea86 0601 	eor.w	r6, r6, r1
  40db42:	fa85 f547 	uadd8	r5, r5, r7
  40db46:	faa3 f587 	sel	r5, r3, r7
  40db4a:	fa86 f647 	uadd8	r6, r6, r7
  40db4e:	faa5 f687 	sel	r6, r5, r7
  40db52:	b98e      	cbnz	r6, 40db78 <memchr+0x78>
  40db54:	d1ee      	bne.n	40db34 <memchr+0x34>
  40db56:	bcf0      	pop	{r4, r5, r6, r7}
  40db58:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  40db5c:	f002 0207 	and.w	r2, r2, #7
  40db60:	b132      	cbz	r2, 40db70 <memchr+0x70>
  40db62:	f810 3b01 	ldrb.w	r3, [r0], #1
  40db66:	3a01      	subs	r2, #1
  40db68:	ea83 0301 	eor.w	r3, r3, r1
  40db6c:	b113      	cbz	r3, 40db74 <memchr+0x74>
  40db6e:	d1f8      	bne.n	40db62 <memchr+0x62>
  40db70:	2000      	movs	r0, #0
  40db72:	4770      	bx	lr
  40db74:	3801      	subs	r0, #1
  40db76:	4770      	bx	lr
  40db78:	2d00      	cmp	r5, #0
  40db7a:	bf06      	itte	eq
  40db7c:	4635      	moveq	r5, r6
  40db7e:	3803      	subeq	r0, #3
  40db80:	3807      	subne	r0, #7
  40db82:	f015 0f01 	tst.w	r5, #1
  40db86:	d107      	bne.n	40db98 <memchr+0x98>
  40db88:	3001      	adds	r0, #1
  40db8a:	f415 7f80 	tst.w	r5, #256	; 0x100
  40db8e:	bf02      	ittt	eq
  40db90:	3001      	addeq	r0, #1
  40db92:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  40db96:	3001      	addeq	r0, #1
  40db98:	bcf0      	pop	{r4, r5, r6, r7}
  40db9a:	3801      	subs	r0, #1
  40db9c:	4770      	bx	lr
  40db9e:	bf00      	nop

0040dba0 <memmove>:
  40dba0:	4288      	cmp	r0, r1
  40dba2:	b510      	push	{r4, lr}
  40dba4:	eb01 0302 	add.w	r3, r1, r2
  40dba8:	d803      	bhi.n	40dbb2 <memmove+0x12>
  40dbaa:	1e42      	subs	r2, r0, #1
  40dbac:	4299      	cmp	r1, r3
  40dbae:	d10c      	bne.n	40dbca <memmove+0x2a>
  40dbb0:	bd10      	pop	{r4, pc}
  40dbb2:	4298      	cmp	r0, r3
  40dbb4:	d2f9      	bcs.n	40dbaa <memmove+0xa>
  40dbb6:	1881      	adds	r1, r0, r2
  40dbb8:	1ad2      	subs	r2, r2, r3
  40dbba:	42d3      	cmn	r3, r2
  40dbbc:	d100      	bne.n	40dbc0 <memmove+0x20>
  40dbbe:	bd10      	pop	{r4, pc}
  40dbc0:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  40dbc4:	f801 4d01 	strb.w	r4, [r1, #-1]!
  40dbc8:	e7f7      	b.n	40dbba <memmove+0x1a>
  40dbca:	f811 4b01 	ldrb.w	r4, [r1], #1
  40dbce:	f802 4f01 	strb.w	r4, [r2, #1]!
  40dbd2:	e7eb      	b.n	40dbac <memmove+0xc>

0040dbd4 <_realloc_r>:
  40dbd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40dbd6:	4607      	mov	r7, r0
  40dbd8:	4614      	mov	r4, r2
  40dbda:	460e      	mov	r6, r1
  40dbdc:	b921      	cbnz	r1, 40dbe8 <_realloc_r+0x14>
  40dbde:	4611      	mov	r1, r2
  40dbe0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  40dbe4:	f7fe bba6 	b.w	40c334 <_malloc_r>
  40dbe8:	b922      	cbnz	r2, 40dbf4 <_realloc_r+0x20>
  40dbea:	f7fe fb55 	bl	40c298 <_free_r>
  40dbee:	4625      	mov	r5, r4
  40dbf0:	4628      	mov	r0, r5
  40dbf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40dbf4:	f000 f821 	bl	40dc3a <_malloc_usable_size_r>
  40dbf8:	4284      	cmp	r4, r0
  40dbfa:	d90f      	bls.n	40dc1c <_realloc_r+0x48>
  40dbfc:	4621      	mov	r1, r4
  40dbfe:	4638      	mov	r0, r7
  40dc00:	f7fe fb98 	bl	40c334 <_malloc_r>
  40dc04:	4605      	mov	r5, r0
  40dc06:	2800      	cmp	r0, #0
  40dc08:	d0f2      	beq.n	40dbf0 <_realloc_r+0x1c>
  40dc0a:	4631      	mov	r1, r6
  40dc0c:	4622      	mov	r2, r4
  40dc0e:	f7fe fb2f 	bl	40c270 <memcpy>
  40dc12:	4631      	mov	r1, r6
  40dc14:	4638      	mov	r0, r7
  40dc16:	f7fe fb3f 	bl	40c298 <_free_r>
  40dc1a:	e7e9      	b.n	40dbf0 <_realloc_r+0x1c>
  40dc1c:	4635      	mov	r5, r6
  40dc1e:	e7e7      	b.n	40dbf0 <_realloc_r+0x1c>

0040dc20 <__ascii_wctomb>:
  40dc20:	b149      	cbz	r1, 40dc36 <__ascii_wctomb+0x16>
  40dc22:	2aff      	cmp	r2, #255	; 0xff
  40dc24:	bf85      	ittet	hi
  40dc26:	238a      	movhi	r3, #138	; 0x8a
  40dc28:	6003      	strhi	r3, [r0, #0]
  40dc2a:	700a      	strbls	r2, [r1, #0]
  40dc2c:	f04f 30ff 	movhi.w	r0, #4294967295
  40dc30:	bf98      	it	ls
  40dc32:	2001      	movls	r0, #1
  40dc34:	4770      	bx	lr
  40dc36:	4608      	mov	r0, r1
  40dc38:	4770      	bx	lr

0040dc3a <_malloc_usable_size_r>:
  40dc3a:	f851 0c04 	ldr.w	r0, [r1, #-4]
  40dc3e:	2800      	cmp	r0, #0
  40dc40:	f1a0 0004 	sub.w	r0, r0, #4
  40dc44:	bfbc      	itt	lt
  40dc46:	580b      	ldrlt	r3, [r1, r0]
  40dc48:	18c0      	addlt	r0, r0, r3
  40dc4a:	4770      	bx	lr
  40dc4c:	0001c200 	.word	0x0001c200
  40dc50:	00000008 	.word	0x00000008
  40dc54:	00000800 	.word	0x00000800
  40dc58:	00000001 	.word	0x00000001

0040dc5c <mmc_trans_multipliers>:
  40dc5c:	00000000 0000000a 0000000c 0000000d     ................
  40dc6c:	0000000f 00000014 0000001a 0000001e     ................
  40dc7c:	00000023 00000028 0000002d 00000034     #...(...-...4...
  40dc8c:	00000037 0000003c 00000046 00000050     7...<...F...P...

0040dc9c <sd_mmc_trans_units>:
  40dc9c:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

0040dcb8 <sd_trans_multipliers>:
  40dcb8:	00000000 0000000a 0000000c 0000000d     ................
  40dcc8:	0000000f 00000014 00000019 0000001e     ................
  40dcd8:	00000023 00000028 0000002d 00000032     #...(...-...2...
  40dce8:	00000037 0000003c 00000046 00000050     7...<...F...P...

0040dcf8 <LfnOfs>:
  40dcf8:	07050301 12100e09 1c181614 0000001e     ................

0040dd08 <excvt.5681>:
  40dd08:	b6909a80 808fb78e d8d4d3d2 8f8eded7     ................
  40dd18:	e2929290 ebeae399 9d9a9959 9f9e9d9c     ........Y.......
  40dd28:	e9e0d6b5 a7a6a5a5 abaaa9a8 afae21ac     .............!..
  40dd38:	b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc     ................
  40dd48:	c3c2c1c0 c7c7c5c4 cbcac9c8 cfcecdcc     ................
  40dd58:	d3d2d1d0 d7d6d5d4 dbdad9d8 dfdedddc     ................
  40dd68:	e3e2e1e0 e7e6e5e5 ebeae9e7 efeeeded     ................
  40dd78:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................
  40dd88:	3c3a2a22 7f7c3f3e 00000000 3d3b2c2b     "*:<>?|.....+,;=
  40dd98:	00005d5b                                []..

0040dd9c <Tbl>:
  40dd9c:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
  40ddac:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
  40ddbc:	00e600c9 00f400c6 00f200f6 00f900fb     ................
  40ddcc:	00d600ff 00f800dc 00d800a3 019200d7     ................
  40dddc:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
  40ddec:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
  40ddfc:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
  40de0c:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
  40de1c:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
  40de2c:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
  40de3c:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
  40de4c:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
  40de5c:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
  40de6c:	00da00de 00d900db 00dd00fd 00b400af     ................
  40de7c:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
  40de8c:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

0040de9c <tbl_lower.5431>:
  40de9c:	00620061 00640063 00660065 00680067     a.b.c.d.e.f.g.h.
  40deac:	006a0069 006c006b 006e006d 0070006f     i.j.k.l.m.n.o.p.
  40debc:	00720071 00740073 00760075 00780077     q.r.s.t.u.v.w.x.
  40decc:	007a0079 00a200a1 00a500a3 00af00ac     y.z.............
  40dedc:	00e100e0 00e300e2 00e500e4 00e700e6     ................
  40deec:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
  40defc:	00f100f0 00f300f2 00f500f4 00f800f6     ................
  40df0c:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
  40df1c:	01050103 01090107 010d010b 0111010f     ................
  40df2c:	01150113 01190117 011d011b 0121011f     ..............!.
  40df3c:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
  40df4c:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
  40df5c:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
  40df6c:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
  40df7c:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
  40df8c:	01770175 017c017a 0192017e 03b203b1     u.w.z.|.~.......
  40df9c:	03b403b3 03b603b5 03b803b7 03ba03b9     ................
  40dfac:	03bc03bb 03be03bd 03c003bf 03c303c1     ................
  40dfbc:	03c503c4 03c703c6 03c903c8 043003ca     ..............0.
  40dfcc:	04320431 04340433 04360435 04380437     1.2.3.4.5.6.7.8.
  40dfdc:	043a0439 043c043b 043e043d 0440043f     9.:.;.<.=.>.?.@.
  40dfec:	04420441 04440443 04460445 04480447     A.B.C.D.E.F.G.H.
  40dffc:	044a0449 044c044b 044e044d 0451044f     I.J.K.L.M.N.O.Q.
  40e00c:	04530452 04550454 04570456 04590458     R.S.T.U.V.W.X.Y.
  40e01c:	045b045a 045e045c 2170045f 21722171     Z.[.\.^._.p!q!r!
  40e02c:	21742173 21762175 21782177 217a2179     s!t!u!v!w!x!y!z!
  40e03c:	217c217b 217e217d ff41217f ff43ff42     {!|!}!~!.!A.B.C.
  40e04c:	ff45ff44 ff47ff46 ff49ff48 ff4bff4a     D.E.F.G.H.I.J.K.
  40e05c:	ff4dff4c ff4fff4e ff51ff50 ff53ff52     L.M.N.O.P.Q.R.S.
  40e06c:	ff55ff54 ff57ff56 ff59ff58 0000ff5a     T.U.V.W.X.Y.Z...

0040e07c <tbl_upper.5432>:
  40e07c:	00420041 00440043 00460045 00480047     A.B.C.D.E.F.G.H.
  40e08c:	004a0049 004c004b 004e004d 0050004f     I.J.K.L.M.N.O.P.
  40e09c:	00520051 00540053 00560055 00580057     Q.R.S.T.U.V.W.X.
  40e0ac:	005a0059 ffe00021 ffe5ffe1 ffe3ffe2     Y.Z.!...........
  40e0bc:	00c100c0 00c300c2 00c500c4 00c700c6     ................
  40e0cc:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
  40e0dc:	00d100d0 00d300d2 00d500d4 00d800d6     ................
  40e0ec:	00da00d9 00dc00db 00de00dd 01000178     ............x...
  40e0fc:	01040102 01080106 010c010a 0110010e     ................
  40e10c:	01140112 01180116 011c011a 0120011e     .............. .
  40e11c:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
  40e12c:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
  40e13c:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
  40e14c:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
  40e15c:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
  40e16c:	01760174 017b0179 0191017d 03920391     t.v.y.{.}.......
  40e17c:	03940393 03960395 03980397 039a0399     ................
  40e18c:	039c039b 039e039d 03a0039f 03a303a1     ................
  40e19c:	03a503a4 03a703a6 03a903a8 041003aa     ................
  40e1ac:	04120411 04140413 04160415 04180417     ................
  40e1bc:	041a0419 041c041b 041e041d 0420041f     .............. .
  40e1cc:	04220421 04240423 04260425 04280427     !.".#.$.%.&.'.(.
  40e1dc:	042a0429 042c042b 042e042d 0401042f     ).*.+.,.-.../...
  40e1ec:	04030402 04050404 04070406 04090408     ................
  40e1fc:	040b040a 040e040c 2160040f 21622161     ..........`!a!b!
  40e20c:	21642163 21662165 21682167 216a2169     c!d!e!f!g!h!i!j!
  40e21c:	216c216b 216e216d ff21216f ff23ff22     k!l!m!n!o!!.".#.
  40e22c:	ff25ff24 ff27ff26 ff29ff28 ff2bff2a     $.%.&.'.(.).*.+.
  40e23c:	ff2dff2c ff2fff2e ff31ff30 ff33ff32     ,.-.../.0.1.2.3.
  40e24c:	ff35ff34 ff37ff36 ff39ff38 0000ff3a     4.5.6.7.8.9.:...
  40e25c:	48646d63 6c646e61 00007265 666e6f63     cmdHandler..conf
  40e26c:	252f6769 00000064 69746f6d 252f6e6f     ig/%d...motion/%
  40e27c:	00000073 4c49460a 414e5f45 253d454d     s....FILE_NAME=%
  40e28c:	00000a73 75716573 65636e65 0064252f     s...sequence/%d.
  40e29c:	2e302e30 00000030 69746f6d 75516e6f     0.0.0...motionQu
  40e2ac:	00657565 4d767244 00006e6f 00000104     eue.DrvMon......
  40e2bc:	00fa0000 00fa0000 00000000 00000000     ................
  40e2cc:	00640000 00640000 00640000 00640000     ..d...d...d...d.
  40e2dc:	00003a30 73253a30 00000000 0000002e     0:..0:%s........
  40e2ec:	00002e2e 5b313325 3d5d3d5e 00006425     ....%31[^=]=%d..
  40e2fc:	49544f4d 545f4e4f 00455059 56495244     MOTION_TYPE.DRIV
  40e30c:	4e5f5245 45424d55 00000052 49534f50     ER_NUMBER...POSI
  40e31c:	4e4f4954 00000000 5346464f 00005445     TION....OFFSET..
  40e32c:	494d4f48 4d5f474e 0045444f 494d4f48     HOMING_MODE.HOMI
  40e33c:	535f474e 4f534e45 00000052 534e4553     NG_SENSOR...SENS
  40e34c:	485f524f 5f454d4f 554c4156 00000045     OR_HOME_VALUE...
  40e35c:	504d4152 5059545f 00000045 5f58414d     RAMP_TYPE...MAX_
  40e36c:	45455053 00000044 5f58414d 45434341     SPEED...MAX_ACCE
  40e37c:	4152454c 4e4f4954 00000000 5f58414d     LERATION....MAX_
  40e38c:	45434544 4152454c 4e4f4954 00000000     DECELERATION....
  40e39c:	31574f42 00000000 32574f42 00000000     BOW1....BOW2....
  40e3ac:	33574f42 00000000 34574f42 00000000     BOW3....BOW4....
  40e3bc:	5f455355 45564e49 5f455352 454d4954     USE_INVERSE_TIME
  40e3cc:	00000000 454d4954 00534d5f 253d6425     ....TIME_MS.%d=%
  40e3dc:	00000064 69746f6d 5f2f6e6f 65646e69     d...motion/_inde
  40e3ec:	70614d78 00000000 253d6425 00733133     xMap....%d=%31s.
  40e3fc:	5243494d 4554534f 45505f50 55465f52     MICROSTEP_PER_FU
  40e40c:	54534c4c 00005045 4c4c5546 50455453     LLSTEP..FULLSTEP
  40e41c:	5245505f 5645525f 54554c4f 004e4f49     _PER_REVOLUTION.
  40e42c:	54494e55 5245505f 5645525f 54554c4f     UNIT_PER_REVOLUT
  40e43c:	004e4f49 4b414550 5255435f 544e4552     ION.PEAK_CURRENT
  40e44c:	00000000 444c4f48 5f474e49 52525543     ....HOLDING_CURR
  40e45c:	00544e45 504f5453 5f4e4f5f 4c415453     ENT.STOP_ON_STAL
  40e46c:	4e455f4c 454c4241 00000000 504f5453     L_ENABLE....STOP
  40e47c:	5f4e4f5f 4c415453 48545f4c 48534552     _ON_STALL_THRESH
  40e48c:	00444c4f 534f4c43 4c5f4445 5f504f4f     OLD.CLOSED_LOOP_
  40e49c:	42414e45 0000454c 534f4c43 4c5f4445     ENABLE..CLOSED_L
  40e4ac:	5f504f4f 5f455355 00444950 4f434e45     OOP_USE_PID.ENCO
  40e4bc:	5f524544 534c5550 45505f45 45525f52     DER_PULSE_PER_RE
  40e4cc:	554c4f56 4e4f4954 00000000 5f58414d     VOLUTION....MAX_
  40e4dc:	544c4544 55505f41 0045534c 41455453     DELTA_PULSE.STEA
  40e4ec:	5f48544c 504f4843 5248545f 4f485345     LTH_CHOP_THRESHO
  40e4fc:	0000444c 454c4449 00000000 20726d54     LD..IDLE....Tmr 
  40e50c:	00637653                                Svc.

0040e510 <can_bit_time>:
  40e510:	02020308 02094b03 43020303 0303030a     .....K.....C....
  40e520:	040b4603 48040303 0404030c 040d4304     .F.....H.....C..
  40e530:	4d040404 0504040e 040f4004 43040505     ...M.....@.....C
  40e540:	05050510 06114504 47040505 06060512     .....E.....G....
  40e550:	06134304 44040606 06060714 08154604     .C.....D.....F..
  40e560:	47040606 07070716 08174404 46040708     ...G.....D.....F
  40e570:	08080718 08194304 44040808              .....C.....D

0040e57c <_global_impure_ptr>:
  40e57c:	20000024                                $.. 

0040e580 <__sf_fake_stderr>:
	...

0040e5a0 <__sf_fake_stdin>:
	...

0040e5c0 <__sf_fake_stdout>:
	...
  40e5e0:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
  40e5f0:	32313000 36353433 41393837 45444342     .0123456789ABCDE
  40e600:	31300046 35343332 39383736 64636261     F.0123456789abcd
  40e610:	00006665 0040e632 0040e635 0040e638     ef..2.@.5.@.8.@.
  40e620:	61462d41 3938662d 33323130 37363534     A-Fa-f8901234567
  40e630:	2d2b005d 00303000 43005878 534f5000     ].+-.00.xX.C.POS
  40e640:	2e005849 20200000                                IX...

0040e645 <_ctype_>:
  40e645:	20202000 20202020 28282020 20282828     .         ((((( 
  40e655:	20202020 20202020 20202020 20202020                     
  40e665:	10108820 10101010 10101010 10101010      ...............
  40e675:	04040410 04040404 10040404 10101010     ................
  40e685:	41411010 41414141 01010101 01010101     ..AAAAAA........
  40e695:	01010101 01010101 01010101 10101010     ................
  40e6a5:	42421010 42424242 02020202 02020202     ..BBBBBB........
  40e6b5:	02020202 02020202 02020202 10101010     ................
  40e6c5:	00000020 00000000 00000000 00000000      ...............
	...

0040e748 <_init>:
  40e748:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40e74a:	bf00      	nop
  40e74c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40e74e:	bc08      	pop	{r3}
  40e750:	469e      	mov	lr, r3
  40e752:	4770      	bx	lr

0040e754 <__init_array_start>:
  40e754:	0040011d 	.word	0x0040011d
  40e758:	004005b5 	.word	0x004005b5
  40e75c:	00408c51 	.word	0x00408c51

0040e760 <_fini>:
  40e760:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40e762:	bf00      	nop
  40e764:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40e766:	bc08      	pop	{r3}
  40e768:	469e      	mov	lr, r3
  40e76a:	4770      	bx	lr

0040e76c <__fini_array_start>:
  40e76c:	004000f9 	.word	0x004000f9

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr
	...

2000000c <uxCriticalNesting>:
2000000c:	aaaa aaaa                                   ....

20000010 <xFreeBytesRemaining>:
20000010:	a000 0000                                   ....

20000014 <xNextTaskUnblockTime>:
20000014:	ffff ffff                                   ....

20000018 <g_interrupt_enabled>:
20000018:	0001 0000                                   ....

2000001c <SystemCoreClock>:
2000001c:	0900 003d                                   ..=.

20000020 <_impure_ptr>:
20000020:	0024 2000                                   $.. 

20000024 <impure_data>:
20000024:	0000 0000 e5a0 0040 e5c0 0040 e580 0040     ......@...@...@.
	...

20000084 <__global_locale>:
20000084:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
200000a4:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
200000c4:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
200000e4:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000104:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000124:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000144:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000164:	dc21 0040 dad1 0040 0000 0000 e645 0040     !.@...@.....E.@.
20000174:	e643 0040 e5e5 0040 e5e5 0040 e5e5 0040     C.@...@...@...@.
20000184:	e5e5 0040 e5e5 0040 e5e5 0040 e5e5 0040     ..@...@...@...@.
20000194:	e5e5 0040 e5e5 0040 ffff ffff ffff ffff     ..@...@.........
200001a4:	ffff ffff ffff 0000 0001 5341 4943 0049     ..........ASCII.
	...
200001cc:	0000 5341 4943 0049 0000 0000 0000 0000     ..ASCII.........
	...
